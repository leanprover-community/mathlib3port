/-
Copyright (c) 2022 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: YaÃ«l Dillies, Bhavik Mehta

! This file was ported from Lean 3 source module combinatorics.simple_graph.triangle.basic
! leanprover-community/mathlib commit ee05e9ce1322178f0c12004eb93c00d2c8c00ed2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Combinatorics.SimpleGraph.Clique

/-!
# Triangles in graphs

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

A *triangle* in a simple graph is a `3`-clique, namely a set of three vertices that are
pairwise adjacent.

This module defines and proves properties about triangles in simple graphs.

## Main declarations

* `simple_graph.far_from_triangle_free`: Predicate for a graph to have enough triangles that, to
  remove all of them, one must one must remove a lot of edges. This is the crux of the Triangle
  Removal lemma.

## TODO

* Generalise `far_from_triangle_free` to other graphs, to state and prove the Graph Removal Lemma.
* Find a better name for `far_from_triangle_free`. Added 4/26/2022. Remove this TODO if it gets old.
-/


open Finset Fintype Nat

open Classical

namespace SimpleGraph

variable {Î± ğ•œ : Type _} [Fintype Î±] [LinearOrderedField ğ•œ] {G H : SimpleGraph Î±} {Îµ Î´ : ğ•œ} {n : â„•}
  {s : Finset Î±}

#print SimpleGraph.FarFromTriangleFree /-
/-- A simple graph is *`Îµ`-triangle-free far* if one must remove at least `Îµ * (card Î±)^2` edges to
make it triangle-free. -/
def FarFromTriangleFree (G : SimpleGraph Î±) (Îµ : ğ•œ) : Prop :=
  (G.DeleteFar fun H => H.CliqueFree 3) <| Îµ * (card Î± ^ 2 : â„•)
#align simple_graph.far_from_triangle_free SimpleGraph.FarFromTriangleFree
-/

/- warning: simple_graph.far_from_triangle_free_iff -> SimpleGraph.farFromTriangleFree_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {Îµ : ğ•œ}, Iff (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ) (forall {{H : SimpleGraph.{u1} Î±}}, (LE.le.{u1} (SimpleGraph.{u1} Î±) (SimpleGraph.hasLe.{u1} Î±) H G) -> (SimpleGraph.CliqueFree.{u1} Î± H (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) (HMul.hMul.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHMul.{u2} ğ•œ (Distrib.toHasMul.{u2} ğ•œ (Ring.toDistrib.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))) Îµ ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Î± _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HSub.hSub.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHSub.{u2} ğ•œ (SubNegMonoid.toHasSub.{u2} ğ•œ (AddGroup.toSubNegMonoid.{u2} ğ•œ (AddGroupWithOne.toAddGroup.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2))))))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} Î±) (SimpleGraph.edgeFinset.{u1} Î± G (SimpleGraph.fintypeEdgeSet.{u1} Î± G (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± G a b)))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} Î±) (SimpleGraph.edgeFinset.{u1} Î± H (SimpleGraph.fintypeEdgeSet.{u1} Î± H (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± H a b)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {Îµ : ğ•œ}, Iff (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ) (forall {{H : SimpleGraph.{u2} Î±}}, (LE.le.{u2} (SimpleGraph.{u2} Î±) (SimpleGraph.instLESimpleGraph.{u2} Î±) H G) -> (SimpleGraph.CliqueFree.{u2} Î± H (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))))) Îµ (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u2} Î± _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HSub.hSub.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHSub.{u1} ğ•œ (Ring.toSub.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Finset.card.{u2} (Sym2.{u2} Î±) (SimpleGraph.edgeFinset.{u2} Î± G (SimpleGraph.fintypeEdgeSet.{u2} Î± G (Quotient.fintype.{u2} (Prod.{u2, u2} Î± Î±) (instFintypeProd.{u2, u2} Î± Î± _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} Î±) (fun (a : Prod.{u2, u2} Î± Î±) (b : Prod.{u2, u2} Î± Î±) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} Î± Î±) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} Î± Î±) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} Î± Î±) (instHasEquiv.{succ u2} (Prod.{u2, u2} Î± Î±) (Sym2.Rel.setoid.{u2} Î±)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± G a b)))))) (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Finset.card.{u2} (Sym2.{u2} Î±) (SimpleGraph.edgeFinset.{u2} Î± H (SimpleGraph.fintypeEdgeSet.{u2} Î± H (Quotient.fintype.{u2} (Prod.{u2, u2} Î± Î±) (instFintypeProd.{u2, u2} Î± Î± _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} Î±) (fun (a : Prod.{u2, u2} Î± Î±) (b : Prod.{u2, u2} Î± Î±) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} Î± Î±) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} Î± Î±) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} Î± Î±) (instHasEquiv.{succ u2} (Prod.{u2, u2} Î± Î±) (Sym2.Rel.setoid.{u2} Î±)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± H a b)))))))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free_iff SimpleGraph.farFromTriangleFree_iffâ‚“'. -/
theorem farFromTriangleFree_iff :
    G.FarFromTriangleFree Îµ â†”
      âˆ€ â¦ƒHâ¦„,
        H â‰¤ G â†’ H.CliqueFree 3 â†’ Îµ * (card Î± ^ 2 : â„•) â‰¤ G.edgeFinset.card - H.edgeFinset.card :=
  deleteFar_iff
#align simple_graph.far_from_triangle_free_iff SimpleGraph.farFromTriangleFree_iff

/- warning: simple_graph.far_from_triangle_free.le_card_sub_card -> SimpleGraph.farFromTriangleFree.le_card_sub_card is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {Îµ : ğ•œ}, (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (forall {{H : SimpleGraph.{u1} Î±}}, (LE.le.{u1} (SimpleGraph.{u1} Î±) (SimpleGraph.hasLe.{u1} Î±) H G) -> (SimpleGraph.CliqueFree.{u1} Î± H (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) (HMul.hMul.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHMul.{u2} ğ•œ (Distrib.toHasMul.{u2} ğ•œ (Ring.toDistrib.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))) Îµ ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Î± _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HSub.hSub.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHSub.{u2} ğ•œ (SubNegMonoid.toHasSub.{u2} ğ•œ (AddGroup.toSubNegMonoid.{u2} ğ•œ (AddGroupWithOne.toAddGroup.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2))))))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} Î±) (SimpleGraph.edgeFinset.{u1} Î± G (SimpleGraph.fintypeEdgeSet.{u1} Î± G (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± G a b)))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} Î±) (SimpleGraph.edgeFinset.{u1} Î± H (SimpleGraph.fintypeEdgeSet.{u1} Î± H (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± H a b)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {Îµ : ğ•œ}, (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (forall {{H : SimpleGraph.{u2} Î±}}, (LE.le.{u2} (SimpleGraph.{u2} Î±) (SimpleGraph.instLESimpleGraph.{u2} Î±) H G) -> (SimpleGraph.CliqueFree.{u2} Î± H (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))))) Îµ (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u2} Î± _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HSub.hSub.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHSub.{u1} ğ•œ (Ring.toSub.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Finset.card.{u2} (Sym2.{u2} Î±) (SimpleGraph.edgeFinset.{u2} Î± G (SimpleGraph.fintypeEdgeSet.{u2} Î± G (Quotient.fintype.{u2} (Prod.{u2, u2} Î± Î±) (instFintypeProd.{u2, u2} Î± Î± _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} Î±) (fun (a : Prod.{u2, u2} Î± Î±) (b : Prod.{u2, u2} Î± Î±) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} Î± Î±) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} Î± Î±) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} Î± Î±) (instHasEquiv.{succ u2} (Prod.{u2, u2} Î± Î±) (Sym2.Rel.setoid.{u2} Î±)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± G a b)))))) (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Finset.card.{u2} (Sym2.{u2} Î±) (SimpleGraph.edgeFinset.{u2} Î± H (SimpleGraph.fintypeEdgeSet.{u2} Î± H (Quotient.fintype.{u2} (Prod.{u2, u2} Î± Î±) (instFintypeProd.{u2, u2} Î± Î± _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} Î±) (fun (a : Prod.{u2, u2} Î± Î±) (b : Prod.{u2, u2} Î± Î±) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} Î± Î±) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} Î± Î±) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} Î± Î±) (instHasEquiv.{succ u2} (Prod.{u2, u2} Î± Î±) (Sym2.Rel.setoid.{u2} Î±)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± H a b)))))))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.le_card_sub_card SimpleGraph.farFromTriangleFree.le_card_sub_cardâ‚“'. -/
alias far_from_triangle_free_iff â†” far_from_triangle_free.le_card_sub_card _
#align simple_graph.far_from_triangle_free.le_card_sub_card SimpleGraph.farFromTriangleFree.le_card_sub_card

/- warning: simple_graph.far_from_triangle_free.mono -> SimpleGraph.farFromTriangleFree.mono is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {Îµ : ğ•œ} {Î´ : ğ•œ}, (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) Î´ Îµ) -> (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Î´)
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {Îµ : ğ•œ} {Î´ : ğ•œ}, (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) Î´ Îµ) -> (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Î´)
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.mono SimpleGraph.farFromTriangleFree.monoâ‚“'. -/
theorem farFromTriangleFree.mono (hÎµ : G.FarFromTriangleFree Îµ) (h : Î´ â‰¤ Îµ) :
    G.FarFromTriangleFree Î´ :=
  hÎµ.mono <| mul_le_mul_of_nonneg_right h <| cast_nonneg _
#align simple_graph.far_from_triangle_free.mono SimpleGraph.farFromTriangleFree.mono

/- warning: simple_graph.far_from_triangle_free.clique_finset_nonempty' -> SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {H : SimpleGraph.{u1} Î±} {Îµ : ğ•œ}, (LE.le.{u1} (SimpleGraph.{u1} Î±) (SimpleGraph.hasLe.{u1} Î±) H G) -> (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) (HSub.hSub.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHSub.{u2} ğ•œ (SubNegMonoid.toHasSub.{u2} ğ•œ (AddGroup.toSubNegMonoid.{u2} ğ•œ (AddGroupWithOne.toAddGroup.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2))))))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} Î±) (SimpleGraph.edgeFinset.{u1} Î± G (SimpleGraph.fintypeEdgeSet.{u1} Î± G (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± G a b)))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} Î±) (SimpleGraph.edgeFinset.{u1} Î± H (SimpleGraph.fintypeEdgeSet.{u1} Î± H (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± H a b))))))) (HMul.hMul.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHMul.{u2} ğ•œ (Distrib.toHasMul.{u2} ğ•œ (Ring.toDistrib.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))) Îµ ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u2} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u2} Nat ğ•œ (Nat.castCoe.{u2} ğ•œ (AddMonoidWithOne.toNatCast.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (NonAssocRing.toAddGroupWithOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2)))))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Î± _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) -> (Finset.Nonempty.{u1} (Finset.{u1} Î±) (SimpleGraph.cliqueFinset.{u1} Î± H _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± H a b)) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {H : SimpleGraph.{u2} Î±} {Îµ : ğ•œ}, (LE.le.{u2} (SimpleGraph.{u2} Î±) (SimpleGraph.instLESimpleGraph.{u2} Î±) H G) -> (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) (HSub.hSub.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHSub.{u1} ğ•œ (Ring.toSub.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Finset.card.{u2} (Sym2.{u2} Î±) (SimpleGraph.edgeFinset.{u2} Î± G (SimpleGraph.fintypeEdgeSet.{u2} Î± G (Quotient.fintype.{u2} (Prod.{u2, u2} Î± Î±) (instFintypeProd.{u2, u2} Î± Î± _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} Î±) (fun (a : Prod.{u2, u2} Î± Î±) (b : Prod.{u2, u2} Î± Î±) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} Î± Î±) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} Î± Î±) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} Î± Î±) (instHasEquiv.{succ u2} (Prod.{u2, u2} Î± Î±) (Sym2.Rel.setoid.{u2} Î±)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± G a b)))))) (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (Finset.card.{u2} (Sym2.{u2} Î±) (SimpleGraph.edgeFinset.{u2} Î± H (SimpleGraph.fintypeEdgeSet.{u2} Î± H (Quotient.fintype.{u2} (Prod.{u2, u2} Î± Î±) (instFintypeProd.{u2, u2} Î± Î± _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} Î±) (fun (a : Prod.{u2, u2} Î± Î±) (b : Prod.{u2, u2} Î± Î±) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} Î± Î±) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} Î± Î±) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} Î± Î±) (instHasEquiv.{succ u2} (Prod.{u2, u2} Î± Î±) (Sym2.Rel.setoid.{u2} Î±)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± H a b))))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))))) Îµ (Nat.cast.{u1} ğ•œ (NonAssocRing.toNatCast.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u2} Î± _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) -> (Finset.Nonempty.{u2} (Finset.{u2} Î±) (SimpleGraph.cliqueFinset.{u2} Î± H _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u2} Î± a b)) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± H a b)) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.clique_finset_nonempty' SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty'â‚“'. -/
theorem FarFromTriangleFree.cliqueFinset_nonempty' (hH : H â‰¤ G) (hG : G.FarFromTriangleFree Îµ)
    (hcard : (G.edgeFinset.card - H.edgeFinset.card : ğ•œ) < Îµ * (card Î± ^ 2 : â„•)) :
    (H.cliqueFinset 3).Nonempty :=
  nonempty_of_ne_empty <|
    H.cliqueFinset_eq_empty_iff.Not.2 fun hH' => (hG.le_card_sub_card hH hH').not_lt hcard
#align simple_graph.far_from_triangle_free.clique_finset_nonempty' SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty'

variable [Nonempty Î±]

/- warning: simple_graph.far_from_triangle_free.nonpos -> SimpleGraph.FarFromTriangleFree.nonpos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u1} Î±], (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (SimpleGraph.CliqueFree.{u1} Î± G (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) Îµ (OfNat.ofNat.{u2} ğ•œ 0 (OfNat.mk.{u2} ğ•œ 0 (Zero.zero.{u2} ğ•œ (MulZeroClass.toHasZero.{u2} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2))))))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u2} Î±], (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (SimpleGraph.CliqueFree.{u2} Î± G (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) Îµ (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.nonpos SimpleGraph.FarFromTriangleFree.nonposâ‚“'. -/
theorem FarFromTriangleFree.nonpos (hâ‚€ : G.FarFromTriangleFree Îµ) (hâ‚ : G.CliqueFree 3) : Îµ â‰¤ 0 :=
  by
  have := hâ‚€ (empty_subset _)
  rw [coe_empty, Finset.card_empty, cast_zero, delete_edges_empty_eq] at this
  exact nonpos_of_mul_nonpos_left (this hâ‚) (cast_pos.2 <| sq_pos_of_pos Fintype.card_pos)
#align simple_graph.far_from_triangle_free.nonpos SimpleGraph.FarFromTriangleFree.nonpos

/- warning: simple_graph.clique_free.not_far_from_triangle_free -> SimpleGraph.CliqueFree.not_farFromTriangleFree is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u1} Î±], (SimpleGraph.CliqueFree.{u1} Î± G (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) (OfNat.ofNat.{u2} ğ•œ 0 (OfNat.mk.{u2} ğ•œ 0 (Zero.zero.{u2} ğ•œ (MulZeroClass.toHasZero.{u2} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2))))))))))) Îµ) -> (Not (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ))
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u2} Î±], (SimpleGraph.CliqueFree.{u2} Î± G (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_2))))))) Îµ) -> (Not (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ))
Case conversion may be inaccurate. Consider using '#align simple_graph.clique_free.not_far_from_triangle_free SimpleGraph.CliqueFree.not_farFromTriangleFreeâ‚“'. -/
theorem CliqueFree.not_farFromTriangleFree (hG : G.CliqueFree 3) (hÎµ : 0 < Îµ) :
    Â¬G.FarFromTriangleFree Îµ := fun h => (h.nonpos hG).not_lt hÎµ
#align simple_graph.clique_free.not_far_from_triangle_free SimpleGraph.CliqueFree.not_farFromTriangleFree

/- warning: simple_graph.far_from_triangle_free.not_clique_free -> SimpleGraph.FarFromTriangleFree.not_cliqueFree is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u1} Î±], (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) (OfNat.ofNat.{u2} ğ•œ 0 (OfNat.mk.{u2} ğ•œ 0 (Zero.zero.{u2} ğ•œ (MulZeroClass.toHasZero.{u2} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2))))))))))) Îµ) -> (Not (SimpleGraph.CliqueFree.{u1} Î± G (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u2} Î±], (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_2))))))) Îµ) -> (Not (SimpleGraph.CliqueFree.{u2} Î± G (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.not_clique_free SimpleGraph.FarFromTriangleFree.not_cliqueFreeâ‚“'. -/
theorem FarFromTriangleFree.not_cliqueFree (hG : G.FarFromTriangleFree Îµ) (hÎµ : 0 < Îµ) :
    Â¬G.CliqueFree 3 := fun h => (hG.nonpos h).not_lt hÎµ
#align simple_graph.far_from_triangle_free.not_clique_free SimpleGraph.FarFromTriangleFree.not_cliqueFree

/- warning: simple_graph.far_from_triangle_free.clique_finset_nonempty -> SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} [_inst_1 : Fintype.{u1} Î±] [_inst_2 : LinearOrderedField.{u2} ğ•œ] {G : SimpleGraph.{u1} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u1} Î±], (SimpleGraph.FarFromTriangleFree.{u1, u2} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_2))))))) (OfNat.ofNat.{u2} ğ•œ 0 (OfNat.mk.{u2} ğ•œ 0 (Zero.zero.{u2} ğ•œ (MulZeroClass.toHasZero.{u2} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_2))))))))))) Îµ) -> (Finset.Nonempty.{u1} (Finset.{u1} Î±) (SimpleGraph.cliqueFinset.{u1} Î± G _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u1} Î± a b)) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u1} Î± G a b)) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {Î± : Type.{u2}} {ğ•œ : Type.{u1}} [_inst_1 : Fintype.{u2} Î±] [_inst_2 : LinearOrderedField.{u1} ğ•œ] {G : SimpleGraph.{u2} Î±} {Îµ : ğ•œ} [_inst_3 : Nonempty.{succ u2} Î±], (SimpleGraph.FarFromTriangleFree.{u2, u1} Î± ğ•œ _inst_1 _inst_2 G Îµ) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_2)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_2))))))) Îµ) -> (Finset.Nonempty.{u2} (Finset.{u2} Î±) (SimpleGraph.cliqueFinset.{u2} Î± G _inst_1 (fun (a : Î±) (b : Î±) => Classical.propDecidable (Eq.{succ u2} Î± a b)) (fun (a : Î±) (b : Î±) => Classical.propDecidable (SimpleGraph.Adj.{u2} Î± G a b)) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.clique_finset_nonempty SimpleGraph.FarFromTriangleFree.cliqueFinset_nonemptyâ‚“'. -/
theorem FarFromTriangleFree.cliqueFinset_nonempty (hG : G.FarFromTriangleFree Îµ) (hÎµ : 0 < Îµ) :
    (G.cliqueFinset 3).Nonempty :=
  nonempty_of_ne_empty <| G.cliqueFinset_eq_empty_iff.Not.2 <| hG.not_cliqueFree hÎµ
#align simple_graph.far_from_triangle_free.clique_finset_nonempty SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty

end SimpleGraph

