import Mathbin.Data.Equiv.Encodable.Basic 
import Mathbin.Order.Atoms

/-!
# Order ideals, cofinal sets, and the Rasiowaâ€“Sikorski lemma

## Main definitions

Throughout this file, `P` is at least a preorder, but some sections require more
structure, such as a bottom element, a top element, or a join-semilattice structure.
- `order.ideal P`: the type of nonempty, upward directed, and downward closed subsets of `P`.
  Dual to the notion of a filter on a preorder.
- `order.is_ideal P`: a predicate for when a `set P` is an ideal.
- `order.ideal.principal p`: the principal ideal generated by `p : P`.
- `order.ideal.is_proper P`: a predicate for proper ideals.
  Dual to the notion of a proper filter.
- `order.ideal.is_maximal`: a predicate for maximal ideals.
  Dual to the notion of an ultrafilter.
- `ideal_inter_nonempty P`: a predicate for when the intersection of any two ideals of
  `P` is nonempty.
- `ideal_Inter_nonempty P`: a predicate for when the intersection of all ideals of
  `P` is nonempty.
- `order.cofinal P`: the type of subsets of `P` containing arbitrarily large elements.
  Dual to the notion of 'dense set' used in forcing.
- `order.ideal_of_cofinals p ğ’Ÿ`, where `p : P`, and `ğ’Ÿ` is a countable family of cofinal
  subsets of P: an ideal in `P` which contains `p` and intersects every set in `ğ’Ÿ`. (This a form
  of the Rasiowaâ€“Sikorski lemma.)

## References

- <https://en.wikipedia.org/wiki/Ideal_(order_theory)>
- <https://en.wikipedia.org/wiki/Cofinal_(mathematics)>
- <https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma>

Note that for the Rasiowaâ€“Sikorski lemma, Wikipedia uses the opposite ordering on `P`,
in line with most presentations of forcing.

## Tags

ideal, cofinal, dense, countable, generic

-/


namespace Order

variable {P : Type _}

/-- An ideal on a preorder `P` is a subset of `P` that is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
structure ideal (P) [Preorderâ‚“ P] where 
  Carrier : Set P 
  Nonempty : carrier.nonempty 
  Directed : DirectedOn (Â· â‰¤ Â·) carrier 
  mem_of_le : âˆ€ {x y : P}, x â‰¤ y â†’ y âˆˆ carrier â†’ x âˆˆ carrier

/-- A subset of a preorder `P` is an ideal if it is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
@[mkIff]
structure is_ideal {P} [Preorderâ‚“ P] (I : Set P) : Prop where 
  Nonempty : I.nonempty 
  Directed : DirectedOn (Â· â‰¤ Â·) I 
  mem_of_le : âˆ€ {x y : P}, x â‰¤ y â†’ y âˆˆ I â†’ x âˆˆ I

/-- Create an element of type `order.ideal` from a set satisfying the predicate
`order.is_ideal`. -/
def is_ideal.to_ideal [Preorderâ‚“ P] {I : Set P} (h : is_ideal I) : ideal P :=
  âŸ¨I, h.1, h.2, h.3âŸ©

namespace Ideal

section Preorderâ‚“

variable [Preorderâ‚“ P] {x y : P} {I J : ideal P}

/-- The smallest ideal containing a given element. -/
def principal (p : P) : ideal P :=
  { Carrier := { x | x â‰¤ p }, Nonempty := âŸ¨p, le_reflâ‚“ _âŸ©, Directed := fun x hx y hy => âŸ¨p, le_reflâ‚“ _, hx, hyâŸ©,
    mem_of_le := fun x y hxy hy => le_transâ‚“ hxy hy }

instance [Inhabited P] : Inhabited (ideal P) :=
  âŸ¨ideal.principal$ default PâŸ©

/-- An ideal of `P` can be viewed as a subset of `P`. -/
instance : Coe (ideal P) (Set P) :=
  âŸ¨carrierâŸ©

/-- For the notation `x âˆˆ I`. -/
instance : HasMem P (ideal P) :=
  âŸ¨fun x I => x âˆˆ (I : Set P)âŸ©

@[simp]
theorem mem_coe : x âˆˆ (I : Set P) â†” x âˆˆ I :=
  iff_of_eq rfl

@[simp]
theorem mem_principal : x âˆˆ principal y â†” x â‰¤ y :=
  by 
    rfl

/-- Two ideals are equal when their underlying sets are equal. -/
@[ext]
theorem ext : âˆ€ I J : ideal P, (I : Set P) = J â†’ I = J
| âŸ¨_, _, _, _âŸ©, âŸ¨_, _, _, _âŸ©, rfl => rfl

@[simp, normCast]
theorem ext_set_eq {I J : ideal P} : (I : Set P) = J â†” I = J :=
  âŸ¨by 
      ext,
    congr_argâ‚“ _âŸ©

theorem ext'_iff {I J : ideal P} : I = J â†” (I : Set P) = J :=
  ext_set_eq.symm

theorem is_ideal (I : ideal P) : is_ideal (I : Set P) :=
  âŸ¨I.2, I.3, I.4âŸ©

/-- The partial ordering by subset inclusion, inherited from `set P`. -/
instance : PartialOrderâ‚“ (ideal P) :=
  PartialOrderâ‚“.lift coeâ‚“ ext

@[trans]
theorem mem_of_mem_of_le : x âˆˆ I â†’ I â‰¤ J â†’ x âˆˆ J :=
  @Set.mem_of_mem_of_subset P x I J

@[simp]
theorem principal_le_iff : principal x â‰¤ I â†” x âˆˆ I :=
  âŸ¨fun h : âˆ€ {y}, y â‰¤ x â†’ y âˆˆ I => h (le_reflâ‚“ x), fun h_mem y h_le : y â‰¤ x => I.mem_of_le h_le h_memâŸ©

theorem mem_compl_of_ge {x y : P} : x â‰¤ y â†’ x âˆˆ Â«expr á¶œÂ» (I : Set P) â†’ y âˆˆ Â«expr á¶œÂ» (I : Set P) :=
  fun h => mt (I.mem_of_le h)

/-- A proper ideal is one that is not the whole set.
    Note that the whole set might not be an ideal. -/
@[mkIff]
class is_proper (I : ideal P) : Prop where 
  ne_univ : (I : Set P) â‰  Set.Univ

theorem is_proper_of_not_mem {I : ideal P} {p : P} (nmem : p âˆ‰ I) : is_proper I :=
  âŸ¨fun hp =>
      by 
        change p âˆ‰ Â«exprâ†‘ Â» I at nmem 
        rw [hp] at nmem 
        exact nmem (Set.mem_univ p)âŸ©

/-- An ideal is maximal if it is maximal in the collection of proper ideals.
  Note that we cannot use the `is_coatom` class because `P` might not have a `top` element.
-/
@[mkIff]
class is_maximal (I : ideal P) extends is_proper I : Prop where 
  maximal_proper : âˆ€ â¦ƒJ : ideal Pâ¦„, I < J â†’ (J : Set P) = Set.Univ

variable (P)

/-- A preorder `P` has the `ideal_inter_nonempty` property if the
    intersection of any two ideals is nonempty.
    Most importantly, a `semilattice_sup` preorder with this property
    satisfies that its ideal poset is a lattice.
-/
class ideal_inter_nonempty : Prop where 
  inter_nonempty : âˆ€ I J : ideal P, ((I : Set P) âˆ© (J : Set P)).Nonempty

/-- A preorder `P` has the `ideal_Inter_nonempty` property if the
    intersection of all ideals is nonempty.
    Most importantly, a `semilattice_sup` preorder with this property
    satisfies that its ideal poset is a complete lattice.
-/
class ideal_Inter_nonempty : Prop where 
  Inter_nonempty : (â‹‚I : ideal P, (I : Set P)).Nonempty

variable {P}

theorem inter_nonempty [ideal_inter_nonempty P] : âˆ€ I J : ideal P, ((I : Set P) âˆ© (J : Set P)).Nonempty :=
  ideal_inter_nonempty.inter_nonempty

theorem Inter_nonempty [ideal_Inter_nonempty P] : (â‹‚I : ideal P, (I : Set P)).Nonempty :=
  ideal_Inter_nonempty.Inter_nonempty

theorem ideal_Inter_nonempty.exists_all_mem [ideal_Inter_nonempty P] : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I :=
  by 
    change âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ (I : Set P)
    rw [â†Set.nonempty_Inter]
    exact Inter_nonempty

theorem ideal_Inter_nonempty_of_exists_all_mem (h : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I) : ideal_Inter_nonempty P :=
  { Inter_nonempty :=
      by 
        rwa [Set.nonempty_Inter] }

theorem ideal_Inter_nonempty_iff : ideal_Inter_nonempty P â†” âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I :=
  âŸ¨fun _ =>
      by 
        exact ideal_Inter_nonempty.exists_all_mem,
    ideal_Inter_nonempty_of_exists_all_memâŸ©

end Preorderâ‚“

section OrderBot

variable [Preorderâ‚“ P] [OrderBot P] {I : ideal P}

/-- A specific witness of `I.nonempty` when `P` has a bottom element. -/
@[simp]
theorem bot_mem : âŠ¥ âˆˆ I :=
  I.mem_of_le bot_le I.nonempty.some_mem

/-- There is a bottom ideal when `P` has a bottom element. -/
instance : OrderBot (ideal P) :=
  { bot := principal âŠ¥,
    bot_le :=
      by 
        simp  }

instance (priority := 100) order_bot.ideal_Inter_nonempty : ideal_Inter_nonempty P :=
  by 
    rw [ideal_Inter_nonempty_iff]
    exact âŸ¨âŠ¥, fun I => bot_memâŸ©

end OrderBot

section OrderTop

variable [Preorderâ‚“ P] [OrderTop P]

/-- There is a top ideal when `P` has a top element. -/
instance : OrderTop (ideal P) :=
  { top := principal âŠ¤, le_top := fun I x h => le_top }

@[simp]
theorem coe_top : ((âŠ¤ : ideal P) : Set P) = Set.Univ :=
  Set.univ_subset_iff.1 fun p _ => le_top

theorem top_of_mem_top {I : ideal P} (mem_top : âŠ¤ âˆˆ I) : I = âŠ¤ :=
  by 
    ext 
    change x âˆˆ I â†” x âˆˆ ((âŠ¤ : ideal P) : Set P)
    split 
    Â·
      simp [coe_top]
    Â·
      exact fun _ => I.mem_of_le le_top mem_top

theorem is_proper_of_ne_top {I : ideal P} (ne_top : I â‰  âŠ¤) : is_proper I :=
  is_proper_of_not_mem fun h => ne_top (top_of_mem_top h)

theorem is_proper.ne_top {I : ideal P} (hI : is_proper I) : I â‰  âŠ¤ :=
  by 
    intro h 
    rw [ext'_iff, coe_top] at h 
    apply hI.ne_univ 
    assumption

theorem is_proper.top_not_mem {I : ideal P} (hI : is_proper I) : âŠ¤ âˆ‰ I :=
  by 
    byContra 
    exact hI.ne_top (top_of_mem_top h)

theorem _root_.is_coatom.is_proper {I : ideal P} (hI : IsCoatom I) : is_proper I :=
  is_proper_of_ne_top hI.1

theorem is_proper_iff_ne_top {I : ideal P} : is_proper I â†” I â‰  âŠ¤ :=
  âŸ¨fun h => h.ne_top, fun h => is_proper_of_ne_top hâŸ©

theorem is_maximal.is_coatom {I : ideal P} (h : is_maximal I) : IsCoatom I :=
  âŸ¨is_maximal.to_is_proper.ne_top,
    fun _ _ =>
      by 
        rw [ext'_iff, coe_top]
        exact is_maximal.maximal_proper â€¹_â€ºâŸ©

theorem is_maximal.is_coatom' {I : ideal P} [is_maximal I] : IsCoatom I :=
  is_maximal.is_coatom â€¹_â€º

theorem _root_.is_coatom.is_maximal {I : ideal P} (hI : IsCoatom I) : is_maximal I :=
  { IsCoatom.is_proper â€¹_â€º with
    maximal_proper :=
      fun _ _ =>
        by 
          simp [hI.2 _ â€¹_â€º] }

theorem is_maximal_iff_is_coatom {I : ideal P} : is_maximal I â†” IsCoatom I :=
  âŸ¨fun h => h.is_coatom, fun h => h.is_maximalâŸ©

end OrderTop

section SemilatticeSup

variable [SemilatticeSup P] {x y : P} {I : ideal P}

/-- A specific witness of `I.directed` when `P` has joins. -/
theorem sup_mem x y (_ : x âˆˆ I) (_ : y âˆˆ I) : xâŠ”y âˆˆ I :=
  let âŸ¨z, h_mem, hx, hyâŸ© := I.directed x â€¹_â€º y â€¹_â€º
  I.mem_of_le (sup_le hx hy) h_mem

@[simp]
theorem sup_mem_iff : xâŠ”y âˆˆ I â†” x âˆˆ I âˆ§ y âˆˆ I :=
  âŸ¨fun h => âŸ¨I.mem_of_le le_sup_left h, I.mem_of_le le_sup_right hâŸ©, fun h => sup_mem x y h.left h.rightâŸ©

end SemilatticeSup

section SemilatticeSupIdealInterNonempty

variable [SemilatticeSup P] [ideal_inter_nonempty P] {x : P} {I J K : ideal P}

/-- The intersection of two ideals is an ideal, when it is nonempty and `P` has joins. -/
def inf (I J : ideal P) : ideal P :=
  { Carrier := I âˆ© J, Nonempty := inter_nonempty I J,
    Directed :=
      fun x âŸ¨_, _âŸ© y âŸ¨_, _âŸ© =>
        âŸ¨xâŠ”y, âŸ¨sup_mem x y â€¹_â€º â€¹_â€º, sup_mem x y â€¹_â€º â€¹_â€ºâŸ©,
          by 
            simp âŸ©,
    mem_of_le := fun x y h âŸ¨_, _âŸ© => âŸ¨mem_of_le I h â€¹_â€º, mem_of_le J h â€¹_â€ºâŸ© }

/-- There is a smallest ideal containing two ideals, when their intersection is nonempty and
    `P` has joins. -/
def sup (I J : ideal P) : ideal P :=
  { Carrier := { x | âˆƒ (i : _)(_ : i âˆˆ I)(j : _)(_ : j âˆˆ J), x â‰¤ iâŠ”j },
    Nonempty :=
      by 
        cases inter_nonempty I J 
        exact âŸ¨w, w, h.1, w, h.2, le_sup_leftâŸ©,
    Directed :=
      fun x âŸ¨xi, _, xj, _, _âŸ© y âŸ¨yi, _, yj, _, _âŸ© =>
        âŸ¨xâŠ”y,
          âŸ¨xiâŠ”yi, sup_mem xi yi â€¹_â€º â€¹_â€º, xjâŠ”yj, sup_mem xj yj â€¹_â€º â€¹_â€º,
            sup_le
              (calc x â‰¤ xiâŠ”xj := â€¹_â€º
                _ â‰¤ xiâŠ”yiâŠ”(xjâŠ”yj) := sup_le_sup le_sup_left le_sup_left
                )
              (calc y â‰¤ yiâŠ”yj := â€¹_â€º
                _ â‰¤ xiâŠ”yiâŠ”(xjâŠ”yj) := sup_le_sup le_sup_right le_sup_right
                )âŸ©,
          le_sup_left, le_sup_rightâŸ©,
    mem_of_le := fun x y _ âŸ¨yi, _, yj, _, _âŸ© => âŸ¨yi, â€¹_â€º, yj, â€¹_â€º, le_transâ‚“ â€¹x â‰¤ yâ€º â€¹_â€ºâŸ© }

theorem sup_le : I â‰¤ K â†’ J â‰¤ K â†’ sup I J â‰¤ K :=
  fun hIK hJK x âŸ¨i, hiI, j, hjJ, hxijâŸ© =>
    K.mem_of_le hxij$ sup_mem i j (mem_of_mem_of_le hiI hIK) (mem_of_mem_of_le hjJ hJK)

instance : Lattice (ideal P) :=
  { ideal.partial_order with sup := sup,
    le_sup_left :=
      fun I J i _ : i âˆˆ I =>
        by 
          cases Nonempty J 
          exact âŸ¨i, â€¹_â€º, w, â€¹_â€º, le_sup_leftâŸ©,
    le_sup_right :=
      fun I J j _ : j âˆˆ J =>
        by 
          cases Nonempty I 
          exact âŸ¨w, â€¹_â€º, j, â€¹_â€º, le_sup_rightâŸ©,
    sup_le := @sup_le _ _ _, inf := inf, inf_le_left := fun I J => Set.inter_subset_left I J,
    inf_le_right := fun I J => Set.inter_subset_right I J, le_inf := fun I J K => Set.subset_inter }

@[simp]
theorem mem_inf : x âˆˆ IâŠ“J â†” x âˆˆ I âˆ§ x âˆˆ J :=
  iff_of_eq rfl

@[simp]
theorem mem_sup : x âˆˆ IâŠ”J â†” âˆƒ (i : _)(_ : i âˆˆ I)(j : _)(_ : j âˆˆ J), x â‰¤ iâŠ”j :=
  iff_of_eq rfl

theorem lt_sup_principal_of_not_mem (hx : x âˆ‰ I) : I < IâŠ”principal x :=
  by 
    apply lt_of_le_of_neâ‚“ le_sup_left 
    intro h 
    simp  at h 
    exact hx h

end SemilatticeSupIdealInterNonempty

section IdealInterNonempty

variable [Preorderâ‚“ P] [ideal_Inter_nonempty P]

instance (priority := 100) ideal_Inter_nonempty.ideal_inter_nonempty : ideal_inter_nonempty P :=
  { inter_nonempty :=
      fun _ _ =>
        by 
          obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem 
          exact âŸ¨a, ha _, ha _âŸ© }

variable {Î± Î² Î³ : Type _} {Î¹ : Sort _}

theorem ideal_Inter_nonempty.all_Inter_nonempty {f : Î¹ â†’ ideal P} : (â‹‚x, (f x : Set P)).Nonempty :=
  by 
    obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem 
    exact
      âŸ¨a,
        by 
          simp [ha]âŸ©

theorem ideal_Inter_nonempty.all_bInter_nonempty {f : Î± â†’ ideal P} {s : Set Î±} :
  (â‹‚(x : _)(_ : x âˆˆ s), (f x : Set P)).Nonempty :=
  by 
    obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem 
    exact
      âŸ¨a,
        by 
          simp [ha]âŸ©

end IdealInterNonempty

section SemilatticeSupIdealInterNonempty

variable [SemilatticeSup P] [ideal_Inter_nonempty P] {x : P} {I J K : ideal P}

instance : HasInfâ‚“ (ideal P) :=
  { inf :=
      fun s =>
        { Carrier := â‹‚(I : _)(_ : I âˆˆ s), (I : Set P), Nonempty := ideal_Inter_nonempty.all_bInter_nonempty,
          Directed :=
            fun x hx y hy =>
              âŸ¨xâŠ”y,
                âŸ¨fun S âŸ¨I, hSâŸ© =>
                    by 
                      simp only [â†hS, sup_mem_iff, mem_coe, Set.mem_Inter]
                      intro hI 
                      rw [Set.mem_bInter_iff] at *
                      exact âŸ¨hx _ hI, hy _ hIâŸ©,
                  le_sup_left, le_sup_rightâŸ©âŸ©,
          mem_of_le :=
            fun x y hxy hy =>
              by 
                rw [Set.mem_bInter_iff] at *
                exact fun I hI => mem_of_le I â€¹_â€º (hy I hI) } }

variable {s : Set (ideal P)}

@[simp]
theorem mem_Inf : x âˆˆ Inf s â†” âˆ€ I _ : I âˆˆ s, x âˆˆ I :=
  by 
    change (x âˆˆ â‹‚(I : _)(_ : I âˆˆ s), (I : Set P)) â†” âˆ€ I _ : I âˆˆ s, x âˆˆ I 
    simp 

@[simp]
theorem coe_Inf : Â«exprâ†‘ Â» (Inf s) = â‹‚(I : _)(_ : I âˆˆ s), (I : Set P) :=
  rfl

theorem Inf_le (hI : I âˆˆ s) : Inf s â‰¤ I :=
  fun _ hx =>
    hx I
      âŸ¨I,
        by 
          simp [hI]âŸ©

theorem le_Inf (h : âˆ€ J _ : J âˆˆ s, I â‰¤ J) : I â‰¤ Inf s :=
  fun _ _ =>
    by 
      simp only [mem_coe, coe_Inf, Set.mem_Inter]
      tauto

theorem is_glb_Inf : IsGlb s (Inf s) :=
  âŸ¨fun _ => Inf_le, fun _ => le_InfâŸ©

instance : CompleteLattice (ideal P) :=
  { ideal.lattice, completeLatticeOfInf (ideal P) fun _ => @is_glb_Inf _ _ _ _ with  }

end SemilatticeSupIdealInterNonempty

section SemilatticeInf

variable [SemilatticeInf P]

instance (priority := 100) semilattice_inf.ideal_inter_nonempty : ideal_inter_nonempty P :=
  { inter_nonempty :=
      fun I J =>
        by 
          cases' I.nonempty with i _ 
          cases' J.nonempty with j _ 
          exact âŸ¨iâŠ“j, I.mem_of_le inf_le_left â€¹_â€º, J.mem_of_le inf_le_right â€¹_â€ºâŸ© }

end SemilatticeInf

section DistribLattice

variable [DistribLattice P]

variable {I J : ideal P}

theorem eq_sup_of_le_sup {x i j : P} (hi : i âˆˆ I) (hj : j âˆˆ J) (hx : x â‰¤ iâŠ”j) :
  âˆƒ (i' : _)(_ : i' âˆˆ I)(j' : _)(_ : j' âˆˆ J), x = i'âŠ”j' :=
  by 
    refine' âŸ¨xâŠ“i, I.mem_of_le inf_le_right hi, xâŠ“j, J.mem_of_le inf_le_right hj, _âŸ©
    calc x = xâŠ“(iâŠ”j) := left_eq_inf.mpr hx _ = xâŠ“iâŠ”xâŠ“j := inf_sup_left

theorem coe_sup_eq : Â«exprâ†‘ Â» (IâŠ”J) = { x | âˆƒ (i : _)(_ : i âˆˆ I), âˆƒ (j : _)(_ : j âˆˆ J), x = iâŠ”j } :=
  by 
    ext 
    rw [mem_coe, mem_sup]
    exact âŸ¨fun âŸ¨_, _, _, _, _âŸ© => eq_sup_of_le_sup â€¹_â€º â€¹_â€º â€¹_â€º, fun âŸ¨i, _, j, _, _âŸ© => âŸ¨i, â€¹_â€º, j, â€¹_â€º, le_of_eqâ‚“ â€¹_â€ºâŸ©âŸ©

end DistribLattice

section BooleanAlgebra

variable [BooleanAlgebra P] {x : P} {I : ideal P}

-- error in Order.Ideal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_proper.not_mem_of_compl_mem (hI : is_proper I) (hxc : Â«expr âˆˆ Â»(Â«expr á¶œÂ»(x), I)) : Â«expr âˆ‰ Â»(x, I) :=
begin
  intro [ident hx],
  apply [expr hI.top_not_mem],
  have [ident ht] [":", expr Â«expr âˆˆ Â»(Â«expr âŠ” Â»(x, Â«expr á¶œÂ»(x)), I)] [":=", expr sup_mem _ _ Â«exprâ€¹ â€ºÂ»(_) Â«exprâ€¹ â€ºÂ»(_)],
  rwa [expr sup_compl_eq_top] ["at", ident ht]
end

theorem is_proper.not_mem_or_compl_not_mem (hI : is_proper I) : x âˆ‰ I âˆ¨ Â«expr á¶œÂ» x âˆ‰ I :=
  have h : Â«expr á¶œÂ» x âˆˆ I â†’ x âˆ‰ I := hI.not_mem_of_compl_mem 
  by 
    tauto

end BooleanAlgebra

end Ideal

/-- For a preorder `P`, `cofinal P` is the type of subsets of `P`
  containing arbitrarily large elements. They are the dense sets in
  the topology whose open sets are terminal segments. -/
structure cofinal (P) [Preorderâ‚“ P] where 
  Carrier : Set P 
  mem_gt : âˆ€ x : P, âˆƒ (y : _)(_ : y âˆˆ carrier), x â‰¤ y

namespace Cofinal

variable [Preorderâ‚“ P]

instance : Inhabited (cofinal P) :=
  âŸ¨{ Carrier := Set.Univ, mem_gt := fun x => âŸ¨x, trivialâ‚“, le_reflâ‚“ _âŸ© }âŸ©

instance : HasMem P (cofinal P) :=
  âŸ¨fun x D => x âˆˆ D.carrierâŸ©

variable (D : cofinal P) (x : P)

/-- A (noncomputable) element of a cofinal set lying above a given element. -/
noncomputable def above : P :=
  Classical.some$ D.mem_gt x

theorem above_mem : D.above x âˆˆ D :=
  Exists.elim (Classical.some_spec$ D.mem_gt x)$ fun a _ => a

theorem le_above : x â‰¤ D.above x :=
  Exists.elim (Classical.some_spec$ D.mem_gt x)$ fun _ b => b

end Cofinal

section IdealOfCofinals

variable [Preorderâ‚“ P] (p : P) {Î¹ : Type _} [Encodable Î¹] (ğ’Ÿ : Î¹ â†’ cofinal P)

/-- Given a starting point, and a countable family of cofinal sets,
  this is an increasing sequence that intersects each cofinal set. -/
noncomputable def sequence_of_cofinals : â„• â†’ P
| 0 => p
| n+1 =>
  match Encodable.decode Î¹ n with 
  | none => sequence_of_cofinals n
  | some i => (ğ’Ÿ i).above (sequence_of_cofinals n)

theorem sequence_of_cofinals.monotone : Monotone (sequence_of_cofinals p ğ’Ÿ) :=
  by 
    apply monotone_nat_of_le_succ 
    intro n 
    dunfold sequence_of_cofinals 
    cases Encodable.decode Î¹ n
    Â·
      rfl
    Â·
      apply cofinal.le_above

theorem sequence_of_cofinals.encode_mem (i : Î¹) : sequence_of_cofinals p ğ’Ÿ (Encodable.encode i+1) âˆˆ ğ’Ÿ i :=
  by 
    dunfold sequence_of_cofinals 
    rw [Encodable.encodek]
    apply cofinal.above_mem

/-- Given an element `p : P` and a family `ğ’Ÿ` of cofinal subsets of a preorder `P`,
  indexed by a countable type, `ideal_of_cofinals p ğ’Ÿ` is an ideal in `P` which
  - contains `p`, according to `mem_ideal_of_cofinals p ğ’Ÿ`, and
  - intersects every set in `ğ’Ÿ`, according to `cofinal_meets_ideal_of_cofinals p ğ’Ÿ`.

  This proves the Rasiowaâ€“Sikorski lemma. -/
def ideal_of_cofinals : ideal P :=
  { Carrier := { x:P | âˆƒ n, x â‰¤ sequence_of_cofinals p ğ’Ÿ n }, Nonempty := âŸ¨p, 0, le_reflâ‚“ _âŸ©,
    Directed :=
      fun x âŸ¨n, hnâŸ© y âŸ¨m, hmâŸ© =>
        âŸ¨_, âŸ¨max n m, le_reflâ‚“ _âŸ©, le_transâ‚“ hn$ sequence_of_cofinals.monotone p ğ’Ÿ (le_max_leftâ‚“ _ _),
          le_transâ‚“ hm$ sequence_of_cofinals.monotone p ğ’Ÿ (le_max_rightâ‚“ _ _)âŸ©,
    mem_of_le := fun x y hxy âŸ¨n, hnâŸ© => âŸ¨n, le_transâ‚“ hxy hnâŸ© }

theorem mem_ideal_of_cofinals : p âˆˆ ideal_of_cofinals p ğ’Ÿ :=
  âŸ¨0, le_reflâ‚“ _âŸ©

/-- `ideal_of_cofinals p ğ’Ÿ` is `ğ’Ÿ`-generic. -/
theorem cofinal_meets_ideal_of_cofinals (i : Î¹) : âˆƒ x : P, x âˆˆ ğ’Ÿ i âˆ§ x âˆˆ ideal_of_cofinals p ğ’Ÿ :=
  âŸ¨_, sequence_of_cofinals.encode_mem p ğ’Ÿ i, _, le_reflâ‚“ _âŸ©

end IdealOfCofinals

end Order

