/-
Copyright (c) 2020 David WÃ¤rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David WÃ¤rn
-/
import Mathbin.Data.Equiv.Encodable.Basic
import Mathbin.Order.Atoms

/-!
# Order ideals, cofinal sets, and the Rasiowaâ€“Sikorski lemma

## Main definitions

Throughout this file, `P` is at least a preorder, but some sections require more
structure, such as a bottom element, a top element, or a join-semilattice structure.
- `order.ideal P`: the type of nonempty, upward directed, and downward closed subsets of `P`.
  Dual to the notion of a filter on a preorder.
- `order.is_ideal P`: a predicate for when a `set P` is an ideal.
- `order.ideal.principal p`: the principal ideal generated by `p : P`.
- `order.ideal.is_proper P`: a predicate for proper ideals.
  Dual to the notion of a proper filter.
- `order.ideal.is_maximal`: a predicate for maximal ideals.
  Dual to the notion of an ultrafilter.
- `ideal_Inter_nonempty P`: a predicate for when the intersection of all ideals of
  `P` is nonempty.
- `order.cofinal P`: the type of subsets of `P` containing arbitrarily large elements.
  Dual to the notion of 'dense set' used in forcing.
- `order.ideal_of_cofinals p ğ’Ÿ`, where `p : P`, and `ğ’Ÿ` is a countable family of cofinal
  subsets of P: an ideal in `P` which contains `p` and intersects every set in `ğ’Ÿ`. (This a form
  of the Rasiowaâ€“Sikorski lemma.)

## References

- <https://en.wikipedia.org/wiki/Ideal_(order_theory)>
- <https://en.wikipedia.org/wiki/Cofinal_(mathematics)>
- <https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma>

Note that for the Rasiowaâ€“Sikorski lemma, Wikipedia uses the opposite ordering on `P`,
in line with most presentations of forcing.

## TODO

`order.ideal.ideal_Inter_nonempty` is a complicated way to say that `P` has a bottom element. It
should be replaced by this clearer condition, which could be called strong directedness and which
is a Prop version of `order_bot`.

## Tags

ideal, cofinal, dense, countable, generic

-/


open Function

namespace Order

variable {P : Type _}

/-- An ideal on an order `P` is a subset of `P` that is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
structure Ideal (P) [LE P] where
  Carrier : Set P
  Nonempty : carrier.Nonempty
  Directed : DirectedOn (Â· â‰¤ Â·) carrier
  mem_of_le : âˆ€ {x y : P}, x â‰¤ y â†’ y âˆˆ carrier â†’ x âˆˆ carrier

/-- A subset of a preorder `P` is an ideal if it is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
@[mk_iff]
structure IsIdeal {P} [LE P] (I : Set P) : Prop where
  Nonempty : I.Nonempty
  Directed : DirectedOn (Â· â‰¤ Â·) I
  mem_of_le : âˆ€ {x y : P}, x â‰¤ y â†’ y âˆˆ I â†’ x âˆˆ I

attribute [protected] ideal.nonempty ideal.directed is_ideal.nonempty is_ideal.directed

/-- Create an element of type `order.ideal` from a set satisfying the predicate
`order.is_ideal`. -/
def IsIdeal.toIdeal [LE P] {I : Set P} (h : IsIdeal I) : Ideal P :=
  âŸ¨I, h.1, h.2, h.3âŸ©

namespace Ideal

section LE

variable [LE P] {I J : Ideal P} {x y : P}

/-- An ideal of `P` can be viewed as a subset of `P`. -/
instance : Coe (Ideal P) (Set P) :=
  âŸ¨CarrierâŸ©

/-- For the notation `x âˆˆ I`. -/
instance : HasMem P (Ideal P) :=
  âŸ¨fun x I => x âˆˆ (I : Set P)âŸ©

@[simp]
theorem mem_coe : x âˆˆ (I : Set P) â†” x âˆˆ I :=
  iff_of_eq rfl

/-- Two ideals are equal when their underlying sets are equal. -/
@[ext]
theorem ext : âˆ€ {I J : Ideal P}, (I : Set P) = J â†’ I = J
  | âŸ¨_, _, _, _âŸ©, âŸ¨_, _, _, _âŸ©, rfl => rfl

theorem coe_injective : Injective (coe : Ideal P â†’ Set P) := fun _ _ => ext

@[simp, norm_cast]
theorem coe_inj : (I : Set P) = J â†” I = J :=
  âŸ¨by
    ext, congr_argâ‚“ _âŸ©

theorem ext_iff : I = J â†” (I : Set P) = J :=
  coe_inj.symm

protected theorem is_ideal (I : Ideal P) : IsIdeal (I : Set P) :=
  âŸ¨I.2, I.3, I.4âŸ©

/-- The partial ordering by subset inclusion, inherited from `set P`. -/
instance : PartialOrderâ‚“ (Ideal P) :=
  PartialOrderâ‚“.lift coe coe_injective

@[trans]
theorem mem_of_mem_of_le : x âˆˆ I â†’ I â‰¤ J â†’ x âˆˆ J :=
  @Set.mem_of_mem_of_subset P x I J

/-- A proper ideal is one that is not the whole set.
    Note that the whole set might not be an ideal. -/
@[mk_iff]
class IsProper (I : Ideal P) : Prop where
  ne_univ : (I : Set P) â‰  Set.Univ

theorem is_proper_of_not_mem {I : Ideal P} {p : P} (nmem : p âˆ‰ I) : IsProper I :=
  âŸ¨fun hp => by
    change p âˆ‰ â†‘I at nmem
    rw [hp] at nmem
    exact nmem (Set.mem_univ p)âŸ©

/-- An ideal is maximal if it is maximal in the collection of proper ideals.

Note that `is_coatom` is less general because ideals only have a top element when `P` is directed
and nonempty. -/
@[mk_iff]
class IsMaximal (I : Ideal P) extends IsProper I : Prop where
  maximal_proper : âˆ€ â¦ƒJ : Ideal Pâ¦„, I < J â†’ (J : Set P) = Set.Univ

variable (P)

/-- An order `P` has the `ideal_Inter_nonempty` property if the intersection of all ideals is
nonempty. Most importantly, the ideals of a `semilattice_sup` with this property form a complete
lattice.

TODO: This is equivalent to the existence of a bottom element and shouldn't be specialized to
ideals. -/
class IdealInterNonempty : Prop where
  Inter_nonempty : (â‹‚ I : Ideal P, (I : Set P)).Nonempty

variable {P}

theorem Inter_nonempty [IdealInterNonempty P] : (â‹‚ I : Ideal P, (I : Set P)).Nonempty :=
  ideal_Inter_nonempty.Inter_nonempty

theorem IdealInterNonempty.exists_all_mem [IdealInterNonempty P] : âˆƒ a : P, âˆ€ I : Ideal P, a âˆˆ I := by
  change âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ (I : Set P)
  rw [â† Set.nonempty_Inter]
  exact Inter_nonempty

theorem ideal_Inter_nonempty_of_exists_all_mem (h : âˆƒ a : P, âˆ€ I : Ideal P, a âˆˆ I) : IdealInterNonempty P :=
  { Inter_nonempty := by
      rwa [Set.nonempty_Inter] }

theorem ideal_Inter_nonempty_iff : IdealInterNonempty P â†” âˆƒ a : P, âˆ€ I : Ideal P, a âˆˆ I :=
  âŸ¨fun _ => ideal_Inter_nonempty.exists_all_mem, ideal_Inter_nonempty_of_exists_all_memâŸ©

theorem inter_nonempty [IsDirected P (swap (Â· â‰¤ Â·))] (I J : Ideal P) : (I âˆ© J : Set P).Nonempty := by
  obtain âŸ¨a, haâŸ© := I.nonempty
  obtain âŸ¨b, hbâŸ© := J.nonempty
  obtain âŸ¨c, hac, hbcâŸ© := directed_of (swap (Â· â‰¤ Â·)) a b
  exact âŸ¨c, I.mem_of_le hac ha, J.mem_of_le hbc hbâŸ©

end LE

section Preorderâ‚“

variable [Preorderâ‚“ P] {I J : Ideal P} {x y : P}

/-- The smallest ideal containing a given element. -/
def principal (p : P) : Ideal P where
  Carrier := { x | x â‰¤ p }
  Nonempty := âŸ¨p, le_rflâŸ©
  Directed := fun x hx y hy => âŸ¨p, le_rfl, hx, hyâŸ©
  mem_of_le := fun x y hxy hy => le_transâ‚“ hxy hy

instance [Inhabited P] : Inhabited (Ideal P) :=
  âŸ¨Ideal.principal defaultâŸ©

@[simp]
theorem principal_le_iff : principal x â‰¤ I â†” x âˆˆ I :=
  âŸ¨fun h : âˆ€ {y}, y â‰¤ x â†’ y âˆˆ I => h (le_reflâ‚“ x), fun h_le : y â‰¤ x => I.mem_of_le h_le h_memâŸ©

@[simp]
theorem mem_principal : x âˆˆ principal y â†” x â‰¤ y :=
  Iff.rfl

theorem mem_compl_of_ge {x y : P} : x â‰¤ y â†’ x âˆˆ (I : Set P)á¶œ â†’ y âˆˆ (I : Set P)á¶œ := fun h => mt (I.mem_of_le h)

end Preorderâ‚“

section OrderBot

/-- A specific witness of `I.nonempty` when `P` has a bottom element. -/
@[simp]
theorem bot_mem [LE P] [OrderBot P] {I : Ideal P} : âŠ¥ âˆˆ I :=
  I.mem_of_le bot_le I.Nonempty.some_mem

variable [Preorderâ‚“ P] [OrderBot P] {I : Ideal P}

/-- There is a bottom ideal when `P` has a bottom element. -/
instance : OrderBot (Ideal P) where
  bot := principal âŠ¥
  bot_le := by
    simp

instance (priority := 100) orderBot.ideal_Inter_nonempty : IdealInterNonempty P := by
  rw [ideal_Inter_nonempty_iff]
  exact âŸ¨âŠ¥, fun I => bot_memâŸ©

end OrderBot

section Directed

variable [LE P] [IsDirected P (Â· â‰¤ Â·)] [Nonempty P] {I : Ideal P}

/-- In a directed and nonempty order, the top ideal of a is `set.univ`. -/
instance : OrderTop (Ideal P) where
  top :=
    { Carrier := Set.Univ, Nonempty := Set.univ_nonempty, Directed := directed_on_univ,
      mem_of_le := fun _ _ _ _ => trivialâ‚“ }
  le_top := fun I => le_top

@[simp]
theorem coe_top : ((âŠ¤ : Ideal P) : Set P) = Set.Univ :=
  rfl

theorem is_proper_of_ne_top (ne_top : I â‰  âŠ¤) : IsProper I :=
  âŸ¨fun h => ne_top <| ext hâŸ©

theorem IsProper.ne_top (hI : IsProper I) : I â‰  âŠ¤ := by
  intro h
  rw [ext_iff, coe_top] at h
  apply hI.ne_univ
  assumption

theorem _root_.is_coatom.is_proper (hI : IsCoatom I) : IsProper I :=
  is_proper_of_ne_top hI.1

theorem is_proper_iff_ne_top : IsProper I â†” I â‰  âŠ¤ :=
  âŸ¨fun h => h.ne_top, fun h => is_proper_of_ne_top hâŸ©

theorem IsMaximal.is_coatom (h : IsMaximal I) : IsCoatom I :=
  âŸ¨IsMaximal.to_is_proper.ne_top, fun _ _ => by
    rw [ext_iff, coe_top]
    exact is_maximal.maximal_proper â€¹_â€ºâŸ©

theorem IsMaximal.is_coatom' [IsMaximal I] : IsCoatom I :=
  IsMaximal.is_coatom â€¹_â€º

theorem _root_.is_coatom.is_maximal (hI : IsCoatom I) : IsMaximal I :=
  { IsCoatom.is_proper â€¹_â€º with
    maximal_proper := fun _ _ => by
      simp [hI.2 _ â€¹_â€º] }

theorem is_maximal_iff_is_coatom : IsMaximal I â†” IsCoatom I :=
  âŸ¨fun h => h.IsCoatom, fun h => h.IsMaximalâŸ©

end Directed

section OrderTop

variable [LE P] [OrderTop P] {I : Ideal P}

theorem top_of_top_mem (hI : âŠ¤ âˆˆ I) : I = âŠ¤ := by
  ext
  exact iff_of_true (I.mem_of_le le_top hI) trivialâ‚“

theorem IsProper.top_not_mem (hI : IsProper I) : âŠ¤ âˆ‰ I := fun h => hI.ne_top <| top_of_top_mem h

end OrderTop

section SemilatticeSup

variable [SemilatticeSup P] {x y : P} {I : Ideal P}

-- ././Mathport/Syntax/Translate/Basic.lean:598:2: warning: expanding binder collection (x y Â«expr âˆˆ Â» I)
/-- A specific witness of `I.directed` when `P` has joins. -/
theorem sup_mem x y (_ : x âˆˆ I) (_ : y âˆˆ I) : xâŠ”y âˆˆ I :=
  let âŸ¨z, h_mem, hx, hyâŸ© := I.Directed x â€¹_â€º y â€¹_â€º
  I.mem_of_le (sup_le hx hy) h_mem

@[simp]
theorem sup_mem_iff : xâŠ”y âˆˆ I â†” x âˆˆ I âˆ§ y âˆˆ I :=
  âŸ¨fun h => âŸ¨I.mem_of_le le_sup_left h, I.mem_of_le le_sup_right hâŸ©, fun h => sup_mem x h.left y h.rightâŸ©

end SemilatticeSup

section SemilatticeSupDirected

variable [SemilatticeSup P] [IsDirected P (swap (Â· â‰¤ Â·))] {x : P} {I J K : Ideal P}

/-- The infimum of two ideals of a co-directed order is their intersection. -/
instance : HasInf (Ideal P) :=
  âŸ¨fun I J =>
    { Carrier := I âˆ© J, Nonempty := inter_nonempty I J,
      Directed := fun y âŸ¨_, _âŸ© =>
        âŸ¨xâŠ”y, âŸ¨sup_mem x â€¹_â€º y â€¹_â€º, sup_mem x â€¹_â€º y â€¹_â€ºâŸ©, by
          simp âŸ©,
      mem_of_le := fun x y h âŸ¨_, _âŸ© => âŸ¨mem_of_le I h â€¹_â€º, mem_of_le J h â€¹_â€ºâŸ© }âŸ©

/-- The supremum of two ideals of a co-directed order is the union of the down sets of the pointwise
supremum of `I` and `J`. -/
instance : HasSup (Ideal P) :=
  âŸ¨fun I J =>
    { Carrier := { x | âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x â‰¤ iâŠ”j },
      Nonempty := by
        cases inter_nonempty I J
        exact âŸ¨w, w, h.1, w, h.2, le_sup_leftâŸ©,
      Directed := fun y âŸ¨yi, _, yj, _, _âŸ© =>
        âŸ¨xâŠ”y,
          âŸ¨xiâŠ”yi, sup_mem xi â€¹_â€º yi â€¹_â€º, xjâŠ”yj, sup_mem xj â€¹_â€º yj â€¹_â€º,
            sup_le
              (calc
                x â‰¤ xiâŠ”xj := â€¹_â€º
                _ â‰¤ xiâŠ”yiâŠ”(xjâŠ”yj) := sup_le_sup le_sup_left le_sup_left
                )
              (calc
                y â‰¤ yiâŠ”yj := â€¹_â€º
                _ â‰¤ xiâŠ”yiâŠ”(xjâŠ”yj) := sup_le_sup le_sup_right le_sup_right
                )âŸ©,
          le_sup_left, le_sup_rightâŸ©,
      mem_of_le := fun x y _ âŸ¨yi, _, yj, _, _âŸ© => âŸ¨yi, â€¹_â€º, yj, â€¹_â€º, le_transâ‚“ â€¹x â‰¤ yâ€º â€¹_â€ºâŸ© }âŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:598:2: warning: expanding binder collection (i Â«expr âˆˆ Â» I)
-- ././Mathport/Syntax/Translate/Basic.lean:598:2: warning: expanding binder collection (j Â«expr âˆˆ Â» J)
instance : Lattice (Ideal P) :=
  { Ideal.partialOrder with sup := (Â·âŠ”Â·),
    le_sup_left := fun i _ : i âˆˆ I => by
      cases J.nonempty
      exact âŸ¨i, â€¹_â€º, w, â€¹_â€º, le_sup_leftâŸ©,
    le_sup_right := fun j _ : j âˆˆ J => by
      cases I.nonempty
      exact âŸ¨w, â€¹_â€º, j, â€¹_â€º, le_sup_rightâŸ©,
    sup_le := fun I J K hIK hJK a âŸ¨i, hi, j, hj, haâŸ© =>
      K.mem_of_le ha <| sup_mem i (mem_of_mem_of_le hi hIK) j (mem_of_mem_of_le hj hJK),
    inf := (Â·âŠ“Â·), inf_le_left := fun I J => Set.inter_subset_left I J,
    inf_le_right := fun I J => Set.inter_subset_right I J, le_inf := fun I J K => Set.subset_inter }

@[simp]
theorem mem_inf : x âˆˆ IâŠ“J â†” x âˆˆ I âˆ§ x âˆˆ J :=
  Iff.rfl

@[simp]
theorem mem_sup : x âˆˆ IâŠ”J â†” âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x â‰¤ iâŠ”j :=
  Iff.rfl

theorem lt_sup_principal_of_not_mem (hx : x âˆ‰ I) : I < IâŠ”principal x :=
  le_sup_left.lt_of_ne fun h =>
    hx <| by
      simpa only [left_eq_sup, principal_le_iff] using h

end SemilatticeSupDirected

section IdealInterNonempty

variable [Preorderâ‚“ P] [IdealInterNonempty P]

instance (priority := 100) IdealInterNonempty.to_directed_ge : IsDirected P (swap (Â· â‰¤ Â·)) :=
  âŸ¨fun a b => by
    obtain âŸ¨c, hcâŸ© : âˆƒ a, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem
    exact âŸ¨c, hc (principal a), hc (principal b)âŸ©âŸ©

variable {Î± Î² Î³ : Type _} {Î¹ : Sort _}

theorem IdealInterNonempty.all_Inter_nonempty {f : Î¹ â†’ Ideal P} : (â‹‚ x, (f x : Set P)).Nonempty := by
  obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem
  exact
    âŸ¨a, by
      simp [ha]âŸ©

theorem IdealInterNonempty.all_bInter_nonempty {f : Î± â†’ Ideal P} {s : Set Î±} : (â‹‚ x âˆˆ s, (f x : Set P)).Nonempty := by
  obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem
  exact
    âŸ¨a, by
      simp [ha]âŸ©

end IdealInterNonempty

section SemilatticeSupIdealInterNonempty

variable [SemilatticeSup P] [IdealInterNonempty P] {x : P} {I J K : Ideal P}

instance : HasInfâ‚“ (Ideal P) where
  inf := fun s =>
    { Carrier := â‹‚ I âˆˆ s, (I : Set P), Nonempty := IdealInterNonempty.all_bInter_nonempty,
      Directed := fun x hx y hy =>
        âŸ¨xâŠ”y,
          âŸ¨fun S âŸ¨I, hSâŸ© => by
            simp only [â† hS, sup_mem_iff, mem_coe, Set.mem_Inter]
            intro hI
            rw [Set.mem_Interâ‚‚] at *
            exact âŸ¨hx _ hI, hy _ hIâŸ©, le_sup_left, le_sup_rightâŸ©âŸ©,
      mem_of_le := fun x y hxy hy => by
        rw [Set.mem_Interâ‚‚] at *
        exact fun I hI => mem_of_le I â€¹_â€º (hy I hI) }

variable {s : Set (Ideal P)}

@[simp]
theorem mem_Inf : x âˆˆ inf s â†” âˆ€, âˆ€ I âˆˆ s, âˆ€, x âˆˆ I := by
  change (x âˆˆ â‹‚ I âˆˆ s, (I : Set P)) â†” âˆ€, âˆ€ I âˆˆ s, âˆ€, x âˆˆ I
  simp

@[simp]
theorem coe_Inf : â†‘(inf s) = â‹‚ I âˆˆ s, (I : Set P) :=
  rfl

theorem Inf_le (hI : I âˆˆ s) : inf s â‰¤ I := fun _ hx =>
  hx I
    âŸ¨I, by
      simp [hI]âŸ©

theorem le_Inf (h : âˆ€, âˆ€ J âˆˆ s, âˆ€, I â‰¤ J) : I â‰¤ inf s := fun _ _ => by
  simp only [mem_coe, coe_Inf, Set.mem_Inter]
  tauto

theorem is_glb_Inf : IsGlb s (inf s) :=
  âŸ¨fun _ => Inf_le, fun _ => le_InfâŸ©

instance : CompleteLattice (Ideal P) :=
  { Ideal.lattice, completeLatticeOfInf (Ideal P) fun _ => @is_glb_Inf _ _ _ _ with }

end SemilatticeSupIdealInterNonempty

section DistribLattice

variable [DistribLattice P]

variable {I J : Ideal P}

theorem eq_sup_of_le_sup {x i j : P} (hi : i âˆˆ I) (hj : j âˆˆ J) (hx : x â‰¤ iâŠ”j) : âˆƒ i' âˆˆ I, âˆƒ j' âˆˆ J, x = i'âŠ”j' := by
  refine' âŸ¨xâŠ“i, I.mem_of_le inf_le_right hi, xâŠ“j, J.mem_of_le inf_le_right hj, _âŸ©
  calc x = xâŠ“(iâŠ”j) := left_eq_inf.mpr hx _ = xâŠ“iâŠ”xâŠ“j := inf_sup_left

theorem coe_sup_eq : â†‘(IâŠ”J) = { x | âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x = iâŠ”j } := by
  ext
  rw [mem_coe, mem_sup]
  exact âŸ¨fun âŸ¨_, _, _, _, _âŸ© => eq_sup_of_le_sup â€¹_â€º â€¹_â€º â€¹_â€º, fun âŸ¨i, _, j, _, _âŸ© => âŸ¨i, â€¹_â€º, j, â€¹_â€º, le_of_eqâ‚“ â€¹_â€ºâŸ©âŸ©

end DistribLattice

section BooleanAlgebra

variable [BooleanAlgebra P] {x : P} {I : Ideal P}

theorem IsProper.not_mem_of_compl_mem (hI : IsProper I) (hxc : xá¶œ âˆˆ I) : x âˆ‰ I := by
  intro hx
  apply hI.top_not_mem
  have ht : xâŠ”xá¶œ âˆˆ I := sup_mem _ â€¹_â€º _ â€¹_â€º
  rwa [sup_compl_eq_top] at ht

theorem IsProper.not_mem_or_compl_not_mem (hI : IsProper I) : (x âˆ‰ I) âˆ¨ xá¶œ âˆ‰ I := by
  have h : xá¶œ âˆˆ I â†’ x âˆ‰ I := hI.not_mem_of_compl_mem
  tauto

end BooleanAlgebra

end Ideal

/-- For a preorder `P`, `cofinal P` is the type of subsets of `P`
  containing arbitrarily large elements. They are the dense sets in
  the topology whose open sets are terminal segments. -/
structure Cofinal (P) [Preorderâ‚“ P] where
  Carrier : Set P
  mem_gt : âˆ€ x : P, âˆƒ y âˆˆ carrier, x â‰¤ y

namespace Cofinal

variable [Preorderâ‚“ P]

instance : Inhabited (Cofinal P) :=
  âŸ¨{ Carrier := Set.Univ, mem_gt := fun x => âŸ¨x, trivialâ‚“, le_rflâŸ© }âŸ©

instance : HasMem P (Cofinal P) :=
  âŸ¨fun x D => x âˆˆ D.CarrierâŸ©

variable (D : Cofinal P) (x : P)

/-- A (noncomputable) element of a cofinal set lying above a given element. -/
noncomputable def above : P :=
  Classical.some <| D.mem_gt x

theorem above_mem : D.above x âˆˆ D :=
  (Exists.elim (Classical.some_spec <| D.mem_gt x)) fun a _ => a

theorem le_above : x â‰¤ D.above x :=
  (Exists.elim (Classical.some_spec <| D.mem_gt x)) fun _ b => b

end Cofinal

section IdealOfCofinals

variable [Preorderâ‚“ P] (p : P) {Î¹ : Type _} [Encodable Î¹] (ğ’Ÿ : Î¹ â†’ Cofinal P)

/-- Given a starting point, and a countable family of cofinal sets,
  this is an increasing sequence that intersects each cofinal set. -/
noncomputable def sequenceOfCofinals : â„• â†’ P
  | 0 => p
  | n + 1 =>
    match Encodable.decode Î¹ n with
    | none => sequence_of_cofinals n
    | some i => (ğ’Ÿ i).above (sequence_of_cofinals n)

theorem sequenceOfCofinals.monotone : Monotone (sequenceOfCofinals p ğ’Ÿ) := by
  apply monotone_nat_of_le_succ
  intro n
  dunfold sequence_of_cofinals
  cases Encodable.decode Î¹ n
  Â· rfl
    
  Â· apply cofinal.le_above
    

theorem sequenceOfCofinals.encode_mem (i : Î¹) : sequenceOfCofinals p ğ’Ÿ (Encodable.encode i + 1) âˆˆ ğ’Ÿ i := by
  dunfold sequence_of_cofinals
  rw [Encodable.encodek]
  apply cofinal.above_mem

/-- Given an element `p : P` and a family `ğ’Ÿ` of cofinal subsets of a preorder `P`,
  indexed by a countable type, `ideal_of_cofinals p ğ’Ÿ` is an ideal in `P` which
  - contains `p`, according to `mem_ideal_of_cofinals p ğ’Ÿ`, and
  - intersects every set in `ğ’Ÿ`, according to `cofinal_meets_ideal_of_cofinals p ğ’Ÿ`.

  This proves the Rasiowaâ€“Sikorski lemma. -/
def idealOfCofinals : Ideal P where
  Carrier := { x : P | âˆƒ n, x â‰¤ sequenceOfCofinals p ğ’Ÿ n }
  Nonempty := âŸ¨p, 0, le_rflâŸ©
  Directed := fun y âŸ¨m, hmâŸ© =>
    âŸ¨_, âŸ¨max n m, le_rflâŸ©, le_transâ‚“ hn <| sequenceOfCofinals.monotone p ğ’Ÿ (le_max_leftâ‚“ _ _),
      le_transâ‚“ hm <| sequenceOfCofinals.monotone p ğ’Ÿ (le_max_rightâ‚“ _ _)âŸ©
  mem_of_le := fun x y hxy âŸ¨n, hnâŸ© => âŸ¨n, le_transâ‚“ hxy hnâŸ©

theorem mem_ideal_of_cofinals : p âˆˆ idealOfCofinals p ğ’Ÿ :=
  âŸ¨0, le_rflâŸ©

/-- `ideal_of_cofinals p ğ’Ÿ` is `ğ’Ÿ`-generic. -/
theorem cofinal_meets_ideal_of_cofinals (i : Î¹) : âˆƒ x : P, x âˆˆ ğ’Ÿ i âˆ§ x âˆˆ idealOfCofinals p ğ’Ÿ :=
  âŸ¨_, sequenceOfCofinals.encode_mem p ğ’Ÿ i, _, le_rflâŸ©

end IdealOfCofinals

end Order

