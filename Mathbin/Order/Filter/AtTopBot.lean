import Mathbin.Order.Filter.Bases 
import Mathbin.Data.Finset.Preimage

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `at_top`: corresponds to `n â†’ +âˆ`;
* `at_bot`: corresponds to `n â†’ -âˆ`.

Then we prove many lemmas like â€œif `f â†’ +âˆ`, then `f Â± c â†’ +âˆ`â€.
-/


variable{Î¹ Î¹' Î± Î² Î³ : Type _}

open Set

open_locale Classical Filter BigOperators

namespace Filter

/-- `at_top` is the filter representing the limit `â†’ âˆ` on an ordered set.
  It is generated by the collection of up-sets `{b | a â‰¤ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def at_top [Preorderâ‚“ Î±] : Filter Î± :=
  â¨…a, ğ“Ÿ (Ici a)

/-- `at_bot` is the filter representing the limit `â†’ -âˆ` on an ordered set.
  It is generated by the collection of down-sets `{b | b â‰¤ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def at_bot [Preorderâ‚“ Î±] : Filter Î± :=
  â¨…a, ğ“Ÿ (Iic a)

theorem mem_at_top [Preorderâ‚“ Î±] (a : Î±) : { b:Î± | a â‰¤ b } âˆˆ @at_top Î± _ :=
  mem_infi_of_mem a$ subset.refl _

theorem Ioi_mem_at_top [Preorderâ‚“ Î±] [NoTopOrder Î±] (x : Î±) : Ioi x âˆˆ (at_top : Filter Î±) :=
  let âŸ¨z, hzâŸ© := no_top x 
  mem_of_superset (mem_at_top z)$ fun y h => lt_of_lt_of_leâ‚“ hz h

theorem mem_at_bot [Preorderâ‚“ Î±] (a : Î±) : { b:Î± | b â‰¤ a } âˆˆ @at_bot Î± _ :=
  mem_infi_of_mem a$ subset.refl _

theorem Iio_mem_at_bot [Preorderâ‚“ Î±] [NoBotOrder Î±] (x : Î±) : Iio x âˆˆ (at_bot : Filter Î±) :=
  let âŸ¨z, hzâŸ© := no_bot x 
  mem_of_superset (mem_at_bot z)$ fun y h => lt_of_le_of_ltâ‚“ h hz

theorem at_top_basis [Nonempty Î±] [SemilatticeSup Î±] : (@at_top Î± _).HasBasis (fun _ => True) Ici :=
  has_basis_infi_principal (directed_of_sup$ fun a b => Ici_subset_Ici.2)

theorem at_top_basis' [SemilatticeSup Î±] (a : Î±) : (@at_top Î± _).HasBasis (fun x => a â‰¤ x) Ici :=
  âŸ¨fun t =>
      (@at_top_basis Î± âŸ¨aâŸ© _).mem_iff.trans
        âŸ¨fun âŸ¨x, _, hxâŸ© => âŸ¨xâŠ”a, le_sup_right, fun y hy => hx (le_transâ‚“ le_sup_left hy)âŸ©,
          fun âŸ¨x, _, hxâŸ© => âŸ¨x, trivialâ‚“, hxâŸ©âŸ©âŸ©

theorem at_bot_basis [Nonempty Î±] [SemilatticeInf Î±] : (@at_bot Î± _).HasBasis (fun _ => True) Iic :=
  @at_top_basis (OrderDual Î±) _ _

theorem at_bot_basis' [SemilatticeInf Î±] (a : Î±) : (@at_bot Î± _).HasBasis (fun x => x â‰¤ a) Iic :=
  @at_top_basis' (OrderDual Î±) _ _

@[instance]
theorem at_top_ne_bot [Nonempty Î±] [SemilatticeSup Î±] : ne_bot (at_top : Filter Î±) :=
  at_top_basis.ne_bot_iff.2$ fun a _ => nonempty_Ici

@[instance]
theorem at_bot_ne_bot [Nonempty Î±] [SemilatticeInf Î±] : ne_bot (at_bot : Filter Î±) :=
  @at_top_ne_bot (OrderDual Î±) _ _

@[simp]
theorem mem_at_top_sets [Nonempty Î±] [SemilatticeSup Î±] {s : Set Î±} :
  s âˆˆ (at_top : Filter Î±) â†” âˆƒ a : Î±, âˆ€ b _ : b â‰¥ a, b âˆˆ s :=
  at_top_basis.mem_iff.trans$ exists_congr$ fun _ => exists_const _

@[simp]
theorem mem_at_bot_sets [Nonempty Î±] [SemilatticeInf Î±] {s : Set Î±} :
  s âˆˆ (at_bot : Filter Î±) â†” âˆƒ a : Î±, âˆ€ b _ : b â‰¤ a, b âˆˆ s :=
  @mem_at_top_sets (OrderDual Î±) _ _ _

@[simp]
theorem eventually_at_top [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
  (âˆ€á¶ x in at_top, p x) â†” âˆƒ a, âˆ€ b _ : b â‰¥ a, p b :=
  mem_at_top_sets

@[simp]
theorem eventually_at_bot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
  (âˆ€á¶ x in at_bot, p x) â†” âˆƒ a, âˆ€ b _ : b â‰¤ a, p b :=
  mem_at_bot_sets

theorem eventually_ge_at_top [Preorderâ‚“ Î±] (a : Î±) : âˆ€á¶ x in at_top, a â‰¤ x :=
  mem_at_top a

theorem eventually_le_at_bot [Preorderâ‚“ Î±] (a : Î±) : âˆ€á¶ x in at_bot, x â‰¤ a :=
  mem_at_bot a

theorem eventually_gt_at_top [Preorderâ‚“ Î±] [NoTopOrder Î±] (a : Î±) : âˆ€á¶ x in at_top, a < x :=
  Ioi_mem_at_top a

theorem eventually_lt_at_bot [Preorderâ‚“ Î±] [NoBotOrder Î±] (a : Î±) : âˆ€á¶ x in at_bot, x < a :=
  Iio_mem_at_bot a

theorem at_top_basis_Ioi [Nonempty Î±] [SemilatticeSup Î±] [NoTopOrder Î±] : (@at_top Î± _).HasBasis (fun _ => True) Ioi :=
  (at_top_basis.to_has_basis fun a ha => âŸ¨a, ha, Ioi_subset_Ici_selfâŸ©)$
    fun a ha => (no_top a).imp$ fun b hb => âŸ¨ha, Ici_subset_Ioi.2 hbâŸ©

theorem at_top_countable_basis [Nonempty Î±] [SemilatticeSup Î±] [Encodable Î±] :
  has_countable_basis (at_top : Filter Î±) (fun _ => True) Ici :=
  { at_top_basis with Countable := countable_encodable _ }

theorem at_bot_countable_basis [Nonempty Î±] [SemilatticeInf Î±] [Encodable Î±] :
  has_countable_basis (at_bot : Filter Î±) (fun _ => True) Iic :=
  { at_bot_basis with Countable := countable_encodable _ }

instance (priority := 200)at_top.is_countably_generated [Preorderâ‚“ Î±] [Encodable Î±] :
  (at_top : Filter$ Î±).IsCountablyGenerated :=
  is_countably_generated_seq _

instance (priority := 200)at_bot.is_countably_generated [Preorderâ‚“ Î±] [Encodable Î±] :
  (at_bot : Filter$ Î±).IsCountablyGenerated :=
  is_countably_generated_seq _

theorem order_top.at_top_eq Î± [PartialOrderâ‚“ Î±] [OrderTop Î±] : (at_top : Filter Î±) = pure âŠ¤ :=
  le_antisymmâ‚“ (le_pure_iff.2$ (eventually_ge_at_top âŠ¤).mono$ fun b => top_unique)
    (le_infi$ fun b => le_principal_iff.2 le_top)

theorem order_bot.at_bot_eq Î± [PartialOrderâ‚“ Î±] [OrderBot Î±] : (at_bot : Filter Î±) = pure âŠ¥ :=
  @order_top.at_top_eq (OrderDual Î±) _ _

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[nontriviality #[]]
theorem subsingleton.at_top_eq (Î±) [subsingleton Î±] [preorder Î±] : Â«expr = Â»((at_top : filter Î±), Â«exprâŠ¤Â»()) :=
begin
  refine [expr top_unique (Î» s hs x, _)],
  letI [] [":", expr unique Î±] [":=", expr âŸ¨âŸ¨xâŸ©, Î» y, subsingleton.elim y xâŸ©],
  rw ["[", expr at_top, ",", expr infi_unique, ",", expr unique.default_eq x, ",", expr mem_principal, "]"] ["at", ident hs],
  exact [expr hs left_mem_Ici]
end

@[nontriviality]
theorem subsingleton.at_bot_eq Î± [Subsingleton Î±] [Preorderâ‚“ Î±] : (at_bot : Filter Î±) = âŠ¤ :=
  @subsingleton.at_top_eq (OrderDual Î±) _ _

theorem tendsto_at_top_pure [PartialOrderâ‚“ Î±] [OrderTop Î±] (f : Î± â†’ Î²) : tendsto f at_top (pure$ f âŠ¤) :=
  (order_top.at_top_eq Î±).symm â–¸ tendsto_pure_pure _ _

theorem tendsto_at_bot_pure [PartialOrderâ‚“ Î±] [OrderBot Î±] (f : Î± â†’ Î²) : tendsto f at_bot (pure$ f âŠ¥) :=
  @tendsto_at_top_pure (OrderDual Î±) _ _ _ _

theorem eventually.exists_forall_of_at_top [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop} (h : âˆ€á¶ x in at_top, p x) :
  âˆƒ a, âˆ€ b _ : b â‰¥ a, p b :=
  eventually_at_top.mp h

theorem eventually.exists_forall_of_at_bot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop} (h : âˆ€á¶ x in at_bot, p x) :
  âˆƒ a, âˆ€ b _ : b â‰¤ a, p b :=
  eventually_at_bot.mp h

theorem frequently_at_top [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶ x in at_top, p x) â†” âˆ€ a, âˆƒ (b : _)(_ : b â‰¥ a), p b :=
  by 
    simp [at_top_basis.frequently_iff]

theorem frequently_at_bot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶ x in at_bot, p x) â†” âˆ€ a, âˆƒ (b : _)(_ : b â‰¤ a), p b :=
  @frequently_at_top (OrderDual Î±) _ _ _

theorem frequently_at_top' [SemilatticeSup Î±] [Nonempty Î±] [NoTopOrder Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶ x in at_top, p x) â†” âˆ€ a, âˆƒ (b : _)(_ : b > a), p b :=
  by 
    simp [at_top_basis_Ioi.frequently_iff]

theorem frequently_at_bot' [SemilatticeInf Î±] [Nonempty Î±] [NoBotOrder Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶ x in at_bot, p x) â†” âˆ€ a, âˆƒ (b : _)(_ : b < a), p b :=
  @frequently_at_top' (OrderDual Î±) _ _ _ _

theorem frequently.forall_exists_of_at_top [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop} (h : âˆƒá¶ x in at_top, p x) :
  âˆ€ a, âˆƒ (b : _)(_ : b â‰¥ a), p b :=
  frequently_at_top.mp h

theorem frequently.forall_exists_of_at_bot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop} (h : âˆƒá¶ x in at_bot, p x) :
  âˆ€ a, âˆƒ (b : _)(_ : b â‰¤ a), p b :=
  frequently_at_bot.mp h

theorem map_at_top_eq [Nonempty Î±] [SemilatticeSup Î±] {f : Î± â†’ Î²} : at_top.map f = â¨…a, ğ“Ÿ$ f '' { a' | a â‰¤ a' } :=
  (at_top_basis.map _).eq_infi

theorem map_at_bot_eq [Nonempty Î±] [SemilatticeInf Î±] {f : Î± â†’ Î²} : at_bot.map f = â¨…a, ğ“Ÿ$ f '' { a' | a' â‰¤ a } :=
  @map_at_top_eq (OrderDual Î±) _ _ _ _

theorem tendsto_at_top [Preorderâ‚“ Î²] {m : Î± â†’ Î²} {f : Filter Î±} : tendsto m f at_top â†” âˆ€ b, âˆ€á¶ a in f, b â‰¤ m a :=
  by 
    simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]

theorem tendsto_at_bot [Preorderâ‚“ Î²] {m : Î± â†’ Î²} {f : Filter Î±} : tendsto m f at_bot â†” âˆ€ b, âˆ€á¶ a in f, m a â‰¤ b :=
  @tendsto_at_top Î± (OrderDual Î²) _ m f

theorem tendsto_at_top_mono' [Preorderâ‚“ Î²] (l : Filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
  tendsto fâ‚ l at_top â†’ tendsto fâ‚‚ l at_top :=
  fun hâ‚ =>
    tendsto_at_top.2$ fun b => mp_mem (tendsto_at_top.1 hâ‚ b) (monotone_mem (fun a ha haâ‚ => le_transâ‚“ haâ‚ ha) h)

theorem tendsto_at_bot_mono' [Preorderâ‚“ Î²] (l : Filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
  tendsto fâ‚‚ l at_bot â†’ tendsto fâ‚ l at_bot :=
  @tendsto_at_top_mono' _ (OrderDual Î²) _ _ _ _ h

theorem tendsto_at_top_mono [Preorderâ‚“ Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
  tendsto f l at_top â†’ tendsto g l at_top :=
  tendsto_at_top_mono' l$ eventually_of_forall h

theorem tendsto_at_bot_mono [Preorderâ‚“ Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
  tendsto g l at_bot â†’ tendsto f l at_bot :=
  @tendsto_at_top_mono _ (OrderDual Î²) _ _ _ _ h

/-!
### Sequences
-/


theorem inf_map_at_top_ne_bot_iff [SemilatticeSup Î±] [Nonempty Î±] {F : Filter Î²} {u : Î± â†’ Î²} :
  ne_bot (FâŠ“map u at_top) â†” âˆ€ U _ : U âˆˆ F, âˆ€ N, âˆƒ (n : _)(_ : n â‰¥ N), u n âˆˆ U :=
  by 
    simpRw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top] <;> rfl

theorem inf_map_at_bot_ne_bot_iff [SemilatticeInf Î±] [Nonempty Î±] {F : Filter Î²} {u : Î± â†’ Î²} :
  ne_bot (FâŠ“map u at_bot) â†” âˆ€ U _ : U âˆˆ F, âˆ€ N, âˆƒ (n : _)(_ : n â‰¤ N), u n âˆˆ U :=
  @inf_map_at_top_ne_bot_iff (OrderDual Î±) _ _ _ _ _

theorem extraction_of_frequently_at_top' {P : â„• â†’ Prop} (h : âˆ€ N, âˆƒ (n : _)(_ : n > N), P n) :
  âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
  by 
    choose u hu using h 
    cases' forall_and_distrib.mp hu with hu hu' 
    exact âŸ¨u âˆ˜ Nat.rec 0 fun n v => u v, strict_mono_nat_of_lt_succ fun n => hu _, fun n => hu' _âŸ©

theorem extraction_of_frequently_at_top {P : â„• â†’ Prop} (h : âˆƒá¶ n in at_top, P n) :
  âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
  by 
    rw [frequently_at_top'] at h 
    exact extraction_of_frequently_at_top' h

theorem extraction_of_eventually_at_top {P : â„• â†’ Prop} (h : âˆ€á¶ n in at_top, P n) :
  âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
  extraction_of_frequently_at_top h.frequently

theorem extraction_forall_of_frequently {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒá¶ k in at_top, P n k) :
  âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  by 
    simp only [frequently_at_top'] at h 
    choose u hu hu' using h 
    use (fun n => Nat.recOn n (u 0 0) fun n v => u (n+1) v : â„• â†’ â„•)
    split 
    Â·
      apply strict_mono_nat_of_lt_succ 
      intro n 
      apply hu
    Â·
      intro n 
      cases n <;> simp [hu']

theorem extraction_forall_of_eventually {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆ€á¶ k in at_top, P n k) :
  âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  extraction_forall_of_frequently fun n => (h n).Frequently

theorem extraction_forall_of_eventually' {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒ N, âˆ€ k _ : k â‰¥ N, P n k) :
  âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  extraction_forall_of_eventually
    (by 
      simp [eventually_at_top, h])

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem exists_le_of_tendsto_at_top
[semilattice_sup Î±]
[preorder Î²]
{u : Î± â†’ Î²}
(h : tendsto u at_top at_top)
(a : Î±)
(b : Î²) : Â«exprâˆƒ , Â»((a' Â«expr â‰¥ Â» a), Â«expr â‰¤ Â»(b, u a')) :=
begin
  have [] [":", expr Â«exprâˆ€á¶  in , Â»((x), at_top, Â«expr âˆ§ Â»(Â«expr â‰¤ Â»(a, x), Â«expr â‰¤ Â»(b, u x)))] [":=", expr (eventually_ge_at_top a).and Â«expr $ Â»(h.eventually, eventually_ge_at_top b)],
  haveI [] [":", expr nonempty Î±] [":=", expr âŸ¨aâŸ©],
  rcases [expr this.exists, "with", "âŸ¨", ident a', ",", ident ha, ",", ident hb, "âŸ©"],
  exact [expr âŸ¨a', ha, hbâŸ©]
end

@[nolint ge_or_gt]
theorem exists_le_of_tendsto_at_bot [SemilatticeSup Î±] [Preorderâ‚“ Î²] {u : Î± â†’ Î²} (h : tendsto u at_top at_bot) :
  âˆ€ a b, âˆƒ (a' : _)(_ : a' â‰¥ a), u a' â‰¤ b :=
  @exists_le_of_tendsto_at_top _ (OrderDual Î²) _ _ _ h

theorem exists_lt_of_tendsto_at_top [SemilatticeSup Î±] [Preorderâ‚“ Î²] [NoTopOrder Î²] {u : Î± â†’ Î²}
  (h : tendsto u at_top at_top) (a : Î±) (b : Î²) : âˆƒ (a' : _)(_ : a' â‰¥ a), b < u a' :=
  by 
    cases' no_top b with b' hb' 
    rcases exists_le_of_tendsto_at_top h a b' with âŸ¨a', ha', ha''âŸ©
    exact âŸ¨a', ha', lt_of_lt_of_leâ‚“ hb' ha''âŸ©

@[nolint ge_or_gt]
theorem exists_lt_of_tendsto_at_bot [SemilatticeSup Î±] [Preorderâ‚“ Î²] [NoBotOrder Î²] {u : Î± â†’ Î²}
  (h : tendsto u at_top at_bot) : âˆ€ a b, âˆƒ (a' : _)(_ : a' â‰¥ a), u a' < b :=
  @exists_lt_of_tendsto_at_top _ (OrderDual Î²) _ _ _ _ h

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/--
If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
theorem high_scores
[linear_order Î²]
[no_top_order Î²]
{u : exprâ„•() â†’ Î²}
(hu : tendsto u at_top at_top) : âˆ€ N, Â«exprâˆƒ , Â»((n Â«expr â‰¥ Â» N), âˆ€ k Â«expr < Â» n, Â«expr < Â»(u k, u n)) :=
begin
  intros [ident N],
  obtain ["âŸ¨", ident k, ":", expr exprâ„•(), ",", ident hkn, ":", expr Â«expr â‰¤ Â»(k, N), ",", ident hku, ":", expr âˆ€
   l Â«expr â‰¤ Â» N, Â«expr â‰¤ Â»(u l, u k), "âŸ©", ":", expr Â«exprâˆƒ , Â»((k Â«expr â‰¤ Â» N), âˆ€
    l Â«expr â‰¤ Â» N, Â«expr â‰¤ Â»(u l, u k))],
  from [expr exists_max_image _ u (finite_le_nat N) âŸ¨N, le_refl NâŸ©],
  have [ident ex] [":", expr Â«exprâˆƒ , Â»((n Â«expr â‰¥ Â» N), Â«expr < Â»(u k, u n))] [],
  from [expr exists_lt_of_tendsto_at_top hu _ _],
  obtain ["âŸ¨", ident n, ":", expr exprâ„•(), ",", ident hnN, ":", expr Â«expr â‰¥ Â»(n, N), ",", ident hnk, ":", expr Â«expr < Â»(u k, u n), ",", ident hn_min, ":", expr âˆ€
   m, Â«expr < Â»(m, n) â†’ Â«expr â‰¤ Â»(N, m) â†’ Â«expr â‰¤ Â»(u m, u k), "âŸ©", ":", expr Â«exprâˆƒ , Â»((n Â«expr â‰¥ Â» N), Â«expr âˆ§ Â»(Â«expr < Â»(u k, u n), âˆ€
     m, Â«expr < Â»(m, n) â†’ Â«expr â‰¤ Â»(N, m) â†’ Â«expr â‰¤ Â»(u m, u k)))],
  { rcases [expr nat.find_x ex, "with", "âŸ¨", ident n, ",", "âŸ¨", ident hnN, ",", ident hnk, "âŸ©", ",", ident hn_min, "âŸ©"],
    push_neg ["at", ident hn_min],
    exact [expr âŸ¨n, hnN, hnk, hn_minâŸ©] },
  use ["[", expr n, ",", expr hnN, "]"],
  rintros ["(", ident l, ":", expr exprâ„•(), ")", "(", ident hl, ":", expr Â«expr < Â»(l, n), ")"],
  have [ident hlk] [":", expr Â«expr â‰¤ Â»(u l, u k)] [],
  { cases [expr (le_total l N : Â«expr âˆ¨ Â»(Â«expr â‰¤ Â»(l, N), Â«expr â‰¤ Â»(N, l)))] ["with", ident H, ident H],
    { exact [expr hku l H] },
    { exact [expr hn_min l hl H] } },
  calc
    Â«expr â‰¤ Â»(u l, u k) : hlk
    Â«expr < Â»(..., u n) : hnk
end

/--
If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
@[nolint ge_or_gt]
theorem low_scores [LinearOrderâ‚“ Î²] [NoBotOrder Î²] {u : â„• â†’ Î²} (hu : tendsto u at_top at_bot) :
  âˆ€ N, âˆƒ (n : _)(_ : n â‰¥ N), âˆ€ k _ : k < n, u n < u k :=
  @high_scores (OrderDual Î²) _ _ _ hu

/--
If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
theorem frequently_high_scores [LinearOrderâ‚“ Î²] [NoTopOrder Î²] {u : â„• â†’ Î²} (hu : tendsto u at_top at_top) :
  âˆƒá¶ n in at_top, âˆ€ k _ : k < n, u k < u n :=
  by 
    simpa [frequently_at_top] using high_scores hu

/--
If `u` is a sequence which is unbounded below,
then it `frequently` reaches a value strictly smaller than all previous values.
-/
theorem frequently_low_scores [LinearOrderâ‚“ Î²] [NoBotOrder Î²] {u : â„• â†’ Î²} (hu : tendsto u at_top at_bot) :
  âˆƒá¶ n in at_top, âˆ€ k _ : k < n, u n < u k :=
  @frequently_high_scores (OrderDual Î²) _ _ _ hu

theorem strict_mono_subseq_of_tendsto_at_top {Î² : Type _} [LinearOrderâ‚“ Î²] [NoTopOrder Î²] {u : â„• â†’ Î²}
  (hu : tendsto u at_top at_top) : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ StrictMono (u âˆ˜ Ï†) :=
  let âŸ¨Ï†, h, h'âŸ© := extraction_of_frequently_at_top (frequently_high_scores hu)
  âŸ¨Ï†, h, fun n m hnm => h' m _ (h hnm)âŸ©

theorem strict_mono_subseq_of_id_le {u : â„• â†’ â„•} (hu : âˆ€ n, n â‰¤ u n) : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ StrictMono (u âˆ˜ Ï†) :=
  strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)

theorem _root_.strict_mono.tendsto_at_top {Ï† : â„• â†’ â„•} (h : StrictMono Ï†) : tendsto Ï† at_top at_top :=
  tendsto_at_top_mono h.id_le tendsto_id

section OrderedAddCommMonoid

variable[OrderedAddCommMonoid Î²]{l : Filter Î±}{f g : Î± â†’ Î²}

theorem tendsto_at_top_add_nonneg_left' (hf : âˆ€á¶ x in l, 0 â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_mono' l (hf.mono fun x => le_add_of_nonneg_left) hg

theorem tendsto_at_bot_add_nonpos_left' (hf : âˆ€á¶ x in l, f x â‰¤ 0) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_left' _ (OrderDual Î²) _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_left (hf : âˆ€ x, 0 â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg

theorem tendsto_at_bot_add_nonpos_left (hf : âˆ€ x, f x â‰¤ 0) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_left _ (OrderDual Î²) _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_right' (hf : tendsto f l at_top) (hg : âˆ€á¶ x in l, 0 â‰¤ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_mono' l (monotone_mem (fun x => le_add_of_nonneg_right) hg) hf

theorem tendsto_at_bot_add_nonpos_right' (hf : tendsto f l at_bot) (hg : âˆ€á¶ x in l, g x â‰¤ 0) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_right' _ (OrderDual Î²) _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_right (hf : tendsto f l at_top) (hg : âˆ€ x, 0 â‰¤ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)

theorem tendsto_at_bot_add_nonpos_right (hf : tendsto f l at_bot) (hg : âˆ€ x, g x â‰¤ 0) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_right _ (OrderDual Î²) _ _ _ _ hf hg

theorem tendsto_at_top_add (hf : tendsto f l at_top) (hg : tendsto g l at_top) : tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_nonneg_left' (tendsto_at_top.mp hf 0) hg

theorem tendsto_at_bot_add (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) : tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add _ (OrderDual Î²) _ _ _ _ hf hg

theorem tendsto.nsmul_at_top (hf : tendsto f l at_top) {n : â„•} (hn : 0 < n) : tendsto (fun x => n â€¢ f x) l at_top :=
  tendsto_at_top.2$
    fun y =>
      (tendsto_at_top.1 hf y).mp$
        (tendsto_at_top.1 hf 0).mono$
          fun x hâ‚€ hy =>
            calc y â‰¤ f x := hy 
              _ = 1 â€¢ f x := (one_nsmul _).symm 
              _ â‰¤ n â€¢ f x := nsmul_le_nsmul hâ‚€ hn
              

theorem tendsto.nsmul_at_bot (hf : tendsto f l at_bot) {n : â„•} (hn : 0 < n) : tendsto (fun x => n â€¢ f x) l at_bot :=
  @tendsto.nsmul_at_top Î± (OrderDual Î²) _ l f hf n hn

theorem tendsto_bit0_at_top : tendsto bit0 (at_top : Filter Î²) at_top :=
  tendsto_at_top_add tendsto_id tendsto_id

theorem tendsto_bit0_at_bot : tendsto bit0 (at_bot : Filter Î²) at_bot :=
  tendsto_at_bot_add tendsto_id tendsto_id

end OrderedAddCommMonoid

section OrderedCancelAddCommMonoid

variable[OrderedCancelAddCommMonoid Î²]{l : Filter Î±}{f g : Î± â†’ Î²}

theorem tendsto_at_top_of_add_const_left (C : Î²) (hf : tendsto (fun x => C+f x) l at_top) : tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (C+b)).mono fun x => le_of_add_le_add_left

theorem tendsto_at_bot_of_add_const_left (C : Î²) (hf : tendsto (fun x => C+f x) l at_bot) : tendsto f l at_bot :=
  @tendsto_at_top_of_add_const_left _ (OrderDual Î²) _ _ _ C hf

theorem tendsto_at_top_of_add_const_right (C : Î²) (hf : tendsto (fun x => f x+C) l at_top) : tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (b+C)).mono fun x => le_of_add_le_add_right

theorem tendsto_at_bot_of_add_const_right (C : Î²) (hf : tendsto (fun x => f x+C) l at_bot) : tendsto f l at_bot :=
  @tendsto_at_top_of_add_const_right _ (OrderDual Î²) _ _ _ C hf

theorem tendsto_at_top_of_add_bdd_above_left' C (hC : âˆ€á¶ x in l, f x â‰¤ C) (h : tendsto (fun x => f x+g x) l at_top) :
  tendsto g l at_top :=
  tendsto_at_top_of_add_const_left C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)

theorem tendsto_at_bot_of_add_bdd_below_left' C (hC : âˆ€á¶ x in l, C â‰¤ f x) (h : tendsto (fun x => f x+g x) l at_bot) :
  tendsto g l at_bot :=
  @tendsto_at_top_of_add_bdd_above_left' _ (OrderDual Î²) _ _ _ _ C hC h

theorem tendsto_at_top_of_add_bdd_above_left C (hC : âˆ€ x, f x â‰¤ C) :
  tendsto (fun x => f x+g x) l at_top â†’ tendsto g l at_top :=
  tendsto_at_top_of_add_bdd_above_left' C (univ_mem' hC)

theorem tendsto_at_bot_of_add_bdd_below_left C (hC : âˆ€ x, C â‰¤ f x) :
  tendsto (fun x => f x+g x) l at_bot â†’ tendsto g l at_bot :=
  @tendsto_at_top_of_add_bdd_above_left _ (OrderDual Î²) _ _ _ _ C hC

theorem tendsto_at_top_of_add_bdd_above_right' C (hC : âˆ€á¶ x in l, g x â‰¤ C) (h : tendsto (fun x => f x+g x) l at_top) :
  tendsto f l at_top :=
  tendsto_at_top_of_add_const_right C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)

theorem tendsto_at_bot_of_add_bdd_below_right' C (hC : âˆ€á¶ x in l, C â‰¤ g x) (h : tendsto (fun x => f x+g x) l at_bot) :
  tendsto f l at_bot :=
  @tendsto_at_top_of_add_bdd_above_right' _ (OrderDual Î²) _ _ _ _ C hC h

theorem tendsto_at_top_of_add_bdd_above_right C (hC : âˆ€ x, g x â‰¤ C) :
  tendsto (fun x => f x+g x) l at_top â†’ tendsto f l at_top :=
  tendsto_at_top_of_add_bdd_above_right' C (univ_mem' hC)

theorem tendsto_at_bot_of_add_bdd_below_right C (hC : âˆ€ x, C â‰¤ g x) :
  tendsto (fun x => f x+g x) l at_bot â†’ tendsto f l at_bot :=
  @tendsto_at_top_of_add_bdd_above_right _ (OrderDual Î²) _ _ _ _ C hC

end OrderedCancelAddCommMonoid

section OrderedGroup

variable[OrderedAddCommGroup Î²](l : Filter Î±){f g : Î± â†’ Î²}

theorem tendsto_at_top_add_left_of_le' (C : Î²) (hf : âˆ€á¶ x in l, C â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  @tendsto_at_top_of_add_bdd_above_left' _ _ _ l (fun x => -f x) (fun x => f x+g x) (-C)
    (by 
      simpa)
    (by 
      simpa)

theorem tendsto_at_bot_add_left_of_ge' (C : Î²) (hf : âˆ€á¶ x in l, f x â‰¤ C) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_left_of_le' _ (OrderDual Î²) _ _ _ _ C hf hg

theorem tendsto_at_top_add_left_of_le (C : Î²) (hf : âˆ€ x, C â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_left_of_le' l C (univ_mem' hf) hg

theorem tendsto_at_bot_add_left_of_ge (C : Î²) (hf : âˆ€ x, f x â‰¤ C) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_left_of_le _ (OrderDual Î²) _ _ _ _ C hf hg

theorem tendsto_at_top_add_right_of_le' (C : Î²) (hf : tendsto f l at_top) (hg : âˆ€á¶ x in l, C â‰¤ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  @tendsto_at_top_of_add_bdd_above_right' _ _ _ l (fun x => f x+g x) (fun x => -g x) (-C)
    (by 
      simp [hg])
    (by 
      simp [hf])

theorem tendsto_at_bot_add_right_of_ge' (C : Î²) (hf : tendsto f l at_bot) (hg : âˆ€á¶ x in l, g x â‰¤ C) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_right_of_le' _ (OrderDual Î²) _ _ _ _ C hf hg

theorem tendsto_at_top_add_right_of_le (C : Î²) (hf : tendsto f l at_top) (hg : âˆ€ x, C â‰¤ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem' hg)

theorem tendsto_at_bot_add_right_of_ge (C : Î²) (hf : tendsto f l at_bot) (hg : âˆ€ x, g x â‰¤ C) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_right_of_le _ (OrderDual Î²) _ _ _ _ C hf hg

theorem tendsto_at_top_add_const_left (C : Î²) (hf : tendsto f l at_top) : tendsto (fun x => C+f x) l at_top :=
  tendsto_at_top_add_left_of_le' l C (univ_mem'$ fun _ => le_reflâ‚“ C) hf

theorem tendsto_at_bot_add_const_left (C : Î²) (hf : tendsto f l at_bot) : tendsto (fun x => C+f x) l at_bot :=
  @tendsto_at_top_add_const_left _ (OrderDual Î²) _ _ _ C hf

theorem tendsto_at_top_add_const_right (C : Î²) (hf : tendsto f l at_top) : tendsto (fun x => f x+C) l at_top :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem'$ fun _ => le_reflâ‚“ C)

theorem tendsto_at_bot_add_const_right (C : Î²) (hf : tendsto f l at_bot) : tendsto (fun x => f x+C) l at_bot :=
  @tendsto_at_top_add_const_right _ (OrderDual Î²) _ _ _ C hf

theorem tendsto_neg_at_top_at_bot : tendsto (Neg.neg : Î² â†’ Î²) at_top at_bot :=
  by 
    simp only [tendsto_at_bot, neg_le]
    exact fun b => eventually_ge_at_top _

theorem tendsto_neg_at_bot_at_top : tendsto (Neg.neg : Î² â†’ Î²) at_bot at_top :=
  @tendsto_neg_at_top_at_bot (OrderDual Î²) _

end OrderedGroup

section OrderedSemiring

variable[OrderedSemiring Î±]{l : Filter Î²}{f g : Î² â†’ Î±}

theorem tendsto_bit1_at_top : tendsto bit1 (at_top : Filter Î±) at_top :=
  tendsto_at_top_add_nonneg_right tendsto_bit0_at_top fun _ => zero_le_one

theorem tendsto.at_top_mul_at_top (hf : tendsto f l at_top) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    refine' tendsto_at_top_mono' _ _ hg 
    filterUpwards [hg.eventually (eventually_ge_at_top 0), hf.eventually (eventually_ge_at_top 1)]
    exact fun x => le_mul_of_one_le_left

theorem tendsto_mul_self_at_top : tendsto (fun x : Î± => x*x) at_top at_top :=
  tendsto_id.at_top_mul_at_top tendsto_id

/-- The monomial function `x^n` tends to `+âˆ` at `+âˆ` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_at_top`. -/
theorem tendsto_pow_at_top {n : â„•} (hn : 1 â‰¤ n) : tendsto (fun x : Î± => x ^ n) at_top at_top :=
  by 
    refine' tendsto_at_top_mono' _ ((eventually_ge_at_top 1).mono$ fun x hx => _) tendsto_id 
    simpa only [pow_oneâ‚“] using pow_le_pow hx hn

end OrderedSemiring

theorem zero_pow_eventually_eq [MonoidWithZeroâ‚“ Î±] : (fun n : â„• => (0 : Î±) ^ n) =á¶ [at_top] fun n => 0 :=
  eventually_at_top.2 âŸ¨1, fun n hn => zero_pow (zero_lt_one.trans_le hn)âŸ©

section OrderedRing

variable[OrderedRing Î±]{l : Filter Î²}{f g : Î² â†’ Î±}

theorem tendsto.at_top_mul_at_bot (hf : tendsto f l at_top) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_bot :=
  have  := hf.at_top_mul_at_top$ tendsto_neg_at_bot_at_top.comp hg 
  by 
    simpa only [Â· âˆ˜ Â·, neg_mul_eq_mul_neg, neg_negâ‚“] using tendsto_neg_at_top_at_bot.comp this

theorem tendsto.at_bot_mul_at_top (hf : tendsto f l at_bot) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_bot :=
  have  : tendsto (fun x => (-f x)*g x) l at_top := (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top hg 
  by 
    simpa only [Â· âˆ˜ Â·, neg_mul_eq_neg_mul, neg_negâ‚“] using tendsto_neg_at_top_at_bot.comp this

theorem tendsto.at_bot_mul_at_bot (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_top :=
  have  : tendsto (fun x => (-f x)*-g x) l at_top :=
    (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top (tendsto_neg_at_bot_at_top.comp hg)
  by 
    simpa only [neg_mul_neg] using this

end OrderedRing

section LinearOrderedAddCommGroup

variable[LinearOrderedAddCommGroup Î±]

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_top_at_top : tendsto (abs : Î± â†’ Î±) at_top at_top :=
  tendsto_at_top_mono le_abs_self tendsto_id

/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_bot_at_top : tendsto (abs : Î± â†’ Î±) at_bot at_top :=
  tendsto_at_top_mono neg_le_abs_self tendsto_neg_at_bot_at_top

end LinearOrderedAddCommGroup

section LinearOrderedSemiring

variable[LinearOrderedSemiring Î±]{l : Filter Î²}{f : Î² â†’ Î±}

theorem tendsto.at_top_of_const_mul {c : Î±} (hc : 0 < c) (hf : tendsto (fun x => c*f x) l at_top) :
  tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (c*b)).mono$ fun x hx => le_of_mul_le_mul_left hx hc

theorem tendsto.at_top_of_mul_const {c : Î±} (hc : 0 < c) (hf : tendsto (fun x => f x*c) l at_top) :
  tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (b*c)).mono$ fun x hx => le_of_mul_le_mul_right hx hc

end LinearOrderedSemiring

theorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing Î±] {a : Î±} (h : âˆ€á¶ n in at_top, 0 â‰¤ a ^ (n : â„•)) : 0 â‰¤ a :=
  let âŸ¨n, hnâŸ© := (tendsto_bit1_at_top.Eventually h).exists 
  pow_bit1_nonneg_iff.1 hn

section LinearOrderedField

variable[LinearOrderedField Î±]{l : Filter Î²}{f : Î² â†’ Î±}{r : Î±}

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `â„•` or `â„¤`, use
`filter.tendsto.const_mul_at_top'` instead. -/
theorem tendsto.const_mul_at_top (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => r*f x) l at_top :=
  tendsto.at_top_of_const_mul (inv_pos.2 hr)$
    by 
      simpa only [inv_mul_cancel_leftâ‚€ hr.ne']

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `â„•` or `â„¤`, use
`filter.tendsto.at_top_mul_const'` instead. -/
theorem tendsto.at_top_mul_const (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => f x*r) l at_top :=
  by 
    simpa only [mul_commâ‚“] using hf.const_mul_at_top hr

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
theorem tendsto.at_top_div_const (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => f x / r) l at_top :=
  by 
    simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
theorem tendsto.neg_const_mul_at_top (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun x => r*f x) l at_bot :=
  by 
    simpa only [Â· âˆ˜ Â·, neg_mul_eq_neg_mul, neg_negâ‚“] using
      tendsto_neg_at_top_at_bot.comp (hf.const_mul_at_top (neg_pos.2 hr))

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
theorem tendsto.at_top_mul_neg_const (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun x => f x*r) l at_bot :=
  by 
    simpa only [mul_commâ‚“] using hf.neg_const_mul_at_top hr

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
theorem tendsto.const_mul_at_bot (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => r*f x) l at_bot :=
  by 
    simpa only [Â· âˆ˜ Â·, neg_mul_eq_mul_neg, neg_negâ‚“] using
      tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).const_mul_at_top hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
theorem tendsto.at_bot_mul_const (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => f x*r) l at_bot :=
  by 
    simpa only [mul_commâ‚“] using hf.const_mul_at_bot hr

/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
theorem tendsto.at_bot_div_const (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => f x / r) l at_bot :=
  by 
    simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
theorem tendsto.neg_const_mul_at_bot (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun x => r*f x) l at_top :=
  by 
    simpa only [Â· âˆ˜ Â·, neg_mul_eq_neg_mul, neg_negâ‚“] using
      tendsto_neg_at_bot_at_top.comp (hf.const_mul_at_bot (neg_pos.2 hr))

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
theorem tendsto.at_bot_mul_neg_const (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun x => f x*r) l at_top :=
  by 
    simpa only [mul_commâ‚“] using hf.neg_const_mul_at_bot hr

theorem tendsto_const_mul_pow_at_top {c : Î±} {n : â„•} (hn : 1 â‰¤ n) (hc : 0 < c) :
  tendsto (fun x => c*x ^ n) at_top at_top :=
  tendsto.const_mul_at_top hc (tendsto_pow_at_top hn)

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_const_mul_pow_at_top_iff
(c : Î±)
(n : exprâ„•()) : Â«expr â†” Â»(tendsto (Î»
  x, Â«expr * Â»(c, Â«expr ^ Â»(x, n))) at_top at_top, Â«expr âˆ§ Â»(Â«expr â‰¤ Â»(1, n), Â«expr < Â»(0, c))) :=
begin
  refine [expr âŸ¨Î» h, _, Î» h, tendsto_const_mul_pow_at_top h.1 h.2âŸ©],
  simp [] [] ["only"] ["[", expr tendsto_at_top, ",", expr eventually_at_top, "]"] [] ["at", ident h],
  have [] [":", expr Â«expr < Â»(0, c)] [":=", expr let âŸ¨x, hxâŸ© := h 1 in
   pos_of_mul_pos_right (lt_of_lt_of_le zero_lt_one (hx (max x 1) (le_max_left x 1))) (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n)],
  refine [expr âŸ¨nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Î» hn, _))), thisâŸ©],
  obtain ["âŸ¨", ident x, ",", ident hx, "âŸ©", ":=", expr h Â«expr + Â»(c, 1)],
  specialize [expr hx x le_rfl],
  rw ["[", expr hn, ",", expr pow_zero, ",", expr mul_one, ",", expr add_le_iff_nonpos_right, "]"] ["at", ident hx],
  exact [expr absurd hx (not_le.mpr zero_lt_one)]
end

theorem tendsto_neg_const_mul_pow_at_top {c : Î±} {n : â„•} (hn : 1 â‰¤ n) (hc : c < 0) :
  tendsto (fun x => c*x ^ n) at_top at_bot :=
  tendsto.neg_const_mul_at_top hc (tendsto_pow_at_top hn)

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_neg_const_mul_pow_at_top_iff
(c : Î±)
(n : exprâ„•()) : Â«expr â†” Â»(tendsto (Î»
  x, Â«expr * Â»(c, Â«expr ^ Â»(x, n))) at_top at_bot, Â«expr âˆ§ Â»(Â«expr â‰¤ Â»(1, n), Â«expr < Â»(c, 0))) :=
begin
  refine [expr âŸ¨Î» h, _, Î» h, tendsto_neg_const_mul_pow_at_top h.1 h.2âŸ©],
  simp [] [] ["only"] ["[", expr tendsto_at_bot, ",", expr eventually_at_top, "]"] [] ["at", ident h],
  have [] [":", expr Â«expr < Â»(c, 0)] [":=", expr let âŸ¨x, hxâŸ© := h Â«expr- Â»(1) in
   neg_of_mul_neg_right (lt_of_le_of_lt (hx (max x 1) (le_max_left x 1)) (by simp [] [] [] ["[", expr zero_lt_one, "]"] [] [])) (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n)],
  refine [expr âŸ¨nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Î» hn, _))), thisâŸ©],
  obtain ["âŸ¨", ident x, ",", ident hx, "âŸ©", ":=", expr h Â«expr - Â»(c, 1)],
  specialize [expr hx x le_rfl],
  rw ["[", expr hn, ",", expr pow_zero, ",", expr mul_one, ",", expr le_sub, ",", expr sub_self, "]"] ["at", ident hx],
  exact [expr absurd hx (not_le.mpr zero_lt_one)]
end

end LinearOrderedField

open_locale Filter

theorem tendsto_at_top' [Nonempty Î±] [SemilatticeSup Î±] {f : Î± â†’ Î²} {l : Filter Î²} :
  tendsto f at_top l â†” âˆ€ s _ : s âˆˆ l, âˆƒ a, âˆ€ b _ : b â‰¥ a, f b âˆˆ s :=
  by 
    simp only [tendsto_def, mem_at_top_sets] <;> rfl

theorem tendsto_at_bot' [Nonempty Î±] [SemilatticeInf Î±] {f : Î± â†’ Î²} {l : Filter Î²} :
  tendsto f at_bot l â†” âˆ€ s _ : s âˆˆ l, âˆƒ a, âˆ€ b _ : b â‰¤ a, f b âˆˆ s :=
  @tendsto_at_top' (OrderDual Î±) _ _ _ _ _

theorem tendsto_at_top_principal [Nonempty Î²] [SemilatticeSup Î²] {f : Î² â†’ Î±} {s : Set Î±} :
  tendsto f at_top (ğ“Ÿ s) â†” âˆƒ N, âˆ€ n _ : n â‰¥ N, f n âˆˆ s :=
  by 
    rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets] <;> rfl

theorem tendsto_at_bot_principal [Nonempty Î²] [SemilatticeInf Î²] {f : Î² â†’ Î±} {s : Set Î±} :
  tendsto f at_bot (ğ“Ÿ s) â†” âˆƒ N, âˆ€ n _ : n â‰¤ N, f n âˆˆ s :=
  @tendsto_at_top_principal _ (OrderDual Î²) _ _ _ _

/-- A function `f` grows to `+âˆ` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_top_at_top [Nonempty Î±] [SemilatticeSup Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²} :
  tendsto f at_top at_top â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ b â‰¤ f a :=
  Iff.trans tendsto_infi$ forall_congrâ‚“$ fun b => tendsto_at_top_principal

theorem tendsto_at_top_at_bot [Nonempty Î±] [SemilatticeSup Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²} :
  tendsto f at_top at_bot â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ f a â‰¤ b :=
  @tendsto_at_top_at_top Î± (OrderDual Î²) _ _ _ f

theorem tendsto_at_bot_at_top [Nonempty Î±] [SemilatticeInf Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²} :
  tendsto f at_bot at_top â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, a â‰¤ i â†’ b â‰¤ f a :=
  @tendsto_at_top_at_top (OrderDual Î±) Î² _ _ _ f

theorem tendsto_at_bot_at_bot [Nonempty Î±] [SemilatticeInf Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²} :
  tendsto f at_bot at_bot â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, a â‰¤ i â†’ f a â‰¤ b :=
  @tendsto_at_top_at_top (OrderDual Î±) (OrderDual Î²) _ _ _ f

theorem tendsto_at_top_at_top_of_monotone [Preorderâ‚“ Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²} (hf : Monotone f)
  (h : âˆ€ b, âˆƒ a, b â‰¤ f a) : tendsto f at_top at_top :=
  tendsto_infi.2$
    fun b =>
      tendsto_principal.2$
        let âŸ¨a, haâŸ© := h b 
        mem_of_superset (mem_at_top a)$ fun a' ha' => le_transâ‚“ ha (hf ha')

theorem tendsto_at_bot_at_bot_of_monotone [Preorderâ‚“ Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²} (hf : Monotone f)
  (h : âˆ€ b, âˆƒ a, f a â‰¤ b) : tendsto f at_bot at_bot :=
  tendsto_infi.2$
    fun b =>
      tendsto_principal.2$
        let âŸ¨a, haâŸ© := h b 
        mem_of_superset (mem_at_bot a)$ fun a' ha' => le_transâ‚“ (hf ha') ha

theorem tendsto_at_top_at_top_iff_of_monotone [Nonempty Î±] [SemilatticeSup Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²}
  (hf : Monotone f) : tendsto f at_top at_top â†” âˆ€ b : Î², âˆƒ a : Î±, b â‰¤ f a :=
  tendsto_at_top_at_top.trans$
    forall_congrâ‚“$ fun b => exists_congr$ fun a => âŸ¨fun h => h a (le_reflâ‚“ a), fun h a' ha' => le_transâ‚“ h$ hf ha'âŸ©

theorem tendsto_at_bot_at_bot_iff_of_monotone [Nonempty Î±] [SemilatticeInf Î±] [Preorderâ‚“ Î²] {f : Î± â†’ Î²}
  (hf : Monotone f) : tendsto f at_bot at_bot â†” âˆ€ b : Î², âˆƒ a : Î±, f a â‰¤ b :=
  tendsto_at_bot_at_bot.trans$
    forall_congrâ‚“$ fun b => exists_congr$ fun a => âŸ¨fun h => h a (le_reflâ‚“ a), fun h a' ha' => le_transâ‚“ (hf ha') hâŸ©

alias tendsto_at_top_at_top_of_monotone â† Monotone.tendsto_at_top_at_top

alias tendsto_at_bot_at_bot_of_monotone â† Monotone.tendsto_at_bot_at_bot

alias tendsto_at_top_at_top_iff_of_monotone â† Monotone.tendsto_at_top_at_top_iff

alias tendsto_at_bot_at_bot_iff_of_monotone â† Monotone.tendsto_at_bot_at_bot_iff

theorem tendsto_at_top_embedding [Preorderâ‚“ Î²] [Preorderâ‚“ Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±}
  (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, c â‰¤ e b) : tendsto (e âˆ˜ f) l at_top â†” tendsto f l at_top :=
  by 
    refine' âŸ¨_, (tendsto_at_top_at_top_of_monotone (fun bâ‚ bâ‚‚ => (hm bâ‚ bâ‚‚).2) hu).compâŸ©
    rw [tendsto_at_top, tendsto_at_top]
    exact fun hc b => (hc (e b)).mono fun a => (hm b (f a)).1

/-- A function `f` goes to `-âˆ` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_bot_embedding [Preorderâ‚“ Î²] [Preorderâ‚“ Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±}
  (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, e b â‰¤ c) : tendsto (e âˆ˜ f) l at_bot â†” tendsto f l at_bot :=
  @tendsto_at_top_embedding Î± (OrderDual Î²) (OrderDual Î³) _ _ f e l (Function.swap hm) hu

theorem tendsto_finset_range : tendsto Finset.range at_top at_top :=
  Finset.range_mono.tendsto_at_top_at_top Finset.exists_nat_subset_range

theorem at_top_finset_eq_infi : (at_top : Filter$ Finset Î±) = â¨…x : Î±, ğ“Ÿ (Ici {x}) :=
  by 
    refine' le_antisymmâ‚“ (le_infi fun i => le_principal_iff.2$ mem_at_top {i}) _ 
    refine' le_infi fun s => le_principal_iff.2$ mem_infi_of_Inter s.finite_to_set (fun i => mem_principal_self _) _ 
    simp only [subset_def, mem_Inter, SetCoe.forall, mem_Ici, Finset.le_iff_subset, Finset.mem_singleton,
      Finset.subset_iff, forall_eq]
    dsimp 
    exact fun t => id

/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
theorem tendsto_at_top_finset_of_monotone [Preorderâ‚“ Î²] {f : Î² â†’ Finset Î±} (h : Monotone f)
  (h' : âˆ€ x : Î±, âˆƒ n, x âˆˆ f n) : tendsto f at_top at_top :=
  by 
    simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal]
    intro a 
    rcases h' a with âŸ¨b, hbâŸ©
    exact eventually.mono (mem_at_top b) fun b' hb' => le_transâ‚“ (Finset.singleton_subset_iff.2 hb) (h hb')

alias tendsto_at_top_finset_of_monotone â† Monotone.tendsto_at_top_finset

theorem tendsto_finset_image_at_top_at_top {i : Î² â†’ Î³} {j : Î³ â†’ Î²} (h : Function.LeftInverse j i) :
  tendsto (Finset.image j) at_top at_top :=
  (Finset.image_mono j).tendsto_at_top_finset$
    fun a =>
      âŸ¨{i a},
        by 
          simp only [Finset.image_singleton, h a, Finset.mem_singleton]âŸ©

theorem tendsto_finset_preimage_at_top_at_top {f : Î± â†’ Î²} (hf : Function.Injective f) :
  tendsto (fun s : Finset Î² => s.preimage f (hf.inj_on _)) at_top at_top :=
  (Finset.monotone_preimage hf).tendsto_at_top_finset$
    fun x => âŸ¨{f x}, Finset.mem_preimage.2$ Finset.mem_singleton_self _âŸ©

theorem prod_at_top_at_top_eq {Î²â‚ Î²â‚‚ : Type _} [SemilatticeSup Î²â‚] [SemilatticeSup Î²â‚‚] :
  (at_top : Filter Î²â‚) Ã—á¶  (at_top : Filter Î²â‚‚) = (at_top : Filter (Î²â‚ Ã— Î²â‚‚)) :=
  by 
    cases' (is_empty_or_nonempty Î²â‚).symm 
    cases' (is_empty_or_nonempty Î²â‚‚).symm
    Â·
      simp [at_top, prod_infi_left, prod_infi_right, infi_prod]
      exact infi_comm
    Â·
      simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]
    Â·
      simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]

theorem prod_at_bot_at_bot_eq {Î²â‚ Î²â‚‚ : Type _} [SemilatticeInf Î²â‚] [SemilatticeInf Î²â‚‚] :
  (at_bot : Filter Î²â‚) Ã—á¶  (at_bot : Filter Î²â‚‚) = (at_bot : Filter (Î²â‚ Ã— Î²â‚‚)) :=
  @prod_at_top_at_top_eq (OrderDual Î²â‚) (OrderDual Î²â‚‚) _ _

theorem prod_map_at_top_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type _} [SemilatticeSup Î²â‚] [SemilatticeSup Î²â‚‚] (uâ‚ : Î²â‚ â†’ Î±â‚)
  (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) : map uâ‚ at_top Ã—á¶  map uâ‚‚ at_top = map (Prod.mapâ‚“ uâ‚ uâ‚‚) at_top :=
  by 
    rw [prod_map_map_eq, prod_at_top_at_top_eq, Prod.map_defâ‚“]

theorem prod_map_at_bot_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type _} [SemilatticeInf Î²â‚] [SemilatticeInf Î²â‚‚] (uâ‚ : Î²â‚ â†’ Î±â‚)
  (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) : map uâ‚ at_bot Ã—á¶  map uâ‚‚ at_bot = map (Prod.mapâ‚“ uâ‚ uâ‚‚) at_bot :=
  @prod_map_at_top_eq _ _ (OrderDual Î²â‚) (OrderDual Î²â‚‚) _ _ _ _

theorem tendsto.subseq_mem {F : Filter Î±} {V : â„• â†’ Set Î±} (h : âˆ€ n, V n âˆˆ F) {u : â„• â†’ Î±} (hu : tendsto u at_top F) :
  âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, u (Ï† n) âˆˆ V n :=
  extraction_forall_of_eventually' (fun n => tendsto_at_top'.mp hu _ (h n) : âˆ€ n, âˆƒ N, âˆ€ k _ : k â‰¥ N, u k âˆˆ V n)

theorem tendsto_at_bot_diagonal [SemilatticeInf Î±] : tendsto (fun a : Î± => (a, a)) at_bot at_bot :=
  by 
    rw [â†prod_at_bot_at_bot_eq]
    exact tendsto_id.prod_mk tendsto_id

theorem tendsto_at_top_diagonal [SemilatticeSup Î±] : tendsto (fun a : Î± => (a, a)) at_top at_top :=
  by 
    rw [â†prod_at_top_at_top_eq]
    exact tendsto_id.prod_mk tendsto_id

theorem tendsto.prod_map_prod_at_bot [SemilatticeInf Î³] {F : Filter Î±} {G : Filter Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³}
  (hf : tendsto f F at_bot) (hg : tendsto g G at_bot) : tendsto (Prod.mapâ‚“ f g) (F Ã—á¶  G) at_bot :=
  by 
    rw [â†prod_at_bot_at_bot_eq]
    exact hf.prod_map hg

theorem tendsto.prod_map_prod_at_top [SemilatticeSup Î³] {F : Filter Î±} {G : Filter Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³}
  (hf : tendsto f F at_top) (hg : tendsto g G at_top) : tendsto (Prod.mapâ‚“ f g) (F Ã—á¶  G) at_top :=
  by 
    rw [â†prod_at_top_at_top_eq]
    exact hf.prod_map hg

theorem tendsto.prod_at_bot [SemilatticeInf Î±] [SemilatticeInf Î³] {f g : Î± â†’ Î³} (hf : tendsto f at_bot at_bot)
  (hg : tendsto g at_bot at_bot) : tendsto (Prod.mapâ‚“ f g) at_bot at_bot :=
  by 
    rw [â†prod_at_bot_at_bot_eq]
    exact hf.prod_map_prod_at_bot hg

theorem tendsto.prod_at_top [SemilatticeSup Î±] [SemilatticeSup Î³] {f g : Î± â†’ Î³} (hf : tendsto f at_top at_top)
  (hg : tendsto g at_top at_top) : tendsto (Prod.mapâ‚“ f g) at_top at_top :=
  by 
    rw [â†prod_at_top_at_top_eq]
    exact hf.prod_map_prod_at_top hg

theorem eventually_at_bot_prod_self [SemilatticeInf Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶ x in at_bot, p x) â†” âˆƒ a, âˆ€ k l, k â‰¤ a â†’ l â‰¤ a â†’ p (k, l) :=
  by 
    simp [â†prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]

theorem eventually_at_top_prod_self [SemilatticeSup Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶ x in at_top, p x) â†” âˆƒ a, âˆ€ k l, a â‰¤ k â†’ a â‰¤ l â†’ p (k, l) :=
  by 
    simp [â†prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]

theorem eventually_at_bot_prod_self' [SemilatticeInf Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶ x in at_bot, p x) â†” âˆƒ a, âˆ€ k _ : k â‰¤ a, âˆ€ l _ : l â‰¤ a, p (k, l) :=
  by 
    rw [Filter.eventually_at_bot_prod_self]
    apply exists_congr 
    tauto

theorem eventually_at_top_prod_self' [SemilatticeSup Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶ x in at_top, p x) â†” âˆƒ a, âˆ€ k _ : k â‰¥ a, âˆ€ l _ : l â‰¥ a, p (k, l) :=
  by 
    rw [Filter.eventually_at_top_prod_self]
    apply exists_congr 
    tauto

/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
theorem map_at_top_eq_of_gc [SemilatticeSup Î±] [SemilatticeSup Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²) (hf : Monotone f)
  (gc : âˆ€ a, âˆ€ b _ : b â‰¥ b', f a â‰¤ b â†” a â‰¤ g b) (hgi : âˆ€ b _ : b â‰¥ b', b â‰¤ f (g b)) : map f at_top = at_top :=
  by 
    refine' le_antisymmâ‚“ (hf.tendsto_at_top_at_top$ fun b => âŸ¨g (bâŠ”b'), le_sup_left.trans$ hgi _ le_sup_rightâŸ©) _ 
    rw [@map_at_top_eq _ _ âŸ¨g b'âŸ©]
    refine' le_infi fun a => infi_le_of_le (f aâŠ”b')$ principal_mono.2$ fun b hb => _ 
    rw [mem_Ici, sup_le_iff] at hb 
    exact âŸ¨g b, (gc _ _ hb.2).1 hb.1, le_antisymmâ‚“ ((gc _ _ hb.2).2 (le_reflâ‚“ _)) (hgi _ hb.2)âŸ©

theorem map_at_bot_eq_of_gc [SemilatticeInf Î±] [SemilatticeInf Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²) (hf : Monotone f)
  (gc : âˆ€ a, âˆ€ b _ : b â‰¤ b', b â‰¤ f a â†” g b â‰¤ a) (hgi : âˆ€ b _ : b â‰¤ b', f (g b) â‰¤ b) : map f at_bot = at_bot :=
  @map_at_top_eq_of_gc (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ hf.dual gc hgi

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem map_coe_at_top_of_Ici_subset
[semilattice_sup Î±]
{a : Î±}
{s : set Î±}
(h : Â«expr âŠ† Â»(Ici a, s)) : Â«expr = Â»(map (coe : s â†’ Î±) at_top, at_top) :=
begin
  have [] [":", expr directed ((Â«expr â‰¥ Â»)) (Î» x : s, exprğ“Ÿ() (Ici x))] [],
  { intros [ident x, ident y],
    use [expr âŸ¨Â«expr âŠ” Â»(Â«expr âŠ” Â»(x, y), a), h le_sup_rightâŸ©],
    simp [] [] ["only"] ["[", expr ge_iff_le, ",", expr principal_mono, ",", expr Ici_subset_Ici, ",", "<-", expr subtype.coe_le_coe, ",", expr subtype.coe_mk, "]"] [] [],
    exact [expr âŸ¨le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_leftâŸ©] },
  haveI [] [":", expr nonempty s] [":=", expr âŸ¨âŸ¨a, h le_rflâŸ©âŸ©],
  simp [] [] ["only"] ["[", expr le_antisymm_iff, ",", expr at_top, ",", expr le_infi_iff, ",", expr le_principal_iff, ",", expr mem_map, ",", expr mem_set_of_eq, ",", expr map_infi_eq this, ",", expr map_principal, "]"] [] [],
  split,
  { intro [ident x],
    refine [expr mem_of_superset (mem_infi_of_mem âŸ¨Â«expr âŠ” Â»(x, a), h le_sup_rightâŸ© (mem_principal_self _)) _],
    rintro ["_", "âŸ¨", ident y, ",", ident hy, ",", ident rfl, "âŸ©"],
    exact [expr le_trans le_sup_left (subtype.coe_le_coe.2 hy)] },
  { intro [ident x],
    filter_upwards ["[", expr mem_at_top Â«expr âŠ” Â»(Â«exprâ†‘ Â»(x), a), "]"] [],
    intros [ident b, ident hb],
    exact [expr âŸ¨âŸ¨b, Â«expr $ Â»(h, le_sup_right.trans hb)âŸ©, subtype.coe_le_coe.1 (le_sup_left.trans hb), rflâŸ©] }
end

/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/
@[simp]
theorem map_coe_Ici_at_top [SemilatticeSup Î±] (a : Î±) : map (coeâ‚“ : Ici a â†’ Î±) at_top = at_top :=
  map_coe_at_top_of_Ici_subset (subset.refl _)

/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/
@[simp]
theorem map_coe_Ioi_at_top [SemilatticeSup Î±] [NoTopOrder Î±] (a : Î±) : map (coeâ‚“ : Ioi a â†’ Î±) at_top = at_top :=
  by 
    rcases no_top a with âŸ¨b, hbâŸ©
    exact map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb)

/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ioi_eq [SemilatticeSup Î±] (a : Î±) : at_top = comap (coeâ‚“ : Ioi a â†’ Î±) at_top :=
  by 
    nontriviality 
    rcases nontrivial_iff_nonempty.1 â€¹_â€º with âŸ¨b, hbâŸ©
    rw [â†map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]

/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ici_eq [SemilatticeSup Î±] (a : Î±) : at_top = comap (coeâ‚“ : Ici a â†’ Î±) at_top :=
  by 
    rw [â†map_coe_Ici_at_top a, comap_map Subtype.coe_injective]

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_coe_Iio_at_bot [SemilatticeInf Î±] [NoBotOrder Î±] (a : Î±) : map (coeâ‚“ : Iio a â†’ Î±) at_bot = at_bot :=
  @map_coe_Ioi_at_top (OrderDual Î±) _ _ _

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iio_eq [SemilatticeInf Î±] (a : Î±) : at_bot = comap (coeâ‚“ : Iio a â†’ Î±) at_bot :=
  @at_top_Ioi_eq (OrderDual Î±) _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_coe_Iic_at_bot [SemilatticeInf Î±] (a : Î±) : map (coeâ‚“ : Iic a â†’ Î±) at_bot = at_bot :=
  @map_coe_Ici_at_top (OrderDual Î±) _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iic_eq [SemilatticeInf Î±] (a : Î±) : at_bot = comap (coeâ‚“ : Iic a â†’ Î±) at_bot :=
  @at_top_Ici_eq (OrderDual Î±) _ _

theorem tendsto_Ioi_at_top [SemilatticeSup Î±] {a : Î±} {f : Î² â†’ Ioi a} {l : Filter Î²} :
  tendsto f l at_top â†” tendsto (fun x => (f x : Î±)) l at_top :=
  by 
    rw [at_top_Ioi_eq, tendsto_comap_iff]

theorem tendsto_Iio_at_bot [SemilatticeInf Î±] {a : Î±} {f : Î² â†’ Iio a} {l : Filter Î²} :
  tendsto f l at_bot â†” tendsto (fun x => (f x : Î±)) l at_bot :=
  by 
    rw [at_bot_Iio_eq, tendsto_comap_iff]

theorem tendsto_Ici_at_top [SemilatticeSup Î±] {a : Î±} {f : Î² â†’ Ici a} {l : Filter Î²} :
  tendsto f l at_top â†” tendsto (fun x => (f x : Î±)) l at_top :=
  by 
    rw [at_top_Ici_eq, tendsto_comap_iff]

theorem tendsto_Iic_at_bot [SemilatticeInf Î±] {a : Î±} {f : Î² â†’ Iic a} {l : Filter Î²} :
  tendsto f l at_bot â†” tendsto (fun x => (f x : Î±)) l at_bot :=
  by 
    rw [at_bot_Iic_eq, tendsto_comap_iff]

@[simp]
theorem tendsto_comp_coe_Ioi_at_top [SemilatticeSup Î±] [NoTopOrder Î±] {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
  tendsto (fun x : Ioi a => f x) at_top l â†” tendsto f at_top l :=
  by 
    rw [â†map_coe_Ioi_at_top a, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Ici_at_top [SemilatticeSup Î±] {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
  tendsto (fun x : Ici a => f x) at_top l â†” tendsto f at_top l :=
  by 
    rw [â†map_coe_Ici_at_top a, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Iio_at_bot [SemilatticeInf Î±] [NoBotOrder Î±] {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
  tendsto (fun x : Iio a => f x) at_bot l â†” tendsto f at_bot l :=
  by 
    rw [â†map_coe_Iio_at_bot a, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Iic_at_bot [SemilatticeInf Î±] {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
  tendsto (fun x : Iic a => f x) at_bot l â†” tendsto f at_bot l :=
  by 
    rw [â†map_coe_Iic_at_bot a, tendsto_map'_iff]

theorem map_add_at_top_eq_nat (k : â„•) : map (fun a => a+k) at_top = at_top :=
  map_at_top_eq_of_gc (fun a => a - k) k (fun a b h => add_le_add_right h k) (fun a b h => (le_tsub_iff_right h).symm)
    fun a h =>
      by 
        rw [tsub_add_cancel_of_le h]

theorem map_sub_at_top_eq_nat (k : â„•) : map (fun a => a - k) at_top = at_top :=
  map_at_top_eq_of_gc (fun a => a+k) 0 (fun a b h => tsub_le_tsub_right h _) (fun a b _ => tsub_le_iff_right)
    fun b _ =>
      by 
        rw [add_tsub_cancel_right]

theorem tendsto_add_at_top_nat (k : â„•) : tendsto (fun a => a+k) at_top at_top :=
  le_of_eqâ‚“ (map_add_at_top_eq_nat k)

theorem tendsto_sub_at_top_nat (k : â„•) : tendsto (fun a => a - k) at_top at_top :=
  le_of_eqâ‚“ (map_sub_at_top_eq_nat k)

theorem tendsto_add_at_top_iff_nat {f : â„• â†’ Î±} {l : Filter Î±} (k : â„•) :
  tendsto (fun n => f (n+k)) at_top l â†” tendsto f at_top l :=
  show tendsto (f âˆ˜ fun n => n+k) at_top l â†” tendsto f at_top l by 
    rw [â†tendsto_map'_iff, map_add_at_top_eq_nat]

theorem map_div_at_top_eq_nat (k : â„•) (hk : 0 < k) : map (fun a => a / k) at_top = at_top :=
  map_at_top_eq_of_gc (fun b => (b*k)+k - 1) 1 (fun a b h => Nat.div_le_div_right h)
    (fun a b _ =>
      calc a / k â‰¤ b â†” a / k < b+1 :=
        by 
          rw [â†Nat.succ_eq_add_one, Nat.lt_succ_iff]
        _ â†” a < (b+1)*k := Nat.div_lt_iff_lt_mulâ‚“ _ _ hk 
        _ â†” _ :=
        by 
          cases k 
          exact (lt_irreflâ‚“ _ hk).elim 
          rw [add_mulâ‚“, one_mulâ‚“, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.add_succ, Nat.lt_succ_iff]
        )
    fun b _ =>
      calc b = (b*k) / k :=
        by 
          rw [Nat.mul_div_cancelâ‚“ b hk]
        _ â‰¤ ((b*k)+k - 1) / k := Nat.div_le_div_right$ Nat.le_add_rightâ‚“ _ _
        

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
theorem tendsto_at_top_at_top_of_monotone' [Preorderâ‚“ Î¹] [LinearOrderâ‚“ Î±] {u : Î¹ â†’ Î±} (h : Monotone u)
  (H : Â¬BddAbove (range u)) : tendsto u at_top at_top :=
  by 
    apply h.tendsto_at_top_at_top 
    intro b 
    rcases not_bdd_above_iff.1 H b with âŸ¨_, âŸ¨N, rflâŸ©, hNâŸ©
    exact âŸ¨N, le_of_ltâ‚“ hNâŸ©

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `tendsto u at_bot at_bot`. -/
theorem tendsto_at_bot_at_bot_of_monotone' [Preorderâ‚“ Î¹] [LinearOrderâ‚“ Î±] {u : Î¹ â†’ Î±} (h : Monotone u)
  (H : Â¬BddBelow (range u)) : tendsto u at_bot at_bot :=
  @tendsto_at_top_at_top_of_monotone' (OrderDual Î¹) (OrderDual Î±) _ _ _ h.dual H

theorem unbounded_of_tendsto_at_top [Nonempty Î±] [SemilatticeSup Î±] [Preorderâ‚“ Î²] [NoTopOrder Î²] {f : Î± â†’ Î²}
  (h : tendsto f at_top at_top) : Â¬BddAbove (range f) :=
  by 
    rintro âŸ¨M, hMâŸ©
    cases' mem_at_top_sets.mp (h$ Ioi_mem_at_top M) with a ha 
    apply lt_irreflâ‚“ M 
    calc M < f a := ha a (le_reflâ‚“ _)_ â‰¤ M := hM (Set.mem_range_self a)

theorem unbounded_of_tendsto_at_bot [Nonempty Î±] [SemilatticeSup Î±] [Preorderâ‚“ Î²] [NoBotOrder Î²] {f : Î± â†’ Î²}
  (h : tendsto f at_top at_bot) : Â¬BddBelow (range f) :=
  @unbounded_of_tendsto_at_top _ (OrderDual Î²) _ _ _ _ _ h

theorem unbounded_of_tendsto_at_top' [Nonempty Î±] [SemilatticeInf Î±] [Preorderâ‚“ Î²] [NoTopOrder Î²] {f : Î± â†’ Î²}
  (h : tendsto f at_bot at_top) : Â¬BddAbove (range f) :=
  @unbounded_of_tendsto_at_top (OrderDual Î±) _ _ _ _ _ _ h

theorem unbounded_of_tendsto_at_bot' [Nonempty Î±] [SemilatticeInf Î±] [Preorderâ‚“ Î²] [NoBotOrder Î²] {f : Î± â†’ Î²}
  (h : tendsto f at_bot at_bot) : Â¬BddBelow (range f) :=
  @unbounded_of_tendsto_at_top (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ h

/-- If a monotone function `u : Î¹ â†’ Î±` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
theorem tendsto_at_top_of_monotone_of_filter [Preorderâ‚“ Î¹] [Preorderâ‚“ Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±} (h : Monotone u)
  [ne_bot l] (hu : tendsto u l at_top) : tendsto u at_top at_top :=
  h.tendsto_at_top_at_top$ fun b => (hu.eventually (mem_at_top b)).exists

/-- If a monotone function `u : Î¹ â†’ Î±` tends to `at_bot` along *some* non-trivial filter `l`, then
it tends to `at_bot` along `at_bot`. -/
theorem tendsto_at_bot_of_monotone_of_filter [Preorderâ‚“ Î¹] [Preorderâ‚“ Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±} (h : Monotone u)
  [ne_bot l] (hu : tendsto u l at_bot) : tendsto u at_bot at_bot :=
  @tendsto_at_top_of_monotone_of_filter (OrderDual Î¹) (OrderDual Î±) _ _ _ _ h.dual _ hu

theorem tendsto_at_top_of_monotone_of_subseq [Preorderâ‚“ Î¹] [Preorderâ‚“ Î±] {u : Î¹ â†’ Î±} {Ï† : Î¹' â†’ Î¹} (h : Monotone u)
  {l : Filter Î¹'} [ne_bot l] (H : tendsto (u âˆ˜ Ï†) l at_top) : tendsto u at_top at_top :=
  tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)

theorem tendsto_at_bot_of_monotone_of_subseq [Preorderâ‚“ Î¹] [Preorderâ‚“ Î±] {u : Î¹ â†’ Î±} {Ï† : Î¹' â†’ Î¹} (h : Monotone u)
  {l : Filter Î¹'} [ne_bot l] (H : tendsto (u âˆ˜ Ï†) l at_bot) : tendsto u at_bot at_bot :=
  tendsto_at_bot_of_monotone_of_filter h (tendsto_map' H)

/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (Î» s, âˆ b in s, f b)` with
`at_top.map (Î» s, âˆ b in s, g b)`. This is useful to compare the set of limit points of
`Î  b in s, f b` as `s â†’ at_top` with the similar set for `g`. -/
@[toAdditive]
theorem map_at_top_finset_prod_le_of_prod_eq [CommMonoidâ‚“ Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±}
  (h_eq : âˆ€ u : Finset Î³, âˆƒ v : Finset Î², âˆ€ v', v âŠ† v' â†’ âˆƒ u', u âŠ† u' âˆ§ (âˆx in u', g x) = âˆb in v', f b) :
  (at_top.map fun s : Finset Î² => âˆb in s, f b) â‰¤ at_top.map fun s : Finset Î³ => âˆx in s, g x :=
  by 
    rw [map_at_top_eq, map_at_top_eq] <;>
      exact
        le_infi$
          fun b =>
            let âŸ¨v, hvâŸ© := h_eq b 
            infi_le_of_le v$
              by 
                simp [Set.image_subset_iff] <;> exact hv

theorem has_antitone_basis.tendsto [SemilatticeSup Î¹] [Nonempty Î¹] {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}
  (hl : l.has_antitone_basis p s) {Ï† : Î¹ â†’ Î±} (h : âˆ€ i : Î¹, Ï† i âˆˆ s i) : tendsto Ï† at_top l :=
  (at_top_basis.tendsto_iff hl.to_has_basis).2$
    fun i hi => âŸ¨i, trivialâ‚“, fun j hij => hl.decreasing hi (hl.mono hij hi) hij (h j)âŸ©

/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`
converging to `k`, `f âˆ˜ u` tends to `l`. -/
theorem tendsto_iff_seq_tendsto {f : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k.is_countably_generated] :
  tendsto f k l â†” âˆ€ x : â„• â†’ Î±, tendsto x at_top k â†’ tendsto (f âˆ˜ x) at_top l :=
  suffices (âˆ€ x : â„• â†’ Î±, tendsto x at_top k â†’ tendsto (f âˆ˜ x) at_top l) â†’ tendsto f k l from
    âŸ¨by 
        intros  <;> apply tendsto.comp <;> assumption,
      by 
        assumptionâŸ©
  by 
    obtain âŸ¨g, gbasis, gmon, -âŸ© := k.exists_antitone_basis 
    contrapose 
    simp only [not_forall, gbasis.tendsto_left_iff, exists_const, not_exists, not_imp]
    rintro âŸ¨B, hBl, hfBkâŸ©
    choose x h using hfBk 
    use x 
    split 
    Â·
      exact (at_top_basis.tendsto_iff gbasis).2 fun i _ => âŸ¨i, trivialâ‚“, fun j hj => gmon trivialâ‚“ trivialâ‚“ hj (h j).1âŸ©
    Â·
      simp only [tendsto_at_top', Â· âˆ˜ Â·, not_forall, not_exists]
      use B, hBl 
      intro i 
      use i, le_reflâ‚“ _ 
      apply (h i).right

theorem tendsto_of_seq_tendsto {f : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k.is_countably_generated] :
  (âˆ€ x : â„• â†’ Î±, tendsto x at_top k â†’ tendsto (f âˆ˜ x) at_top l) â†’ tendsto f k l :=
  tendsto_iff_seq_tendsto.2

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If `f` is a nontrivial countably generated basis, then there exists a sequence that converges
to `f`. -/
theorem exists_seq_tendsto
(f : filter Î±)
[is_countably_generated f]
[ne_bot f] : Â«exprâˆƒ , Â»((x : exprâ„•() â†’ Î±), tendsto x at_top f) :=
begin
  obtain ["âŸ¨", ident B, ",", ident h, ",", ident h_mono, ",", "-", "âŸ©", ":=", expr f.exists_antitone_basis],
  have [] [] [":=", expr Î» n, nonempty_of_mem (h.mem_of_mem trivial : Â«expr âˆˆ Â»(B n, f))],
  choose [] [ident x] [ident hx] [],
  exact [expr âŸ¨x, Â«expr $ Â»(h.tendsto_right_iff.2, Î»
     n hn, eventually_at_top.2 âŸ¨n, Î» m hm, h_mono trivial trivial hm (hx m)âŸ©)âŸ©]
end

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem subseq_tendsto_of_ne_bot
{f : filter Î±}
[is_countably_generated f]
{u : exprâ„•() â†’ Î±}
(hx : ne_bot Â«expr âŠ“ Â»(f, map u at_top)) : Â«exprâˆƒ , Â»((Î¸ : exprâ„•() â†’ exprâ„•()), Â«expr âˆ§ Â»(strict_mono Î¸, tendsto Â«expr âˆ˜ Â»(u, Î¸) at_top f)) :=
begin
  obtain ["âŸ¨", ident B, ",", ident h, "âŸ©", ":=", expr f.exists_antitone_basis],
  have [] [":", expr âˆ€ N, Â«exprâˆƒ , Â»((n Â«expr â‰¥ Â» N), Â«expr âˆˆ Â»(u n, B N))] [],
  from [expr Î» N, filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial) N],
  choose [] [ident Ï†] [ident hÏ†] ["using", expr this],
  cases [expr forall_and_distrib.mp hÏ†] ["with", ident Ï†_ge, ident Ï†_in],
  have [ident lim_uÏ†] [":", expr tendsto Â«expr âˆ˜ Â»(u, Ï†) at_top f] [],
  from [expr h.tendsto Ï†_in],
  have [ident lim_Ï†] [":", expr tendsto Ï† at_top at_top] [],
  from [expr tendsto_at_top_mono Ï†_ge tendsto_id],
  obtain ["âŸ¨", ident Ïˆ, ",", ident hÏˆ, ",", ident hÏˆÏ†, "âŸ©", ":", expr Â«exprâˆƒ , Â»((Ïˆ : exprâ„•() â†’ exprâ„•()), Â«expr âˆ§ Â»(strict_mono Ïˆ, strict_mono Â«expr âˆ˜ Â»(Ï†, Ïˆ)))],
  from [expr strict_mono_subseq_of_tendsto_at_top lim_Ï†],
  exact [expr âŸ¨Â«expr âˆ˜ Â»(Ï†, Ïˆ), hÏˆÏ†, lim_uÏ†.comp hÏˆ.tendsto_at_topâŸ©]
end

end Filter

open Filter Finset

section 

variable{R : Type _}[LinearOrderedSemiring R]

theorem exists_lt_mul_self (a : R) : âˆƒ (x : _)(_ : x â‰¥ 0), a < x*x :=
  let âŸ¨x, hxa, hx0âŸ© :=
    ((tendsto_mul_self_at_top.Eventually (eventually_gt_at_top a)).And (eventually_ge_at_top 0)).exists
  âŸ¨x, hx0, hxaâŸ©

theorem exists_le_mul_self (a : R) : âˆƒ (x : _)(_ : x â‰¥ 0), a â‰¤ x*x :=
  let âŸ¨x, hx0, hxaâŸ© := exists_lt_mul_self a
  âŸ¨x, hx0, hxa.leâŸ©

end 

namespace OrderIso

variable[Preorderâ‚“ Î±][Preorderâ‚“ Î²]

@[simp]
theorem comap_at_top (e : Î± â‰ƒo Î²) : comap e at_top = at_top :=
  by 
    simp [at_top, â†e.surjective.infi_comp]

@[simp]
theorem comap_at_bot (e : Î± â‰ƒo Î²) : comap e at_bot = at_bot :=
  e.dual.comap_at_top

@[simp]
theorem map_at_top (e : Î± â‰ƒo Î²) : map (e : Î± â†’ Î²) at_top = at_top :=
  by 
    rw [â†e.comap_at_top, map_comap_of_surjective e.surjective]

@[simp]
theorem map_at_bot (e : Î± â‰ƒo Î²) : map (e : Î± â†’ Î²) at_bot = at_bot :=
  e.dual.map_at_top

theorem tendsto_at_top (e : Î± â‰ƒo Î²) : tendsto e at_top at_top :=
  e.map_at_top.le

theorem tendsto_at_bot (e : Î± â‰ƒo Î²) : tendsto e at_bot at_bot :=
  e.map_at_bot.le

@[simp]
theorem tendsto_at_top_iff {l : Filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
  tendsto (fun x => e (f x)) l at_top â†” tendsto f l at_top :=
  by 
    rw [â†e.comap_at_top, tendsto_comap_iff]

@[simp]
theorem tendsto_at_bot_iff {l : Filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
  tendsto (fun x => e (f x)) l at_bot â†” tendsto f l at_bot :=
  e.dual.tendsto_at_top_iff

end OrderIso

/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (Î» s, âˆ i in s, f (g i))` and `at_top.map (Î» s, âˆ i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
@[toAdditive]
theorem Function.Injective.map_at_top_finset_prod_eq [CommMonoidâ‚“ Î±] {g : Î³ â†’ Î²} (hg : Function.Injective g) {f : Î² â†’ Î±}
  (hf : âˆ€ x _ : x âˆ‰ Set.Range g, f x = 1) :
  map (fun s => âˆi in s, f (g i)) at_top = map (fun s => âˆi in s, f i) at_top :=
  by 
    apply le_antisymmâ‚“ <;> refine' map_at_top_finset_prod_le_of_prod_eq fun s => _
    Â·
      refine' âŸ¨s.preimage g (hg.inj_on _), fun t ht => _âŸ©
      refine' âŸ¨t.image g âˆª s, Finset.subset_union_right _ _, _âŸ©
      rw [â†Finset.prod_image (hg.inj_on _)]
      refine' (prod_subset (subset_union_left _ _) _).symm 
      simp only [Finset.mem_union, Finset.mem_image]
      refine' fun y hy hyt => hf y (mt _ hyt)
      rintro âŸ¨x, rflâŸ©
      exact âŸ¨x, ht (Finset.mem_preimage.2$ hy.resolve_left hyt), rflâŸ©
    Â·
      refine' âŸ¨s.image g, fun t ht => _âŸ©
      simp only [â†prod_preimage _ _ (hg.inj_on _) _ fun x _ => hf x]
      exact âŸ¨_, (image_subset_iff_subset_preimage _).1 ht, rflâŸ©

/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `at_top.map (Î» s, âˆ‘ i in s, f (g i))` and `at_top.map (Î» s, âˆ‘ i in s, f i)` coincide.

This lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
add_decl_doc Function.Injective.map_at_top_finset_sum_eq

