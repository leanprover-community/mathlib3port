/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot

! This file was ported from Lean 3 source module order.filter.at_top_bot
! leanprover-community/mathlib commit 4d392a6c9c4539cbeca399b3ee0afea398fbd2eb
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Field.Basic
import Mathbin.Data.Finset.Preimage
import Mathbin.Data.Set.Intervals.Disjoint
import Mathbin.Data.Set.Intervals.OrderIso
import Mathbin.Order.Filter.Bases
import Mathbin.Algebra.Order.Group.MinMax

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define the filters

* `at_top`: corresponds to `n â†’ +âˆž`;
* `at_bot`: corresponds to `n â†’ -âˆž`.

Then we prove many lemmas like â€œif `f â†’ +âˆž`, then `f Â± c â†’ +âˆž`â€.
-/


variable {Î¹ Î¹' Î± Î² Î³ : Type _}

open Set

open Classical Filter BigOperators

namespace Filter

#print Filter.atTop /-
/-- `at_top` is the filter representing the limit `â†’ âˆž` on an ordered set.
  It is generated by the collection of up-sets `{b | a â‰¤ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def atTop [Preorder Î±] : Filter Î± :=
  â¨… a, ð“Ÿ (Ici a)
#align filter.at_top Filter.atTop
-/

#print Filter.atBot /-
/-- `at_bot` is the filter representing the limit `â†’ -âˆž` on an ordered set.
  It is generated by the collection of down-sets `{b | b â‰¤ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def atBot [Preorder Î±] : Filter Î± :=
  â¨… a, ð“Ÿ (Iic a)
#align filter.at_bot Filter.atBot
-/

/- warning: filter.mem_at_top -> Filter.mem_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) (setOf.{u1} Î± (fun (b : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1) a b)) (Filter.atTop.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) (setOf.{u1} Î± (fun (b : Î±) => LE.le.{u1} Î± (Preorder.toLE.{u1} Î± _inst_1) a b)) (Filter.atTop.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.mem_at_top Filter.mem_atTopâ‚“'. -/
theorem mem_atTop [Preorder Î±] (a : Î±) : { b : Î± | a â‰¤ b } âˆˆ @atTop Î± _ :=
  mem_iInf_of_mem a <| Subset.refl _
#align filter.mem_at_top Filter.mem_atTop

#print Filter.Ici_mem_atTop /-
theorem Ici_mem_atTop [Preorder Î±] (a : Î±) : Ici a âˆˆ (atTop : Filter Î±) :=
  mem_atTop a
#align filter.Ici_mem_at_top Filter.Ici_mem_atTop
-/

/- warning: filter.Ioi_mem_at_top -> Filter.Ioi_mem_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±), Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) (Set.Ioi.{u1} Î± _inst_1 x) (Filter.atTop.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (x : Î±), Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) (Set.Ioi.{u1} Î± _inst_1 x) (Filter.atTop.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.Ioi_mem_at_top Filter.Ioi_mem_atTopâ‚“'. -/
theorem Ioi_mem_atTop [Preorder Î±] [NoMaxOrder Î±] (x : Î±) : Ioi x âˆˆ (atTop : Filter Î±) :=
  let âŸ¨z, hzâŸ© := exists_gt x
  mem_of_superset (mem_atTop z) fun y h => lt_of_lt_of_le hz h
#align filter.Ioi_mem_at_top Filter.Ioi_mem_atTop

/- warning: filter.mem_at_bot -> Filter.mem_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) (setOf.{u1} Î± (fun (b : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1) b a)) (Filter.atBot.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) (setOf.{u1} Î± (fun (b : Î±) => LE.le.{u1} Î± (Preorder.toLE.{u1} Î± _inst_1) b a)) (Filter.atBot.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.mem_at_bot Filter.mem_atBotâ‚“'. -/
theorem mem_atBot [Preorder Î±] (a : Î±) : { b : Î± | b â‰¤ a } âˆˆ @atBot Î± _ :=
  mem_iInf_of_mem a <| Subset.refl _
#align filter.mem_at_bot Filter.mem_atBot

#print Filter.Iic_mem_atBot /-
theorem Iic_mem_atBot [Preorder Î±] (a : Î±) : Iic a âˆˆ (atBot : Filter Î±) :=
  mem_atBot a
#align filter.Iic_mem_at_bot Filter.Iic_mem_atBot
-/

/- warning: filter.Iio_mem_at_bot -> Filter.Iio_mem_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±), Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) (Set.Iio.{u1} Î± _inst_1 x) (Filter.atBot.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (x : Î±), Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) (Set.Iio.{u1} Î± _inst_1 x) (Filter.atBot.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.Iio_mem_at_bot Filter.Iio_mem_atBotâ‚“'. -/
theorem Iio_mem_atBot [Preorder Î±] [NoMinOrder Î±] (x : Î±) : Iio x âˆˆ (atBot : Filter Î±) :=
  let âŸ¨z, hzâŸ© := exists_lt x
  mem_of_superset (mem_atBot z) fun y h => lt_of_le_of_lt h hz
#align filter.Iio_mem_at_bot Filter.Iio_mem_atBot

/- warning: filter.disjoint_at_bot_principal_Ioi -> Filter.disjoint_atBot_principal_Ioi is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Filter.atBot.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Ioi.{u1} Î± _inst_1 x))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Filter.atBot.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Ioi.{u1} Î± _inst_1 x))
Case conversion may be inaccurate. Consider using '#align filter.disjoint_at_bot_principal_Ioi Filter.disjoint_atBot_principal_Ioiâ‚“'. -/
theorem disjoint_atBot_principal_Ioi [Preorder Î±] (x : Î±) : Disjoint atBot (ð“Ÿ (Ioi x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_atBot x) (mem_principal_self _)
#align filter.disjoint_at_bot_principal_Ioi Filter.disjoint_atBot_principal_Ioi

/- warning: filter.disjoint_at_top_principal_Iio -> Filter.disjoint_atTop_principal_Iio is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Filter.atTop.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Iio.{u1} Î± _inst_1 x))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Filter.atTop.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Iio.{u1} Î± _inst_1 x))
Case conversion may be inaccurate. Consider using '#align filter.disjoint_at_top_principal_Iio Filter.disjoint_atTop_principal_Iioâ‚“'. -/
theorem disjoint_atTop_principal_Iio [Preorder Î±] (x : Î±) : Disjoint atTop (ð“Ÿ (Iio x)) :=
  @disjoint_atBot_principal_Ioi Î±áµ’áµˆ _ _
#align filter.disjoint_at_top_principal_Iio Filter.disjoint_atTop_principal_Iio

/- warning: filter.disjoint_at_top_principal_Iic -> Filter.disjoint_atTop_principal_Iic is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Filter.atTop.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Iic.{u1} Î± _inst_1 x))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Filter.atTop.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Iic.{u1} Î± _inst_1 x))
Case conversion may be inaccurate. Consider using '#align filter.disjoint_at_top_principal_Iic Filter.disjoint_atTop_principal_Iicâ‚“'. -/
theorem disjoint_atTop_principal_Iic [Preorder Î±] [NoMaxOrder Î±] (x : Î±) :
    Disjoint atTop (ð“Ÿ (Iic x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_atTop x)
    (mem_principal_self _)
#align filter.disjoint_at_top_principal_Iic Filter.disjoint_atTop_principal_Iic

/- warning: filter.disjoint_at_bot_principal_Ici -> Filter.disjoint_atBot_principal_Ici is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Filter.atBot.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Ici.{u1} Î± _inst_1 x))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Filter.atBot.{u1} Î± _inst_1) (Filter.principal.{u1} Î± (Set.Ici.{u1} Î± _inst_1 x))
Case conversion may be inaccurate. Consider using '#align filter.disjoint_at_bot_principal_Ici Filter.disjoint_atBot_principal_Iciâ‚“'. -/
theorem disjoint_atBot_principal_Ici [Preorder Î±] [NoMinOrder Î±] (x : Î±) :
    Disjoint atBot (ð“Ÿ (Ici x)) :=
  @disjoint_atTop_principal_Iic Î±áµ’áµˆ _ _ _
#align filter.disjoint_at_bot_principal_Ici Filter.disjoint_atBot_principal_Ici

/- warning: filter.disjoint_pure_at_top -> Filter.disjoint_pure_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Î± x) (Filter.atTop.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î± x) (Filter.atTop.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.disjoint_pure_at_top Filter.disjoint_pure_atTopâ‚“'. -/
theorem disjoint_pure_atTop [Preorder Î±] [NoMaxOrder Î±] (x : Î±) : Disjoint (pure x) atTop :=
  Disjoint.symm ((disjoint_atTop_principal_Iic x).mono_right <| le_principal_iff.2 le_rfl)
#align filter.disjoint_pure_at_top Filter.disjoint_pure_atTop

/- warning: filter.disjoint_pure_at_bot -> Filter.disjoint_pure_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Î± x) (Filter.atBot.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (x : Î±), Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î± x) (Filter.atBot.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.disjoint_pure_at_bot Filter.disjoint_pure_atBotâ‚“'. -/
theorem disjoint_pure_atBot [Preorder Î±] [NoMinOrder Î±] (x : Î±) : Disjoint (pure x) atBot :=
  @disjoint_pure_atTop Î±áµ’áµˆ _ _ _
#align filter.disjoint_pure_at_bot Filter.disjoint_pure_atBot

/- warning: filter.not_tendsto_const_at_top -> Filter.not_tendsto_const_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±) (l : Filter.{u2} Î²) [_inst_3 : Filter.NeBot.{u2} Î² l], Not (Filter.Tendsto.{u2, u1} Î² Î± (fun (_x : Î²) => x) l (Filter.atTop.{u1} Î± _inst_1))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : NoMaxOrder.{u2} Î± (Preorder.toLT.{u2} Î± _inst_1)] (x : Î±) (l : Filter.{u1} Î²) [_inst_3 : Filter.NeBot.{u1} Î² l], Not (Filter.Tendsto.{u1, u2} Î² Î± (fun (_x : Î²) => x) l (Filter.atTop.{u2} Î± _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.not_tendsto_const_at_top Filter.not_tendsto_const_atTopâ‚“'. -/
theorem not_tendsto_const_atTop [Preorder Î±] [NoMaxOrder Î±] (x : Î±) (l : Filter Î²) [l.ne_bot] :
    Â¬Tendsto (fun _ => x) l atTop :=
  tendsto_const_pure.not_tendsto (disjoint_pure_atTop x)
#align filter.not_tendsto_const_at_top Filter.not_tendsto_const_atTop

/- warning: filter.not_tendsto_const_at_bot -> Filter.not_tendsto_const_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (x : Î±) (l : Filter.{u2} Î²) [_inst_3 : Filter.NeBot.{u2} Î² l], Not (Filter.Tendsto.{u2, u1} Î² Î± (fun (_x : Î²) => x) l (Filter.atBot.{u1} Î± _inst_1))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : NoMinOrder.{u2} Î± (Preorder.toLT.{u2} Î± _inst_1)] (x : Î±) (l : Filter.{u1} Î²) [_inst_3 : Filter.NeBot.{u1} Î² l], Not (Filter.Tendsto.{u1, u2} Î² Î± (fun (_x : Î²) => x) l (Filter.atBot.{u2} Î± _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.not_tendsto_const_at_bot Filter.not_tendsto_const_atBotâ‚“'. -/
theorem not_tendsto_const_atBot [Preorder Î±] [NoMinOrder Î±] (x : Î±) (l : Filter Î²) [l.ne_bot] :
    Â¬Tendsto (fun _ => x) l atBot :=
  tendsto_const_pure.not_tendsto (disjoint_pure_atBot x)
#align filter.not_tendsto_const_at_bot Filter.not_tendsto_const_atBot

/- warning: filter.disjoint_at_bot_at_top -> Filter.disjoint_atBot_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : Nontrivial.{u1} Î±], Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : Nontrivial.{u1} Î±], Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.disjoint_at_bot_at_top Filter.disjoint_atBot_atTopâ‚“'. -/
theorem disjoint_atBot_atTop [PartialOrder Î±] [Nontrivial Î±] : Disjoint (atBot : Filter Î±) atTop :=
  by
  rcases exists_pair_ne Î± with âŸ¨x, y, hneâŸ©
  by_cases hle : x â‰¤ y
  Â· refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot x) (Ici_mem_at_top y)
    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le
  Â· refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot y) (Ici_mem_at_top x)
    exact Iic_disjoint_Ici.2 hle
#align filter.disjoint_at_bot_at_top Filter.disjoint_atBot_atTop

/- warning: filter.disjoint_at_top_at_bot -> Filter.disjoint_atTop_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : Nontrivial.{u1} Î±], Disjoint.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : Nontrivial.{u1} Î±], Disjoint.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.disjoint_at_top_at_bot Filter.disjoint_atTop_atBotâ‚“'. -/
theorem disjoint_atTop_atBot [PartialOrder Î±] [Nontrivial Î±] : Disjoint (atTop : Filter Î±) atBot :=
  disjoint_atBot_atTop.symm
#align filter.disjoint_at_top_at_bot Filter.disjoint_atTop_atBot

#print Filter.atTop_basis /-
theorem atTop_basis [Nonempty Î±] [SemilatticeSup Î±] : (@atTop Î± _).HasBasis (fun _ => True) Ici :=
  hasBasis_iInf_principal (directed_of_sup fun a b => Ici_subset_Ici.2)
#align filter.at_top_basis Filter.atTop_basis
-/

/- warning: filter.at_top_basis' -> Filter.atTop_basis' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] (a : Î±), Filter.HasBasis.{u1, succ u1} Î± Î± (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a x) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] (a : Î±), Filter.HasBasis.{u1, succ u1} Î± Î± (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a x) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.at_top_basis' Filter.atTop_basis'â‚“'. -/
theorem atTop_basis' [SemilatticeSup Î±] (a : Î±) : (@atTop Î± _).HasBasis (fun x => a â‰¤ x) Ici :=
  âŸ¨fun t =>
    (@atTop_basis Î± âŸ¨aâŸ© _).mem_iff.trans
      âŸ¨fun âŸ¨x, _, hxâŸ© => âŸ¨x âŠ” a, le_sup_right, fun y hy => hx (le_trans le_sup_left hy)âŸ©,
        fun âŸ¨x, _, hxâŸ© => âŸ¨x, trivial, hxâŸ©âŸ©âŸ©
#align filter.at_top_basis' Filter.atTop_basis'

#print Filter.atBot_basis /-
theorem atBot_basis [Nonempty Î±] [SemilatticeInf Î±] : (@atBot Î± _).HasBasis (fun _ => True) Iic :=
  @atTop_basis Î±áµ’áµˆ _ _
#align filter.at_bot_basis Filter.atBot_basis
-/

/- warning: filter.at_bot_basis' -> Filter.atBot_basis' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] (a : Î±), Filter.HasBasis.{u1, succ u1} Î± Î± (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) x a) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] (a : Î±), Filter.HasBasis.{u1, succ u1} Î± Î± (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) x a) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.at_bot_basis' Filter.atBot_basis'â‚“'. -/
theorem atBot_basis' [SemilatticeInf Î±] (a : Î±) : (@atBot Î± _).HasBasis (fun x => x â‰¤ a) Iic :=
  @atTop_basis' Î±áµ’áµˆ _ _
#align filter.at_bot_basis' Filter.atBot_basis'

#print Filter.atTop_neBot /-
@[instance]
theorem atTop_neBot [Nonempty Î±] [SemilatticeSup Î±] : NeBot (atTop : Filter Î±) :=
  atTop_basis.neBot_iff.2 fun a _ => nonempty_Ici
#align filter.at_top_ne_bot Filter.atTop_neBot
-/

#print Filter.atBot_neBot /-
@[instance]
theorem atBot_neBot [Nonempty Î±] [SemilatticeInf Î±] : NeBot (atBot : Filter Î±) :=
  @atTop_neBot Î±áµ’áµˆ _ _
#align filter.at_bot_ne_bot Filter.atBot_neBot
-/

/- warning: filter.mem_at_top_sets -> Filter.mem_atTop_sets is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] {s : Set.{u1} Î±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) s (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) b a) -> (Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) b s)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] {s : Set.{u1} Î±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) s (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) b a) -> (Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) b s)))
Case conversion may be inaccurate. Consider using '#align filter.mem_at_top_sets Filter.mem_atTop_setsâ‚“'. -/
@[simp]
theorem mem_atTop_sets [Nonempty Î±] [SemilatticeSup Î±] {s : Set Î±} :
    s âˆˆ (atTop : Filter Î±) â†” âˆƒ a : Î±, âˆ€ b â‰¥ a, b âˆˆ s :=
  atTop_basis.mem_iff.trans <| exists_congr fun _ => exists_const _
#align filter.mem_at_top_sets Filter.mem_atTop_sets

/- warning: filter.mem_at_bot_sets -> Filter.mem_atBot_sets is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] {s : Set.{u1} Î±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) s (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) b a) -> (Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) b s)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] {s : Set.{u1} Î±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) s (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) b a) -> (Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) b s)))
Case conversion may be inaccurate. Consider using '#align filter.mem_at_bot_sets Filter.mem_atBot_setsâ‚“'. -/
@[simp]
theorem mem_atBot_sets [Nonempty Î±] [SemilatticeInf Î±] {s : Set Î±} :
    s âˆˆ (atBot : Filter Î±) â†” âˆƒ a : Î±, âˆ€ b â‰¤ a, b âˆˆ s :=
  @mem_atTop_sets Î±áµ’áµˆ _ _ _
#align filter.mem_at_bot_sets Filter.mem_atBot_sets

/- warning: filter.eventually_at_top -> Filter.eventually_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_top Filter.eventually_atTopâ‚“'. -/
@[simp]
theorem eventually_atTop [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
    (âˆ€á¶  x in atTop, p x) â†” âˆƒ a, âˆ€ b â‰¥ a, p b :=
  mem_atTop_sets
#align filter.eventually_at_top Filter.eventually_atTop

/- warning: filter.eventually_at_bot -> Filter.eventually_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_bot Filter.eventually_atBotâ‚“'. -/
@[simp]
theorem eventually_atBot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
    (âˆ€á¶  x in atBot, p x) â†” âˆƒ a, âˆ€ b â‰¤ a, p b :=
  mem_atBot_sets
#align filter.eventually_at_bot Filter.eventually_atBot

/- warning: filter.eventually_ge_at_top -> Filter.eventually_ge_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1) a x) (Filter.atTop.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toLE.{u1} Î± _inst_1) a x) (Filter.atTop.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.eventually_ge_at_top Filter.eventually_ge_atTopâ‚“'. -/
theorem eventually_ge_atTop [Preorder Î±] (a : Î±) : âˆ€á¶  x in atTop, a â‰¤ x :=
  mem_atTop a
#align filter.eventually_ge_at_top Filter.eventually_ge_atTop

/- warning: filter.eventually_le_at_bot -> Filter.eventually_le_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1) x a) (Filter.atBot.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u1} Î± (Preorder.toLE.{u1} Î± _inst_1) x a) (Filter.atBot.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.eventually_le_at_bot Filter.eventually_le_atBotâ‚“'. -/
theorem eventually_le_atBot [Preorder Î±] (a : Î±) : âˆ€á¶  x in atBot, x â‰¤ a :=
  mem_atBot a
#align filter.eventually_le_at_bot Filter.eventually_le_atBot

/- warning: filter.eventually_gt_at_top -> Filter.eventually_gt_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1) a x) (Filter.atTop.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1) a x) (Filter.atTop.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.eventually_gt_at_top Filter.eventually_gt_atTopâ‚“'. -/
theorem eventually_gt_atTop [Preorder Î±] [NoMaxOrder Î±] (a : Î±) : âˆ€á¶  x in atTop, a < x :=
  Ioi_mem_atTop a
#align filter.eventually_gt_at_top Filter.eventually_gt_atTop

/- warning: filter.eventually_ne_at_top -> Filter.eventually_ne_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u1} Î± x a) (Filter.atTop.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u1} Î± x a) (Filter.atTop.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.eventually_ne_at_top Filter.eventually_ne_atTopâ‚“'. -/
theorem eventually_ne_atTop [Preorder Î±] [NoMaxOrder Î±] (a : Î±) : âˆ€á¶  x in atTop, x â‰  a :=
  (eventually_gt_atTop a).mono fun x => ne_of_gt
#align filter.eventually_ne_at_top Filter.eventually_ne_atTop

/- warning: filter.tendsto.eventually_gt_at_top -> Filter.Tendsto.eventually_gt_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMaxOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_1) c (f x)) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMaxOrder.{u2} Î² (Preorder.toLT.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² _inst_1) c (f x)) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto.eventually_gt_at_top Filter.Tendsto.eventually_gt_atTopâ‚“'. -/
theorem Tendsto.eventually_gt_atTop [Preorder Î²] [NoMaxOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atTop) (c : Î²) : âˆ€á¶  x in l, c < f x :=
  hf.Eventually (eventually_gt_atTop c)
#align filter.tendsto.eventually_gt_at_top Filter.Tendsto.eventually_gt_atTop

/- warning: filter.tendsto.eventually_ge_at_top -> Filter.Tendsto.eventually_ge_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) c (f x)) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) c (f x)) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto.eventually_ge_at_top Filter.Tendsto.eventually_ge_atTopâ‚“'. -/
theorem Tendsto.eventually_ge_atTop [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} (hf : Tendsto f l atTop)
    (c : Î²) : âˆ€á¶  x in l, c â‰¤ f x :=
  hf.Eventually (eventually_ge_atTop c)
#align filter.tendsto.eventually_ge_at_top Filter.Tendsto.eventually_ge_atTop

/- warning: filter.tendsto.eventually_ne_at_top -> Filter.Tendsto.eventually_ne_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMaxOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u2} Î² (f x) c) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMaxOrder.{u2} Î² (Preorder.toLT.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u2} Î² (f x) c) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto.eventually_ne_at_top Filter.Tendsto.eventually_ne_atTopâ‚“'. -/
theorem Tendsto.eventually_ne_atTop [Preorder Î²] [NoMaxOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atTop) (c : Î²) : âˆ€á¶  x in l, f x â‰  c :=
  hf.Eventually (eventually_ne_atTop c)
#align filter.tendsto.eventually_ne_at_top Filter.Tendsto.eventually_ne_atTop

/- warning: filter.tendsto.eventually_ne_at_top' -> Filter.Tendsto.eventually_ne_atTop' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMaxOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u1} Î± x c) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMaxOrder.{u2} Î² (Preorder.toLT.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (forall (c : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u1} Î± x c) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto.eventually_ne_at_top' Filter.Tendsto.eventually_ne_atTop'â‚“'. -/
theorem Tendsto.eventually_ne_atTop' [Preorder Î²] [NoMaxOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atTop) (c : Î±) : âˆ€á¶  x in l, x â‰  c :=
  (hf.eventually_ne_atTop (f c)).mono fun x => ne_of_apply_ne f
#align filter.tendsto.eventually_ne_at_top' Filter.Tendsto.eventually_ne_atTop'

/- warning: filter.eventually_lt_at_bot -> Filter.eventually_lt_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1) x a) (Filter.atBot.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1) x a) (Filter.atBot.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.eventually_lt_at_bot Filter.eventually_lt_atBotâ‚“'. -/
theorem eventually_lt_atBot [Preorder Î±] [NoMinOrder Î±] (a : Î±) : âˆ€á¶  x in atBot, x < a :=
  Iio_mem_atBot a
#align filter.eventually_lt_at_bot Filter.eventually_lt_atBot

/- warning: filter.eventually_ne_at_bot -> Filter.eventually_ne_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u1} Î± x a) (Filter.atBot.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toLT.{u1} Î± _inst_1)] (a : Î±), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u1} Î± x a) (Filter.atBot.{u1} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.eventually_ne_at_bot Filter.eventually_ne_atBotâ‚“'. -/
theorem eventually_ne_atBot [Preorder Î±] [NoMinOrder Î±] (a : Î±) : âˆ€á¶  x in atBot, x â‰  a :=
  (eventually_lt_atBot a).mono fun x => ne_of_lt
#align filter.eventually_ne_at_bot Filter.eventually_ne_atBot

/- warning: filter.tendsto.eventually_lt_at_bot -> Filter.Tendsto.eventually_lt_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMinOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_1) (f x) c) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMinOrder.{u2} Î² (Preorder.toLT.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² _inst_1) (f x) c) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto.eventually_lt_at_bot Filter.Tendsto.eventually_lt_atBotâ‚“'. -/
theorem Tendsto.eventually_lt_atBot [Preorder Î²] [NoMinOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atBot) (c : Î²) : âˆ€á¶  x in l, f x < c :=
  hf.Eventually (eventually_lt_atBot c)
#align filter.tendsto.eventually_lt_at_bot Filter.Tendsto.eventually_lt_atBot

/- warning: filter.tendsto.eventually_le_at_bot -> Filter.Tendsto.eventually_le_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) (f x) c) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) (f x) c) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto.eventually_le_at_bot Filter.Tendsto.eventually_le_atBotâ‚“'. -/
theorem Tendsto.eventually_le_atBot [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} (hf : Tendsto f l atBot)
    (c : Î²) : âˆ€á¶  x in l, f x â‰¤ c :=
  hf.Eventually (eventually_le_atBot c)
#align filter.tendsto.eventually_le_at_bot Filter.Tendsto.eventually_le_atBot

/- warning: filter.tendsto.eventually_ne_at_bot -> Filter.Tendsto.eventually_ne_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMinOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u2} Î² (f x) c) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : NoMinOrder.{u2} Î² (Preorder.toLT.{u2} Î² _inst_1)] {f : Î± -> Î²} {l : Filter.{u1} Î±}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1)) -> (forall (c : Î²), Filter.Eventually.{u1} Î± (fun (x : Î±) => Ne.{succ u2} Î² (f x) c) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto.eventually_ne_at_bot Filter.Tendsto.eventually_ne_atBotâ‚“'. -/
theorem Tendsto.eventually_ne_atBot [Preorder Î²] [NoMinOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atBot) (c : Î²) : âˆ€á¶  x in l, f x â‰  c :=
  hf.Eventually (eventually_ne_atBot c)
#align filter.tendsto.eventually_ne_at_bot Filter.Tendsto.eventually_ne_atBot

/- warning: filter.at_top_basis_Ioi -> Filter.atTop_basis_Ioi is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)))], Filter.HasBasis.{u1, succ u1} Î± Î± (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (fun (_x : Î±) => True) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)))], Filter.HasBasis.{u1, succ u1} Î± Î± (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (fun (_x : Î±) => True) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.at_top_basis_Ioi Filter.atTop_basis_Ioiâ‚“'. -/
theorem atTop_basis_Ioi [Nonempty Î±] [SemilatticeSup Î±] [NoMaxOrder Î±] :
    (@atTop Î± _).HasBasis (fun _ => True) Ioi :=
  atTop_basis.to_hasBasis (fun a ha => âŸ¨a, ha, Ioi_subset_Ici_selfâŸ©) fun a ha =>
    (exists_gt a).imp fun b hb => âŸ¨ha, Ici_subset_Ioi.2 hbâŸ©
#align filter.at_top_basis_Ioi Filter.atTop_basis_Ioi

#print Filter.atTop_countable_basis /-
theorem atTop_countable_basis [Nonempty Î±] [SemilatticeSup Î±] [Countable Î±] :
    HasCountableBasis (atTop : Filter Î±) (fun _ => True) Ici :=
  { atTop_basis with Countable := to_countable _ }
#align filter.at_top_countable_basis Filter.atTop_countable_basis
-/

#print Filter.atBot_countable_basis /-
theorem atBot_countable_basis [Nonempty Î±] [SemilatticeInf Î±] [Countable Î±] :
    HasCountableBasis (atBot : Filter Î±) (fun _ => True) Iic :=
  { atBot_basis with Countable := to_countable _ }
#align filter.at_bot_countable_basis Filter.atBot_countable_basis
-/

#print Filter.atTop.isCountablyGenerated /-
instance (priority := 200) atTop.isCountablyGenerated [Preorder Î±] [Countable Î±] :
    (atTop : Filter <| Î±).IsCountablyGenerated :=
  isCountablyGenerated_seq _
#align filter.at_top.is_countably_generated Filter.atTop.isCountablyGenerated
-/

#print Filter.atBot.isCountablyGenerated /-
instance (priority := 200) atBot.isCountablyGenerated [Preorder Î±] [Countable Î±] :
    (atBot : Filter <| Î±).IsCountablyGenerated :=
  isCountablyGenerated_seq _
#align filter.at_bot.is_countably_generated Filter.atBot.isCountablyGenerated
-/

/- warning: filter.order_top.at_top_eq -> Filter.OrderTop.atTop_eq is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : OrderTop.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Î± (Top.top.{u1} Î± (OrderTop.toHasTop.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) _inst_2)))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : OrderTop.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î± (Top.top.{u1} Î± (OrderTop.toTop.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.order_top.at_top_eq Filter.OrderTop.atTop_eqâ‚“'. -/
theorem OrderTop.atTop_eq (Î±) [PartialOrder Î±] [OrderTop Î±] : (atTop : Filter Î±) = pure âŠ¤ :=
  le_antisymm (le_pure_iff.2 <| (eventually_ge_atTop âŠ¤).mono fun b => top_unique)
    (le_iInf fun b => le_principal_iff.2 le_top)
#align filter.order_top.at_top_eq Filter.OrderTop.atTop_eq

/- warning: filter.order_bot.at_bot_eq -> Filter.OrderBot.atBot_eq is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : OrderBot.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Î± (Bot.bot.{u1} Î± (OrderBot.toHasBot.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) _inst_2)))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : OrderBot.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î± (Bot.bot.{u1} Î± (OrderBot.toBot.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.order_bot.at_bot_eq Filter.OrderBot.atBot_eqâ‚“'. -/
theorem OrderBot.atBot_eq (Î±) [PartialOrder Î±] [OrderBot Î±] : (atBot : Filter Î±) = pure âŠ¥ :=
  @OrderTop.atTop_eq Î±áµ’áµˆ _ _
#align filter.order_bot.at_bot_eq Filter.OrderBot.atBot_eq

/- warning: filter.subsingleton.at_top_eq -> Filter.Subsingleton.atTop_eq is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Subsingleton.{succ u1} Î±] [_inst_2 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atTop.{u1} Î± _inst_2) (Top.top.{u1} (Filter.{u1} Î±) (Filter.hasTop.{u1} Î±))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Subsingleton.{succ u1} Î±] [_inst_2 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atTop.{u1} Î± _inst_2) (Top.top.{u1} (Filter.{u1} Î±) (Filter.instTopFilter.{u1} Î±))
Case conversion may be inaccurate. Consider using '#align filter.subsingleton.at_top_eq Filter.Subsingleton.atTop_eqâ‚“'. -/
@[nontriviality]
theorem Subsingleton.atTop_eq (Î±) [Subsingleton Î±] [Preorder Î±] : (atTop : Filter Î±) = âŠ¤ :=
  by
  refine' top_unique fun s hs x => _
  letI : Unique Î± := âŸ¨âŸ¨xâŸ©, fun y => Subsingleton.elim y xâŸ©
  rw [at_top, ciInf_unique, Unique.default_eq x, mem_principal] at hs
  exact hs left_mem_Ici
#align filter.subsingleton.at_top_eq Filter.Subsingleton.atTop_eq

/- warning: filter.subsingleton.at_bot_eq -> Filter.Subsingleton.atBot_eq is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Subsingleton.{succ u1} Î±] [_inst_2 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atBot.{u1} Î± _inst_2) (Top.top.{u1} (Filter.{u1} Î±) (Filter.hasTop.{u1} Î±))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Subsingleton.{succ u1} Î±] [_inst_2 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} Î±) (Filter.atBot.{u1} Î± _inst_2) (Top.top.{u1} (Filter.{u1} Î±) (Filter.instTopFilter.{u1} Î±))
Case conversion may be inaccurate. Consider using '#align filter.subsingleton.at_bot_eq Filter.Subsingleton.atBot_eqâ‚“'. -/
@[nontriviality]
theorem Subsingleton.atBot_eq (Î±) [Subsingleton Î±] [Preorder Î±] : (atBot : Filter Î±) = âŠ¤ :=
  @Subsingleton.atTop_eq Î±áµ’áµˆ _ _
#align filter.subsingleton.at_bot_eq Filter.Subsingleton.atBot_eq

/- warning: filter.tendsto_at_top_pure -> Filter.tendsto_atTop_pure is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : OrderTop.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))] (f : Î± -> Î²), Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Pure.pure.{u2, u2} Filter.{u2} Filter.hasPure.{u2} Î² (f (Top.top.{u1} Î± (OrderTop.toHasTop.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) _inst_2))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : PartialOrder.{u2} Î±] [_inst_2 : OrderTop.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± _inst_1))] (f : Î± -> Î²), Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± _inst_1)) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î² (f (Top.top.{u2} Î± (OrderTop.toTop.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± _inst_1)) _inst_2))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_pure Filter.tendsto_atTop_pureâ‚“'. -/
theorem tendsto_atTop_pure [PartialOrder Î±] [OrderTop Î±] (f : Î± â†’ Î²) :
    Tendsto f atTop (pure <| f âŠ¤) :=
  (OrderTop.atTop_eq Î±).symm â–¸ tendsto_pure_pure _ _
#align filter.tendsto_at_top_pure Filter.tendsto_atTop_pure

/- warning: filter.tendsto_at_bot_pure -> Filter.tendsto_atBot_pure is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : PartialOrder.{u1} Î±] [_inst_2 : OrderBot.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1))] (f : Î± -> Î²), Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) (Pure.pure.{u2, u2} Filter.{u2} Filter.hasPure.{u2} Î² (f (Bot.bot.{u1} Î± (OrderBot.toHasBot.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± _inst_1)) _inst_2))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : PartialOrder.{u2} Î±] [_inst_2 : OrderBot.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± _inst_1))] (f : Î± -> Î²), Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± _inst_1)) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î² (f (Bot.bot.{u2} Î± (OrderBot.toBot.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± _inst_1)) _inst_2))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_pure Filter.tendsto_atBot_pureâ‚“'. -/
theorem tendsto_atBot_pure [PartialOrder Î±] [OrderBot Î±] (f : Î± â†’ Î²) :
    Tendsto f atBot (pure <| f âŠ¥) :=
  @tendsto_atTop_pure Î±áµ’áµˆ _ _ _ _
#align filter.tendsto_at_bot_pure Filter.tendsto_atBot_pure

/- warning: filter.eventually.exists_forall_of_at_top -> Filter.Eventually.exists_forall_of_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) -> (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) -> (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
Case conversion may be inaccurate. Consider using '#align filter.eventually.exists_forall_of_at_top Filter.Eventually.exists_forall_of_atTopâ‚“'. -/
theorem Eventually.exists_forall_of_atTop [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop}
    (h : âˆ€á¶  x in atTop, p x) : âˆƒ a, âˆ€ b â‰¥ a, p b :=
  eventually_atTop.mp h
#align filter.eventually.exists_forall_of_at_top Filter.Eventually.exists_forall_of_atTop

/- warning: filter.eventually.exists_forall_of_at_bot -> Filter.Eventually.exists_forall_of_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) -> (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Eventually.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) -> (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) -> (p b)))
Case conversion may be inaccurate. Consider using '#align filter.eventually.exists_forall_of_at_bot Filter.Eventually.exists_forall_of_atBotâ‚“'. -/
theorem Eventually.exists_forall_of_atBot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop}
    (h : âˆ€á¶  x in atBot, p x) : âˆƒ a, âˆ€ b â‰¤ a, p b :=
  eventually_atBot.mp h
#align filter.eventually.exists_forall_of_at_bot Filter.Eventually.exists_forall_of_atBot

/- warning: filter.frequently_at_top -> Filter.frequently_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => Exists.{0} (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) (fun (H : GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) => p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => And (GE.ge.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.frequently_at_top Filter.frequently_atTopâ‚“'. -/
theorem frequently_atTop [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
    (âˆƒá¶  x in atTop, p x) â†” âˆ€ a, âˆƒ b â‰¥ a, p b := by simp [at_top_basis.frequently_iff]
#align filter.frequently_at_top Filter.frequently_atTop

/- warning: filter.frequently_at_bot -> Filter.frequently_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => Exists.{0} (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) (fun (H : LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) => p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => And (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.frequently_at_bot Filter.frequently_atBotâ‚“'. -/
theorem frequently_atBot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop} :
    (âˆƒá¶  x in atBot, p x) â†” âˆ€ a, âˆƒ b â‰¤ a, p b :=
  @frequently_atTop Î±áµ’áµˆ _ _ _
#align filter.frequently_at_bot Filter.frequently_atBot

/- warning: filter.frequently_at_top' -> Filter.frequently_atTop' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] [_inst_3 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => Exists.{0} (GT.gt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) (fun (H : GT.gt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) => p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] [_inst_3 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => And (GT.gt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.frequently_at_top' Filter.frequently_atTop'â‚“'. -/
theorem frequently_atTop' [SemilatticeSup Î±] [Nonempty Î±] [NoMaxOrder Î±] {p : Î± â†’ Prop} :
    (âˆƒá¶  x in atTop, p x) â†” âˆ€ a, âˆƒ b > a, p b := by simp [at_top_basis_Ioi.frequently_iff]
#align filter.frequently_at_top' Filter.frequently_atTop'

/- warning: filter.frequently_at_bot' -> Filter.frequently_atBot' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] [_inst_3 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => Exists.{0} (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) (fun (H : LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) => p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] [_inst_3 : NoMinOrder.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))] {p : Î± -> Prop}, Iff (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.frequently_at_bot' Filter.frequently_atBot'â‚“'. -/
theorem frequently_atBot' [SemilatticeInf Î±] [Nonempty Î±] [NoMinOrder Î±] {p : Î± â†’ Prop} :
    (âˆƒá¶  x in atBot, p x) â†” âˆ€ a, âˆƒ b < a, p b :=
  @frequently_atTop' Î±áµ’áµˆ _ _ _ _
#align filter.frequently_at_bot' Filter.frequently_atBot'

/- warning: filter.frequently.forall_exists_of_at_top -> Filter.Frequently.forall_exists_of_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) -> (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => Exists.{0} (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) (fun (H : GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) => p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) -> (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => And (GE.ge.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.frequently.forall_exists_of_at_top Filter.Frequently.forall_exists_of_atTopâ‚“'. -/
theorem Frequently.forall_exists_of_atTop [SemilatticeSup Î±] [Nonempty Î±] {p : Î± â†’ Prop}
    (h : âˆƒá¶  x in atTop, p x) : âˆ€ a, âˆƒ b â‰¥ a, p b :=
  frequently_atTop.mp h
#align filter.frequently.forall_exists_of_at_top Filter.Frequently.forall_exists_of_atTop

/- warning: filter.frequently.forall_exists_of_at_bot -> Filter.Frequently.forall_exists_of_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) -> (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => Exists.{0} (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) (fun (H : LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) => p b)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : Î± -> Prop}, (Filter.Frequently.{u1} Î± (fun (x : Î±) => p x) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) -> (forall (a : Î±), Exists.{succ u1} Î± (fun (b : Î±) => And (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.frequently.forall_exists_of_at_bot Filter.Frequently.forall_exists_of_atBotâ‚“'. -/
theorem Frequently.forall_exists_of_atBot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop}
    (h : âˆƒá¶  x in atBot, p x) : âˆ€ a, âˆƒ b â‰¤ a, p b :=
  frequently_atBot.mp h
#align filter.frequently.forall_exists_of_at_bot Filter.Frequently.forall_exists_of_atBot

/- warning: filter.map_at_top_eq -> Filter.map_atTop_eq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] {f : Î± -> Î²}, Eq.{succ u2} (Filter.{u2} Î²) (Filter.map.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)))) (iInf.{u2, succ u1} (Filter.{u2} Î²) (ConditionallyCompleteLattice.toHasInf.{u2} (Filter.{u2} Î²) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Î²) (Filter.completeLattice.{u2} Î²))) Î± (fun (a : Î±) => Filter.principal.{u2} Î² (Set.image.{u1, u2} Î± Î² f (setOf.{u1} Î± (fun (a' : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) a a')))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] {f : Î± -> Î²}, Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2)))) (iInf.{u1, succ u2} (Filter.{u1} Î²) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Î²) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Î²) (Filter.instCompleteLatticeFilter.{u1} Î²))) Î± (fun (a : Î±) => Filter.principal.{u1} Î² (Set.image.{u2, u1} Î± Î² f (setOf.{u2} Î± (fun (a' : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) a a')))))
Case conversion may be inaccurate. Consider using '#align filter.map_at_top_eq Filter.map_atTop_eqâ‚“'. -/
theorem map_atTop_eq [Nonempty Î±] [SemilatticeSup Î±] {f : Î± â†’ Î²} :
    atTop.map f = â¨… a, ð“Ÿ <| f '' { a' | a â‰¤ a' } :=
  (atTop_basis.map _).eq_iInf
#align filter.map_at_top_eq Filter.map_atTop_eq

/- warning: filter.map_at_bot_eq -> Filter.map_atBot_eq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] {f : Î± -> Î²}, Eq.{succ u2} (Filter.{u2} Î²) (Filter.map.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2)))) (iInf.{u2, succ u1} (Filter.{u2} Î²) (ConditionallyCompleteLattice.toHasInf.{u2} (Filter.{u2} Î²) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Î²) (Filter.completeLattice.{u2} Î²))) Î± (fun (a : Î±) => Filter.principal.{u2} Î² (Set.image.{u1, u2} Î± Î² f (setOf.{u1} Î± (fun (a' : Î±) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) a' a)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] {f : Î± -> Î²}, Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2)))) (iInf.{u1, succ u2} (Filter.{u1} Î²) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Î²) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Î²) (Filter.instCompleteLatticeFilter.{u1} Î²))) Î± (fun (a : Î±) => Filter.principal.{u1} Î² (Set.image.{u2, u1} Î± Î² f (setOf.{u2} Î± (fun (a' : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) a' a)))))
Case conversion may be inaccurate. Consider using '#align filter.map_at_bot_eq Filter.map_atBot_eqâ‚“'. -/
theorem map_atBot_eq [Nonempty Î±] [SemilatticeInf Î±] {f : Î± â†’ Î²} :
    atBot.map f = â¨… a, ð“Ÿ <| f '' { a' | a' â‰¤ a } :=
  @map_atTop_eq Î±áµ’áµˆ _ _ _ _
#align filter.map_at_bot_eq Filter.map_atBot_eq

/- warning: filter.tendsto_at_top -> Filter.tendsto_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {m : Î± -> Î²} {f : Filter.{u1} Î±}, Iff (Filter.Tendsto.{u1, u2} Î± Î² m f (Filter.atTop.{u2} Î² _inst_1)) (forall (b : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) b (m a)) f)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {m : Î± -> Î²} {f : Filter.{u1} Î±}, Iff (Filter.Tendsto.{u1, u2} Î± Î² m f (Filter.atTop.{u2} Î² _inst_1)) (forall (b : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) b (m a)) f)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top Filter.tendsto_atTopâ‚“'. -/
theorem tendsto_atTop [Preorder Î²] {m : Î± â†’ Î²} {f : Filter Î±} :
    Tendsto m f atTop â†” âˆ€ b, âˆ€á¶  a in f, b â‰¤ m a := by
  simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]
#align filter.tendsto_at_top Filter.tendsto_atTop

/- warning: filter.tendsto_at_bot -> Filter.tendsto_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {m : Î± -> Î²} {f : Filter.{u1} Î±}, Iff (Filter.Tendsto.{u1, u2} Î± Î² m f (Filter.atBot.{u2} Î² _inst_1)) (forall (b : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) (m a) b) f)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {m : Î± -> Î²} {f : Filter.{u1} Î±}, Iff (Filter.Tendsto.{u1, u2} Î± Î² m f (Filter.atBot.{u2} Î² _inst_1)) (forall (b : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) (m a) b) f)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot Filter.tendsto_atBotâ‚“'. -/
theorem tendsto_atBot [Preorder Î²] {m : Î± â†’ Î²} {f : Filter Î±} :
    Tendsto m f atBot â†” âˆ€ b, âˆ€á¶  a in f, m a â‰¤ b :=
  @tendsto_atTop Î± Î²áµ’áµˆ _ m f
#align filter.tendsto_at_bot Filter.tendsto_atBot

/- warning: filter.tendsto_at_top_mono' -> Filter.tendsto_atTop_mono' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] (l : Filter.{u1} Î±) {{fâ‚ : Î± -> Î²}} {{fâ‚‚ : Î± -> Î²}}, (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toHasLe.{u2} Î² _inst_1) l fâ‚ fâ‚‚) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚ l (Filter.atTop.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚‚ l (Filter.atTop.{u2} Î² _inst_1))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] (l : Filter.{u1} Î±) {{fâ‚ : Î± -> Î²}} {{fâ‚‚ : Î± -> Î²}}, (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toLE.{u2} Î² _inst_1) l fâ‚ fâ‚‚) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚ l (Filter.atTop.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚‚ l (Filter.atTop.{u2} Î² _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_mono' Filter.tendsto_atTop_mono'â‚“'. -/
theorem tendsto_atTop_mono' [Preorder Î²] (l : Filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
    Tendsto fâ‚ l atTop â†’ Tendsto fâ‚‚ l atTop := fun hâ‚ =>
  tendsto_atTop.2 fun b =>
    mp_mem (tendsto_atTop.1 hâ‚ b) (monotone_mem (fun a ha haâ‚ => le_trans haâ‚ ha) h)
#align filter.tendsto_at_top_mono' Filter.tendsto_atTop_mono'

/- warning: filter.tendsto_at_bot_mono' -> Filter.tendsto_atBot_mono' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] (l : Filter.{u1} Î±) {{fâ‚ : Î± -> Î²}} {{fâ‚‚ : Î± -> Î²}}, (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toHasLe.{u2} Î² _inst_1) l fâ‚ fâ‚‚) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚‚ l (Filter.atBot.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚ l (Filter.atBot.{u2} Î² _inst_1))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] (l : Filter.{u1} Î±) {{fâ‚ : Î± -> Î²}} {{fâ‚‚ : Î± -> Î²}}, (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toLE.{u2} Î² _inst_1) l fâ‚ fâ‚‚) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚‚ l (Filter.atBot.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² fâ‚ l (Filter.atBot.{u2} Î² _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_mono' Filter.tendsto_atBot_mono'â‚“'. -/
theorem tendsto_atBot_mono' [Preorder Î²] (l : Filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
    Tendsto fâ‚‚ l atBot â†’ Tendsto fâ‚ l atBot :=
  @tendsto_atTop_mono' _ Î²áµ’áµˆ _ _ _ _ h
#align filter.tendsto_at_bot_mono' Filter.tendsto_atBot_mono'

/- warning: filter.tendsto_at_top_mono -> Filter.tendsto_atTop_mono is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (n : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) (f n) (g n)) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² _inst_1))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (n : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) (f n) (g n)) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_mono Filter.tendsto_atTop_monoâ‚“'. -/
theorem tendsto_atTop_mono [Preorder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
    Tendsto f l atTop â†’ Tendsto g l atTop :=
  tendsto_atTop_mono' l <| eventually_of_forall h
#align filter.tendsto_at_top_mono Filter.tendsto_atTop_mono

/- warning: filter.tendsto_at_bot_mono -> Filter.tendsto_atBot_mono is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (n : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) (f n) (g n)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (n : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) (f n) (g n)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² _inst_1)) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_mono Filter.tendsto_atBot_monoâ‚“'. -/
theorem tendsto_atBot_mono [Preorder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
    Tendsto g l atBot â†’ Tendsto f l atBot :=
  @tendsto_atTop_mono _ Î²áµ’áµˆ _ _ _ _ h
#align filter.tendsto_at_bot_mono Filter.tendsto_atBot_mono

end Filter

namespace OrderIso

open Filter

variable [Preorder Î±] [Preorder Î²]

/- warning: order_iso.comap_at_top -> OrderIso.comap_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Eq.{succ u1} (Filter.{u1} Î±) (Filter.comap.{u1, u2} Î± Î² (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e) (Filter.atTop.{u2} Î² _inst_2)) (Filter.atTop.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Eq.{succ u2} (Filter.{u2} Î±) (Filter.comap.{u2, u1} Î± Î² (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e) (Filter.atTop.{u1} Î² _inst_2)) (Filter.atTop.{u2} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align order_iso.comap_at_top OrderIso.comap_atTopâ‚“'. -/
@[simp]
theorem comap_atTop (e : Î± â‰ƒo Î²) : comap e atTop = atTop := by
  simp [at_top, â† e.surjective.infi_comp]
#align order_iso.comap_at_top OrderIso.comap_atTop

/- warning: order_iso.comap_at_bot -> OrderIso.comap_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Eq.{succ u1} (Filter.{u1} Î±) (Filter.comap.{u1, u2} Î± Î² (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e) (Filter.atBot.{u2} Î² _inst_2)) (Filter.atBot.{u1} Î± _inst_1)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Eq.{succ u2} (Filter.{u2} Î±) (Filter.comap.{u2, u1} Î± Î² (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e) (Filter.atBot.{u1} Î² _inst_2)) (Filter.atBot.{u2} Î± _inst_1)
Case conversion may be inaccurate. Consider using '#align order_iso.comap_at_bot OrderIso.comap_atBotâ‚“'. -/
@[simp]
theorem comap_atBot (e : Î± â‰ƒo Î²) : comap e atBot = atBot :=
  e.dual.comap_atTop
#align order_iso.comap_at_bot OrderIso.comap_atBot

/- warning: order_iso.map_at_top -> OrderIso.map_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Eq.{succ u2} (Filter.{u2} Î²) (Filter.map.{u1, u2} Î± Î² (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e) (Filter.atTop.{u1} Î± _inst_1)) (Filter.atTop.{u2} Î² _inst_2)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u2, u1} Î± Î² (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e) (Filter.atTop.{u2} Î± _inst_1)) (Filter.atTop.{u1} Î² _inst_2)
Case conversion may be inaccurate. Consider using '#align order_iso.map_at_top OrderIso.map_atTopâ‚“'. -/
@[simp]
theorem map_atTop (e : Î± â‰ƒo Î²) : map (e : Î± â†’ Î²) atTop = atTop := by
  rw [â† e.comap_at_top, map_comap_of_surjective e.surjective]
#align order_iso.map_at_top OrderIso.map_atTop

/- warning: order_iso.map_at_bot -> OrderIso.map_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Eq.{succ u2} (Filter.{u2} Î²) (Filter.map.{u1, u2} Î± Î² (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e) (Filter.atBot.{u1} Î± _inst_1)) (Filter.atBot.{u2} Î² _inst_2)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u2, u1} Î± Î² (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e) (Filter.atBot.{u2} Î± _inst_1)) (Filter.atBot.{u1} Î² _inst_2)
Case conversion may be inaccurate. Consider using '#align order_iso.map_at_bot OrderIso.map_atBotâ‚“'. -/
@[simp]
theorem map_atBot (e : Î± â‰ƒo Î²) : map (e : Î± â†’ Î²) atBot = atBot :=
  e.dual.map_atTop
#align order_iso.map_at_bot OrderIso.map_atBot

/- warning: order_iso.tendsto_at_top -> OrderIso.tendsto_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Filter.Tendsto.{u1, u2} Î± Î² (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e) (Filter.atTop.{u1} Î± _inst_1) (Filter.atTop.{u2} Î² _inst_2)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Filter.Tendsto.{u2, u1} Î± Î² (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e) (Filter.atTop.{u2} Î± _inst_1) (Filter.atTop.{u1} Î² _inst_2)
Case conversion may be inaccurate. Consider using '#align order_iso.tendsto_at_top OrderIso.tendsto_atTopâ‚“'. -/
theorem tendsto_atTop (e : Î± â‰ƒo Î²) : Tendsto e atTop atTop :=
  e.map_atTop.le
#align order_iso.tendsto_at_top OrderIso.tendsto_atTop

/- warning: order_iso.tendsto_at_bot -> OrderIso.tendsto_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Filter.Tendsto.{u1, u2} Î± Î² (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e) (Filter.atBot.{u1} Î± _inst_1) (Filter.atBot.{u2} Î² _inst_2)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Filter.Tendsto.{u2, u1} Î± Î² (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e) (Filter.atBot.{u2} Î± _inst_1) (Filter.atBot.{u1} Î² _inst_2)
Case conversion may be inaccurate. Consider using '#align order_iso.tendsto_at_bot OrderIso.tendsto_atBotâ‚“'. -/
theorem tendsto_atBot (e : Î± â‰ƒo Î²) : Tendsto e atBot atBot :=
  e.map_atBot.le
#align order_iso.tendsto_at_bot OrderIso.tendsto_atBot

/- warning: order_iso.tendsto_at_top_iff -> OrderIso.tendsto_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {l : Filter.{u3} Î³} {f : Î³ -> Î±} (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Iff (Filter.Tendsto.{u3, u2} Î³ Î² (fun (x : Î³) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e (f x)) l (Filter.atTop.{u2} Î² _inst_2)) (Filter.Tendsto.{u3, u1} Î³ Î± f l (Filter.atTop.{u1} Î± _inst_1))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {Î³ : Type.{u3}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {l : Filter.{u3} Î³} {f : Î³ -> Î±} (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Iff (Filter.Tendsto.{u3, u1} Î³ Î² (fun (x : Î³) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e (f x)) l (Filter.atTop.{u1} Î² _inst_2)) (Filter.Tendsto.{u3, u2} Î³ Î± f l (Filter.atTop.{u2} Î± _inst_1))
Case conversion may be inaccurate. Consider using '#align order_iso.tendsto_at_top_iff OrderIso.tendsto_atTop_iffâ‚“'. -/
@[simp]
theorem tendsto_atTop_iff {l : Filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
    Tendsto (fun x => e (f x)) l atTop â†” Tendsto f l atTop := by
  rw [â† e.comap_at_top, tendsto_comap_iff]
#align order_iso.tendsto_at_top_iff OrderIso.tendsto_atTop_iff

/- warning: order_iso.tendsto_at_bot_iff -> OrderIso.tendsto_atBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {l : Filter.{u3} Î³} {f : Î³ -> Î±} (e : OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)), Iff (Filter.Tendsto.{u3, u2} Î³ Î² (fun (x : Î³) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} Î± Î² (Preorder.toHasLe.{u1} Î± _inst_1) (Preorder.toHasLe.{u2} Î² _inst_2)) (fun (_x : RelIso.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) => Î± -> Î²) (RelIso.hasCoeToFun.{u1, u2} Î± Î² (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± _inst_1)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2))) e (f x)) l (Filter.atBot.{u2} Î² _inst_2)) (Filter.Tendsto.{u3, u1} Î³ Î± f l (Filter.atBot.{u1} Î± _inst_1))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {Î³ : Type.{u3}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {l : Filter.{u3} Î³} {f : Î³ -> Î±} (e : OrderIso.{u2, u1} Î± Î² (Preorder.toLE.{u2} Î± _inst_1) (Preorder.toLE.{u1} Î² _inst_2)), Iff (Filter.Tendsto.{u3, u1} Î³ Î² (fun (x : Î³) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± (fun (_x : Î±) => Î²) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (RelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302)) Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302) (RelIso.instRelHomClassRelIso.{u2, u1} Î± Î² (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1285 : Î±) (x._@.Mathlib.Order.Hom.Basic._hyg.1287 : Î±) => LE.le.{u2} Î± (Preorder.toLE.{u2} Î± _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1285 x._@.Mathlib.Order.Hom.Basic._hyg.1287) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1300 : Î²) (x._@.Mathlib.Order.Hom.Basic._hyg.1302 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1300 x._@.Mathlib.Order.Hom.Basic._hyg.1302))) e (f x)) l (Filter.atBot.{u1} Î² _inst_2)) (Filter.Tendsto.{u3, u2} Î³ Î± f l (Filter.atBot.{u2} Î± _inst_1))
Case conversion may be inaccurate. Consider using '#align order_iso.tendsto_at_bot_iff OrderIso.tendsto_atBot_iffâ‚“'. -/
@[simp]
theorem tendsto_atBot_iff {l : Filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
    Tendsto (fun x => e (f x)) l atBot â†” Tendsto f l atBot :=
  e.dual.tendsto_atTop_iff
#align order_iso.tendsto_at_bot_iff OrderIso.tendsto_atBot_iff

end OrderIso

namespace Filter

/-!
### Sequences
-/


/- warning: filter.inf_map_at_top_ne_bot_iff -> Filter.inf_map_atTop_neBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {F : Filter.{u2} Î²} {u : Î± -> Î²}, Iff (Filter.NeBot.{u2} Î² (Inf.inf.{u2} (Filter.{u2} Î²) (Filter.hasInf.{u2} Î²) F (Filter.map.{u1, u2} Î± Î² u (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))))) (forall (U : Set.{u2} Î²), (Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) U F) -> (forall (N : Î±), Exists.{succ u1} Î± (fun (n : Î±) => Exists.{0} (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) n N) (fun (H : GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) n N) => Membership.Mem.{u2, u2} Î² (Set.{u2} Î²) (Set.hasMem.{u2} Î²) (u n) U))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : Nonempty.{succ u2} Î±] {F : Filter.{u1} Î²} {u : Î± -> Î²}, Iff (Filter.NeBot.{u1} Î² (Inf.inf.{u1} (Filter.{u1} Î²) (Filter.instInfFilter.{u1} Î²) F (Filter.map.{u2, u1} Î± Î² u (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)))))) (forall (U : Set.{u1} Î²), (Membership.mem.{u1, u1} (Set.{u1} Î²) (Filter.{u1} Î²) (instMembershipSetFilter.{u1} Î²) U F) -> (forall (N : Î±), Exists.{succ u2} Î± (fun (n : Î±) => And (GE.ge.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) n N) (Membership.mem.{u1, u1} Î² (Set.{u1} Î²) (Set.instMembershipSet.{u1} Î²) (u n) U))))
Case conversion may be inaccurate. Consider using '#align filter.inf_map_at_top_ne_bot_iff Filter.inf_map_atTop_neBot_iffâ‚“'. -/
theorem inf_map_atTop_neBot_iff [SemilatticeSup Î±] [Nonempty Î±] {F : Filter Î²} {u : Î± â†’ Î²} :
    NeBot (F âŠ“ map u atTop) â†” âˆ€ U âˆˆ F, âˆ€ N, âˆƒ n â‰¥ N, u n âˆˆ U := by
  simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top] <;> rfl
#align filter.inf_map_at_top_ne_bot_iff Filter.inf_map_atTop_neBot_iff

/- warning: filter.inf_map_at_bot_ne_bot_iff -> Filter.inf_map_atBot_neBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {F : Filter.{u2} Î²} {u : Î± -> Î²}, Iff (Filter.NeBot.{u2} Î² (Inf.inf.{u2} (Filter.{u2} Î²) (Filter.hasInf.{u2} Î²) F (Filter.map.{u1, u2} Î± Î² u (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))))) (forall (U : Set.{u2} Î²), (Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) U F) -> (forall (N : Î±), Exists.{succ u1} Î± (fun (n : Î±) => Exists.{0} (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) n N) (fun (H : LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) n N) => Membership.Mem.{u2, u2} Î² (Set.{u2} Î²) (Set.hasMem.{u2} Î²) (u n) U))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] [_inst_2 : Nonempty.{succ u2} Î±] {F : Filter.{u1} Î²} {u : Î± -> Î²}, Iff (Filter.NeBot.{u1} Î² (Inf.inf.{u1} (Filter.{u1} Î²) (Filter.instInfFilter.{u1} Î²) F (Filter.map.{u2, u1} Î± Î² u (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)))))) (forall (U : Set.{u1} Î²), (Membership.mem.{u1, u1} (Set.{u1} Î²) (Filter.{u1} Î²) (instMembershipSetFilter.{u1} Î²) U F) -> (forall (N : Î±), Exists.{succ u2} Î± (fun (n : Î±) => And (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))) n N) (Membership.mem.{u1, u1} Î² (Set.{u1} Î²) (Set.instMembershipSet.{u1} Î²) (u n) U))))
Case conversion may be inaccurate. Consider using '#align filter.inf_map_at_bot_ne_bot_iff Filter.inf_map_atBot_neBot_iffâ‚“'. -/
theorem inf_map_atBot_neBot_iff [SemilatticeInf Î±] [Nonempty Î±] {F : Filter Î²} {u : Î± â†’ Î²} :
    NeBot (F âŠ“ map u atBot) â†” âˆ€ U âˆˆ F, âˆ€ N, âˆƒ n â‰¤ N, u n âˆˆ U :=
  @inf_map_atTop_neBot_iff Î±áµ’áµˆ _ _ _ _ _
#align filter.inf_map_at_bot_ne_bot_iff Filter.inf_map_atBot_neBot_iff

/- warning: filter.extraction_of_frequently_at_top' -> Filter.extraction_of_frequently_atTop' is a dubious translation:
lean 3 declaration is
  forall {P : Nat -> Prop}, (forall (N : Nat), Exists.{1} Nat (fun (n : Nat) => Exists.{0} (GT.gt.{0} Nat Nat.hasLt n N) (fun (H : GT.gt.{0} Nat Nat.hasLt n N) => P n))) -> (Exists.{1} (Nat -> Nat) (fun (Ï† : Nat -> Nat) => And (StrictMono.{0, 0} Nat Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) Ï†) (forall (n : Nat), P (Ï† n))))
but is expected to have type
  forall {P : Nat -> Prop}, (forall (N : Nat), Exists.{1} Nat (fun (n : Nat) => And (GT.gt.{0} Nat instLTNat n N) (P n))) -> (Exists.{1} (Nat -> Nat) (fun (Ï† : Nat -> Nat) => And (StrictMono.{0, 0} Nat Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) Ï†) (forall (n : Nat), P (Ï† n))))
Case conversion may be inaccurate. Consider using '#align filter.extraction_of_frequently_at_top' Filter.extraction_of_frequently_atTop'â‚“'. -/
theorem extraction_of_frequently_atTop' {P : â„• â†’ Prop} (h : âˆ€ N, âˆƒ n > N, P n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
  by
  choose u hu using h
  cases' forall_and_distrib.mp hu with hu hu'
  exact âŸ¨u âˆ˜ Nat.rec 0 fun n v => u v, strictMono_nat_of_lt_succ fun n => hu _, fun n => hu' _âŸ©
#align filter.extraction_of_frequently_at_top' Filter.extraction_of_frequently_atTop'

#print Filter.extraction_of_frequently_atTop /-
theorem extraction_of_frequently_atTop {P : â„• â†’ Prop} (h : âˆƒá¶  n in atTop, P n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
  by
  rw [frequently_at_top'] at h
  exact extraction_of_frequently_at_top' h
#align filter.extraction_of_frequently_at_top Filter.extraction_of_frequently_atTop
-/

#print Filter.extraction_of_eventually_atTop /-
theorem extraction_of_eventually_atTop {P : â„• â†’ Prop} (h : âˆ€á¶  n in atTop, P n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
  extraction_of_frequently_atTop h.Frequently
#align filter.extraction_of_eventually_at_top Filter.extraction_of_eventually_atTop
-/

#print Filter.extraction_forall_of_frequently /-
theorem extraction_forall_of_frequently {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒá¶  k in atTop, P n k) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  by
  simp only [frequently_at_top'] at h
  choose u hu hu' using h
  use (fun n => Nat.recOn n (u 0 0) fun n v => u (n + 1) v : â„• â†’ â„•)
  constructor
  Â· apply strictMono_nat_of_lt_succ
    intro n
    apply hu
  Â· intro n
    cases n <;> simp [hu']
#align filter.extraction_forall_of_frequently Filter.extraction_forall_of_frequently
-/

#print Filter.extraction_forall_of_eventually /-
theorem extraction_forall_of_eventually {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆ€á¶  k in atTop, P n k) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  extraction_forall_of_frequently fun n => (h n).Frequently
#align filter.extraction_forall_of_eventually Filter.extraction_forall_of_eventually
-/

#print Filter.extraction_forall_of_eventually' /-
theorem extraction_forall_of_eventually' {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒ N, âˆ€ k â‰¥ N, P n k) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  extraction_forall_of_eventually (by simp [eventually_at_top, h])
#align filter.extraction_forall_of_eventually' Filter.extraction_forall_of_eventually'
-/

/- warning: filter.exists_le_of_tendsto_at_top -> Filter.exists_le_of_tendsto_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {u : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² u (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u2} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u1} Î± (fun (a' : Î±) => Exists.{0} (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) (fun (H : GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2) b (u a'))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {u : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² u (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) (Filter.atTop.{u1} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u2} Î± (fun (a' : Î±) => And (GE.ge.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) a' a) (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) b (u a'))))
Case conversion may be inaccurate. Consider using '#align filter.exists_le_of_tendsto_at_top Filter.exists_le_of_tendsto_atTopâ‚“'. -/
theorem exists_le_of_tendsto_atTop [SemilatticeSup Î±] [Preorder Î²] {u : Î± â†’ Î²}
    (h : Tendsto u atTop atTop) (a : Î±) (b : Î²) : âˆƒ a' â‰¥ a, b â‰¤ u a' :=
  by
  have : âˆ€á¶  x in at_top, a â‰¤ x âˆ§ b â‰¤ u x :=
    (eventually_ge_at_top a).And (h.eventually <| eventually_ge_at_top b)
  haveI : Nonempty Î± := âŸ¨aâŸ©
  rcases this.exists with âŸ¨a', ha, hbâŸ©
  exact âŸ¨a', ha, hbâŸ©
#align filter.exists_le_of_tendsto_at_top Filter.exists_le_of_tendsto_atTop

/- warning: filter.exists_le_of_tendsto_at_bot -> Filter.exists_le_of_tendsto_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {u : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² u (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atBot.{u2} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u1} Î± (fun (a' : Î±) => Exists.{0} (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) (fun (H : GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2) (u a') b)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {u : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² u (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) (Filter.atBot.{u1} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u2} Î± (fun (a' : Î±) => And (GE.ge.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) a' a) (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) (u a') b)))
Case conversion may be inaccurate. Consider using '#align filter.exists_le_of_tendsto_at_bot Filter.exists_le_of_tendsto_atBotâ‚“'. -/
-- see Note [nolint_ge]
@[nolint ge_or_gt]
theorem exists_le_of_tendsto_atBot [SemilatticeSup Î±] [Preorder Î²] {u : Î± â†’ Î²}
    (h : Tendsto u atTop atBot) : âˆ€ a b, âˆƒ a' â‰¥ a, u a' â‰¤ b :=
  @exists_le_of_tendsto_atTop _ Î²áµ’áµˆ _ _ _ h
#align filter.exists_le_of_tendsto_at_bot Filter.exists_le_of_tendsto_atBot

/- warning: filter.exists_lt_of_tendsto_at_top -> Filter.exists_lt_of_tendsto_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] [_inst_3 : NoMaxOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_2)] {u : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² u (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u2} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u1} Î± (fun (a' : Î±) => Exists.{0} (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) (fun (H : GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) => LT.lt.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_2) b (u a'))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] [_inst_3 : NoMaxOrder.{u1} Î² (Preorder.toLT.{u1} Î² _inst_2)] {u : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² u (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) (Filter.atTop.{u1} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u2} Î± (fun (a' : Î±) => And (GE.ge.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) a' a) (LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² _inst_2) b (u a'))))
Case conversion may be inaccurate. Consider using '#align filter.exists_lt_of_tendsto_at_top Filter.exists_lt_of_tendsto_atTopâ‚“'. -/
theorem exists_lt_of_tendsto_atTop [SemilatticeSup Î±] [Preorder Î²] [NoMaxOrder Î²] {u : Î± â†’ Î²}
    (h : Tendsto u atTop atTop) (a : Î±) (b : Î²) : âˆƒ a' â‰¥ a, b < u a' :=
  by
  cases' exists_gt b with b' hb'
  rcases exists_le_of_tendsto_at_top h a b' with âŸ¨a', ha', ha''âŸ©
  exact âŸ¨a', ha', lt_of_lt_of_le hb' ha''âŸ©
#align filter.exists_lt_of_tendsto_at_top Filter.exists_lt_of_tendsto_atTop

/- warning: filter.exists_lt_of_tendsto_at_bot -> Filter.exists_lt_of_tendsto_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] [_inst_3 : NoMinOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_2)] {u : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² u (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atBot.{u2} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u1} Î± (fun (a' : Î±) => Exists.{0} (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) (fun (H : GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a' a) => LT.lt.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_2) (u a') b)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] [_inst_3 : NoMinOrder.{u1} Î² (Preorder.toLT.{u1} Î² _inst_2)] {u : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² u (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) (Filter.atBot.{u1} Î² _inst_2)) -> (forall (a : Î±) (b : Î²), Exists.{succ u2} Î± (fun (a' : Î±) => And (GE.ge.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) a' a) (LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² _inst_2) (u a') b)))
Case conversion may be inaccurate. Consider using '#align filter.exists_lt_of_tendsto_at_bot Filter.exists_lt_of_tendsto_atBotâ‚“'. -/
-- see Note [nolint_ge]
@[nolint ge_or_gt]
theorem exists_lt_of_tendsto_atBot [SemilatticeSup Î±] [Preorder Î²] [NoMinOrder Î²] {u : Î± â†’ Î²}
    (h : Tendsto u atTop atBot) : âˆ€ a b, âˆƒ a' â‰¥ a, u a' < b :=
  @exists_lt_of_tendsto_atTop _ Î²áµ’áµˆ _ _ _ _ h
#align filter.exists_lt_of_tendsto_at_bot Filter.exists_lt_of_tendsto_atBot

/- warning: filter.high_scores -> Filter.high_scores is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMaxOrder.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))) -> (forall (N : Nat), Exists.{1} Nat (fun (n : Nat) => Exists.{0} (GE.ge.{0} Nat Nat.hasLe n N) (fun (H : GE.ge.{0} Nat Nat.hasLe n N) => forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LT.lt.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1))))) (u k) (u n)))))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMaxOrder.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))) -> (forall (N : Nat), Exists.{1} Nat (fun (n : Nat) => And (GE.ge.{0} Nat instLENat n N) (forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1)))))) (u k) (u n)))))
Case conversion may be inaccurate. Consider using '#align filter.high_scores Filter.high_scoresâ‚“'. -/
/-- If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
theorem high_scores [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²} (hu : Tendsto u atTop atTop) :
    âˆ€ N, âˆƒ n â‰¥ N, âˆ€ k < n, u k < u n := by
  intro N
  obtain âŸ¨k : â„•, hkn : k â‰¤ N, hku : âˆ€ l â‰¤ N, u l â‰¤ u kâŸ© : âˆƒ k â‰¤ N, âˆ€ l â‰¤ N, u l â‰¤ u k
  exact exists_max_image _ u (finite_le_nat N) âŸ¨N, le_refl NâŸ©
  have ex : âˆƒ n â‰¥ N, u k < u n := exists_lt_of_tendsto_at_top hu _ _
  obtain âŸ¨n : â„•, hnN : n â‰¥ N, hnk : u k < u n, hn_min : âˆ€ m, m < n â†’ N â‰¤ m â†’ u m â‰¤ u kâŸ© :
    âˆƒ n â‰¥ N, u k < u n âˆ§ âˆ€ m, m < n â†’ N â‰¤ m â†’ u m â‰¤ u k :=
    by
    rcases Nat.findX ex with âŸ¨n, âŸ¨hnN, hnkâŸ©, hn_minâŸ©
    push_neg  at hn_min
    exact âŸ¨n, hnN, hnk, hn_minâŸ©
  use n, hnN
  rintro (l : â„•) (hl : l < n)
  have hlk : u l â‰¤ u k := by
    cases' (le_total l N : l â‰¤ N âˆ¨ N â‰¤ l) with H H
    Â· exact hku l H
    Â· exact hn_min l hl H
  calc
    u l â‰¤ u k := hlk
    _ < u n := hnk
    
#align filter.high_scores Filter.high_scores

/- warning: filter.low_scores -> Filter.low_scores is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMinOrder.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))) -> (forall (N : Nat), Exists.{1} Nat (fun (n : Nat) => Exists.{0} (GE.ge.{0} Nat Nat.hasLe n N) (fun (H : GE.ge.{0} Nat Nat.hasLe n N) => forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LT.lt.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1))))) (u n) (u k)))))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMinOrder.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))) -> (forall (N : Nat), Exists.{1} Nat (fun (n : Nat) => And (GE.ge.{0} Nat instLENat n N) (forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1)))))) (u n) (u k)))))
Case conversion may be inaccurate. Consider using '#align filter.low_scores Filter.low_scoresâ‚“'. -/
-- see Note [nolint_ge]
/-- If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
@[nolint ge_or_gt]
theorem low_scores [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²} (hu : Tendsto u atTop atBot) :
    âˆ€ N, âˆƒ n â‰¥ N, âˆ€ k < n, u n < u k :=
  @high_scores Î²áµ’áµˆ _ _ _ hu
#align filter.low_scores Filter.low_scores

/- warning: filter.frequently_high_scores -> Filter.frequently_high_scores is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMaxOrder.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))) -> (Filter.Frequently.{0} Nat (fun (n : Nat) => forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LT.lt.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1))))) (u k) (u n))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMaxOrder.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))) -> (Filter.Frequently.{0} Nat (fun (n : Nat) => forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1)))))) (u k) (u n))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))))
Case conversion may be inaccurate. Consider using '#align filter.frequently_high_scores Filter.frequently_high_scoresâ‚“'. -/
/-- If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
theorem frequently_high_scores [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²}
    (hu : Tendsto u atTop atTop) : âˆƒá¶  n in atTop, âˆ€ k < n, u k < u n := by
  simpa [frequently_at_top] using high_scores hu
#align filter.frequently_high_scores Filter.frequently_high_scores

/- warning: filter.frequently_low_scores -> Filter.frequently_low_scores is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMinOrder.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))) -> (Filter.Frequently.{0} Nat (fun (n : Nat) => forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LT.lt.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1))))) (u n) (u k))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMinOrder.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))) -> (Filter.Frequently.{0} Nat (fun (n : Nat) => forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1)))))) (u n) (u k))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))))
Case conversion may be inaccurate. Consider using '#align filter.frequently_low_scores Filter.frequently_low_scoresâ‚“'. -/
/-- If `u` is a sequence which is unbounded below,
then it `frequently` reaches a value strictly smaller than all previous values.
-/
theorem frequently_low_scores [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²}
    (hu : Tendsto u atTop atBot) : âˆƒá¶  n in atTop, âˆ€ k < n, u n < u k :=
  @frequently_high_scores Î²áµ’áµˆ _ _ _ hu
#align filter.frequently_low_scores Filter.frequently_low_scores

/- warning: filter.strict_mono_subseq_of_tendsto_at_top -> Filter.strictMono_subseq_of_tendsto_atTop is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMaxOrder.{u1} Î² (Preorder.toHasLt.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))))) -> (Exists.{1} (Nat -> Nat) (fun (Ï† : Nat -> Nat) => And (StrictMono.{0, 0} Nat Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) Ï†) (StrictMono.{0, u1} Nat Î² (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (LinearOrder.toLattice.{u1} Î² _inst_1)))) (Function.comp.{1, 1, succ u1} Nat Nat Î² u Ï†))))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : LinearOrder.{u1} Î²] [_inst_2 : NoMaxOrder.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))] {u : Nat -> Î²}, (Filter.Tendsto.{0, u1} Nat Î² u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))))) -> (Exists.{1} (Nat -> Nat) (fun (Ï† : Nat -> Nat) => And (StrictMono.{0, 0} Nat Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) Ï†) (StrictMono.{0, u1} Nat Î² (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² (Lattice.toSemilatticeInf.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² _inst_1))))) (Function.comp.{1, 1, succ u1} Nat Nat Î² u Ï†))))
Case conversion may be inaccurate. Consider using '#align filter.strict_mono_subseq_of_tendsto_at_top Filter.strictMono_subseq_of_tendsto_atTopâ‚“'. -/
theorem strictMono_subseq_of_tendsto_atTop {Î² : Type _} [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²}
    (hu : Tendsto u atTop atTop) : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ StrictMono (u âˆ˜ Ï†) :=
  let âŸ¨Ï†, h, h'âŸ© := extraction_of_frequently_atTop (frequently_high_scores hu)
  âŸ¨Ï†, h, fun n m hnm => h' m _ (h hnm)âŸ©
#align filter.strict_mono_subseq_of_tendsto_at_top Filter.strictMono_subseq_of_tendsto_atTop

#print Filter.strictMono_subseq_of_id_le /-
theorem strictMono_subseq_of_id_le {u : â„• â†’ â„•} (hu : âˆ€ n, n â‰¤ u n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ StrictMono (u âˆ˜ Ï†) :=
  strictMono_subseq_of_tendsto_atTop (tendsto_atTop_mono hu tendsto_id)
#align filter.strict_mono_subseq_of_id_le Filter.strictMono_subseq_of_id_le
-/

#print StrictMono.tendsto_atTop /-
theorem StrictMono.tendsto_atTop {Ï† : â„• â†’ â„•} (h : StrictMono Ï†) : Tendsto Ï† atTop atTop :=
  tendsto_atTop_mono h.id_le tendsto_id
#align strict_mono.tendsto_at_top StrictMono.tendsto_atTop
-/

section OrderedAddCommMonoid

variable [OrderedAddCommMonoid Î²] {l : Filter Î±} {f g : Î± â†’ Î²}

/- warning: filter.tendsto_at_top_add_nonneg_left' -> Filter.tendsto_atTop_add_nonneg_left' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))))) (f x)) l) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x)) l) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_nonneg_left' Filter.tendsto_atTop_add_nonneg_left'â‚“'. -/
theorem tendsto_atTop_add_nonneg_left' (hf : âˆ€á¶  x in l, 0 â‰¤ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_mono' l (hf.mono fun x => le_add_of_nonneg_left) hg
#align filter.tendsto_at_top_add_nonneg_left' Filter.tendsto_atTop_add_nonneg_left'

/- warning: filter.tendsto_at_bot_add_nonpos_left' -> Filter.tendsto_atBot_add_nonpos_left' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (f x) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1)))))))) l) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (f x) (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1)))))) l) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_nonpos_left' Filter.tendsto_atBot_add_nonpos_left'â‚“'. -/
theorem tendsto_atBot_add_nonpos_left' (hf : âˆ€á¶  x in l, f x â‰¤ 0) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_left' _ Î²áµ’áµˆ _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_left' Filter.tendsto_atBot_add_nonpos_left'

/- warning: filter.tendsto_at_top_add_nonneg_left -> Filter.tendsto_atTop_add_nonneg_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))))) (f x)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (OfNat.ofNat.{u2} Î² 0 (Zero.toOfNat0.{u2} Î² (AddMonoid.toZero.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_nonneg_left Filter.tendsto_atTop_add_nonneg_leftâ‚“'. -/
theorem tendsto_atTop_add_nonneg_left (hf : âˆ€ x, 0 â‰¤ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_nonneg_left' (eventually_of_forall hf) hg
#align filter.tendsto_at_top_add_nonneg_left Filter.tendsto_atTop_add_nonneg_left

/- warning: filter.tendsto_at_bot_add_nonpos_left -> Filter.tendsto_atBot_add_nonpos_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (f x) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1)))))))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (f x) (OfNat.ofNat.{u2} Î² 0 (Zero.toOfNat0.{u2} Î² (AddMonoid.toZero.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1)))))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_nonpos_left Filter.tendsto_atBot_add_nonpos_leftâ‚“'. -/
theorem tendsto_atBot_add_nonpos_left (hf : âˆ€ x, f x â‰¤ 0) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_left _ Î²áµ’áµˆ _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_left Filter.tendsto_atBot_add_nonpos_left

/- warning: filter.tendsto_at_top_add_nonneg_right' -> Filter.tendsto_atTop_add_nonneg_right' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))))) (g x)) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (g x)) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_nonneg_right' Filter.tendsto_atTop_add_nonneg_right'â‚“'. -/
theorem tendsto_atTop_add_nonneg_right' (hf : Tendsto f l atTop) (hg : âˆ€á¶  x in l, 0 â‰¤ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_mono' l (monotone_mem (fun x => le_add_of_nonneg_right) hg) hf
#align filter.tendsto_at_top_add_nonneg_right' Filter.tendsto_atTop_add_nonneg_right'

/- warning: filter.tendsto_at_bot_add_nonpos_right' -> Filter.tendsto_atBot_add_nonpos_right' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (g x) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1)))))))) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (g x) (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1)))))) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_nonpos_right' Filter.tendsto_atBot_add_nonpos_right'â‚“'. -/
theorem tendsto_atBot_add_nonpos_right' (hf : Tendsto f l atBot) (hg : âˆ€á¶  x in l, g x â‰¤ 0) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_right' _ Î²áµ’áµˆ _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_right' Filter.tendsto_atBot_add_nonpos_right'

/- warning: filter.tendsto_at_top_add_nonneg_right -> Filter.tendsto_atTop_add_nonneg_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))))) (g x)) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (g x)) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_nonneg_right Filter.tendsto_atTop_add_nonneg_rightâ‚“'. -/
theorem tendsto_atTop_add_nonneg_right (hf : Tendsto f l atTop) (hg : âˆ€ x, 0 â‰¤ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_nonneg_right' hf (eventually_of_forall hg)
#align filter.tendsto_at_top_add_nonneg_right Filter.tendsto_atTop_add_nonneg_right

/- warning: filter.tendsto_at_bot_add_nonpos_right -> Filter.tendsto_atBot_add_nonpos_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (g x) (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1)))))))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (g x) (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1)))))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_nonpos_right Filter.tendsto_atBot_add_nonpos_rightâ‚“'. -/
theorem tendsto_atBot_add_nonpos_right (hf : Tendsto f l atBot) (hg : âˆ€ x, g x â‰¤ 0) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_right _ Î²áµ’áµˆ _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_right Filter.tendsto_atBot_add_nonpos_right

/- warning: filter.tendsto_at_top_add -> Filter.tendsto_atTop_add is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add Filter.tendsto_atTop_addâ‚“'. -/
theorem tendsto_atTop_add (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_nonneg_left' (tendsto_atTop.mp hf 0) hg
#align filter.tendsto_at_top_add Filter.tendsto_atTop_add

/- warning: filter.tendsto_at_bot_add -> Filter.tendsto_atBot_add is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add Filter.tendsto_atBot_addâ‚“'. -/
theorem tendsto_atBot_add (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add _ Î²áµ’áµˆ _ _ _ _ hf hg
#align filter.tendsto_at_bot_add Filter.tendsto_atBot_add

/- warning: filter.tendsto.nsmul_at_top -> Filter.Tendsto.nsmul_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (forall {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => SMul.smul.{0, u2} Nat Î² (AddMonoid.SMul.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))) n (f x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (forall {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HSMul.hSMul.{0, u1, u1} Nat Î² Î² (instHSMul.{0, u1} Nat Î² (AddMonoid.SMul.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1)))) n (f x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.nsmul_at_top Filter.Tendsto.nsmul_atTopâ‚“'. -/
theorem Tendsto.nsmul_atTop (hf : Tendsto f l atTop) {n : â„•} (hn : 0 < n) :
    Tendsto (fun x => n â€¢ f x) l atTop :=
  tendsto_atTop.2 fun y =>
    (tendsto_atTop.1 hf y).mp <|
      (tendsto_atTop.1 hf 0).mono fun x hâ‚€ hy =>
        calc
          y â‰¤ f x := hy
          _ = 1 â€¢ f x := (one_nsmul _).symm
          _ â‰¤ n â€¢ f x := nsmul_le_nsmul hâ‚€ hn
          
#align filter.tendsto.nsmul_at_top Filter.Tendsto.nsmul_atTop

/- warning: filter.tendsto.nsmul_at_bot -> Filter.Tendsto.nsmul_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (forall {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => SMul.smul.{0, u2} Nat Î² (AddMonoid.SMul.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_1))) n (f x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (forall {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HSMul.hSMul.{0, u1, u1} Nat Î² Î² (instHSMul.{0, u1} Nat Î² (AddMonoid.SMul.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1)))) n (f x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.nsmul_at_bot Filter.Tendsto.nsmul_atBotâ‚“'. -/
theorem Tendsto.nsmul_atBot (hf : Tendsto f l atBot) {n : â„•} (hn : 0 < n) :
    Tendsto (fun x => n â€¢ f x) l atBot :=
  @Tendsto.nsmul_atTop Î± Î²áµ’áµˆ _ l f hf n hn
#align filter.tendsto.nsmul_at_bot Filter.Tendsto.nsmul_atBot

/- warning: filter.tendsto_bit0_at_top -> Filter.tendsto_bit0_atTop is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (bit0.{u1} Î² (AddZeroClass.toHasAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (bit0.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_bit0_at_top Filter.tendsto_bit0_atTopâ‚“'. -/
theorem tendsto_bit0_atTop : Tendsto bit0 (atTop : Filter Î²) atTop :=
  tendsto_atTop_add tendsto_id tendsto_id
#align filter.tendsto_bit0_at_top Filter.tendsto_bit0_atTop

/- warning: filter.tendsto_bit0_at_bot -> Filter.tendsto_bit0_atBot is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (bit0.{u1} Î² (AddZeroClass.toHasAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommMonoid.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (bit0.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_1))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_bit0_at_bot Filter.tendsto_bit0_atBotâ‚“'. -/
theorem tendsto_bit0_atBot : Tendsto bit0 (atBot : Filter Î²) atBot :=
  tendsto_atBot_add tendsto_id tendsto_id
#align filter.tendsto_bit0_at_bot Filter.tendsto_bit0_atBot

end OrderedAddCommMonoid

section OrderedCancelAddCommMonoid

variable [OrderedCancelAddCommMonoid Î²] {l : Filter Î±} {f g : Î± â†’ Î²}

/- warning: filter.tendsto_at_top_of_add_const_left -> Filter.tendsto_atTop_of_add_const_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) C (f x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) C (f x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_add_const_left Filter.tendsto_atTop_of_add_const_leftâ‚“'. -/
theorem tendsto_atTop_of_add_const_left (C : Î²) (hf : Tendsto (fun x => C + f x) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (C + b)).mono fun x => le_of_add_le_add_left
#align filter.tendsto_at_top_of_add_const_left Filter.tendsto_atTop_of_add_const_left

/- warning: filter.tendsto_at_bot_of_add_const_left -> Filter.tendsto_atBot_of_add_const_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) C (f x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) C (f x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_add_const_left Filter.tendsto_atBot_of_add_const_leftâ‚“'. -/
theorem tendsto_atBot_of_add_const_left (C : Î²) (hf : Tendsto (fun x => C + f x) l atBot) :
    Tendsto f l atBot :=
  @tendsto_atTop_of_add_const_left _ Î²áµ’áµˆ _ _ _ C hf
#align filter.tendsto_at_bot_of_add_const_left Filter.tendsto_atBot_of_add_const_left

/- warning: filter.tendsto_at_top_of_add_const_right -> Filter.tendsto_atTop_of_add_const_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) C) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) (f x) C) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_add_const_right Filter.tendsto_atTop_of_add_const_rightâ‚“'. -/
theorem tendsto_atTop_of_add_const_right (C : Î²) (hf : Tendsto (fun x => f x + C) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (b + C)).mono fun x => le_of_add_le_add_right
#align filter.tendsto_at_top_of_add_const_right Filter.tendsto_atTop_of_add_const_right

/- warning: filter.tendsto_at_bot_of_add_const_right -> Filter.tendsto_atBot_of_add_const_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) C) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) (f x) C) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_add_const_right Filter.tendsto_atBot_of_add_const_rightâ‚“'. -/
theorem tendsto_atBot_of_add_const_right (C : Î²) (hf : Tendsto (fun x => f x + C) l atBot) :
    Tendsto f l atBot :=
  @tendsto_atTop_of_add_const_right _ Î²áµ’áµˆ _ _ _ C hf
#align filter.tendsto_at_bot_of_add_const_right Filter.tendsto_atBot_of_add_const_right

/- warning: filter.tendsto_at_top_of_add_bdd_above_left' -> Filter.tendsto_atTop_of_add_bdd_above_left' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (f x) C) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (f x) C) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_add_bdd_above_left' Filter.tendsto_atTop_of_add_bdd_above_left'â‚“'. -/
theorem tendsto_atTop_of_add_bdd_above_left' (C) (hC : âˆ€á¶  x in l, f x â‰¤ C)
    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto g l atTop :=
  tendsto_atTop_of_add_const_left C
    (tendsto_atTop_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)
#align filter.tendsto_at_top_of_add_bdd_above_left' Filter.tendsto_atTop_of_add_bdd_above_left'

/- warning: filter.tendsto_at_bot_of_add_bdd_below_left' -> Filter.tendsto_atBot_of_add_bdd_below_left' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) C (f x)) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) C (f x)) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_add_bdd_below_left' Filter.tendsto_atBot_of_add_bdd_below_left'â‚“'. -/
theorem tendsto_atBot_of_add_bdd_below_left' (C) (hC : âˆ€á¶  x in l, C â‰¤ f x)
    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto g l atBot :=
  @tendsto_atTop_of_add_bdd_above_left' _ Î²áµ’áµˆ _ _ _ _ C hC h
#align filter.tendsto_at_bot_of_add_bdd_below_left' Filter.tendsto_atBot_of_add_bdd_below_left'

/- warning: filter.tendsto_at_top_of_add_bdd_above_left -> Filter.tendsto_atTop_of_add_bdd_above_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (f x) C) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (f x) C) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_add_bdd_above_left Filter.tendsto_atTop_of_add_bdd_above_leftâ‚“'. -/
theorem tendsto_atTop_of_add_bdd_above_left (C) (hC : âˆ€ x, f x â‰¤ C) :
    Tendsto (fun x => f x + g x) l atTop â†’ Tendsto g l atTop :=
  tendsto_atTop_of_add_bdd_above_left' C (univ_mem' hC)
#align filter.tendsto_at_top_of_add_bdd_above_left Filter.tendsto_atTop_of_add_bdd_above_left

/- warning: filter.tendsto_at_bot_of_add_bdd_below_left -> Filter.tendsto_atBot_of_add_bdd_below_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) C (f x)) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) C (f x)) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_add_bdd_below_left Filter.tendsto_atBot_of_add_bdd_below_leftâ‚“'. -/
theorem tendsto_atBot_of_add_bdd_below_left (C) (hC : âˆ€ x, C â‰¤ f x) :
    Tendsto (fun x => f x + g x) l atBot â†’ Tendsto g l atBot :=
  @tendsto_atTop_of_add_bdd_above_left _ Î²áµ’áµˆ _ _ _ _ C hC
#align filter.tendsto_at_bot_of_add_bdd_below_left Filter.tendsto_atBot_of_add_bdd_below_left

/- warning: filter.tendsto_at_top_of_add_bdd_above_right' -> Filter.tendsto_atTop_of_add_bdd_above_right' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (g x) C) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) (g x) C) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_add_bdd_above_right' Filter.tendsto_atTop_of_add_bdd_above_right'â‚“'. -/
theorem tendsto_atTop_of_add_bdd_above_right' (C) (hC : âˆ€á¶  x in l, g x â‰¤ C)
    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto f l atTop :=
  tendsto_atTop_of_add_const_right C
    (tendsto_atTop_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)
#align filter.tendsto_at_top_of_add_bdd_above_right' Filter.tendsto_atTop_of_add_bdd_above_right'

/- warning: filter.tendsto_at_bot_of_add_bdd_below_right' -> Filter.tendsto_atBot_of_add_bdd_below_right' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) C (g x)) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))) C (g x)) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (AddRightCancelMonoid.toAddMonoid.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_add_bdd_below_right' Filter.tendsto_atBot_of_add_bdd_below_right'â‚“'. -/
theorem tendsto_atBot_of_add_bdd_below_right' (C) (hC : âˆ€á¶  x in l, C â‰¤ g x)
    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto f l atBot :=
  @tendsto_atTop_of_add_bdd_above_right' _ Î²áµ’áµˆ _ _ _ _ C hC h
#align filter.tendsto_at_bot_of_add_bdd_below_right' Filter.tendsto_atBot_of_add_bdd_below_right'

/- warning: filter.tendsto_at_top_of_add_bdd_above_right -> Filter.tendsto_atTop_of_add_bdd_above_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (g x) C) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) (g x) C) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_add_bdd_above_right Filter.tendsto_atTop_of_add_bdd_above_rightâ‚“'. -/
theorem tendsto_atTop_of_add_bdd_above_right (C) (hC : âˆ€ x, g x â‰¤ C) :
    Tendsto (fun x => f x + g x) l atTop â†’ Tendsto f l atTop :=
  tendsto_atTop_of_add_bdd_above_right' C (univ_mem' hC)
#align filter.tendsto_at_top_of_add_bdd_above_right Filter.tendsto_atTop_of_add_bdd_above_right

/- warning: filter.tendsto_at_bot_of_add_bdd_below_right -> Filter.tendsto_atBot_of_add_bdd_below_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) C (g x)) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedCancelAddCommMonoid.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))) C (g x)) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddRightCancelMonoid.toAddMonoid.{u2} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u2} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_add_bdd_below_right Filter.tendsto_atBot_of_add_bdd_below_rightâ‚“'. -/
theorem tendsto_atBot_of_add_bdd_below_right (C) (hC : âˆ€ x, C â‰¤ g x) :
    Tendsto (fun x => f x + g x) l atBot â†’ Tendsto f l atBot :=
  @tendsto_atTop_of_add_bdd_above_right _ Î²áµ’áµˆ _ _ _ _ C hC
#align filter.tendsto_at_bot_of_add_bdd_below_right Filter.tendsto_atBot_of_add_bdd_below_right

end OrderedCancelAddCommMonoid

section OrderedGroup

variable [OrderedAddCommGroup Î²] (l : Filter Î±) {f g : Î± â†’ Î²}

/- warning: filter.tendsto_at_top_add_left_of_le' -> Filter.tendsto_atTop_add_left_of_le' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) C (f x)) l) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) C (f x)) l) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_left_of_le' Filter.tendsto_atTop_add_left_of_le'â‚“'. -/
theorem tendsto_atTop_add_left_of_le' (C : Î²) (hf : âˆ€á¶  x in l, C â‰¤ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  @tendsto_atTop_of_add_bdd_above_left' _ _ _ l (fun x => -f x) (fun x => f x + g x) (-C) (by simpa)
    (by simpa)
#align filter.tendsto_at_top_add_left_of_le' Filter.tendsto_atTop_add_left_of_le'

/- warning: filter.tendsto_at_bot_add_left_of_ge' -> Filter.tendsto_atBot_add_left_of_ge' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) (f x) C) l) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) (f x) C) l) -> (Filter.Tendsto.{u2, u1} Î± Î² g l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_left_of_ge' Filter.tendsto_atBot_add_left_of_ge'â‚“'. -/
theorem tendsto_atBot_add_left_of_ge' (C : Î²) (hf : âˆ€á¶  x in l, f x â‰¤ C) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_left_of_le' _ Î²áµ’áµˆ _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_left_of_ge' Filter.tendsto_atBot_add_left_of_ge'

/- warning: filter.tendsto_at_top_add_left_of_le -> Filter.tendsto_atTop_add_left_of_le is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) C (f x)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) C (f x)) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_left_of_le Filter.tendsto_atTop_add_left_of_leâ‚“'. -/
theorem tendsto_atTop_add_left_of_le (C : Î²) (hf : âˆ€ x, C â‰¤ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_left_of_le' l C (univ_mem' hf) hg
#align filter.tendsto_at_top_add_left_of_le Filter.tendsto_atTop_add_left_of_le

/- warning: filter.tendsto_at_bot_add_left_of_ge -> Filter.tendsto_atBot_add_left_of_ge is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) (f x) C) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) (f x) C) -> (Filter.Tendsto.{u1, u2} Î± Î² g l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_left_of_ge Filter.tendsto_atBot_add_left_of_geâ‚“'. -/
theorem tendsto_atBot_add_left_of_ge (C : Î²) (hf : âˆ€ x, f x â‰¤ C) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_left_of_le _ Î²áµ’áµˆ _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_left_of_ge Filter.tendsto_atBot_add_left_of_ge

/- warning: filter.tendsto_at_top_add_right_of_le' -> Filter.tendsto_atTop_add_right_of_le' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) C (g x)) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) C (g x)) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_right_of_le' Filter.tendsto_atTop_add_right_of_le'â‚“'. -/
theorem tendsto_atTop_add_right_of_le' (C : Î²) (hf : Tendsto f l atTop) (hg : âˆ€á¶  x in l, C â‰¤ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  @tendsto_atTop_of_add_bdd_above_right' _ _ _ l (fun x => f x + g x) (fun x => -g x) (-C)
    (by simp [hg]) (by simp [hf])
#align filter.tendsto_at_top_add_right_of_le' Filter.tendsto_atTop_add_right_of_le'

/- warning: filter.tendsto_at_bot_add_right_of_ge' -> Filter.tendsto_atBot_add_right_of_ge' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Eventually.{u1} Î± (fun (x : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) (g x) C) l) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Eventually.{u2} Î± (fun (x : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) (g x) C) l) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_right_of_ge' Filter.tendsto_atBot_add_right_of_ge'â‚“'. -/
theorem tendsto_atBot_add_right_of_ge' (C : Î²) (hf : Tendsto f l atBot) (hg : âˆ€á¶  x in l, g x â‰¤ C) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_right_of_le' _ Î²áµ’áµˆ _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_right_of_ge' Filter.tendsto_atBot_add_right_of_ge'

/- warning: filter.tendsto_at_top_add_right_of_le -> Filter.tendsto_atTop_add_right_of_le is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) C (g x)) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) C (g x)) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_right_of_le Filter.tendsto_atTop_add_right_of_leâ‚“'. -/
theorem tendsto_atTop_add_right_of_le (C : Î²) (hf : Tendsto f l atTop) (hg : âˆ€ x, C â‰¤ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_right_of_le' l C hf (univ_mem' hg)
#align filter.tendsto_at_top_add_right_of_le Filter.tendsto_atTop_add_right_of_le

/- warning: filter.tendsto_at_bot_add_right_of_ge -> Filter.tendsto_atBot_add_right_of_ge is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))) (g x) C) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} {g : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (forall (x : Î±), LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) (g x) C) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) (g x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_right_of_ge Filter.tendsto_atBot_add_right_of_geâ‚“'. -/
theorem tendsto_atBot_add_right_of_ge (C : Î²) (hf : Tendsto f l atBot) (hg : âˆ€ x, g x â‰¤ C) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_right_of_le _ Î²áµ’áµˆ _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_right_of_ge Filter.tendsto_atBot_add_right_of_ge

/- warning: filter.tendsto_at_top_add_const_left -> Filter.tendsto_atTop_add_const_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) C (f x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) C (f x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_const_left Filter.tendsto_atTop_add_const_leftâ‚“'. -/
theorem tendsto_atTop_add_const_left (C : Î²) (hf : Tendsto f l atTop) :
    Tendsto (fun x => C + f x) l atTop :=
  tendsto_atTop_add_left_of_le' l C (univ_mem' fun _ => le_refl C) hf
#align filter.tendsto_at_top_add_const_left Filter.tendsto_atTop_add_const_left

/- warning: filter.tendsto_at_bot_add_const_left -> Filter.tendsto_atBot_add_const_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) C (f x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) C (f x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_const_left Filter.tendsto_atBot_add_const_leftâ‚“'. -/
theorem tendsto_atBot_add_const_left (C : Î²) (hf : Tendsto f l atBot) :
    Tendsto (fun x => C + f x) l atBot :=
  @tendsto_atTop_add_const_left _ Î²áµ’áµˆ _ _ _ C hf
#align filter.tendsto_at_bot_add_const_left Filter.tendsto_atBot_add_const_left

/- warning: filter.tendsto_at_top_add_const_right -> Filter.tendsto_atTop_add_const_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) C) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) C) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_add_const_right Filter.tendsto_atTop_add_const_rightâ‚“'. -/
theorem tendsto_atTop_add_const_right (C : Î²) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x + C) l atTop :=
  tendsto_atTop_add_right_of_le' l C hf (univ_mem' fun _ => le_refl C)
#align filter.tendsto_at_top_add_const_right Filter.tendsto_atTop_add_const_right

/- warning: filter.tendsto_at_bot_add_const_right -> Filter.tendsto_atBot_add_const_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] (l : Filter.{u1} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) -> (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u2, u2, u2} Î² Î² Î² (instHAdd.{u2} Î² (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1))))))) (f x) C) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] (l : Filter.{u2} Î±) {f : Î± -> Î²} (C : Î²), (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => HAdd.hAdd.{u1, u1, u1} Î² Î² Î² (instHAdd.{u1} Î² (AddZeroClass.toAdd.{u1} Î² (AddMonoid.toAddZeroClass.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (f x) C) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_add_const_right Filter.tendsto_atBot_add_const_rightâ‚“'. -/
theorem tendsto_atBot_add_const_right (C : Î²) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x + C) l atBot :=
  @tendsto_atTop_add_const_right _ Î²áµ’áµˆ _ _ _ C hf
#align filter.tendsto_at_bot_add_const_right Filter.tendsto_atBot_add_const_right

/- warning: filter.map_neg_at_bot -> Filter.map_neg_atBot is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (SubNegMonoid.toHasNeg.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.map_neg_at_bot Filter.map_neg_atBotâ‚“'. -/
theorem map_neg_atBot : map (Neg.neg : Î² â†’ Î²) atBot = atTop :=
  (OrderIso.neg Î²).map_atBot
#align filter.map_neg_at_bot Filter.map_neg_atBot

/- warning: filter.map_neg_at_top -> Filter.map_neg_atTop is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (SubNegMonoid.toHasNeg.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.map_neg_at_top Filter.map_neg_atTopâ‚“'. -/
theorem map_neg_atTop : map (Neg.neg : Î² â†’ Î²) atTop = atBot :=
  (OrderIso.neg Î²).map_atTop
#align filter.map_neg_at_top Filter.map_neg_atTop

/- warning: filter.comap_neg_at_bot -> Filter.comap_neg_atBot is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.comap.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (SubNegMonoid.toHasNeg.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.comap.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.comap_neg_at_bot Filter.comap_neg_atBotâ‚“'. -/
@[simp]
theorem comap_neg_atBot : comap (Neg.neg : Î² â†’ Î²) atBot = atTop :=
  (OrderIso.neg Î²).comap_atTop
#align filter.comap_neg_at_bot Filter.comap_neg_atBot

/- warning: filter.comap_neg_at_top -> Filter.comap_neg_atTop is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.comap.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (SubNegMonoid.toHasNeg.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Eq.{succ u1} (Filter.{u1} Î²) (Filter.comap.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.comap_neg_at_top Filter.comap_neg_atTopâ‚“'. -/
@[simp]
theorem comap_neg_atTop : comap (Neg.neg : Î² â†’ Î²) atTop = atBot :=
  (OrderIso.neg Î²).comap_atBot
#align filter.comap_neg_at_top Filter.comap_neg_atTop

/- warning: filter.tendsto_neg_at_top_at_bot -> Filter.tendsto_neg_atTop_atBot is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (SubNegMonoid.toHasNeg.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_neg_at_top_at_bot Filter.tendsto_neg_atTop_atBotâ‚“'. -/
theorem tendsto_neg_atTop_atBot : Tendsto (Neg.neg : Î² â†’ Î²) atTop atBot :=
  (OrderIso.neg Î²).tendsto_atTop
#align filter.tendsto_neg_at_top_at_bot Filter.tendsto_neg_atTop_atBot

/- warning: filter.tendsto_neg_at_bot_at_top -> Filter.tendsto_neg_atBot_atTop is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (SubNegMonoid.toHasNeg.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (AddCommGroup.toAddGroup.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
but is expected to have type
  forall {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²], Filter.Tendsto.{u1, u1} Î² Î² (Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1))))))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_neg_at_bot_at_top Filter.tendsto_neg_atBot_atTopâ‚“'. -/
theorem tendsto_neg_atBot_atTop : Tendsto (Neg.neg : Î² â†’ Î²) atBot atTop :=
  @tendsto_neg_atTop_atBot Î²áµ’áµˆ _
#align filter.tendsto_neg_at_bot_at_top Filter.tendsto_neg_atBot_atTop

variable {l}

/- warning: filter.tendsto_neg_at_top_iff -> Filter.tendsto_neg_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => Neg.neg.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1)))) (f x)) l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1)))))) (f x)) l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_neg_at_top_iff Filter.tendsto_neg_atTop_iffâ‚“'. -/
@[simp]
theorem tendsto_neg_atTop_iff : Tendsto (fun x => -f x) l atTop â†” Tendsto f l atBot :=
  (OrderIso.neg Î²).tendsto_atBot_iff
#align filter.tendsto_neg_at_top_iff Filter.tendsto_neg_atTop_iff

/- warning: filter.tendsto_neg_at_bot_iff -> Filter.tendsto_neg_atBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedAddCommGroup.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² (fun (x : Î±) => Neg.neg.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddCommGroup.toAddGroup.{u2} Î² (OrderedAddCommGroup.toAddCommGroup.{u2} Î² _inst_1)))) (f x)) l (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1)))) (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedAddCommGroup.{u1} Î²] {l : Filter.{u2} Î±} {f : Î± -> Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² (fun (x : Î±) => Neg.neg.{u1} Î² (NegZeroClass.toNeg.{u1} Î² (SubNegZeroMonoid.toNegZeroClass.{u1} Î² (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î² (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î² (AddCommGroup.toDivisionAddCommMonoid.{u1} Î² (OrderedAddCommGroup.toAddCommGroup.{u1} Î² _inst_1)))))) (f x)) l (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1)))) (Filter.Tendsto.{u2, u1} Î± Î² f l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommGroup.toPartialOrder.{u1} Î² _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_neg_at_bot_iff Filter.tendsto_neg_atBot_iffâ‚“'. -/
@[simp]
theorem tendsto_neg_atBot_iff : Tendsto (fun x => -f x) l atBot â†” Tendsto f l atTop :=
  (OrderIso.neg Î²).tendsto_atTop_iff
#align filter.tendsto_neg_at_bot_iff Filter.tendsto_neg_atBot_iff

end OrderedGroup

section StrictOrderedSemiring

variable [StrictOrderedSemiring Î±] {l : Filter Î²} {f g : Î² â†’ Î±}

/- warning: filter.tendsto_bit1_at_top -> Filter.tendsto_bit1_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (bit1.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} Î± (NonAssocSemiring.toAddCommMonoidWithOne.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1))))) (Distrib.toHasAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1)))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (bit1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1)) (Distrib.toAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1)))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_bit1_at_top Filter.tendsto_bit1_atTopâ‚“'. -/
theorem tendsto_bit1_atTop : Tendsto bit1 (atTop : Filter Î±) atTop :=
  tendsto_atTop_add_nonneg_right tendsto_bit0_atTop fun _ => zero_le_one
#align filter.tendsto_bit1_at_top Filter.tendsto_bit1_atTop

/- warning: filter.tendsto.at_top_mul_at_top -> Filter.Tendsto.atTop_mul_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedSemiring.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1)))))) (f x) (g x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedSemiring.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocSemiring.toMul.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1))))) (f x) (g x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_mul_at_top Filter.Tendsto.atTop_mul_atTopâ‚“'. -/
theorem Tendsto.atTop_mul_atTop (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x * g x) l atTop :=
  by
  refine' tendsto_at_top_mono' _ _ hg
  filter_upwards [hg.eventually (eventually_ge_at_top 0),
    hf.eventually (eventually_ge_at_top 1)]with _ using le_mul_of_one_le_left
#align filter.tendsto.at_top_mul_at_top Filter.Tendsto.atTop_mul_atTop

/- warning: filter.tendsto_mul_self_at_top -> Filter.tendsto_mul_self_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1)))))) x x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocSemiring.toMul.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± _inst_1))))) x x) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_self_at_top Filter.tendsto_mul_self_atTopâ‚“'. -/
theorem tendsto_mul_self_atTop : Tendsto (fun x : Î± => x * x) atTop atTop :=
  tendsto_id.atTop_mul_atTop tendsto_id
#align filter.tendsto_mul_self_at_top Filter.tendsto_mul_self_atTop

#print Filter.tendsto_pow_atTop /-
/-- The monomial function `x^n` tends to `+âˆž` at `+âˆž` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_at_top`. -/
theorem tendsto_pow_atTop {n : â„•} (hn : n â‰  0) : Tendsto (fun x : Î± => x ^ n) atTop atTop :=
  tendsto_atTop_mono' _ ((eventually_ge_atTop 1).mono fun x hx => le_self_pow hx hn) tendsto_id
#align filter.tendsto_pow_at_top Filter.tendsto_pow_atTop
-/

end StrictOrderedSemiring

/- warning: filter.zero_pow_eventually_eq -> Filter.zero_pow_eventuallyEq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} Î±], Filter.EventuallyEq.{0, u1} Nat Î± (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (fun (n : Nat) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± _inst_1))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (MulZeroOneClass.toMulZeroClass.{u1} Î± (MonoidWithZero.toMulZeroOneClass.{u1} Î± _inst_1)))))) n) (fun (n : Nat) => OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (MulZeroOneClass.toMulZeroClass.{u1} Î± (MonoidWithZero.toMulZeroOneClass.{u1} Î± _inst_1))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : MonoidWithZero.{u1} Î±], Filter.EventuallyEq.{0, u1} Nat Î± (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (fun (n : Nat) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± _inst_1))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± _inst_1))) n) (fun (n : Nat) => OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.zero_pow_eventually_eq Filter.zero_pow_eventuallyEqâ‚“'. -/
theorem zero_pow_eventuallyEq [MonoidWithZero Î±] :
    (fun n : â„• => (0 : Î±) ^ n) =á¶ [atTop] fun n => 0 :=
  eventually_atTop.2 âŸ¨1, fun n hn => zero_pow (zero_lt_one.trans_le hn)âŸ©
#align filter.zero_pow_eventually_eq Filter.zero_pow_eventuallyEq

section StrictOrderedRing

variable [StrictOrderedRing Î±] {l : Filter Î²} {f g : Î² â†’ Î±}

/- warning: filter.tendsto.at_top_mul_at_bot -> Filter.Tendsto.atTop_mul_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± _inst_1)))) (f x) (g x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± _inst_1))))) (f x) (g x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_mul_at_bot Filter.Tendsto.atTop_mul_atBotâ‚“'. -/
theorem Tendsto.atTop_mul_atBot (hf : Tendsto f l atTop) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x * g x) l atBot :=
  by
  have := hf.atTop_mul_atTop <| tendsto_neg_atBot_atTop.comp hg
  simpa only [(Â· âˆ˜ Â·), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp this
#align filter.tendsto.at_top_mul_at_bot Filter.Tendsto.atTop_mul_atBot

/- warning: filter.tendsto.at_bot_mul_at_top -> Filter.Tendsto.atBot_mul_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± _inst_1)))) (f x) (g x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± _inst_1))))) (f x) (g x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_bot_mul_at_top Filter.Tendsto.atBot_mul_atTopâ‚“'. -/
theorem Tendsto.atBot_mul_atTop (hf : Tendsto f l atBot) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x * g x) l atBot :=
  by
  have : Tendsto (fun x => -f x * g x) l atTop :=
    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop hg
  simpa only [(Â· âˆ˜ Â·), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_top_at_bot.comp this
#align filter.tendsto.at_bot_mul_at_top Filter.Tendsto.atBot_mul_atTop

/- warning: filter.tendsto.at_bot_mul_at_bot -> Filter.Tendsto.atBot_mul_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± _inst_1)))) (f x) (g x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {g : Î² -> Î±}, (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± g l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1)))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± _inst_1))))) (f x) (g x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_bot_mul_at_bot Filter.Tendsto.atBot_mul_atBotâ‚“'. -/
theorem Tendsto.atBot_mul_atBot (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x * g x) l atTop :=
  by
  have : Tendsto (fun x => -f x * -g x) l atTop :=
    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop (tendsto_neg_atBot_atTop.comp hg)
  simpa only [neg_mul_neg] using this
#align filter.tendsto.at_bot_mul_at_bot Filter.Tendsto.atBot_mul_atBot

end StrictOrderedRing

section LinearOrderedAddCommGroup

variable [LinearOrderedAddCommGroup Î±]

/- warning: filter.tendsto_abs_at_top_at_top -> Filter.tendsto_abs_atTop_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (Abs.abs.{u1} Î± (Neg.toHasAbs.{u1} Î± (SubNegMonoid.toHasNeg.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± (AddCommGroup.toAddGroup.{u1} Î± (OrderedAddCommGroup.toAddCommGroup.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))) (SemilatticeSup.toHasSup.{u1} Î± (Lattice.toSemilatticeSup.{u1} Î± (LinearOrder.toLattice.{u1} Î± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Î± _inst_1)))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (Abs.abs.{u1} Î± (Neg.toHasAbs.{u1} Î± (NegZeroClass.toNeg.{u1} Î± (SubNegZeroMonoid.toNegZeroClass.{u1} Î± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î± (AddCommGroup.toDivisionAddCommMonoid.{u1} Î± (OrderedAddCommGroup.toAddCommGroup.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))))) (SemilatticeSup.toSup.{u1} Î± (Lattice.toSemilatticeSup.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Î± _inst_1))))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_abs_at_top_at_top Filter.tendsto_abs_atTop_atTopâ‚“'. -/
/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
theorem tendsto_abs_atTop_atTop : Tendsto (abs : Î± â†’ Î±) atTop atTop :=
  tendsto_atTop_mono le_abs_self tendsto_id
#align filter.tendsto_abs_at_top_at_top Filter.tendsto_abs_atTop_atTop

/- warning: filter.tendsto_abs_at_bot_at_top -> Filter.tendsto_abs_atBot_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (Abs.abs.{u1} Î± (Neg.toHasAbs.{u1} Î± (SubNegMonoid.toHasNeg.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± (AddCommGroup.toAddGroup.{u1} Î± (OrderedAddCommGroup.toAddCommGroup.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))) (SemilatticeSup.toHasSup.{u1} Î± (Lattice.toSemilatticeSup.{u1} Î± (LinearOrder.toLattice.{u1} Î± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Î± _inst_1)))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} Î±], Filter.Tendsto.{u1, u1} Î± Î± (Abs.abs.{u1} Î± (Neg.toHasAbs.{u1} Î± (NegZeroClass.toNeg.{u1} Î± (SubNegZeroMonoid.toNegZeroClass.{u1} Î± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î± (AddCommGroup.toDivisionAddCommMonoid.{u1} Î± (OrderedAddCommGroup.toAddCommGroup.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))))) (SemilatticeSup.toSup.{u1} Î± (Lattice.toSemilatticeSup.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Î± _inst_1))))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_abs_at_bot_at_top Filter.tendsto_abs_atBot_atTopâ‚“'. -/
/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
theorem tendsto_abs_atBot_atTop : Tendsto (abs : Î± â†’ Î±) atBot atTop :=
  tendsto_atTop_mono neg_le_abs_self tendsto_neg_atBot_atTop
#align filter.tendsto_abs_at_bot_at_top Filter.tendsto_abs_atBot_atTop

/- warning: filter.comap_abs_at_top -> Filter.comap_abs_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} Î±], Eq.{succ u1} (Filter.{u1} Î±) (Filter.comap.{u1, u1} Î± Î± (Abs.abs.{u1} Î± (Neg.toHasAbs.{u1} Î± (SubNegMonoid.toHasNeg.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± (AddCommGroup.toAddGroup.{u1} Î± (OrderedAddCommGroup.toAddCommGroup.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))) (SemilatticeSup.toHasSup.{u1} Î± (Lattice.toSemilatticeSup.{u1} Î± (LinearOrder.toLattice.{u1} Î± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Î± _inst_1)))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))) (Sup.sup.{u1} (Filter.{u1} Î±) (SemilatticeSup.toHasSup.{u1} (Filter.{u1} Î±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Î±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} Î±], Eq.{succ u1} (Filter.{u1} Î±) (Filter.comap.{u1, u1} Î± Î± (Abs.abs.{u1} Î± (Neg.toHasAbs.{u1} Î± (NegZeroClass.toNeg.{u1} Î± (SubNegZeroMonoid.toNegZeroClass.{u1} Î± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Î± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Î± (AddCommGroup.toDivisionAddCommMonoid.{u1} Î± (OrderedAddCommGroup.toAddCommGroup.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))))) (SemilatticeSup.toSup.{u1} Î± (Lattice.toSemilatticeSup.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Î± _inst_1))))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1))))) (Sup.sup.{u1} (Filter.{u1} Î±) (SemilatticeSup.toSup.{u1} (Filter.{u1} Î±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Î±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Î± _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.comap_abs_at_top Filter.comap_abs_atTopâ‚“'. -/
@[simp]
theorem comap_abs_atTop : comap (abs : Î± â†’ Î±) atTop = atBot âŠ” atTop :=
  by
  refine'
    le_antisymm (((at_top_basis.comap _).le_basis_iffâ‚“ (at_bot_basis.sup at_top_basis)).2 _)
      (sup_le tendsto_abs_at_bot_at_top.le_comap tendsto_abs_at_top_at_top.le_comap)
  rintro âŸ¨a, bâŸ© -
  refine' âŸ¨max (-a) b, trivial, fun x hx => _âŸ©
  rw [mem_preimage, mem_Ici, le_abs', max_le_iff, â† min_neg_neg, le_min_iff, neg_neg] at hx
  exact hx.imp And.left And.right
#align filter.comap_abs_at_top Filter.comap_abs_atTop

end LinearOrderedAddCommGroup

section LinearOrderedSemiring

variable [LinearOrderedSemiring Î±] {l : Filter Î²} {f : Î² â†’ Î±}

/- warning: filter.tendsto.at_top_of_const_mul -> Filter.Tendsto.atTop_of_const_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemiring.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {c : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))))) c) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))) c (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {c : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (MonoidWithZero.toZero.{u2} Î± (Semiring.toMonoidWithZero.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))))) c) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocSemiring.toMul.{u2} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î± (Semiring.toNonAssocSemiring.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))))) c (f x)) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1))))) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_of_const_mul Filter.Tendsto.atTop_of_const_mulâ‚“'. -/
theorem Tendsto.atTop_of_const_mul {c : Î±} (hc : 0 < c) (hf : Tendsto (fun x => c * f x) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (c * b)).mono fun x hx => le_of_mul_le_mul_left hx hc
#align filter.tendsto.at_top_of_const_mul Filter.Tendsto.atTop_of_const_mul

/- warning: filter.tendsto.at_top_of_mul_const -> Filter.Tendsto.atTop_of_mul_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemiring.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {c : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))))) c) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))) (f x) c) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {c : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (MonoidWithZero.toZero.{u2} Î± (Semiring.toMonoidWithZero.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))))) c) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocSemiring.toMul.{u2} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î± (Semiring.toNonAssocSemiring.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))))) (f x) c) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1))))) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_of_mul_const Filter.Tendsto.atTop_of_mul_constâ‚“'. -/
theorem Tendsto.atTop_of_mul_const {c : Î±} (hc : 0 < c) (hf : Tendsto (fun x => f x * c) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b =>
    (tendsto_atTop.1 hf (b * c)).mono fun x hx => le_of_mul_le_mul_right hx hc
#align filter.tendsto.at_top_of_mul_const Filter.Tendsto.atTop_of_mul_const

#print Filter.tendsto_pow_atTop_iff /-
@[simp]
theorem tendsto_pow_atTop_iff {n : â„•} : Tendsto (fun x : Î± => x ^ n) atTop atTop â†” n â‰  0 :=
  âŸ¨fun h hn => by simpa only [hn, pow_zero, not_tendsto_const_at_top] using h, tendsto_pow_atTopâŸ©
#align filter.tendsto_pow_at_top_iff Filter.tendsto_pow_atTop_iff
-/

end LinearOrderedSemiring

/- warning: filter.nonneg_of_eventually_pow_nonneg -> Filter.nonneg_of_eventually_pow_nonneg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] {a : Î±}, (Filter.Eventually.{0} Nat (fun (n : Nat) => LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (Ring.toMonoid.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) a n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) -> (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) a)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] {a : Î±}, (Filter.Eventually.{0} Nat (fun (n : Nat) => LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) a n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) -> (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) a)
Case conversion may be inaccurate. Consider using '#align filter.nonneg_of_eventually_pow_nonneg Filter.nonneg_of_eventually_pow_nonnegâ‚“'. -/
theorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing Î±] {a : Î±}
    (h : âˆ€á¶  n in atTop, 0 â‰¤ a ^ (n : â„•)) : 0 â‰¤ a :=
  let âŸ¨n, hnâŸ© := (tendsto_bit1_atTop.Eventually h).exists
  pow_bit1_nonneg_iff.1 hn
#align filter.nonneg_of_eventually_pow_nonneg Filter.nonneg_of_eventually_pow_nonneg

/- warning: filter.not_tendsto_pow_at_top_at_bot -> Filter.not_tendsto_pow_atTop_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] {n : Nat}, Not (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (Ring.toMonoid.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) x n) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] {n : Nat}, Not (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) x n) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.not_tendsto_pow_at_top_at_bot Filter.not_tendsto_pow_atTop_atBotâ‚“'. -/
theorem not_tendsto_pow_atTop_atBot [LinearOrderedRing Î±] :
    âˆ€ {n : â„•}, Â¬Tendsto (fun x : Î± => x ^ n) atTop atBot
  | 0 => by simp [not_tendsto_const_at_bot]
  | n + 1 => (tendsto_pow_atTop n.succ_ne_zero).not_tendsto disjoint_atTop_atBot
#align filter.not_tendsto_pow_at_top_at_bot Filter.not_tendsto_pow_atTop_atBot

section LinearOrderedSemifield

variable [LinearOrderedSemifield Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r c : Î±} {n : â„•}

/-!
### Multiplication by constant: iff lemmas
-/


/- warning: filter.tendsto_const_mul_at_top_of_pos -> Filter.tendsto_const_mul_atTop_of_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) r) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± _inst_1)))))) r) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocSemiring.toMul.{u2} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î± (Semiring.toNonAssocSemiring.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_top_of_pos Filter.tendsto_const_mul_atTop_of_posâ‚“'. -/
/-- If `r` is a positive constant, then `Î» x, r * f x` tends to infinity along a filter if and only
if `f` tends to infinity along the same filter. -/
theorem tendsto_const_mul_atTop_of_pos (hr : 0 < r) :
    Tendsto (fun x => r * f x) l atTop â†” Tendsto f l atTop :=
  âŸ¨fun h => h.atTop_of_const_mul hr, fun h =>
    Tendsto.atTop_of_const_mul (inv_pos.2 hr) <| by simpa only [inv_mul_cancel_leftâ‚€ hr.ne'] âŸ©
#align filter.tendsto_const_mul_at_top_of_pos Filter.tendsto_const_mul_atTop_of_pos

/- warning: filter.tendsto_mul_const_at_top_of_pos -> Filter.tendsto_mul_const_atTop_of_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) r) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± _inst_1)))))) r) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocSemiring.toMul.{u2} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î± (Semiring.toNonAssocSemiring.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_top_of_pos Filter.tendsto_mul_const_atTop_of_posâ‚“'. -/
/-- If `r` is a positive constant, then `Î» x, f x * r` tends to infinity along a filter if and only
if `f` tends to infinity along the same filter. -/
theorem tendsto_mul_const_atTop_of_pos (hr : 0 < r) :
    Tendsto (fun x => f x * r) l atTop â†” Tendsto f l atTop := by
  simpa only [mul_comm] using tendsto_const_mul_at_top_of_pos hr
#align filter.tendsto_mul_const_at_top_of_pos Filter.tendsto_mul_const_atTop_of_pos

/- warning: filter.tendsto_const_mul_at_top_iff_pos -> Filter.tendsto_const_mul_atTop_iff_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) r))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocSemiring.toMul.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± _inst_1)))))) r))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_top_iff_pos Filter.tendsto_const_mul_atTop_iff_posâ‚“'. -/
/-- If `f` tends to infinity along a nontrivial filter `l`, then `Î» x, r * f x` tends to infinity
if and only if `0 < r. `-/
theorem tendsto_const_mul_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop â†” 0 < r :=
  by
  refine' âŸ¨fun hrf => not_le.mp fun hr => _, fun hr => (tendsto_const_mul_at_top_of_pos hr).mpr hâŸ©
  rcases((h.eventually_ge_at_top 0).And (hrf.eventually_gt_at_top 0)).exists with âŸ¨x, hx, hrxâŸ©
  exact (mul_nonpos_of_nonpos_of_nonneg hr hx).not_lt hrx
#align filter.tendsto_const_mul_at_top_iff_pos Filter.tendsto_const_mul_atTop_iff_pos

/- warning: filter.tendsto_mul_const_at_top_iff_pos -> Filter.tendsto_mul_const_atTop_iff_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) r))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocSemiring.toMul.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± _inst_1)))))) r))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_top_iff_pos Filter.tendsto_mul_const_atTop_iff_posâ‚“'. -/
/-- If `f` tends to infinity along a nontrivial filter `l`, then `Î» x, f x * r` tends to infinity
if and only if `0 < r. `-/
theorem tendsto_mul_const_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop â†” 0 < r := by
  simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_pos h]
#align filter.tendsto_mul_const_at_top_iff_pos Filter.tendsto_mul_const_atTop_iff_pos

/- warning: filter.tendsto.const_mul_at_top -> Filter.Tendsto.const_mul_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) r) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± _inst_1)))))) r) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocSemiring.toMul.{u2} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î± (Semiring.toNonAssocSemiring.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.const_mul_at_top Filter.Tendsto.const_mul_atTopâ‚“'. -/
/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `â„•` or `â„¤`, use
`filter.tendsto.const_mul_at_top'` instead. -/
theorem Tendsto.const_mul_atTop (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_pos hr).2 hf
#align filter.tendsto.const_mul_at_top Filter.Tendsto.const_mul_atTop

/- warning: filter.tendsto.at_top_mul_const -> Filter.Tendsto.atTop_mul_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) r) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± _inst_1)))))) r) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocSemiring.toMul.{u2} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î± (Semiring.toNonAssocSemiring.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_mul_const Filter.Tendsto.atTop_mul_constâ‚“'. -/
/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `â„•` or `â„¤`, use
`filter.tendsto.at_top_mul_const'` instead. -/
theorem Tendsto.atTop_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_pos hr).2 hf
#align filter.tendsto.at_top_mul_const Filter.Tendsto.atTop_mul_const

/- warning: filter.tendsto.at_top_div_const -> Filter.Tendsto.atTop_div_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) r) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HDiv.hDiv.{u1, u1, u1} Î± Î± Î± (instHDiv.{u1} Î± (DivInvMonoid.toHasDiv.{u1} Î± (GroupWithZero.toDivInvMonoid.{u1} Î± (DivisionSemiring.toGroupWithZero.{u1} Î± (Semifield.toDivisionSemiring.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± _inst_1)))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± _inst_1)))))) r) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HDiv.hDiv.{u2, u2, u2} Î± Î± Î± (instHDiv.{u2} Î± (LinearOrderedSemifield.toDiv.{u2} Î± _inst_1)) (f x) r) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedSemiring.toPartialOrder.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_div_const Filter.Tendsto.atTop_div_constâ‚“'. -/
/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
theorem Tendsto.atTop_div_const (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x / r) l atTop := by
  simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)
#align filter.tendsto.at_top_div_const Filter.Tendsto.atTop_div_const

/- warning: filter.tendsto_const_mul_pow_at_top -> Filter.tendsto_const_mul_pow_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {c : Î±} {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) c) -> (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {c : Î±} {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± _inst_1)))))) c) -> (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocSemiring.toMul.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_pow_at_top Filter.tendsto_const_mul_pow_atTopâ‚“'. -/
theorem tendsto_const_mul_pow_atTop (hn : n â‰  0) (hc : 0 < c) :
    Tendsto (fun x => c * x ^ n) atTop atTop :=
  Tendsto.const_mul_atTop hc (tendsto_pow_atTop hn)
#align filter.tendsto_const_mul_pow_at_top Filter.tendsto_const_mul_pow_atTop

/- warning: filter.tendsto_const_mul_pow_at_top_iff -> Filter.tendsto_const_mul_pow_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {c : Î±} {n : Nat}, Iff (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) (And (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))))))) c))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u1} Î±] {c : Î±} {n : Nat}, Iff (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocSemiring.toMul.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1))))))) (And (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± _inst_1)))))) c))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_pow_at_top_iff Filter.tendsto_const_mul_pow_atTop_iffâ‚“'. -/
theorem tendsto_const_mul_pow_atTop_iff :
    Tendsto (fun x => c * x ^ n) atTop atTop â†” n â‰  0 âˆ§ 0 < c :=
  by
  refine' âŸ¨fun h => âŸ¨_, _âŸ©, fun h => tendsto_const_mul_pow_at_top h.1 h.2âŸ©
  Â· rintro rfl
    simpa only [pow_zero, not_tendsto_const_at_top] using h
  Â· rcases((h.eventually_gt_at_top 0).And (eventually_ge_at_top 0)).exists with âŸ¨k, hck, hkâŸ©
    exact pos_of_mul_pos_left hck (pow_nonneg hk _)
#align filter.tendsto_const_mul_pow_at_top_iff Filter.tendsto_const_mul_pow_atTop_iff

end LinearOrderedSemifield

section LinearOrderedField

variable [LinearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±}

/- warning: filter.tendsto_const_mul_at_bot_of_pos -> Filter.tendsto_const_mul_atBot_of_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1))))))) r) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_bot_of_pos Filter.tendsto_const_mul_atBot_of_posâ‚“'. -/
/-- If `r` is a positive constant, then `Î» x, r * f x` tends to negative infinity along a filter if
and only if `f` tends to negative infinity along the same filter. -/
theorem tendsto_const_mul_atBot_of_pos (hr : 0 < r) :
    Tendsto (fun x => r * f x) l atBot â†” Tendsto f l atBot := by
  simpa only [â† mul_neg, â† tendsto_neg_at_top_iff] using tendsto_const_mul_at_top_of_pos hr
#align filter.tendsto_const_mul_at_bot_of_pos Filter.tendsto_const_mul_atBot_of_pos

/- warning: filter.tendsto_mul_const_at_bot_of_pos -> Filter.tendsto_mul_const_atBot_of_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1))))))) r) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_bot_of_pos Filter.tendsto_mul_const_atBot_of_posâ‚“'. -/
/-- If `r` is a positive constant, then `Î» x, f x * r` tends to negative infinity along a filter if
and only if `f` tends to negative infinity along the same filter. -/
theorem tendsto_mul_const_atBot_of_pos (hr : 0 < r) :
    Tendsto (fun x => f x * r) l atBot â†” Tendsto f l atBot := by
  simpa only [mul_comm] using tendsto_const_mul_at_bot_of_pos hr
#align filter.tendsto_mul_const_at_bot_of_pos Filter.tendsto_mul_const_atBot_of_pos

/- warning: filter.tendsto_const_mul_at_top_of_neg -> Filter.tendsto_const_mul_atTop_of_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_top_of_neg Filter.tendsto_const_mul_atTop_of_negâ‚“'. -/
/-- If `r` is a negative constant, then `Î» x, r * f x` tends to infinity along a filter if and only
if `f` tends to negative infinity along the same filter. -/
theorem tendsto_const_mul_atTop_of_neg (hr : r < 0) :
    Tendsto (fun x => r * f x) l atTop â†” Tendsto f l atBot := by
  simpa only [neg_mul, tendsto_neg_at_bot_iff] using tendsto_const_mul_at_bot_of_pos (neg_pos.2 hr)
#align filter.tendsto_const_mul_at_top_of_neg Filter.tendsto_const_mul_atTop_of_neg

/- warning: filter.tendsto_mul_const_at_top_of_neg -> Filter.tendsto_mul_const_atTop_of_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_top_of_neg Filter.tendsto_mul_const_atTop_of_negâ‚“'. -/
/-- If `r` is a negative constant, then `Î» x, f x * r` tends to infinity along a filter if and only
if `f` tends to negative infinity along the same filter. -/
theorem tendsto_mul_const_atTop_of_neg (hr : r < 0) :
    Tendsto (fun x => f x * r) l atTop â†” Tendsto f l atBot := by
  simpa only [mul_comm] using tendsto_const_mul_at_top_of_neg hr
#align filter.tendsto_mul_const_at_top_of_neg Filter.tendsto_mul_const_atTop_of_neg

/- warning: filter.tendsto_const_mul_at_bot_of_neg -> Filter.tendsto_const_mul_atBot_of_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_bot_of_neg Filter.tendsto_const_mul_atBot_of_negâ‚“'. -/
/-- If `r` is a negative constant, then `Î» x, r * f x` tends to negative infinity along a filter if
and only if `f` tends to infinity along the same filter. -/
theorem tendsto_const_mul_atBot_of_neg (hr : r < 0) :
    Tendsto (fun x => r * f x) l atBot â†” Tendsto f l atTop := by
  simpa only [neg_mul, tendsto_neg_at_top_iff] using tendsto_const_mul_at_top_of_pos (neg_pos.2 hr)
#align filter.tendsto_const_mul_at_bot_of_neg Filter.tendsto_const_mul_atBot_of_neg

/- warning: filter.tendsto_mul_const_at_bot_of_neg -> Filter.tendsto_mul_const_atBot_of_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_bot_of_neg Filter.tendsto_mul_const_atBot_of_negâ‚“'. -/
/-- If `r` is a negative constant, then `Î» x, f x * r` tends to negative infinity along a filter if
and only if `f` tends to infinity along the same filter. -/
theorem tendsto_mul_const_atBot_of_neg (hr : r < 0) :
    Tendsto (fun x => f x * r) l atBot â†” Tendsto f l atTop := by
  simpa only [mul_comm] using tendsto_const_mul_at_bot_of_neg hr
#align filter.tendsto_mul_const_at_bot_of_neg Filter.tendsto_mul_const_atBot_of_neg

/- warning: filter.tendsto_const_mul_at_top_iff -> Filter.tendsto_const_mul_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))) (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_top_iff Filter.tendsto_const_mul_atTop_iffâ‚“'. -/
/-- The function `Î» x, r * f x` tends to infinity along a nontrivial filter if and only if `r > 0`
and `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/
theorem tendsto_const_mul_atTop_iff [NeBot l] :
    Tendsto (fun x => r * f x) l atTop â†” 0 < r âˆ§ Tendsto f l atTop âˆ¨ r < 0 âˆ§ Tendsto f l atBot :=
  by
  rcases lt_trichotomy r 0 with (hr | rfl | hr)
  Â· simp [hr, hr.not_lt, tendsto_const_mul_at_top_of_neg]
  Â· simp [not_tendsto_const_at_top]
  Â· simp [hr, hr.not_lt, tendsto_const_mul_at_top_of_pos]
#align filter.tendsto_const_mul_at_top_iff Filter.tendsto_const_mul_atTop_iff

/- warning: filter.tendsto_mul_const_at_top_iff -> Filter.tendsto_mul_const_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))) (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_top_iff Filter.tendsto_mul_const_atTop_iffâ‚“'. -/
/-- The function `Î» x, f x * r` tends to infinity along a nontrivial filter if and only if `r > 0`
and `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/
theorem tendsto_mul_const_atTop_iff [NeBot l] :
    Tendsto (fun x => f x * r) l atTop â†” 0 < r âˆ§ Tendsto f l atTop âˆ¨ r < 0 âˆ§ Tendsto f l atBot := by
  simp only [mul_comm _ r, tendsto_const_mul_at_top_iff]
#align filter.tendsto_mul_const_at_top_iff Filter.tendsto_mul_const_atTop_iff

/- warning: filter.tendsto_const_mul_at_bot_iff -> Filter.tendsto_const_mul_atBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))) (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_bot_iff Filter.tendsto_const_mul_atBot_iffâ‚“'. -/
/-- The function `Î» x, r * f x` tends to negative infinity along a nontrivial filter if and only if
`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/
theorem tendsto_const_mul_atBot_iff [NeBot l] :
    Tendsto (fun x => r * f x) l atBot â†” 0 < r âˆ§ Tendsto f l atBot âˆ¨ r < 0 âˆ§ Tendsto f l atTop := by
  simp only [â† tendsto_neg_at_top_iff, â† mul_neg, tendsto_const_mul_at_top_iff, neg_neg]
#align filter.tendsto_const_mul_at_bot_iff Filter.tendsto_const_mul_atBot_iff

/- warning: filter.tendsto_mul_const_at_bot_iff -> Filter.tendsto_mul_const_atBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))) (And (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (Or (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))) r) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (And (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))) (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_bot_iff Filter.tendsto_mul_const_atBot_iffâ‚“'. -/
/-- The function `Î» x, f x * r` tends to negative infinity along a nontrivial filter if and only if
`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/
theorem tendsto_mul_const_atBot_iff [NeBot l] :
    Tendsto (fun x => f x * r) l atBot â†” 0 < r âˆ§ Tendsto f l atBot âˆ¨ r < 0 âˆ§ Tendsto f l atTop := by
  simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff]
#align filter.tendsto_mul_const_at_bot_iff Filter.tendsto_mul_const_atBot_iff

/- warning: filter.tendsto_const_mul_at_top_iff_neg -> Filter.tendsto_const_mul_atTop_iff_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_top_iff_neg Filter.tendsto_const_mul_atTop_iff_negâ‚“'. -/
/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `Î» x, r * f x` tends to
infinity if and only if `r < 0. `-/
theorem tendsto_const_mul_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop â†” r < 0 := by
  simp [tendsto_const_mul_at_top_iff, h, h.not_tendsto disjoint_at_bot_at_top]
#align filter.tendsto_const_mul_at_top_iff_neg Filter.tendsto_const_mul_atTop_iff_neg

/- warning: filter.tendsto_mul_const_at_top_iff_neg -> Filter.tendsto_mul_const_atTop_iff_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_top_iff_neg Filter.tendsto_mul_const_atTop_iff_negâ‚“'. -/
/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `Î» x, f x * r` tends to
infinity if and only if `r < 0. `-/
theorem tendsto_mul_const_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop â†” r < 0 := by
  simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_neg h]
#align filter.tendsto_mul_const_at_top_iff_neg Filter.tendsto_mul_const_atTop_iff_neg

/- warning: filter.tendsto_const_mul_at_bot_iff_pos -> Filter.tendsto_const_mul_atBot_iff_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))) r))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_bot_iff_pos Filter.tendsto_const_mul_atBot_iff_posâ‚“'. -/
/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `Î» x, r * f x` tends to
negative infinity if and only if `0 < r. `-/
theorem tendsto_const_mul_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot â†” 0 < r := by
  simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_bot_at_top]
#align filter.tendsto_const_mul_at_bot_iff_pos Filter.tendsto_const_mul_atBot_iff_pos

/- warning: filter.tendsto_mul_const_at_bot_iff_pos -> Filter.tendsto_mul_const_atBot_iff_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))) r))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_bot_iff_pos Filter.tendsto_mul_const_atBot_iff_posâ‚“'. -/
/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `Î» x, f x * r` tends to
negative infinity if and only if `0 < r. `-/
theorem tendsto_mul_const_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atBot â†” 0 < r := by
  simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_pos h]
#align filter.tendsto_mul_const_at_bot_iff_pos Filter.tendsto_mul_const_atBot_iff_pos

/- warning: filter.tendsto_const_mul_at_bot_iff_neg -> Filter.tendsto_const_mul_atBot_iff_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_at_bot_iff_neg Filter.tendsto_const_mul_atBot_iff_negâ‚“'. -/
/-- If `f` tends to infinity along a nontrivial filter `l`, then `Î» x, r * f x` tends to negative
infinity if and only if `r < 0. `-/
theorem tendsto_const_mul_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot â†” r < 0 := by
  simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_top_at_bot]
#align filter.tendsto_const_mul_at_bot_iff_neg Filter.tendsto_const_mul_atBot_iff_neg

/- warning: filter.tendsto_mul_const_at_bot_iff_neg -> Filter.tendsto_mul_const_atBot_iff_neg is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±} [_inst_2 : Filter.NeBot.{u2} Î² l], (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) -> (Iff (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) r (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_mul_const_at_bot_iff_neg Filter.tendsto_mul_const_atBot_iff_negâ‚“'. -/
/-- If `f` tends to infinity along a nontrivial filter `l`, then `Î» x, f x * r` tends to negative
infinity if and only if `r < 0. `-/
theorem tendsto_mul_const_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot â†” r < 0 := by
  simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_neg h]
#align filter.tendsto_mul_const_at_bot_iff_neg Filter.tendsto_mul_const_atBot_iff_neg

/- warning: filter.tendsto.neg_const_mul_at_top -> Filter.Tendsto.neg_const_mul_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.neg_const_mul_at_top Filter.Tendsto.neg_const_mul_atTopâ‚“'. -/
/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
theorem Tendsto.neg_const_mul_atTop (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_neg hr).2 hf
#align filter.tendsto.neg_const_mul_at_top Filter.Tendsto.neg_const_mul_atTop

/- warning: filter.tendsto.at_top_mul_neg_const -> Filter.Tendsto.atTop_mul_neg_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_mul_neg_const Filter.Tendsto.atTop_mul_neg_constâ‚“'. -/
/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
theorem Tendsto.atTop_mul_neg_const (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_neg hr).2 hf
#align filter.tendsto.at_top_mul_neg_const Filter.Tendsto.atTop_mul_neg_const

/- warning: filter.tendsto.const_mul_at_bot -> Filter.Tendsto.const_mul_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1))))))) r) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.const_mul_at_bot Filter.Tendsto.const_mul_atBotâ‚“'. -/
/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
theorem Tendsto.const_mul_atBot (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_pos hr).2 hf
#align filter.tendsto.const_mul_at_bot Filter.Tendsto.const_mul_atBot

/- warning: filter.tendsto.at_bot_mul_const -> Filter.Tendsto.atBot_mul_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1))))))) r) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_bot_mul_const Filter.Tendsto.atBot_mul_constâ‚“'. -/
/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
theorem Tendsto.atBot_mul_const (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_pos hr).2 hf
#align filter.tendsto.at_bot_mul_const Filter.Tendsto.atBot_mul_const

/- warning: filter.tendsto.at_bot_div_const -> Filter.Tendsto.atBot_div_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))))))) r) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HDiv.hDiv.{u1, u1, u1} Î± Î± Î± (instHDiv.{u1} Î± (DivInvMonoid.toHasDiv.{u1} Î± (DivisionRing.toDivInvMonoid.{u1} Î± (Field.toDivisionRing.{u1} Î± (LinearOrderedField.toField.{u1} Î± _inst_1))))) (f x) r) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1))))))) r) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HDiv.hDiv.{u2, u2, u2} Î± Î± Î± (instHDiv.{u2} Î± (LinearOrderedField.toDiv.{u2} Î± _inst_1)) (f x) r) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_bot_div_const Filter.Tendsto.atBot_div_constâ‚“'. -/
/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
theorem Tendsto.atBot_div_const (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x / r) l atBot := by
  simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)
#align filter.tendsto.at_bot_div_const Filter.Tendsto.atBot_div_const

/- warning: filter.tendsto.neg_const_mul_at_bot -> Filter.Tendsto.neg_const_mul_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) r (f x)) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.neg_const_mul_at_bot Filter.Tendsto.neg_const_mul_atBotâ‚“'. -/
/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
theorem Tendsto.neg_const_mul_atBot (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_neg hr).2 hf
#align filter.tendsto.neg_const_mul_at_bot Filter.Tendsto.neg_const_mul_atBot

/- warning: filter.tendsto.at_bot_mul_neg_const -> Filter.Tendsto.atBot_mul_neg_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} Î±] {l : Filter.{u2} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± f l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (f x) r) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} Î±] {l : Filter.{u1} Î²} {f : Î² -> Î±} {r : Î±}, (LT.lt.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))) r (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (CommMonoidWithZero.toZero.{u2} Î± (CommGroupWithZero.toCommMonoidWithZero.{u2} Î± (Semifield.toCommGroupWithZero.{u2} Î± (LinearOrderedSemifield.toSemifield.{u2} Î± (LinearOrderedField.toLinearOrderedSemifield.{u2} Î± _inst_1)))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± f l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1))))))) -> (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => HMul.hMul.{u2, u2, u2} Î± Î± Î± (instHMul.{u2} Î± (NonUnitalNonAssocRing.toMul.{u2} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î± (Ring.toNonAssocRing.{u2} Î± (StrictOrderedRing.toRing.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))) (f x) r) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î± (LinearOrderedField.toLinearOrderedCommRing.{u2} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_bot_mul_neg_const Filter.Tendsto.atBot_mul_neg_constâ‚“'. -/
/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
theorem Tendsto.atBot_mul_neg_const (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_neg hr).2 hf
#align filter.tendsto.at_bot_mul_neg_const Filter.Tendsto.atBot_mul_neg_const

/- warning: filter.tendsto_neg_const_mul_pow_at_top -> Filter.tendsto_neg_const_mul_pow_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} Î±] {c : Î±} {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) c (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))) -> (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (Ring.toMonoid.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} Î±] {c : Î±} {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) c (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))) -> (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_neg_const_mul_pow_at_top Filter.tendsto_neg_const_mul_pow_atTopâ‚“'. -/
theorem tendsto_neg_const_mul_pow_atTop {c : Î±} {n : â„•} (hn : n â‰  0) (hc : c < 0) :
    Tendsto (fun x => c * x ^ n) atTop atBot :=
  Tendsto.neg_const_mul_atTop hc (tendsto_pow_atTop hn)
#align filter.tendsto_neg_const_mul_pow_at_top Filter.tendsto_neg_const_mul_pow_atTop

/- warning: filter.tendsto_const_mul_pow_at_bot_iff -> Filter.tendsto_const_mul_pow_atBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} Î±] {c : Î±} {n : Nat}, Iff (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (Distrib.toHasMul.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (Ring.toMonoid.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) (And (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) c (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} Î±] {c : Î±} {n : Nat}, Iff (Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => HMul.hMul.{u1, u1, u1} Î± Î± Î± (instHMul.{u1} Î± (NonUnitalNonAssocRing.toMul.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))))) c (HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î± (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1))))))))) x n)) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1))))))) (And (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î± (LinearOrderedField.toLinearOrderedCommRing.{u1} Î± _inst_1)))))) c (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (CommMonoidWithZero.toZero.{u1} Î± (CommGroupWithZero.toCommMonoidWithZero.{u1} Î± (Semifield.toCommGroupWithZero.{u1} Î± (LinearOrderedSemifield.toSemifield.{u1} Î± (LinearOrderedField.toLinearOrderedSemifield.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_const_mul_pow_at_bot_iff Filter.tendsto_const_mul_pow_atBot_iffâ‚“'. -/
theorem tendsto_const_mul_pow_atBot_iff {c : Î±} {n : â„•} :
    Tendsto (fun x => c * x ^ n) atTop atBot â†” n â‰  0 âˆ§ c < 0 := by
  simp only [â† tendsto_neg_at_top_iff, â† neg_mul, tendsto_const_mul_pow_at_top_iff, neg_pos]
#align filter.tendsto_const_mul_pow_at_bot_iff Filter.tendsto_const_mul_pow_atBot_iff

end LinearOrderedField

open Filter

/- warning: filter.tendsto_at_top' -> Filter.tendsto_atTop' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] {f : Î± -> Î²} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) l) (forall (s : Set.{u2} Î²), (Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) s l) -> (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) b a) -> (Membership.Mem.{u2, u2} Î² (Set.{u2} Î²) (Set.hasMem.{u2} Î²) (f b) s))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] {f : Î± -> Î²} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) l) (forall (s : Set.{u1} Î²), (Membership.mem.{u1, u1} (Set.{u1} Î²) (Filter.{u1} Î²) (instMembershipSetFilter.{u1} Î²) s l) -> (Exists.{succ u2} Î± (fun (a : Î±) => forall (b : Î±), (GE.ge.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) b a) -> (Membership.mem.{u1, u1} Î² (Set.{u1} Î²) (Set.instMembershipSet.{u1} Î²) (f b) s))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top' Filter.tendsto_atTop'â‚“'. -/
theorem tendsto_atTop' [Nonempty Î±] [SemilatticeSup Î±] {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto f atTop l â†” âˆ€ s âˆˆ l, âˆƒ a, âˆ€ b â‰¥ a, f b âˆˆ s := by
  simp only [tendsto_def, mem_at_top_sets] <;> rfl
#align filter.tendsto_at_top' Filter.tendsto_atTop'

/- warning: filter.tendsto_at_bot' -> Filter.tendsto_atBot' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] {f : Î± -> Î²} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) l) (forall (s : Set.{u2} Î²), (Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) s l) -> (Exists.{succ u1} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) b a) -> (Membership.Mem.{u2, u2} Î² (Set.{u2} Î²) (Set.hasMem.{u2} Î²) (f b) s))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] {f : Î± -> Î²} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) l) (forall (s : Set.{u1} Î²), (Membership.mem.{u1, u1} (Set.{u1} Î²) (Filter.{u1} Î²) (instMembershipSetFilter.{u1} Î²) s l) -> (Exists.{succ u2} Î± (fun (a : Î±) => forall (b : Î±), (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) b a) -> (Membership.mem.{u1, u1} Î² (Set.{u1} Î²) (Set.instMembershipSet.{u1} Î²) (f b) s))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot' Filter.tendsto_atBot'â‚“'. -/
theorem tendsto_atBot' [Nonempty Î±] [SemilatticeInf Î±] {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto f atBot l â†” âˆ€ s âˆˆ l, âˆƒ a, âˆ€ b â‰¤ a, f b âˆˆ s :=
  @tendsto_atTop' Î±áµ’áµˆ _ _ _ _ _
#align filter.tendsto_at_bot' Filter.tendsto_atBot'

/- warning: filter.tendsto_at_top_principal -> Filter.tendsto_atTop_principal is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u2} Î²] [_inst_2 : SemilatticeSup.{u2} Î²] {f : Î² -> Î±} {s : Set.{u1} Î±}, Iff (Filter.Tendsto.{u2, u1} Î² Î± f (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) (Filter.principal.{u1} Î± s)) (Exists.{succ u2} Î² (fun (N : Î²) => forall (n : Î²), (GE.ge.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) n N) -> (Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) (f n) s)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u2} Î²] [_inst_2 : SemilatticeSup.{u2} Î²] {f : Î² -> Î±} {s : Set.{u1} Î±}, Iff (Filter.Tendsto.{u2, u1} Î² Î± f (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) (Filter.principal.{u1} Î± s)) (Exists.{succ u2} Î² (fun (N : Î²) => forall (n : Î²), (GE.ge.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) n N) -> (Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) (f n) s)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_principal Filter.tendsto_atTop_principalâ‚“'. -/
theorem tendsto_atTop_principal [Nonempty Î²] [SemilatticeSup Î²] {f : Î² â†’ Î±} {s : Set Î±} :
    Tendsto f atTop (ð“Ÿ s) â†” âˆƒ N, âˆ€ n â‰¥ N, f n âˆˆ s := by
  rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets] <;> rfl
#align filter.tendsto_at_top_principal Filter.tendsto_atTop_principal

/- warning: filter.tendsto_at_bot_principal -> Filter.tendsto_atBot_principal is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u2} Î²] [_inst_2 : SemilatticeInf.{u2} Î²] {f : Î² -> Î±} {s : Set.{u1} Î±}, Iff (Filter.Tendsto.{u2, u1} Î² Î± f (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) (Filter.principal.{u1} Î± s)) (Exists.{succ u2} Î² (fun (N : Î²) => forall (n : Î²), (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) n N) -> (Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) (f n) s)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u2} Î²] [_inst_2 : SemilatticeInf.{u2} Î²] {f : Î² -> Î±} {s : Set.{u1} Î±}, Iff (Filter.Tendsto.{u2, u1} Î² Î± f (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) (Filter.principal.{u1} Î± s)) (Exists.{succ u2} Î² (fun (N : Î²) => forall (n : Î²), (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) n N) -> (Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) (f n) s)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_principal Filter.tendsto_atBot_principalâ‚“'. -/
theorem tendsto_atBot_principal [Nonempty Î²] [SemilatticeInf Î²] {f : Î² â†’ Î±} {s : Set Î±} :
    Tendsto f atBot (ð“Ÿ s) â†” âˆƒ N, âˆ€ n â‰¤ N, f n âˆˆ s :=
  @tendsto_atTop_principal _ Î²áµ’áµˆ _ _ _ _
#align filter.tendsto_at_bot_principal Filter.tendsto_atBot_principal

/- warning: filter.tendsto_at_top_at_top -> Filter.tendsto_atTop_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (Filter.atTop.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) i a) -> (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) b (f a))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) (Filter.atTop.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) i a) -> (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) b (f a))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_at_top Filter.tendsto_atTop_atTopâ‚“'. -/
/-- A function `f` grows to `+âˆž` independent of an order-preserving embedding `e`. -/
theorem tendsto_atTop_atTop [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] {f : Î± â†’ Î²} :
    Tendsto f atTop atTop â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ b â‰¤ f a :=
  Iff.trans tendsto_iInf <| forall_congr' fun b => tendsto_atTop_principal
#align filter.tendsto_at_top_at_top Filter.tendsto_atTop_atTop

/- warning: filter.tendsto_at_top_at_bot -> Filter.tendsto_atTop_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (Filter.atBot.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) i a) -> (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) (f a) b)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) (Filter.atBot.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) i a) -> (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) (f a) b)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_at_bot Filter.tendsto_atTop_atBotâ‚“'. -/
theorem tendsto_atTop_atBot [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] {f : Î± â†’ Î²} :
    Tendsto f atTop atBot â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ f a â‰¤ b :=
  @tendsto_atTop_atTop Î± Î²áµ’áµˆ _ _ _ f
#align filter.tendsto_at_top_at_bot Filter.tendsto_atTop_atBot

/- warning: filter.tendsto_at_bot_at_top -> Filter.tendsto_atBot_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) (Filter.atTop.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) a i) -> (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) b (f a))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) (Filter.atTop.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) a i) -> (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) b (f a))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_at_top Filter.tendsto_atBot_atTopâ‚“'. -/
theorem tendsto_atBot_atTop [Nonempty Î±] [SemilatticeInf Î±] [Preorder Î²] {f : Î± â†’ Î²} :
    Tendsto f atBot atTop â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, a â‰¤ i â†’ b â‰¤ f a :=
  @tendsto_atTop_atTop Î±áµ’áµˆ Î² _ _ _ f
#align filter.tendsto_at_bot_at_top Filter.tendsto_atBot_atTop

/- warning: filter.tendsto_at_bot_at_bot -> Filter.tendsto_atBot_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) (Filter.atBot.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) a i) -> (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) (f a) b)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) (Filter.atBot.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (i : Î±) => forall (a : Î±), (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) a i) -> (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) (f a) b)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_at_bot Filter.tendsto_atBot_atBotâ‚“'. -/
theorem tendsto_atBot_atBot [Nonempty Î±] [SemilatticeInf Î±] [Preorder Î²] {f : Î± â†’ Î²} :
    Tendsto f atBot atBot â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, a â‰¤ i â†’ f a â‰¤ b :=
  @tendsto_atTop_atTop Î±áµ’áµˆ Î²áµ’áµˆ _ _ _ f
#align filter.tendsto_at_bot_at_bot Filter.tendsto_atBot_atBot

/- warning: filter.tendsto_at_top_at_top_of_monotone -> Filter.tendsto_atTop_atTop_of_monotone is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2) b (f a))) -> (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± _inst_1) (Filter.atTop.{u2} Î² _inst_2))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) b (f a))) -> (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± _inst_1) (Filter.atTop.{u1} Î² _inst_2))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_at_top_of_monotone Filter.tendsto_atTop_atTop_of_monotoneâ‚“'. -/
theorem tendsto_atTop_atTop_of_monotone [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hf : Monotone f)
    (h : âˆ€ b, âˆƒ a, b â‰¤ f a) : Tendsto f atTop atTop :=
  tendsto_iInf.2 fun b =>
    tendsto_principal.2 <|
      let âŸ¨a, haâŸ© := h b
      mem_of_superset (mem_atTop a) fun a' ha' => le_trans ha (hf ha')
#align filter.tendsto_at_top_at_top_of_monotone Filter.tendsto_atTop_atTop_of_monotone

/- warning: filter.tendsto_at_bot_at_bot_of_monotone -> Filter.tendsto_atBot_atBot_of_monotone is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2) (f a) b)) -> (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± _inst_1) (Filter.atBot.{u2} Î² _inst_2))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) (f a) b)) -> (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± _inst_1) (Filter.atBot.{u1} Î² _inst_2))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_at_bot_of_monotone Filter.tendsto_atBot_atBot_of_monotoneâ‚“'. -/
theorem tendsto_atBot_atBot_of_monotone [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hf : Monotone f)
    (h : âˆ€ b, âˆƒ a, f a â‰¤ b) : Tendsto f atBot atBot :=
  tendsto_iInf.2 fun b =>
    tendsto_principal.2 <|
      let âŸ¨a, haâŸ© := h b
      mem_of_superset (mem_atBot a) fun a' ha' => le_trans (hf ha') ha
#align filter.tendsto_at_bot_at_bot_of_monotone Filter.tendsto_atBot_atBot_of_monotone

/- warning: filter.tendsto_at_top_at_top_iff_of_monotone -> Filter.tendsto_atTop_atTop_iff_of_monotone is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (Filter.atTop.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) b (f a))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) (Filter.atTop.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) b (f a))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_at_top_iff_of_monotone Filter.tendsto_atTop_atTop_iff_of_monotoneâ‚“'. -/
theorem tendsto_atTop_atTop_iff_of_monotone [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] {f : Î± â†’ Î²}
    (hf : Monotone f) : Tendsto f atTop atTop â†” âˆ€ b : Î², âˆƒ a : Î±, b â‰¤ f a :=
  tendsto_atTop_atTop.trans <|
    forall_congr' fun b =>
      exists_congr fun a => âŸ¨fun h => h a (le_refl a), fun h a' ha' => le_trans h <| hf ha'âŸ©
#align filter.tendsto_at_top_at_top_iff_of_monotone Filter.tendsto_atTop_atTop_iff_of_monotone

/- warning: filter.tendsto_at_bot_at_bot_iff_of_monotone -> Filter.tendsto_atBot_atBot_iff_of_monotone is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) (Filter.atBot.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) (f a) b)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) (Filter.atBot.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) (f a) b)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_at_bot_iff_of_monotone Filter.tendsto_atBot_atBot_iff_of_monotoneâ‚“'. -/
theorem tendsto_atBot_atBot_iff_of_monotone [Nonempty Î±] [SemilatticeInf Î±] [Preorder Î²] {f : Î± â†’ Î²}
    (hf : Monotone f) : Tendsto f atBot atBot â†” âˆ€ b : Î², âˆƒ a : Î±, f a â‰¤ b :=
  tendsto_atBot_atBot.trans <|
    forall_congr' fun b =>
      exists_congr fun a => âŸ¨fun h => h a (le_refl a), fun h a' ha' => le_trans (hf ha') hâŸ©
#align filter.tendsto_at_bot_at_bot_iff_of_monotone Filter.tendsto_atBot_atBot_iff_of_monotone

/- warning: monotone.tendsto_at_top_at_top -> Monotone.tendsto_atTop_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2) b (f a))) -> (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± _inst_1) (Filter.atTop.{u2} Î² _inst_2))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) b (f a))) -> (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± _inst_1) (Filter.atTop.{u1} Î² _inst_2))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_at_top_at_top Monotone.tendsto_atTop_atTopâ‚“'. -/
alias tendsto_at_top_at_top_of_monotone â† _root_.monotone.tendsto_at_top_at_top
#align monotone.tendsto_at_top_at_top Monotone.tendsto_atTop_atTop

/- warning: monotone.tendsto_at_bot_at_bot -> Monotone.tendsto_atBot_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u1} Î±] [_inst_2 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_2) (f a) b)) -> (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± _inst_1) (Filter.atBot.{u2} Î² _inst_2))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Preorder.{u2} Î±] [_inst_2 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² _inst_1 _inst_2 f) -> (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_2) (f a) b)) -> (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± _inst_1) (Filter.atBot.{u1} Î² _inst_2))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_at_bot_at_bot Monotone.tendsto_atBot_atBotâ‚“'. -/
alias tendsto_at_bot_at_bot_of_monotone â† _root_.monotone.tendsto_at_bot_at_bot
#align monotone.tendsto_at_bot_at_bot Monotone.tendsto_atBot_atBot

/- warning: monotone.tendsto_at_top_at_top_iff -> Monotone.tendsto_atTop_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (Filter.atTop.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) b (f a))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) (Filter.atTop.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) b (f a))))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_at_top_at_top_iff Monotone.tendsto_atTop_atTop_iffâ‚“'. -/
alias tendsto_at_top_at_top_iff_of_monotone â† _root_.monotone.tendsto_at_top_at_top_iff
#align monotone.tendsto_at_top_at_top_iff Monotone.tendsto_atTop_atTop_iff

/- warning: monotone.tendsto_at_bot_at_bot_iff -> Monotone.tendsto_atBot_atBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] {f : Î± -> Î²}, (Monotone.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) (Filter.atBot.{u2} Î² _inst_3)) (forall (b : Î²), Exists.{succ u1} Î± (fun (a : Î±) => LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_3) (f a) b)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] {f : Î± -> Î²}, (Monotone.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2)) _inst_3 f) -> (Iff (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) (Filter.atBot.{u1} Î² _inst_3)) (forall (b : Î²), Exists.{succ u2} Î± (fun (a : Î±) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² _inst_3) (f a) b)))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_at_bot_at_bot_iff Monotone.tendsto_atBot_atBot_iffâ‚“'. -/
alias tendsto_at_bot_at_bot_iff_of_monotone â† _root_.monotone.tendsto_at_bot_at_bot_iff
#align monotone.tendsto_at_bot_at_bot_iff Monotone.tendsto_atBot_atBot_iff

/- warning: filter.comap_embedding_at_top -> Filter.comap_embedding_atTop is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} {Î³ : Type.{u2}} [_inst_1 : Preorder.{u1} Î²] [_inst_2 : Preorder.{u2} Î³] {e : Î² -> Î³}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u2} Î³ (Preorder.toHasLe.{u2} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u1} Î² (Preorder.toHasLe.{u1} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u1} Î² (fun (b : Î²) => LE.le.{u2} Î³ (Preorder.toHasLe.{u2} Î³ _inst_2) c (e b))) -> (Eq.{succ u1} (Filter.{u1} Î²) (Filter.comap.{u1, u2} Î² Î³ e (Filter.atTop.{u2} Î³ _inst_2)) (Filter.atTop.{u1} Î² _inst_1))
but is expected to have type
  forall {Î² : Type.{u2}} {Î³ : Type.{u1}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : Preorder.{u1} Î³] {e : Î² -> Î³}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u1} Î³ (Preorder.toLE.{u1} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u2} Î² (fun (b : Î²) => LE.le.{u1} Î³ (Preorder.toLE.{u1} Î³ _inst_2) c (e b))) -> (Eq.{succ u2} (Filter.{u2} Î²) (Filter.comap.{u2, u1} Î² Î³ e (Filter.atTop.{u1} Î³ _inst_2)) (Filter.atTop.{u2} Î² _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.comap_embedding_at_top Filter.comap_embedding_atTopâ‚“'. -/
theorem comap_embedding_atTop [Preorder Î²] [Preorder Î³] {e : Î² â†’ Î³}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, c â‰¤ e b) : comap e atTop = atTop :=
  le_antisymm
    (le_iInf fun b =>
      le_principal_iff.2 <| mem_comap.2 âŸ¨Ici (e b), mem_atTop _, fun x => (hm _ _).1âŸ©)
    (tendsto_atTop_atTop_of_monotone (fun _ _ => (hm _ _).2) hu).le_comap
#align filter.comap_embedding_at_top Filter.comap_embedding_atTop

/- warning: filter.comap_embedding_at_bot -> Filter.comap_embedding_atBot is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} {Î³ : Type.{u2}} [_inst_1 : Preorder.{u1} Î²] [_inst_2 : Preorder.{u2} Î³] {e : Î² -> Î³}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u2} Î³ (Preorder.toHasLe.{u2} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u1} Î² (Preorder.toHasLe.{u1} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u1} Î² (fun (b : Î²) => LE.le.{u2} Î³ (Preorder.toHasLe.{u2} Î³ _inst_2) (e b) c)) -> (Eq.{succ u1} (Filter.{u1} Î²) (Filter.comap.{u1, u2} Î² Î³ e (Filter.atBot.{u2} Î³ _inst_2)) (Filter.atBot.{u1} Î² _inst_1))
but is expected to have type
  forall {Î² : Type.{u2}} {Î³ : Type.{u1}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : Preorder.{u1} Î³] {e : Î² -> Î³}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u1} Î³ (Preorder.toLE.{u1} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u2} Î² (fun (b : Î²) => LE.le.{u1} Î³ (Preorder.toLE.{u1} Î³ _inst_2) (e b) c)) -> (Eq.{succ u2} (Filter.{u2} Î²) (Filter.comap.{u2, u1} Î² Î³ e (Filter.atBot.{u1} Î³ _inst_2)) (Filter.atBot.{u2} Î² _inst_1))
Case conversion may be inaccurate. Consider using '#align filter.comap_embedding_at_bot Filter.comap_embedding_atBotâ‚“'. -/
theorem comap_embedding_atBot [Preorder Î²] [Preorder Î³] {e : Î² â†’ Î³}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, e b â‰¤ c) : comap e atBot = atBot :=
  @comap_embedding_atTop Î²áµ’áµˆ Î³áµ’áµˆ _ _ e (Function.swap hm) hu
#align filter.comap_embedding_at_bot Filter.comap_embedding_atBot

/- warning: filter.tendsto_at_top_embedding -> Filter.tendsto_atTop_embedding is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : Preorder.{u3} Î³] {f : Î± -> Î²} {e : Î² -> Î³} {l : Filter.{u1} Î±}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u3} Î³ (Preorder.toHasLe.{u3} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u2} Î² (fun (b : Î²) => LE.le.{u3} Î³ (Preorder.toHasLe.{u3} Î³ _inst_2) c (e b))) -> (Iff (Filter.Tendsto.{u1, u3} Î± Î³ (Function.comp.{succ u1, succ u2, succ u3} Î± Î² Î³ e f) l (Filter.atTop.{u3} Î³ _inst_2)) (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atTop.{u2} Î² _inst_1)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u3}} {Î³ : Type.{u2}} [_inst_1 : Preorder.{u3} Î²] [_inst_2 : Preorder.{u2} Î³] {f : Î± -> Î²} {e : Î² -> Î³} {l : Filter.{u1} Î±}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u2} Î³ (Preorder.toLE.{u2} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u3} Î² (Preorder.toLE.{u3} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u3} Î² (fun (b : Î²) => LE.le.{u2} Î³ (Preorder.toLE.{u2} Î³ _inst_2) c (e b))) -> (Iff (Filter.Tendsto.{u1, u2} Î± Î³ (Function.comp.{succ u1, succ u3, succ u2} Î± Î² Î³ e f) l (Filter.atTop.{u2} Î³ _inst_2)) (Filter.Tendsto.{u1, u3} Î± Î² f l (Filter.atTop.{u3} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_embedding Filter.tendsto_atTop_embeddingâ‚“'. -/
theorem tendsto_atTop_embedding [Preorder Î²] [Preorder Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, c â‰¤ e b) :
    Tendsto (e âˆ˜ f) l atTop â†” Tendsto f l atTop := by
  rw [â† comap_embedding_at_top hm hu, tendsto_comap_iff]
#align filter.tendsto_at_top_embedding Filter.tendsto_atTop_embedding

/- warning: filter.tendsto_at_bot_embedding -> Filter.tendsto_atBot_embedding is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : Preorder.{u2} Î²] [_inst_2 : Preorder.{u3} Î³] {f : Î± -> Î²} {e : Î² -> Î³} {l : Filter.{u1} Î±}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u3} Î³ (Preorder.toHasLe.{u3} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u2} Î² (fun (b : Î²) => LE.le.{u3} Î³ (Preorder.toHasLe.{u3} Î³ _inst_2) (e b) c)) -> (Iff (Filter.Tendsto.{u1, u3} Î± Î³ (Function.comp.{succ u1, succ u2, succ u3} Î± Î² Î³ e f) l (Filter.atBot.{u3} Î³ _inst_2)) (Filter.Tendsto.{u1, u2} Î± Î² f l (Filter.atBot.{u2} Î² _inst_1)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u3}} {Î³ : Type.{u2}} [_inst_1 : Preorder.{u3} Î²] [_inst_2 : Preorder.{u2} Î³] {f : Î± -> Î²} {e : Î² -> Î³} {l : Filter.{u1} Î±}, (forall (bâ‚ : Î²) (bâ‚‚ : Î²), Iff (LE.le.{u2} Î³ (Preorder.toLE.{u2} Î³ _inst_2) (e bâ‚) (e bâ‚‚)) (LE.le.{u3} Î² (Preorder.toLE.{u3} Î² _inst_1) bâ‚ bâ‚‚)) -> (forall (c : Î³), Exists.{succ u3} Î² (fun (b : Î²) => LE.le.{u2} Î³ (Preorder.toLE.{u2} Î³ _inst_2) (e b) c)) -> (Iff (Filter.Tendsto.{u1, u2} Î± Î³ (Function.comp.{succ u1, succ u3, succ u2} Î± Î² Î³ e f) l (Filter.atBot.{u2} Î³ _inst_2)) (Filter.Tendsto.{u1, u3} Î± Î² f l (Filter.atBot.{u3} Î² _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_embedding Filter.tendsto_atBot_embeddingâ‚“'. -/
/-- A function `f` goes to `-âˆž` independent of an order-preserving embedding `e`. -/
theorem tendsto_atBot_embedding [Preorder Î²] [Preorder Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, e b â‰¤ c) :
    Tendsto (e âˆ˜ f) l atBot â†” Tendsto f l atBot :=
  @tendsto_atTop_embedding Î± Î²áµ’áµˆ Î³áµ’áµˆ _ _ f e l (Function.swap hm) hu
#align filter.tendsto_at_bot_embedding Filter.tendsto_atBot_embedding

#print Filter.tendsto_finset_range /-
theorem tendsto_finset_range : Tendsto Finset.range atTop atTop :=
  Finset.range_mono.tendsto_atTop_atTop Finset.exists_nat_subset_range
#align filter.tendsto_finset_range Filter.tendsto_finset_range
-/

/- warning: filter.at_top_finset_eq_infi -> Filter.atTop_finset_eq_iInf is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}}, Eq.{succ u1} (Filter.{u1} (Finset.{u1} Î±)) (Filter.atTop.{u1} (Finset.{u1} Î±) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î±) (Finset.partialOrder.{u1} Î±))) (iInf.{u1, succ u1} (Filter.{u1} (Finset.{u1} Î±)) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} (Finset.{u1} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Finset.{u1} Î±)) (Filter.completeLattice.{u1} (Finset.{u1} Î±)))) Î± (fun (x : Î±) => Filter.principal.{u1} (Finset.{u1} Î±) (Set.Ici.{u1} (Finset.{u1} Î±) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î±) (Finset.partialOrder.{u1} Î±)) (Singleton.singleton.{u1, u1} Î± (Finset.{u1} Î±) (Finset.hasSingleton.{u1} Î±) x))))
but is expected to have type
  forall {Î± : Type.{u1}}, Eq.{succ u1} (Filter.{u1} (Finset.{u1} Î±)) (Filter.atTop.{u1} (Finset.{u1} Î±) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î±) (Finset.partialOrder.{u1} Î±))) (iInf.{u1, succ u1} (Filter.{u1} (Finset.{u1} Î±)) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} (Finset.{u1} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Finset.{u1} Î±)) (Filter.instCompleteLatticeFilter.{u1} (Finset.{u1} Î±)))) Î± (fun (x : Î±) => Filter.principal.{u1} (Finset.{u1} Î±) (Set.Ici.{u1} (Finset.{u1} Î±) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î±) (Finset.partialOrder.{u1} Î±)) (Singleton.singleton.{u1, u1} Î± (Finset.{u1} Î±) (Finset.instSingletonFinset.{u1} Î±) x))))
Case conversion may be inaccurate. Consider using '#align filter.at_top_finset_eq_infi Filter.atTop_finset_eq_iInfâ‚“'. -/
theorem atTop_finset_eq_iInf : (atTop : Filter <| Finset Î±) = â¨… x : Î±, ð“Ÿ (Ici {x}) :=
  by
  refine' le_antisymm (le_iInf fun i => le_principal_iff.2 <| mem_at_top {i}) _
  refine'
    le_iInf fun s =>
      le_principal_iff.2 <| mem_infi_of_Inter s.finite_toSet (fun i => mem_principal_self _) _
  simp only [subset_def, mem_Inter, SetCoe.forall, mem_Ici, Finset.le_iff_subset,
    Finset.mem_singleton, Finset.subset_iff, forall_eq]
  dsimp
  exact fun t => id
#align filter.at_top_finset_eq_infi Filter.atTop_finset_eq_iInf

#print Filter.tendsto_atTop_finset_of_monotone /-
/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
theorem tendsto_atTop_finset_of_monotone [Preorder Î²] {f : Î² â†’ Finset Î±} (h : Monotone f)
    (h' : âˆ€ x : Î±, âˆƒ n, x âˆˆ f n) : Tendsto f atTop atTop :=
  by
  simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal]
  intro a
  rcases h' a with âŸ¨b, hbâŸ©
  exact
    eventually.mono (mem_at_top b) fun b' hb' => le_trans (Finset.singleton_subset_iff.2 hb) (h hb')
#align filter.tendsto_at_top_finset_of_monotone Filter.tendsto_atTop_finset_of_monotone
-/

alias tendsto_at_top_finset_of_monotone â† _root_.monotone.tendsto_at_top_finset
#align monotone.tendsto_at_top_finset Monotone.tendsto_atTop_finset

/- warning: filter.tendsto_finset_image_at_top_at_top -> Filter.tendsto_finset_image_atTop_atTop is a dubious translation:
lean 3 declaration is
  forall {Î² : Type.{u1}} {Î³ : Type.{u2}} {i : Î² -> Î³} {j : Î³ -> Î²}, (Function.LeftInverse.{succ u1, succ u2} Î² Î³ j i) -> (Filter.Tendsto.{u2, u1} (Finset.{u2} Î³) (Finset.{u1} Î²) (Finset.image.{u2, u1} Î³ Î² (fun (a : Î²) (b : Î²) => Classical.propDecidable (Eq.{succ u1} Î² a b)) j) (Filter.atTop.{u2} (Finset.{u2} Î³) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î³) (Finset.partialOrder.{u2} Î³))) (Filter.atTop.{u1} (Finset.{u1} Î²) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î²) (Finset.partialOrder.{u1} Î²))))
but is expected to have type
  forall {Î² : Type.{u2}} {Î³ : Type.{u1}} [i : DecidableEq.{succ u2} Î²] {j : Î² -> Î³} {h : Î³ -> Î²}, (Function.LeftInverse.{succ u2, succ u1} Î² Î³ h j) -> (Filter.Tendsto.{u1, u2} (Finset.{u1} Î³) (Finset.{u2} Î²) (Finset.image.{u1, u2} Î³ Î² (fun (a : Î²) (b : Î²) => i a b) h) (Filter.atTop.{u1} (Finset.{u1} Î³) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î³) (Finset.partialOrder.{u1} Î³))) (Filter.atTop.{u2} (Finset.{u2} Î²) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î²) (Finset.partialOrder.{u2} Î²))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_finset_image_at_top_at_top Filter.tendsto_finset_image_atTop_atTopâ‚“'. -/
theorem tendsto_finset_image_atTop_atTop {i : Î² â†’ Î³} {j : Î³ â†’ Î²} (h : Function.LeftInverse j i) :
    Tendsto (Finset.image j) atTop atTop :=
  (Finset.image_mono j).tendsto_atTop_finset fun a =>
    âŸ¨{i a}, by simp only [Finset.image_singleton, h a, Finset.mem_singleton]âŸ©
#align filter.tendsto_finset_image_at_top_at_top Filter.tendsto_finset_image_atTop_atTop

/- warning: filter.tendsto_finset_preimage_at_top_at_top -> Filter.tendsto_finset_preimage_atTop_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {f : Î± -> Î²} (hf : Function.Injective.{succ u1, succ u2} Î± Î² f), Filter.Tendsto.{u2, u1} (Finset.{u2} Î²) (Finset.{u1} Î±) (fun (s : Finset.{u2} Î²) => Finset.preimage.{u1, u2} Î± Î² s f (Function.Injective.injOn.{u1, u2} Î± Î² f hf (Set.preimage.{u1, u2} Î± Î² f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} Î²) (Set.{u2} Î²) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} Î²) (Set.{u2} Î²) (CoeTCâ‚“.coe.{succ u2, succ u2} (Finset.{u2} Î²) (Set.{u2} Î²) (Finset.Set.hasCoeT.{u2} Î²))) s)))) (Filter.atTop.{u2} (Finset.{u2} Î²) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î²) (Finset.partialOrder.{u2} Î²))) (Filter.atTop.{u1} (Finset.{u1} Î±) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î±) (Finset.partialOrder.{u1} Î±)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {f : Î± -> Î²} (hf : Function.Injective.{succ u2, succ u1} Î± Î² f), Filter.Tendsto.{u1, u2} (Finset.{u1} Î²) (Finset.{u2} Î±) (fun (s : Finset.{u1} Î²) => Finset.preimage.{u2, u1} Î± Î² s f (Function.Injective.injOn.{u1, u2} Î± Î² f hf (Set.preimage.{u2, u1} Î± Î² f (Finset.toSet.{u1} Î² s)))) (Filter.atTop.{u1} (Finset.{u1} Î²) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î²) (Finset.partialOrder.{u1} Î²))) (Filter.atTop.{u2} (Finset.{u2} Î±) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î±) (Finset.partialOrder.{u2} Î±)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_finset_preimage_at_top_at_top Filter.tendsto_finset_preimage_atTop_atTopâ‚“'. -/
theorem tendsto_finset_preimage_atTop_atTop {f : Î± â†’ Î²} (hf : Function.Injective f) :
    Tendsto (fun s : Finset Î² => s.Preimage f (hf.InjOn _)) atTop atTop :=
  (Finset.monotone_preimage hf).tendsto_atTop_finset fun x =>
    âŸ¨{f x}, Finset.mem_preimage.2 <| Finset.mem_singleton_self _âŸ©
#align filter.tendsto_finset_preimage_at_top_at_top Filter.tendsto_finset_preimage_atTop_atTop

/- warning: filter.prod_at_top_at_top_eq -> Filter.prod_atTop_atTop_eq is a dubious translation:
lean 3 declaration is
  forall {Î²â‚ : Type.{u1}} {Î²â‚‚ : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î²â‚] [_inst_2 : SemilatticeSup.{u2} Î²â‚‚], Eq.{succ (max u1 u2)} (Filter.{max u1 u2} (Prod.{u1, u2} Î²â‚ Î²â‚‚)) (Filter.prod.{u1, u2} Î²â‚ Î²â‚‚ (Filter.atTop.{u1} Î²â‚ (PartialOrder.toPreorder.{u1} Î²â‚ (SemilatticeSup.toPartialOrder.{u1} Î²â‚ _inst_1))) (Filter.atTop.{u2} Î²â‚‚ (PartialOrder.toPreorder.{u2} Î²â‚‚ (SemilatticeSup.toPartialOrder.{u2} Î²â‚‚ _inst_2)))) (Filter.atTop.{max u1 u2} (Prod.{u1, u2} Î²â‚ Î²â‚‚) (Prod.preorder.{u1, u2} Î²â‚ Î²â‚‚ (PartialOrder.toPreorder.{u1} Î²â‚ (SemilatticeSup.toPartialOrder.{u1} Î²â‚ _inst_1)) (PartialOrder.toPreorder.{u2} Î²â‚‚ (SemilatticeSup.toPartialOrder.{u2} Î²â‚‚ _inst_2))))
but is expected to have type
  forall {Î²â‚ : Type.{u2}} {Î²â‚‚ : Type.{u1}} [_inst_1 : Preorder.{u2} Î²â‚] [_inst_2 : Preorder.{u1} Î²â‚‚], Eq.{max (succ u2) (succ u1)} (Filter.{max u1 u2} (Prod.{u2, u1} Î²â‚ Î²â‚‚)) (Filter.prod.{u2, u1} Î²â‚ Î²â‚‚ (Filter.atTop.{u2} Î²â‚ _inst_1) (Filter.atTop.{u1} Î²â‚‚ _inst_2)) (Filter.atTop.{max u2 u1} (Prod.{u2, u1} Î²â‚ Î²â‚‚) (Prod.instPreorderProd.{u2, u1} Î²â‚ Î²â‚‚ _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align filter.prod_at_top_at_top_eq Filter.prod_atTop_atTop_eqâ‚“'. -/
theorem prod_atTop_atTop_eq {Î²â‚ Î²â‚‚ : Type _} [SemilatticeSup Î²â‚] [SemilatticeSup Î²â‚‚] :
    (atTop : Filter Î²â‚) Ã—á¶  (atTop : Filter Î²â‚‚) = (atTop : Filter (Î²â‚ Ã— Î²â‚‚)) :=
  by
  cases (isEmpty_or_nonempty Î²â‚).symm
  cases (isEmpty_or_nonempty Î²â‚‚).symm
  Â· simp [at_top, prod_infi_left, prod_infi_right, iInf_prod]
    exact iInf_comm
  Â· simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]
  Â· simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]
#align filter.prod_at_top_at_top_eq Filter.prod_atTop_atTop_eq

/- warning: filter.prod_at_bot_at_bot_eq -> Filter.prod_atBot_atBot_eq is a dubious translation:
lean 3 declaration is
  forall {Î²â‚ : Type.{u1}} {Î²â‚‚ : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î²â‚] [_inst_2 : SemilatticeInf.{u2} Î²â‚‚], Eq.{succ (max u1 u2)} (Filter.{max u1 u2} (Prod.{u1, u2} Î²â‚ Î²â‚‚)) (Filter.prod.{u1, u2} Î²â‚ Î²â‚‚ (Filter.atBot.{u1} Î²â‚ (PartialOrder.toPreorder.{u1} Î²â‚ (SemilatticeInf.toPartialOrder.{u1} Î²â‚ _inst_1))) (Filter.atBot.{u2} Î²â‚‚ (PartialOrder.toPreorder.{u2} Î²â‚‚ (SemilatticeInf.toPartialOrder.{u2} Î²â‚‚ _inst_2)))) (Filter.atBot.{max u1 u2} (Prod.{u1, u2} Î²â‚ Î²â‚‚) (Prod.preorder.{u1, u2} Î²â‚ Î²â‚‚ (PartialOrder.toPreorder.{u1} Î²â‚ (SemilatticeInf.toPartialOrder.{u1} Î²â‚ _inst_1)) (PartialOrder.toPreorder.{u2} Î²â‚‚ (SemilatticeInf.toPartialOrder.{u2} Î²â‚‚ _inst_2))))
but is expected to have type
  forall {Î²â‚ : Type.{u2}} {Î²â‚‚ : Type.{u1}} [_inst_1 : Preorder.{u2} Î²â‚] [_inst_2 : Preorder.{u1} Î²â‚‚], Eq.{max (succ u2) (succ u1)} (Filter.{max u1 u2} (Prod.{u2, u1} Î²â‚ Î²â‚‚)) (Filter.prod.{u2, u1} Î²â‚ Î²â‚‚ (Filter.atBot.{u2} Î²â‚ _inst_1) (Filter.atBot.{u1} Î²â‚‚ _inst_2)) (Filter.atBot.{max u2 u1} (Prod.{u2, u1} Î²â‚ Î²â‚‚) (Prod.instPreorderProd.{u2, u1} Î²â‚ Î²â‚‚ _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align filter.prod_at_bot_at_bot_eq Filter.prod_atBot_atBot_eqâ‚“'. -/
theorem prod_atBot_atBot_eq {Î²â‚ Î²â‚‚ : Type _} [SemilatticeInf Î²â‚] [SemilatticeInf Î²â‚‚] :
    (atBot : Filter Î²â‚) Ã—á¶  (atBot : Filter Î²â‚‚) = (atBot : Filter (Î²â‚ Ã— Î²â‚‚)) :=
  @prod_atTop_atTop_eq Î²â‚áµ’áµˆ Î²â‚‚áµ’áµˆ _ _
#align filter.prod_at_bot_at_bot_eq Filter.prod_atBot_atBot_eq

/- warning: filter.prod_map_at_top_eq -> Filter.prod_map_atTop_eq is a dubious translation:
lean 3 declaration is
  forall {Î±â‚ : Type.{u1}} {Î±â‚‚ : Type.{u2}} {Î²â‚ : Type.{u3}} {Î²â‚‚ : Type.{u4}} [_inst_1 : SemilatticeSup.{u3} Î²â‚] [_inst_2 : SemilatticeSup.{u4} Î²â‚‚] (uâ‚ : Î²â‚ -> Î±â‚) (uâ‚‚ : Î²â‚‚ -> Î±â‚‚), Eq.{succ (max u1 u2)} (Filter.{max u1 u2} (Prod.{u1, u2} Î±â‚ Î±â‚‚)) (Filter.prod.{u1, u2} Î±â‚ Î±â‚‚ (Filter.map.{u3, u1} Î²â‚ Î±â‚ uâ‚ (Filter.atTop.{u3} Î²â‚ (PartialOrder.toPreorder.{u3} Î²â‚ (SemilatticeSup.toPartialOrder.{u3} Î²â‚ _inst_1)))) (Filter.map.{u4, u2} Î²â‚‚ Î±â‚‚ uâ‚‚ (Filter.atTop.{u4} Î²â‚‚ (PartialOrder.toPreorder.{u4} Î²â‚‚ (SemilatticeSup.toPartialOrder.{u4} Î²â‚‚ _inst_2))))) (Filter.map.{max u3 u4, max u1 u2} (Prod.{u3, u4} Î²â‚ Î²â‚‚) (Prod.{u1, u2} Î±â‚ Î±â‚‚) (Prod.map.{u3, u1, u4, u2} Î²â‚ Î±â‚ Î²â‚‚ Î±â‚‚ uâ‚ uâ‚‚) (Filter.atTop.{max u3 u4} (Prod.{u3, u4} Î²â‚ Î²â‚‚) (Prod.preorder.{u3, u4} Î²â‚ Î²â‚‚ (PartialOrder.toPreorder.{u3} Î²â‚ (SemilatticeSup.toPartialOrder.{u3} Î²â‚ _inst_1)) (PartialOrder.toPreorder.{u4} Î²â‚‚ (SemilatticeSup.toPartialOrder.{u4} Î²â‚‚ _inst_2)))))
but is expected to have type
  forall {Î±â‚ : Type.{u4}} {Î±â‚‚ : Type.{u3}} {Î²â‚ : Type.{u2}} {Î²â‚‚ : Type.{u1}} [_inst_1 : Preorder.{u2} Î²â‚] [_inst_2 : Preorder.{u1} Î²â‚‚] (uâ‚ : Î²â‚ -> Î±â‚) (uâ‚‚ : Î²â‚‚ -> Î±â‚‚), Eq.{max (succ u4) (succ u3)} (Filter.{max u3 u4} (Prod.{u4, u3} Î±â‚ Î±â‚‚)) (Filter.prod.{u4, u3} Î±â‚ Î±â‚‚ (Filter.map.{u2, u4} Î²â‚ Î±â‚ uâ‚ (Filter.atTop.{u2} Î²â‚ _inst_1)) (Filter.map.{u1, u3} Î²â‚‚ Î±â‚‚ uâ‚‚ (Filter.atTop.{u1} Î²â‚‚ _inst_2))) (Filter.map.{max u1 u2, max u3 u4} (Prod.{u2, u1} Î²â‚ Î²â‚‚) (Prod.{u4, u3} Î±â‚ Î±â‚‚) (Prod.map.{u2, u4, u1, u3} Î²â‚ Î±â‚ Î²â‚‚ Î±â‚‚ uâ‚ uâ‚‚) (Filter.atTop.{max u2 u1} (Prod.{u2, u1} Î²â‚ Î²â‚‚) (Prod.instPreorderProd.{u2, u1} Î²â‚ Î²â‚‚ _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.prod_map_at_top_eq Filter.prod_map_atTop_eqâ‚“'. -/
theorem prod_map_atTop_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type _} [SemilatticeSup Î²â‚] [SemilatticeSup Î²â‚‚]
    (uâ‚ : Î²â‚ â†’ Î±â‚) (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) : map uâ‚ atTop Ã—á¶  map uâ‚‚ atTop = map (Prod.map uâ‚ uâ‚‚) atTop := by
  rw [prod_map_map_eq, prod_at_top_at_top_eq, Prod.map_def]
#align filter.prod_map_at_top_eq Filter.prod_map_atTop_eq

/- warning: filter.prod_map_at_bot_eq -> Filter.prod_map_atBot_eq is a dubious translation:
lean 3 declaration is
  forall {Î±â‚ : Type.{u1}} {Î±â‚‚ : Type.{u2}} {Î²â‚ : Type.{u3}} {Î²â‚‚ : Type.{u4}} [_inst_1 : SemilatticeInf.{u3} Î²â‚] [_inst_2 : SemilatticeInf.{u4} Î²â‚‚] (uâ‚ : Î²â‚ -> Î±â‚) (uâ‚‚ : Î²â‚‚ -> Î±â‚‚), Eq.{succ (max u1 u2)} (Filter.{max u1 u2} (Prod.{u1, u2} Î±â‚ Î±â‚‚)) (Filter.prod.{u1, u2} Î±â‚ Î±â‚‚ (Filter.map.{u3, u1} Î²â‚ Î±â‚ uâ‚ (Filter.atBot.{u3} Î²â‚ (PartialOrder.toPreorder.{u3} Î²â‚ (SemilatticeInf.toPartialOrder.{u3} Î²â‚ _inst_1)))) (Filter.map.{u4, u2} Î²â‚‚ Î±â‚‚ uâ‚‚ (Filter.atBot.{u4} Î²â‚‚ (PartialOrder.toPreorder.{u4} Î²â‚‚ (SemilatticeInf.toPartialOrder.{u4} Î²â‚‚ _inst_2))))) (Filter.map.{max u3 u4, max u1 u2} (Prod.{u3, u4} Î²â‚ Î²â‚‚) (Prod.{u1, u2} Î±â‚ Î±â‚‚) (Prod.map.{u3, u1, u4, u2} Î²â‚ Î±â‚ Î²â‚‚ Î±â‚‚ uâ‚ uâ‚‚) (Filter.atBot.{max u3 u4} (Prod.{u3, u4} Î²â‚ Î²â‚‚) (Prod.preorder.{u3, u4} Î²â‚ Î²â‚‚ (PartialOrder.toPreorder.{u3} Î²â‚ (SemilatticeInf.toPartialOrder.{u3} Î²â‚ _inst_1)) (PartialOrder.toPreorder.{u4} Î²â‚‚ (SemilatticeInf.toPartialOrder.{u4} Î²â‚‚ _inst_2)))))
but is expected to have type
  forall {Î±â‚ : Type.{u4}} {Î±â‚‚ : Type.{u3}} {Î²â‚ : Type.{u2}} {Î²â‚‚ : Type.{u1}} [_inst_1 : Preorder.{u2} Î²â‚] [_inst_2 : Preorder.{u1} Î²â‚‚] (uâ‚ : Î²â‚ -> Î±â‚) (uâ‚‚ : Î²â‚‚ -> Î±â‚‚), Eq.{max (succ u4) (succ u3)} (Filter.{max u3 u4} (Prod.{u4, u3} Î±â‚ Î±â‚‚)) (Filter.prod.{u4, u3} Î±â‚ Î±â‚‚ (Filter.map.{u2, u4} Î²â‚ Î±â‚ uâ‚ (Filter.atBot.{u2} Î²â‚ _inst_1)) (Filter.map.{u1, u3} Î²â‚‚ Î±â‚‚ uâ‚‚ (Filter.atBot.{u1} Î²â‚‚ _inst_2))) (Filter.map.{max u1 u2, max u3 u4} (Prod.{u2, u1} Î²â‚ Î²â‚‚) (Prod.{u4, u3} Î±â‚ Î±â‚‚) (Prod.map.{u2, u4, u1, u3} Î²â‚ Î±â‚ Î²â‚‚ Î±â‚‚ uâ‚ uâ‚‚) (Filter.atBot.{max u2 u1} (Prod.{u2, u1} Î²â‚ Î²â‚‚) (Prod.instPreorderProd.{u2, u1} Î²â‚ Î²â‚‚ _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.prod_map_at_bot_eq Filter.prod_map_atBot_eqâ‚“'. -/
theorem prod_map_atBot_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type _} [SemilatticeInf Î²â‚] [SemilatticeInf Î²â‚‚]
    (uâ‚ : Î²â‚ â†’ Î±â‚) (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) : map uâ‚ atBot Ã—á¶  map uâ‚‚ atBot = map (Prod.map uâ‚ uâ‚‚) atBot :=
  @prod_map_atTop_eq _ _ Î²â‚áµ’áµˆ Î²â‚‚áµ’áµˆ _ _ _ _
#align filter.prod_map_at_bot_eq Filter.prod_map_atBot_eq

#print Filter.Tendsto.subseq_mem /-
theorem Tendsto.subseq_mem {F : Filter Î±} {V : â„• â†’ Set Î±} (h : âˆ€ n, V n âˆˆ F) {u : â„• â†’ Î±}
    (hu : Tendsto u atTop F) : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, u (Ï† n) âˆˆ V n :=
  extraction_forall_of_eventually'
    (fun n => tendsto_atTop'.mp hu _ (h n) : âˆ€ n, âˆƒ N, âˆ€ k â‰¥ N, u k âˆˆ V n)
#align filter.tendsto.subseq_mem Filter.Tendsto.subseq_mem
-/

/- warning: filter.tendsto_at_bot_diagonal -> Filter.tendsto_atBot_diagonal is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±], Filter.Tendsto.{u1, u1} Î± (Prod.{u1, u1} Î± Î±) (fun (a : Î±) => Prod.mk.{u1, u1} Î± Î± a a) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) (Filter.atBot.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±], Filter.Tendsto.{u1, u1} Î± (Prod.{u1, u1} Î± Î±) (fun (a : Î±) => Prod.mk.{u1, u1} Î± Î± a a) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) (Filter.atBot.{u1} (Prod.{u1, u1} Î± Î±) (Prod.instPreorderProd.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_diagonal Filter.tendsto_atBot_diagonalâ‚“'. -/
theorem tendsto_atBot_diagonal [SemilatticeInf Î±] : Tendsto (fun a : Î± => (a, a)) atBot atBot :=
  by
  rw [â† prod_at_bot_at_bot_eq]
  exact tendsto_id.prod_mk tendsto_id
#align filter.tendsto_at_bot_diagonal Filter.tendsto_atBot_diagonal

/- warning: filter.tendsto_at_top_diagonal -> Filter.tendsto_atTop_diagonal is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±], Filter.Tendsto.{u1, u1} Î± (Prod.{u1, u1} Î± Î±) (fun (a : Î±) => Prod.mk.{u1, u1} Î± Î± a a) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±], Filter.Tendsto.{u1, u1} Î± (Prod.{u1, u1} Î± Î±) (fun (a : Î±) => Prod.mk.{u1, u1} Î± Î± a a) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u1} (Prod.{u1, u1} Î± Î±) (Prod.instPreorderProd.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_diagonal Filter.tendsto_atTop_diagonalâ‚“'. -/
theorem tendsto_atTop_diagonal [SemilatticeSup Î±] : Tendsto (fun a : Î± => (a, a)) atTop atTop :=
  by
  rw [â† prod_at_top_at_top_eq]
  exact tendsto_id.prod_mk tendsto_id
#align filter.tendsto_at_top_diagonal Filter.tendsto_atTop_diagonal

/- warning: filter.tendsto.prod_map_prod_at_bot -> Filter.Tendsto.prod_map_prod_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : SemilatticeInf.{u3} Î³] {F : Filter.{u1} Î±} {G : Filter.{u2} Î²} {f : Î± -> Î³} {g : Î² -> Î³}, (Filter.Tendsto.{u1, u3} Î± Î³ f F (Filter.atBot.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{u2, u3} Î² Î³ g G (Filter.atBot.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{max u1 u2, u3} (Prod.{u1, u2} Î± Î²) (Prod.{u3, u3} Î³ Î³) (Prod.map.{u1, u3, u2, u3} Î± Î³ Î² Î³ f g) (Filter.prod.{u1, u2} Î± Î² F G) (Filter.atBot.{u3} (Prod.{u3, u3} Î³ Î³) (Prod.preorder.{u3, u3} Î³ Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)) (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {Î³ : Type.{u3}} [_inst_1 : SemilatticeInf.{u3} Î³] {F : Filter.{u2} Î±} {G : Filter.{u1} Î²} {f : Î± -> Î³} {g : Î² -> Î³}, (Filter.Tendsto.{u2, u3} Î± Î³ f F (Filter.atBot.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{u1, u3} Î² Î³ g G (Filter.atBot.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{max u1 u2, u3} (Prod.{u2, u1} Î± Î²) (Prod.{u3, u3} Î³ Î³) (Prod.map.{u2, u3, u1, u3} Î± Î³ Î² Î³ f g) (Filter.prod.{u2, u1} Î± Î² F G) (Filter.atBot.{u3} (Prod.{u3, u3} Î³ Î³) (Prod.instPreorderProd.{u3, u3} Î³ Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)) (PartialOrder.toPreorder.{u3} Î³ (SemilatticeInf.toPartialOrder.{u3} Î³ _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.prod_map_prod_at_bot Filter.Tendsto.prod_map_prod_atBotâ‚“'. -/
theorem Tendsto.prod_map_prod_atBot [SemilatticeInf Î³] {F : Filter Î±} {G : Filter Î²} {f : Î± â†’ Î³}
    {g : Î² â†’ Î³} (hf : Tendsto f F atBot) (hg : Tendsto g G atBot) :
    Tendsto (Prod.map f g) (F Ã—á¶  G) atBot :=
  by
  rw [â† prod_at_bot_at_bot_eq]
  exact hf.prod_map hg
#align filter.tendsto.prod_map_prod_at_bot Filter.Tendsto.prod_map_prod_atBot

/- warning: filter.tendsto.prod_map_prod_at_top -> Filter.Tendsto.prod_map_prod_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} Î³] {F : Filter.{u1} Î±} {G : Filter.{u2} Î²} {f : Î± -> Î³} {g : Î² -> Î³}, (Filter.Tendsto.{u1, u3} Î± Î³ f F (Filter.atTop.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{u2, u3} Î² Î³ g G (Filter.atTop.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{max u1 u2, u3} (Prod.{u1, u2} Î± Î²) (Prod.{u3, u3} Î³ Î³) (Prod.map.{u1, u3, u2, u3} Î± Î³ Î² Î³ f g) (Filter.prod.{u1, u2} Î± Î² F G) (Filter.atTop.{u3} (Prod.{u3, u3} Î³ Î³) (Prod.preorder.{u3, u3} Î³ Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)) (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {Î³ : Type.{u3}} [_inst_1 : SemilatticeSup.{u3} Î³] {F : Filter.{u2} Î±} {G : Filter.{u1} Î²} {f : Î± -> Î³} {g : Î² -> Î³}, (Filter.Tendsto.{u2, u3} Î± Î³ f F (Filter.atTop.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{u1, u3} Î² Î³ g G (Filter.atTop.{u3} Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)))) -> (Filter.Tendsto.{max u1 u2, u3} (Prod.{u2, u1} Î± Î²) (Prod.{u3, u3} Î³ Î³) (Prod.map.{u2, u3, u1, u3} Î± Î³ Î² Î³ f g) (Filter.prod.{u2, u1} Î± Î² F G) (Filter.atTop.{u3} (Prod.{u3, u3} Î³ Î³) (Prod.instPreorderProd.{u3, u3} Î³ Î³ (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)) (PartialOrder.toPreorder.{u3} Î³ (SemilatticeSup.toPartialOrder.{u3} Î³ _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.prod_map_prod_at_top Filter.Tendsto.prod_map_prod_atTopâ‚“'. -/
theorem Tendsto.prod_map_prod_atTop [SemilatticeSup Î³] {F : Filter Î±} {G : Filter Î²} {f : Î± â†’ Î³}
    {g : Î² â†’ Î³} (hf : Tendsto f F atTop) (hg : Tendsto g G atTop) :
    Tendsto (Prod.map f g) (F Ã—á¶  G) atTop :=
  by
  rw [â† prod_at_top_at_top_eq]
  exact hf.prod_map hg
#align filter.tendsto.prod_map_prod_at_top Filter.Tendsto.prod_map_prod_atTop

/- warning: filter.tendsto.prod_at_bot -> Filter.Tendsto.prod_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î³ : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : SemilatticeInf.{u2} Î³] {f : Î± -> Î³} {g : Î± -> Î³}, (Filter.Tendsto.{u1, u2} Î± Î³ f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) (Filter.atBot.{u2} Î³ (PartialOrder.toPreorder.{u2} Î³ (SemilatticeInf.toPartialOrder.{u2} Î³ _inst_2)))) -> (Filter.Tendsto.{u1, u2} Î± Î³ g (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) (Filter.atBot.{u2} Î³ (PartialOrder.toPreorder.{u2} Î³ (SemilatticeInf.toPartialOrder.{u2} Î³ _inst_2)))) -> (Filter.Tendsto.{u1, u2} (Prod.{u1, u1} Î± Î±) (Prod.{u2, u2} Î³ Î³) (Prod.map.{u1, u2, u1, u2} Î± Î³ Î± Î³ f g) (Filter.atBot.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (Filter.atBot.{u2} (Prod.{u2, u2} Î³ Î³) (Prod.preorder.{u2, u2} Î³ Î³ (PartialOrder.toPreorder.{u2} Î³ (SemilatticeInf.toPartialOrder.{u2} Î³ _inst_2)) (PartialOrder.toPreorder.{u2} Î³ (SemilatticeInf.toPartialOrder.{u2} Î³ _inst_2)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î³ : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] [_inst_2 : SemilatticeInf.{u1} Î³] {f : Î± -> Î³} {g : Î± -> Î³}, (Filter.Tendsto.{u2, u1} Î± Î³ f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))) (Filter.atBot.{u1} Î³ (PartialOrder.toPreorder.{u1} Î³ (SemilatticeInf.toPartialOrder.{u1} Î³ _inst_2)))) -> (Filter.Tendsto.{u2, u1} Î± Î³ g (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))) (Filter.atBot.{u1} Î³ (PartialOrder.toPreorder.{u1} Î³ (SemilatticeInf.toPartialOrder.{u1} Î³ _inst_2)))) -> (Filter.Tendsto.{u2, u1} (Prod.{u2, u2} Î± Î±) (Prod.{u1, u1} Î³ Î³) (Prod.map.{u2, u1, u2, u1} Î± Î³ Î± Î³ f g) (Filter.atBot.{u2} (Prod.{u2, u2} Î± Î±) (Prod.instPreorderProd.{u2, u2} Î± Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)))) (Filter.atBot.{u1} (Prod.{u1, u1} Î³ Î³) (Prod.instPreorderProd.{u1, u1} Î³ Î³ (PartialOrder.toPreorder.{u1} Î³ (SemilatticeInf.toPartialOrder.{u1} Î³ _inst_2)) (PartialOrder.toPreorder.{u1} Î³ (SemilatticeInf.toPartialOrder.{u1} Î³ _inst_2)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.prod_at_bot Filter.Tendsto.prod_atBotâ‚“'. -/
theorem Tendsto.prod_atBot [SemilatticeInf Î±] [SemilatticeInf Î³] {f g : Î± â†’ Î³}
    (hf : Tendsto f atBot atBot) (hg : Tendsto g atBot atBot) :
    Tendsto (Prod.map f g) atBot atBot :=
  by
  rw [â† prod_at_bot_at_bot_eq]
  exact hf.prod_map_prod_at_bot hg
#align filter.tendsto.prod_at_bot Filter.Tendsto.prod_atBot

/- warning: filter.tendsto.prod_at_top -> Filter.Tendsto.prod_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î³ : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : SemilatticeSup.{u2} Î³] {f : Î± -> Î³} {g : Î± -> Î³}, (Filter.Tendsto.{u1, u2} Î± Î³ f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u2} Î³ (PartialOrder.toPreorder.{u2} Î³ (SemilatticeSup.toPartialOrder.{u2} Î³ _inst_2)))) -> (Filter.Tendsto.{u1, u2} Î± Î³ g (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) (Filter.atTop.{u2} Î³ (PartialOrder.toPreorder.{u2} Î³ (SemilatticeSup.toPartialOrder.{u2} Î³ _inst_2)))) -> (Filter.Tendsto.{u1, u2} (Prod.{u1, u1} Î± Î±) (Prod.{u2, u2} Î³ Î³) (Prod.map.{u1, u2, u1, u2} Î± Î³ Î± Î³ f g) (Filter.atTop.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (Filter.atTop.{u2} (Prod.{u2, u2} Î³ Î³) (Prod.preorder.{u2, u2} Î³ Î³ (PartialOrder.toPreorder.{u2} Î³ (SemilatticeSup.toPartialOrder.{u2} Î³ _inst_2)) (PartialOrder.toPreorder.{u2} Î³ (SemilatticeSup.toPartialOrder.{u2} Î³ _inst_2)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î³ : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : SemilatticeSup.{u1} Î³] {f : Î± -> Î³} {g : Î± -> Î³}, (Filter.Tendsto.{u2, u1} Î± Î³ f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) (Filter.atTop.{u1} Î³ (PartialOrder.toPreorder.{u1} Î³ (SemilatticeSup.toPartialOrder.{u1} Î³ _inst_2)))) -> (Filter.Tendsto.{u2, u1} Î± Î³ g (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) (Filter.atTop.{u1} Î³ (PartialOrder.toPreorder.{u1} Î³ (SemilatticeSup.toPartialOrder.{u1} Î³ _inst_2)))) -> (Filter.Tendsto.{u2, u1} (Prod.{u2, u2} Î± Î±) (Prod.{u1, u1} Î³ Î³) (Prod.map.{u2, u1, u2, u1} Î± Î³ Î± Î³ f g) (Filter.atTop.{u2} (Prod.{u2, u2} Î± Î±) (Prod.instPreorderProd.{u2, u2} Î± Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)))) (Filter.atTop.{u1} (Prod.{u1, u1} Î³ Î³) (Prod.instPreorderProd.{u1, u1} Î³ Î³ (PartialOrder.toPreorder.{u1} Î³ (SemilatticeSup.toPartialOrder.{u1} Î³ _inst_2)) (PartialOrder.toPreorder.{u1} Î³ (SemilatticeSup.toPartialOrder.{u1} Î³ _inst_2)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.prod_at_top Filter.Tendsto.prod_atTopâ‚“'. -/
theorem Tendsto.prod_atTop [SemilatticeSup Î±] [SemilatticeSup Î³] {f g : Î± â†’ Î³}
    (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :
    Tendsto (Prod.map f g) atTop atTop :=
  by
  rw [â† prod_at_top_at_top_eq]
  exact hf.prod_map_prod_at_top hg
#align filter.tendsto.prod_at_top Filter.Tendsto.prod_atTop

/- warning: filter.eventually_at_bot_prod_self -> Filter.eventually_atBot_prod_self is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atBot.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±) (l : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) k a) -> (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) l a) -> (p (Prod.mk.{u1, u1} Î± Î± k l))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atBot.{u1} (Prod.{u1, u1} Î± Î±) (Prod.instPreorderProd.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±) (l : Î±), (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) k a) -> (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) l a) -> (p (Prod.mk.{u1, u1} Î± Î± k l))))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_bot_prod_self Filter.eventually_atBot_prod_selfâ‚“'. -/
theorem eventually_atBot_prod_self [SemilatticeInf Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
    (âˆ€á¶  x in atBot, p x) â†” âˆƒ a, âˆ€ k l, k â‰¤ a â†’ l â‰¤ a â†’ p (k, l) := by
  simp [â† prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]
#align filter.eventually_at_bot_prod_self Filter.eventually_atBot_prod_self

/- warning: filter.eventually_at_top_prod_self -> Filter.eventually_atTop_prod_self is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atTop.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±) (l : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a k) -> (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a l) -> (p (Prod.mk.{u1, u1} Î± Î± k l))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atTop.{u1} (Prod.{u1, u1} Î± Î±) (Prod.instPreorderProd.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±) (l : Î±), (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a k) -> (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a l) -> (p (Prod.mk.{u1, u1} Î± Î± k l))))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_top_prod_self Filter.eventually_atTop_prod_selfâ‚“'. -/
theorem eventually_atTop_prod_self [SemilatticeSup Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
    (âˆ€á¶  x in atTop, p x) â†” âˆƒ a, âˆ€ k l, a â‰¤ k â†’ a â‰¤ l â†’ p (k, l) := by
  simp [â† prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]
#align filter.eventually_at_top_prod_self Filter.eventually_atTop_prod_self

/- warning: filter.eventually_at_bot_prod_self' -> Filter.eventually_atBot_prod_self' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atBot.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) k a) -> (forall (l : Î±), (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) l a) -> (p (Prod.mk.{u1, u1} Î± Î± k l)))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atBot.{u1} (Prod.{u1, u1} Î± Î±) (Prod.instPreorderProd.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±), (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) k a) -> (forall (l : Î±), (LE.le.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) l a) -> (p (Prod.mk.{u1, u1} Î± Î± k l)))))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_bot_prod_self' Filter.eventually_atBot_prod_self'â‚“'. -/
theorem eventually_atBot_prod_self' [SemilatticeInf Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
    (âˆ€á¶  x in atBot, p x) â†” âˆƒ a, âˆ€ k â‰¤ a, âˆ€ l â‰¤ a, p (k, l) :=
  by
  rw [Filter.eventually_atBot_prod_self]
  apply exists_congr
  tauto
#align filter.eventually_at_bot_prod_self' Filter.eventually_atBot_prod_self'

/- warning: filter.eventually_at_top_prod_self' -> Filter.eventually_atTop_prod_self' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atTop.{u1} (Prod.{u1, u1} Î± Î±) (Prod.preorder.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±), (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) k a) -> (forall (l : Î±), (GE.ge.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) l a) -> (p (Prod.mk.{u1, u1} Î± Î± k l)))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : Nonempty.{succ u1} Î±] {p : (Prod.{u1, u1} Î± Î±) -> Prop}, Iff (Filter.Eventually.{u1} (Prod.{u1, u1} Î± Î±) (fun (x : Prod.{u1, u1} Î± Î±) => p x) (Filter.atTop.{u1} (Prod.{u1, u1} Î± Î±) (Prod.instPreorderProd.{u1, u1} Î± Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))) (Exists.{succ u1} Î± (fun (a : Î±) => forall (k : Î±), (GE.ge.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) k a) -> (forall (l : Î±), (GE.ge.{u1} Î± (Preorder.toLE.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) l a) -> (p (Prod.mk.{u1, u1} Î± Î± k l)))))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_top_prod_self' Filter.eventually_atTop_prod_self'â‚“'. -/
theorem eventually_atTop_prod_self' [SemilatticeSup Î±] [Nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
    (âˆ€á¶  x in atTop, p x) â†” âˆƒ a, âˆ€ k â‰¥ a, âˆ€ l â‰¥ a, p (k, l) :=
  by
  rw [Filter.eventually_atTop_prod_self]
  apply exists_congr
  tauto
#align filter.eventually_at_top_prod_self' Filter.eventually_atTop_prod_self'

/- warning: filter.eventually_at_top_curry -> Filter.eventually_atTop_curry is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : SemilatticeSup.{u2} Î²] {p : (Prod.{u1, u2} Î± Î²) -> Prop}, (Filter.Eventually.{max u1 u2} (Prod.{u1, u2} Î± Î²) (fun (x : Prod.{u1, u2} Î± Î²) => p x) (Filter.atTop.{max u1 u2} (Prod.{u1, u2} Î± Î²) (Prod.preorder.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))))) -> (Filter.Eventually.{u1} Î± (fun (k : Î±) => Filter.Eventually.{u2} Î² (fun (l : Î²) => p (Prod.mk.{u1, u2} Î± Î² k l)) (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : SemilatticeSup.{u1} Î²] {p : (Prod.{u2, u1} Î± Î²) -> Prop}, (Filter.Eventually.{max u2 u1} (Prod.{u2, u1} Î± Î²) (fun (x : Prod.{u2, u1} Î± Î²) => p x) (Filter.atTop.{max u2 u1} (Prod.{u2, u1} Î± Î²) (Prod.instPreorderProd.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2))))) -> (Filter.Eventually.{u2} Î± (fun (k : Î±) => Filter.Eventually.{u1} Î² (fun (l : Î²) => p (Prod.mk.{u2, u1} Î± Î² k l)) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2)))) (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_top_curry Filter.eventually_atTop_curryâ‚“'. -/
theorem eventually_atTop_curry [SemilatticeSup Î±] [SemilatticeSup Î²] {p : Î± Ã— Î² â†’ Prop}
    (hp : âˆ€á¶  x : Î± Ã— Î² in Filter.atTop, p x) : âˆ€á¶  k in atTop, âˆ€á¶  l in atTop, p (k, l) :=
  by
  rw [â† prod_at_top_at_top_eq] at hp
  exact hp.curry
#align filter.eventually_at_top_curry Filter.eventually_atTop_curry

/- warning: filter.eventually_at_bot_curry -> Filter.eventually_atBot_curry is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : SemilatticeInf.{u2} Î²] {p : (Prod.{u1, u2} Î± Î²) -> Prop}, (Filter.Eventually.{max u1 u2} (Prod.{u1, u2} Î± Î²) (fun (x : Prod.{u1, u2} Î± Î²) => p x) (Filter.atBot.{max u1 u2} (Prod.{u1, u2} Î± Î²) (Prod.preorder.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))))) -> (Filter.Eventually.{u1} Î± (fun (k : Î±) => Filter.Eventually.{u2} Î² (fun (l : Î²) => p (Prod.mk.{u1, u2} Î± Î² k l)) (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2)))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] [_inst_2 : SemilatticeInf.{u1} Î²] {p : (Prod.{u2, u1} Î± Î²) -> Prop}, (Filter.Eventually.{max u2 u1} (Prod.{u2, u1} Î± Î²) (fun (x : Prod.{u2, u1} Î± Î²) => p x) (Filter.atBot.{max u2 u1} (Prod.{u2, u1} Î± Î²) (Prod.instPreorderProd.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2))))) -> (Filter.Eventually.{u2} Î± (fun (k : Î±) => Filter.Eventually.{u1} Î² (fun (l : Î²) => p (Prod.mk.{u2, u1} Î± Î² k l)) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2)))) (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.eventually_at_bot_curry Filter.eventually_atBot_curryâ‚“'. -/
theorem eventually_atBot_curry [SemilatticeInf Î±] [SemilatticeInf Î²] {p : Î± Ã— Î² â†’ Prop}
    (hp : âˆ€á¶  x : Î± Ã— Î² in Filter.atBot, p x) : âˆ€á¶  k in atBot, âˆ€á¶  l in atBot, p (k, l) :=
  @eventually_atTop_curry Î±áµ’áµˆ Î²áµ’áµˆ _ _ _ hp
#align filter.eventually_at_bot_curry Filter.eventually_atBot_curry

/- warning: filter.map_at_top_eq_of_gc -> Filter.map_atTop_eq_of_gc is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : SemilatticeSup.{u2} Î²] {f : Î± -> Î²} (g : Î² -> Î±) (b' : Î²), (Monotone.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2)) f) -> (forall (a : Î±) (b : Î²), (GE.ge.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) b b') -> (Iff (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) (f a) b) (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) a (g b)))) -> (forall (b : Î²), (GE.ge.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) b b') -> (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))) b (f (g b)))) -> (Eq.{succ u2} (Filter.{u2} Î²) (Filter.map.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))) (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeSup.toPartialOrder.{u2} Î² _inst_2))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : SemilatticeSup.{u1} Î²] {f : Î± -> Î²} (g : Î² -> Î±) (b' : Î²), (Monotone.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2)) f) -> (forall (a : Î±) (b : Î²), (GE.ge.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2))) b b') -> (Iff (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2))) (f a) b) (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) a (g b)))) -> (forall (b : Î²), (GE.ge.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2))) b b') -> (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2))) b (f (g b)))) -> (Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)))) (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeSup.toPartialOrder.{u1} Î² _inst_2))))
Case conversion may be inaccurate. Consider using '#align filter.map_at_top_eq_of_gc Filter.map_atTop_eq_of_gcâ‚“'. -/
/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
theorem map_atTop_eq_of_gc [SemilatticeSup Î±] [SemilatticeSup Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²)
    (hf : Monotone f) (gc : âˆ€ a, âˆ€ b â‰¥ b', f a â‰¤ b â†” a â‰¤ g b) (hgi : âˆ€ b â‰¥ b', b â‰¤ f (g b)) :
    map f atTop = atTop :=
  by
  refine'
    le_antisymm
      (hf.tendsto_at_top_at_top fun b => âŸ¨g (b âŠ” b'), le_sup_left.trans <| hgi _ le_sup_rightâŸ©) _
  rw [@map_at_top_eq _ _ âŸ¨g b'âŸ©]
  refine' le_iInf fun a => iInf_le_of_le (f a âŠ” b') <| principal_mono.2 fun b hb => _
  rw [mem_Ici, sup_le_iff] at hb
  exact âŸ¨g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 le_rfl) (hgi _ hb.2)âŸ©
#align filter.map_at_top_eq_of_gc Filter.map_atTop_eq_of_gc

/- warning: filter.map_at_bot_eq_of_gc -> Filter.map_atBot_eq_of_gc is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : SemilatticeInf.{u2} Î²] {f : Î± -> Î²} (g : Î² -> Î±) (b' : Î²), (Monotone.{u1, u2} Î± Î² (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2)) f) -> (forall (a : Î±) (b : Î²), (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) b b') -> (Iff (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) b (f a)) (LE.le.{u1} Î± (Preorder.toHasLe.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) (g b) a))) -> (forall (b : Î²), (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) b b') -> (LE.le.{u2} Î² (Preorder.toHasLe.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))) (f (g b)) b)) -> (Eq.{succ u2} (Filter.{u2} Î²) (Filter.map.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))) (Filter.atBot.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (SemilatticeInf.toPartialOrder.{u2} Î² _inst_2))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] [_inst_2 : SemilatticeInf.{u1} Î²] {f : Î± -> Î²} (g : Î² -> Î±) (b' : Î²), (Monotone.{u2, u1} Î± Î² (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2)) f) -> (forall (a : Î±) (b : Î²), (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2))) b b') -> (Iff (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2))) b (f a)) (LE.le.{u2} Î± (Preorder.toLE.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))) (g b) a))) -> (forall (b : Î²), (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2))) b b') -> (LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2))) (f (g b)) b)) -> (Eq.{succ u1} (Filter.{u1} Î²) (Filter.map.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)))) (Filter.atBot.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (SemilatticeInf.toPartialOrder.{u1} Î² _inst_2))))
Case conversion may be inaccurate. Consider using '#align filter.map_at_bot_eq_of_gc Filter.map_atBot_eq_of_gcâ‚“'. -/
theorem map_atBot_eq_of_gc [SemilatticeInf Î±] [SemilatticeInf Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²)
    (hf : Monotone f) (gc : âˆ€ a, âˆ€ b â‰¤ b', b â‰¤ f a â†” g b â‰¤ a) (hgi : âˆ€ b â‰¤ b', f (g b) â‰¤ b) :
    map f atBot = atBot :=
  @map_atTop_eq_of_gc Î±áµ’áµˆ Î²áµ’áµˆ _ _ _ _ _ hf.dual gc hgi
#align filter.map_at_bot_eq_of_gc Filter.map_atBot_eq_of_gc

#print Filter.map_val_atTop_of_Ici_subset /-
theorem map_val_atTop_of_Ici_subset [SemilatticeSup Î±] {a : Î±} {s : Set Î±} (h : Ici a âŠ† s) :
    map (coe : s â†’ Î±) atTop = atTop :=
  by
  have : Directed (Â· â‰¥ Â·) fun x : s => ð“Ÿ (Ici x) :=
    by
    intro x y
    use âŸ¨x âŠ” y âŠ” a, h le_sup_rightâŸ©
    simp only [ge_iff_le, principal_mono, Ici_subset_Ici, â† Subtype.coe_le_coe, Subtype.coe_mk]
    exact âŸ¨le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_leftâŸ©
  haveI : Nonempty s := âŸ¨âŸ¨a, h le_rflâŸ©âŸ©
  simp only [le_antisymm_iff, at_top, le_iInf_iff, le_principal_iff, mem_map, mem_set_of_eq,
    map_infi_eq this, map_principal]
  constructor
  Â· intro x
    refine' mem_of_superset (mem_infi_of_mem âŸ¨x âŠ” a, h le_sup_rightâŸ© (mem_principal_self _)) _
    rintro _ âŸ¨y, hy, rflâŸ©
    exact le_trans le_sup_left (Subtype.coe_le_coe.2 hy)
  Â· intro x
    filter_upwards [mem_at_top (â†‘x âŠ” a)]with b hb
    exact âŸ¨âŸ¨b, h <| le_sup_right.trans hbâŸ©, Subtype.coe_le_coe.1 (le_sup_left.trans hb), rflâŸ©
#align filter.map_coe_at_top_of_Ici_subset Filter.map_val_atTop_of_Ici_subset
-/

#print Filter.map_val_Ici_atTop /-
/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/
@[simp]
theorem map_val_Ici_atTop [SemilatticeSup Î±] (a : Î±) : map (coe : Ici a â†’ Î±) atTop = atTop :=
  map_val_atTop_of_Ici_subset (Subset.refl _)
#align filter.map_coe_Ici_at_top Filter.map_val_Ici_atTop
-/

/- warning: filter.map_coe_Ioi_at_top -> Filter.map_val_Ioi_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))] (a : Î±), Eq.{succ u1} (Filter.{u1} Î±) (Filter.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))))))) (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))] (a : Î±), Eq.{succ u1} (Filter.{u1} Î±) (Filter.map.{u1, u1} (Subtype.{succ u1} Î± (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))) Î± (Subtype.val.{succ u1} Î± (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))) (Filter.atTop.{u1} (Subtype.{succ u1} Î± (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.map_coe_Ioi_at_top Filter.map_val_Ioi_atTopâ‚“'. -/
/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/
@[simp]
theorem map_val_Ioi_atTop [SemilatticeSup Î±] [NoMaxOrder Î±] (a : Î±) :
    map (coe : Ioi a â†’ Î±) atTop = atTop :=
  let âŸ¨b, hbâŸ© := exists_gt a
  map_val_atTop_of_Ici_subset <| Ici_subset_Ioi.2 hb
#align filter.map_coe_Ioi_at_top Filter.map_val_Ioi_atTop

#print Filter.atTop_Ioi_eq /-
/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient
order. -/
theorem atTop_Ioi_eq [SemilatticeSup Î±] (a : Î±) : atTop = comap (coe : Ioi a â†’ Î±) atTop :=
  by
  nontriviality
  rcases nontrivial_iff_nonempty.1 â€¹_â€º with âŸ¨b, hbâŸ©
  rw [â† map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]
#align filter.at_top_Ioi_eq Filter.atTop_Ioi_eq
-/

#print Filter.atTop_Ici_eq /-
/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient
order. -/
theorem atTop_Ici_eq [SemilatticeSup Î±] (a : Î±) : atTop = comap (coe : Ici a â†’ Î±) atTop := by
  rw [â† map_coe_Ici_at_top a, comap_map Subtype.coe_injective]
#align filter.at_top_Ici_eq Filter.atTop_Ici_eq
-/

/- warning: filter.map_coe_Iio_at_bot -> Filter.map_val_Iio_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))] (a : Î±), Eq.{succ u1} (Filter.{u1} Î±) (Filter.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))))))) (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))] (a : Î±), Eq.{succ u1} (Filter.{u1} Î±) (Filter.map.{u1, u1} (Subtype.{succ u1} Î± (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))) Î± (Subtype.val.{succ u1} Î± (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))) (Filter.atBot.{u1} (Subtype.{succ u1} Î± (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.map_coe_Iio_at_bot Filter.map_val_Iio_atBotâ‚“'. -/
/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_val_Iio_atBot [SemilatticeInf Î±] [NoMinOrder Î±] (a : Î±) :
    map (coe : Iio a â†’ Î±) atBot = atBot :=
  @map_val_Ioi_atTop Î±áµ’áµˆ _ _ _
#align filter.map_coe_Iio_at_bot Filter.map_val_Iio_atBot

#print Filter.atBot_Iio_eq /-
/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
theorem atBot_Iio_eq [SemilatticeInf Î±] (a : Î±) : atBot = comap (coe : Iio a â†’ Î±) atBot :=
  @atTop_Ioi_eq Î±áµ’áµˆ _ _
#align filter.at_bot_Iio_eq Filter.atBot_Iio_eq
-/

#print Filter.map_val_Iic_atBot /-
/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_val_Iic_atBot [SemilatticeInf Î±] (a : Î±) : map (coe : Iic a â†’ Î±) atBot = atBot :=
  @map_val_Ici_atTop Î±áµ’áµˆ _ _
#align filter.map_coe_Iic_at_bot Filter.map_val_Iic_atBot
-/

#print Filter.atBot_Iic_eq /-
/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
theorem atBot_Iic_eq [SemilatticeInf Î±] (a : Î±) : atBot = comap (coe : Iic a â†’ Î±) atBot :=
  @atTop_Ici_eq Î±áµ’áµˆ _ _
#align filter.at_bot_Iic_eq Filter.atBot_Iic_eq
-/

/- warning: filter.tendsto_Ioi_at_top -> Filter.tendsto_Ioi_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] {a : Î±} {f : Î² -> (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u2, u1} Î² (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) f l (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)))))) (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] {a : Î±} {f : Î² -> (Set.Elem.{u2} Î± (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a))} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u1, u2} Î² (Set.Elem.{u2} Î± (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) f l (Filter.atTop.{u2} (Set.Elem.{u2} Î± (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a))))) (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) (f x)) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_Ioi_at_top Filter.tendsto_Ioi_atTopâ‚“'. -/
theorem tendsto_Ioi_atTop [SemilatticeSup Î±] {a : Î±} {f : Î² â†’ Ioi a} {l : Filter Î²} :
    Tendsto f l atTop â†” Tendsto (fun x => (f x : Î±)) l atTop := by
  rw [at_top_Ioi_eq, tendsto_comap_iff]
#align filter.tendsto_Ioi_at_top Filter.tendsto_Ioi_atTop

/- warning: filter.tendsto_Iio_at_bot -> Filter.tendsto_Iio_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] {a : Î±} {f : Î² -> (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u2, u1} Î² (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) f l (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)))))) (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] {a : Î±} {f : Î² -> (Set.Elem.{u2} Î± (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a))} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u1, u2} Î² (Set.Elem.{u2} Î± (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) f l (Filter.atBot.{u2} (Set.Elem.{u2} Î± (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a))))) (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) (f x)) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_Iio_at_bot Filter.tendsto_Iio_atBotâ‚“'. -/
theorem tendsto_Iio_atBot [SemilatticeInf Î±] {a : Î±} {f : Î² â†’ Iio a} {l : Filter Î²} :
    Tendsto f l atBot â†” Tendsto (fun x => (f x : Î±)) l atBot := by
  rw [at_bot_Iio_eq, tendsto_comap_iff]
#align filter.tendsto_Iio_at_bot Filter.tendsto_Iio_atBot

/- warning: filter.tendsto_Ici_at_top -> Filter.tendsto_Ici_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] {a : Î±} {f : Î² -> (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u2, u1} Î² (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) f l (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)))))) (f x)) l (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] {a : Î±} {f : Î² -> (Set.Elem.{u2} Î± (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a))} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u1, u2} Î² (Set.Elem.{u2} Î± (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) f l (Filter.atTop.{u2} (Set.Elem.{u2} Î± (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a))))) (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) (f x)) l (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_Ici_at_top Filter.tendsto_Ici_atTopâ‚“'. -/
theorem tendsto_Ici_atTop [SemilatticeSup Î±] {a : Î±} {f : Î² â†’ Ici a} {l : Filter Î²} :
    Tendsto f l atTop â†” Tendsto (fun x => (f x : Î±)) l atTop := by
  rw [at_top_Ici_eq, tendsto_comap_iff]
#align filter.tendsto_Ici_at_top Filter.tendsto_Ici_atTop

/- warning: filter.tendsto_Iic_at_bot -> Filter.tendsto_Iic_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] {a : Î±} {f : Î² -> (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u2, u1} Î² (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) f l (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a))))) (Filter.Tendsto.{u2, u1} Î² Î± (fun (x : Î²) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)))))) (f x)) l (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] {a : Î±} {f : Î² -> (Set.Elem.{u2} Î± (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a))} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u1, u2} Î² (Set.Elem.{u2} Î± (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) f l (Filter.atBot.{u2} (Set.Elem.{u2} Î± (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a))))) (Filter.Tendsto.{u1, u2} Î² Î± (fun (x : Î²) => Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) (f x)) l (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_Iic_at_bot Filter.tendsto_Iic_atBotâ‚“'. -/
theorem tendsto_Iic_atBot [SemilatticeInf Î±] {a : Î±} {f : Î² â†’ Iic a} {l : Filter Î²} :
    Tendsto f l atBot â†” Tendsto (fun x => (f x : Î±)) l atBot := by
  rw [at_bot_Iic_eq, tendsto_comap_iff]
#align filter.tendsto_Iic_at_bot Filter.tendsto_Iic_atBot

/- warning: filter.tendsto_comp_coe_Ioi_at_top -> Filter.tendsto_comp_val_Ioi_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] [_inst_2 : NoMaxOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)))] {a : Î±} {f : Î± -> Î²} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î² (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)))))) x)) (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) l)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] [_inst_2 : NoMaxOrder.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)))] {a : Î±} {f : Î± -> Î²} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Î± (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) Î² (fun (x : Set.Elem.{u2} Î± (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) => f (Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) x)) (Filter.atTop.{u2} (Set.Elem.{u2} Î± (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ioi.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_comp_coe_Ioi_at_top Filter.tendsto_comp_val_Ioi_atTopâ‚“'. -/
@[simp]
theorem tendsto_comp_val_Ioi_atTop [SemilatticeSup Î±] [NoMaxOrder Î±] {a : Î±} {f : Î± â†’ Î²}
    {l : Filter Î²} : Tendsto (fun x : Ioi a => f x) atTop l â†” Tendsto f atTop l := by
  rw [â† map_coe_Ioi_at_top a, tendsto_map'_iff]
#align filter.tendsto_comp_coe_Ioi_at_top Filter.tendsto_comp_val_Ioi_atTop

/- warning: filter.tendsto_comp_coe_Ici_at_top -> Filter.tendsto_comp_val_Ici_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} Î±] {a : Î±} {f : Î± -> Î²} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î² (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)))))) x)) (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_1))) l)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} Î±] {a : Î±} {f : Î± -> Î²} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Î± (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) Î² (fun (x : Set.Elem.{u2} Î± (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) => f (Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) x)) (Filter.atTop.{u2} (Set.Elem.{u2} Î± (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Ici.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_1))) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_comp_coe_Ici_at_top Filter.tendsto_comp_val_Ici_atTopâ‚“'. -/
@[simp]
theorem tendsto_comp_val_Ici_atTop [SemilatticeSup Î±] {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto (fun x : Ici a => f x) atTop l â†” Tendsto f atTop l := by
  rw [â† map_coe_Ici_at_top a, tendsto_map'_iff]
#align filter.tendsto_comp_coe_Ici_at_top Filter.tendsto_comp_val_Ici_atTop

/- warning: filter.tendsto_comp_coe_Iio_at_bot -> Filter.tendsto_comp_val_Iio_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] [_inst_2 : NoMinOrder.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)))] {a : Î±} {f : Î± -> Î²} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î² (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)))))) x)) (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) l)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] [_inst_2 : NoMinOrder.{u2} Î± (Preorder.toLT.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)))] {a : Î±} {f : Î± -> Î²} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Î± (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) Î² (fun (x : Set.Elem.{u2} Î± (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) => f (Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) x)) (Filter.atBot.{u2} (Set.Elem.{u2} Î± (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iio.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_comp_coe_Iio_at_bot Filter.tendsto_comp_val_Iio_atBotâ‚“'. -/
@[simp]
theorem tendsto_comp_val_Iio_atBot [SemilatticeInf Î±] [NoMinOrder Î±] {a : Î±} {f : Î± â†’ Î²}
    {l : Filter Î²} : Tendsto (fun x : Iio a => f x) atBot l â†” Tendsto f atBot l := by
  rw [â† map_coe_Iio_at_bot a, tendsto_map'_iff]
#align filter.tendsto_comp_coe_Iio_at_bot Filter.tendsto_comp_val_Iio_atBot

/- warning: filter.tendsto_comp_coe_Iic_at_bot -> Filter.tendsto_comp_val_Iic_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} Î±] {a : Î±} {f : Î± -> Î²} {l : Filter.{u2} Î²}, Iff (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î² (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) Î± (coeSubtype.{succ u1} Î± (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)))))) x)) (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î±) Type.{u1} (Set.hasCoeToSort.{u1} Î±) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)) (Subtype.preorder.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) (fun (x : Î±) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) x (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_1))) l)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} Î±] {a : Î±} {f : Î± -> Î²} {l : Filter.{u1} Î²}, Iff (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Î± (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) Î² (fun (x : Set.Elem.{u2} Î± (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) => f (Subtype.val.{succ u2} Î± (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) x)) (Filter.atBot.{u2} (Set.Elem.{u2} Î± (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)) (Subtype.preorder.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) (fun (x : Î±) => Membership.mem.{u2, u2} Î± (Set.{u2} Î±) (Set.instMembershipSet.{u2} Î±) x (Set.Iic.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1)) a)))) l) (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_1))) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_comp_coe_Iic_at_bot Filter.tendsto_comp_val_Iic_atBotâ‚“'. -/
@[simp]
theorem tendsto_comp_val_Iic_atBot [SemilatticeInf Î±] {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto (fun x : Iic a => f x) atBot l â†” Tendsto f atBot l := by
  rw [â† map_coe_Iic_at_bot a, tendsto_map'_iff]
#align filter.tendsto_comp_coe_Iic_at_bot Filter.tendsto_comp_val_Iic_atBot

#print Filter.map_add_atTop_eq_nat /-
theorem map_add_atTop_eq_nat (k : â„•) : map (fun a => a + k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a - k) k (fun a b h => add_le_add_right h k)
    (fun a b h => (le_tsub_iff_right h).symm) fun a h => by rw [tsub_add_cancel_of_le h]
#align filter.map_add_at_top_eq_nat Filter.map_add_atTop_eq_nat
-/

#print Filter.map_sub_atTop_eq_nat /-
theorem map_sub_atTop_eq_nat (k : â„•) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
    (fun a b _ => tsub_le_iff_right) fun b _ => by rw [add_tsub_cancel_right]
#align filter.map_sub_at_top_eq_nat Filter.map_sub_atTop_eq_nat
-/

#print Filter.tendsto_add_atTop_nat /-
theorem tendsto_add_atTop_nat (k : â„•) : Tendsto (fun a => a + k) atTop atTop :=
  le_of_eq (map_add_atTop_eq_nat k)
#align filter.tendsto_add_at_top_nat Filter.tendsto_add_atTop_nat
-/

#print Filter.tendsto_sub_atTop_nat /-
theorem tendsto_sub_atTop_nat (k : â„•) : Tendsto (fun a => a - k) atTop atTop :=
  le_of_eq (map_sub_atTop_eq_nat k)
#align filter.tendsto_sub_at_top_nat Filter.tendsto_sub_atTop_nat
-/

#print Filter.tendsto_add_atTop_iff_nat /-
theorem tendsto_add_atTop_iff_nat {f : â„• â†’ Î±} {l : Filter Î±} (k : â„•) :
    Tendsto (fun n => f (n + k)) atTop l â†” Tendsto f atTop l :=
  show Tendsto (f âˆ˜ fun n => n + k) atTop l â†” Tendsto f atTop l by
    rw [â† tendsto_map'_iff, map_add_at_top_eq_nat]
#align filter.tendsto_add_at_top_iff_nat Filter.tendsto_add_atTop_iff_nat
-/

#print Filter.map_div_atTop_eq_nat /-
theorem map_div_atTop_eq_nat (k : â„•) (hk : 0 < k) : map (fun a => a / k) atTop = atTop :=
  map_atTop_eq_of_gc (fun b => b * k + (k - 1)) 1 (fun a b h => Nat.div_le_div_right h)
    (fun a b _ =>
      calc
        a / k â‰¤ b â†” a / k < b + 1 := by rw [â† Nat.succ_eq_add_one, Nat.lt_succ_iff]
        _ â†” a < (b + 1) * k := (Nat.div_lt_iff_lt_mul hk)
        _ â†” _ := by
          cases k
          exact (lt_irrefl _ hk).elim
          rw [add_mul, one_mul, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.add_succ, Nat.lt_succ_iff]
        )
    fun b _ =>
    calc
      b = b * k / k := by rw [Nat.mul_div_cancel b hk]
      _ â‰¤ (b * k + (k - 1)) / k := Nat.div_le_div_right <| Nat.le_add_right _ _
      
#align filter.map_div_at_top_eq_nat Filter.map_div_atTop_eq_nat
-/

/- warning: filter.tendsto_at_top_at_top_of_monotone' -> Filter.tendsto_atTop_atTop_of_monotone' is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u1} Î¹] [_inst_2 : LinearOrder.{u2} Î±] {u : Î¹ -> Î±}, (Monotone.{u1, u2} Î¹ Î± _inst_1 (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± (Lattice.toSemilatticeInf.{u2} Î± (LinearOrder.toLattice.{u2} Î± _inst_2)))) u) -> (Not (BddAbove.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± (Lattice.toSemilatticeInf.{u2} Î± (LinearOrder.toLattice.{u2} Î± _inst_2)))) (Set.range.{u2, succ u1} Î± Î¹ u))) -> (Filter.Tendsto.{u1, u2} Î¹ Î± u (Filter.atTop.{u1} Î¹ _inst_1) (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± (Lattice.toSemilatticeInf.{u2} Î± (LinearOrder.toLattice.{u2} Î± _inst_2))))))
but is expected to have type
  forall {Î¹ : Type.{u2}} {Î± : Type.{u1}} [_inst_1 : Preorder.{u2} Î¹] [_inst_2 : LinearOrder.{u1} Î±] {u : Î¹ -> Î±}, (Monotone.{u2, u1} Î¹ Î± _inst_1 (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± (Lattice.toSemilatticeInf.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± _inst_2))))) u) -> (Not (BddAbove.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± (Lattice.toSemilatticeInf.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± _inst_2))))) (Set.range.{u1, succ u2} Î± Î¹ u))) -> (Filter.Tendsto.{u2, u1} Î¹ Î± u (Filter.atTop.{u2} Î¹ _inst_1) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± (Lattice.toSemilatticeInf.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_at_top_of_monotone' Filter.tendsto_atTop_atTop_of_monotone'â‚“'. -/
/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
theorem tendsto_atTop_atTop_of_monotone' [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u)
    (H : Â¬BddAbove (range u)) : Tendsto u atTop atTop :=
  by
  apply h.tendsto_at_top_at_top
  intro b
  rcases not_bddAbove_iff.1 H b with âŸ¨_, âŸ¨N, rflâŸ©, hNâŸ©
  exact âŸ¨N, le_of_lt hNâŸ©
#align filter.tendsto_at_top_at_top_of_monotone' Filter.tendsto_atTop_atTop_of_monotone'

/- warning: filter.tendsto_at_bot_at_bot_of_monotone' -> Filter.tendsto_atBot_atBot_of_monotone' is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u1} Î¹] [_inst_2 : LinearOrder.{u2} Î±] {u : Î¹ -> Î±}, (Monotone.{u1, u2} Î¹ Î± _inst_1 (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± (Lattice.toSemilatticeInf.{u2} Î± (LinearOrder.toLattice.{u2} Î± _inst_2)))) u) -> (Not (BddBelow.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± (Lattice.toSemilatticeInf.{u2} Î± (LinearOrder.toLattice.{u2} Î± _inst_2)))) (Set.range.{u2, succ u1} Î± Î¹ u))) -> (Filter.Tendsto.{u1, u2} Î¹ Î± u (Filter.atBot.{u1} Î¹ _inst_1) (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± (Lattice.toSemilatticeInf.{u2} Î± (LinearOrder.toLattice.{u2} Î± _inst_2))))))
but is expected to have type
  forall {Î¹ : Type.{u2}} {Î± : Type.{u1}} [_inst_1 : Preorder.{u2} Î¹] [_inst_2 : LinearOrder.{u1} Î±] {u : Î¹ -> Î±}, (Monotone.{u2, u1} Î¹ Î± _inst_1 (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± (Lattice.toSemilatticeInf.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± _inst_2))))) u) -> (Not (BddBelow.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± (Lattice.toSemilatticeInf.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± _inst_2))))) (Set.range.{u1, succ u2} Î± Î¹ u))) -> (Filter.Tendsto.{u2, u1} Î¹ Î± u (Filter.atBot.{u2} Î¹ _inst_1) (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± (Lattice.toSemilatticeInf.{u1} Î± (DistribLattice.toLattice.{u1} Î± (instDistribLattice.{u1} Î± _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_at_bot_of_monotone' Filter.tendsto_atBot_atBot_of_monotone'â‚“'. -/
/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `tendsto u at_bot at_bot`. -/
theorem tendsto_atBot_atBot_of_monotone' [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u)
    (H : Â¬BddBelow (range u)) : Tendsto u atBot atBot :=
  @tendsto_atTop_atTop_of_monotone' Î¹áµ’áµˆ Î±áµ’áµˆ _ _ _ h.dual H
#align filter.tendsto_at_bot_at_bot_of_monotone' Filter.tendsto_atBot_atBot_of_monotone'

/- warning: filter.unbounded_of_tendsto_at_top -> Filter.unbounded_of_tendsto_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] [_inst_4 : NoMaxOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (Filter.atTop.{u2} Î² _inst_3)) -> (Not (BddAbove.{u2} Î² _inst_3 (Set.range.{u2, succ u1} Î² Î± f)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] [_inst_4 : NoMaxOrder.{u1} Î² (Preorder.toLT.{u1} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) (Filter.atTop.{u1} Î² _inst_3)) -> (Not (BddAbove.{u1} Î² _inst_3 (Set.range.{u1, succ u2} Î² Î± f)))
Case conversion may be inaccurate. Consider using '#align filter.unbounded_of_tendsto_at_top Filter.unbounded_of_tendsto_atTopâ‚“'. -/
theorem unbounded_of_tendsto_atTop [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] [NoMaxOrder Î²]
    {f : Î± â†’ Î²} (h : Tendsto f atTop atTop) : Â¬BddAbove (range f) :=
  by
  rintro âŸ¨M, hMâŸ©
  cases' mem_at_top_sets.mp (h <| Ioi_mem_at_top M) with a ha
  apply lt_irrefl M
  calc
    M < f a := ha a le_rfl
    _ â‰¤ M := hM (Set.mem_range_self a)
    
#align filter.unbounded_of_tendsto_at_top Filter.unbounded_of_tendsto_atTop

/- warning: filter.unbounded_of_tendsto_at_bot -> Filter.unbounded_of_tendsto_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeSup.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] [_inst_4 : NoMinOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeSup.toPartialOrder.{u1} Î± _inst_2))) (Filter.atBot.{u2} Î² _inst_3)) -> (Not (BddBelow.{u2} Î² _inst_3 (Set.range.{u2, succ u1} Î² Î± f)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeSup.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] [_inst_4 : NoMinOrder.{u1} Î² (Preorder.toLT.{u1} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atTop.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeSup.toPartialOrder.{u2} Î± _inst_2))) (Filter.atBot.{u1} Î² _inst_3)) -> (Not (BddBelow.{u1} Î² _inst_3 (Set.range.{u1, succ u2} Î² Î± f)))
Case conversion may be inaccurate. Consider using '#align filter.unbounded_of_tendsto_at_bot Filter.unbounded_of_tendsto_atBotâ‚“'. -/
theorem unbounded_of_tendsto_atBot [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] [NoMinOrder Î²]
    {f : Î± â†’ Î²} (h : Tendsto f atTop atBot) : Â¬BddBelow (range f) :=
  @unbounded_of_tendsto_atTop _ Î²áµ’áµˆ _ _ _ _ _ h
#align filter.unbounded_of_tendsto_at_bot Filter.unbounded_of_tendsto_atBot

/- warning: filter.unbounded_of_tendsto_at_top' -> Filter.unbounded_of_tendsto_atTop' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] [_inst_4 : NoMaxOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) (Filter.atTop.{u2} Î² _inst_3)) -> (Not (BddAbove.{u2} Î² _inst_3 (Set.range.{u2, succ u1} Î² Î± f)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] [_inst_4 : NoMaxOrder.{u1} Î² (Preorder.toLT.{u1} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) (Filter.atTop.{u1} Î² _inst_3)) -> (Not (BddAbove.{u1} Î² _inst_3 (Set.range.{u1, succ u2} Î² Î± f)))
Case conversion may be inaccurate. Consider using '#align filter.unbounded_of_tendsto_at_top' Filter.unbounded_of_tendsto_atTop'â‚“'. -/
theorem unbounded_of_tendsto_atTop' [Nonempty Î±] [SemilatticeInf Î±] [Preorder Î²] [NoMaxOrder Î²]
    {f : Î± â†’ Î²} (h : Tendsto f atBot atTop) : Â¬BddAbove (range f) :=
  @unbounded_of_tendsto_atTop Î±áµ’áµˆ _ _ _ _ _ _ h
#align filter.unbounded_of_tendsto_at_top' Filter.unbounded_of_tendsto_atTop'

/- warning: filter.unbounded_of_tendsto_at_bot' -> Filter.unbounded_of_tendsto_atBot' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Nonempty.{succ u1} Î±] [_inst_2 : SemilatticeInf.{u1} Î±] [_inst_3 : Preorder.{u2} Î²] [_inst_4 : NoMinOrder.{u2} Î² (Preorder.toHasLt.{u2} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u1, u2} Î± Î² f (Filter.atBot.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (SemilatticeInf.toPartialOrder.{u1} Î± _inst_2))) (Filter.atBot.{u2} Î² _inst_3)) -> (Not (BddBelow.{u2} Î² _inst_3 (Set.range.{u2, succ u1} Î² Î± f)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : Nonempty.{succ u2} Î±] [_inst_2 : SemilatticeInf.{u2} Î±] [_inst_3 : Preorder.{u1} Î²] [_inst_4 : NoMinOrder.{u1} Î² (Preorder.toLT.{u1} Î² _inst_3)] {f : Î± -> Î²}, (Filter.Tendsto.{u2, u1} Î± Î² f (Filter.atBot.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (SemilatticeInf.toPartialOrder.{u2} Î± _inst_2))) (Filter.atBot.{u1} Î² _inst_3)) -> (Not (BddBelow.{u1} Î² _inst_3 (Set.range.{u1, succ u2} Î² Î± f)))
Case conversion may be inaccurate. Consider using '#align filter.unbounded_of_tendsto_at_bot' Filter.unbounded_of_tendsto_atBot'â‚“'. -/
theorem unbounded_of_tendsto_atBot' [Nonempty Î±] [SemilatticeInf Î±] [Preorder Î²] [NoMinOrder Î²]
    {f : Î± â†’ Î²} (h : Tendsto f atBot atBot) : Â¬BddBelow (range f) :=
  @unbounded_of_tendsto_atTop Î±áµ’áµˆ Î²áµ’áµˆ _ _ _ _ _ h
#align filter.unbounded_of_tendsto_at_bot' Filter.unbounded_of_tendsto_atBot'

/- warning: filter.tendsto_at_top_of_monotone_of_filter -> Filter.tendsto_atTop_of_monotone_of_filter is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u1} Î¹] [_inst_2 : Preorder.{u2} Î±] {l : Filter.{u1} Î¹} {u : Î¹ -> Î±}, (Monotone.{u1, u2} Î¹ Î± _inst_1 _inst_2 u) -> (forall [_inst_3 : Filter.NeBot.{u1} Î¹ l], (Filter.Tendsto.{u1, u2} Î¹ Î± u l (Filter.atTop.{u2} Î± _inst_2)) -> (Filter.Tendsto.{u1, u2} Î¹ Î± u (Filter.atTop.{u1} Î¹ _inst_1) (Filter.atTop.{u2} Î± _inst_2)))
but is expected to have type
  forall {Î¹ : Type.{u2}} {Î± : Type.{u1}} [_inst_1 : Preorder.{u2} Î¹] [_inst_2 : Preorder.{u1} Î±] {l : Filter.{u2} Î¹} {u : Î¹ -> Î±}, (Monotone.{u2, u1} Î¹ Î± _inst_1 _inst_2 u) -> (forall [_inst_3 : Filter.NeBot.{u2} Î¹ l], (Filter.Tendsto.{u2, u1} Î¹ Î± u l (Filter.atTop.{u1} Î± _inst_2)) -> (Filter.Tendsto.{u2, u1} Î¹ Î± u (Filter.atTop.{u2} Î¹ _inst_1) (Filter.atTop.{u1} Î± _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_monotone_of_filter Filter.tendsto_atTop_of_monotone_of_filterâ‚“'. -/
/-- If a monotone function `u : Î¹ â†’ Î±` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
theorem tendsto_atTop_of_monotone_of_filter [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±}
    (h : Monotone u) [NeBot l] (hu : Tendsto u l atTop) : Tendsto u atTop atTop :=
  h.tendsto_atTop_atTop fun b => (hu.Eventually (mem_atTop b)).exists
#align filter.tendsto_at_top_of_monotone_of_filter Filter.tendsto_atTop_of_monotone_of_filter

/- warning: filter.tendsto_at_bot_of_monotone_of_filter -> Filter.tendsto_atBot_of_monotone_of_filter is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u1} Î¹] [_inst_2 : Preorder.{u2} Î±] {l : Filter.{u1} Î¹} {u : Î¹ -> Î±}, (Monotone.{u1, u2} Î¹ Î± _inst_1 _inst_2 u) -> (forall [_inst_3 : Filter.NeBot.{u1} Î¹ l], (Filter.Tendsto.{u1, u2} Î¹ Î± u l (Filter.atBot.{u2} Î± _inst_2)) -> (Filter.Tendsto.{u1, u2} Î¹ Î± u (Filter.atBot.{u1} Î¹ _inst_1) (Filter.atBot.{u2} Î± _inst_2)))
but is expected to have type
  forall {Î¹ : Type.{u2}} {Î± : Type.{u1}} [_inst_1 : Preorder.{u2} Î¹] [_inst_2 : Preorder.{u1} Î±] {l : Filter.{u2} Î¹} {u : Î¹ -> Î±}, (Monotone.{u2, u1} Î¹ Î± _inst_1 _inst_2 u) -> (forall [_inst_3 : Filter.NeBot.{u2} Î¹ l], (Filter.Tendsto.{u2, u1} Î¹ Î± u l (Filter.atBot.{u1} Î± _inst_2)) -> (Filter.Tendsto.{u2, u1} Î¹ Î± u (Filter.atBot.{u2} Î¹ _inst_1) (Filter.atBot.{u1} Î± _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_monotone_of_filter Filter.tendsto_atBot_of_monotone_of_filterâ‚“'. -/
/-- If a monotone function `u : Î¹ â†’ Î±` tends to `at_bot` along *some* non-trivial filter `l`, then
it tends to `at_bot` along `at_bot`. -/
theorem tendsto_atBot_of_monotone_of_filter [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±}
    (h : Monotone u) [NeBot l] (hu : Tendsto u l atBot) : Tendsto u atBot atBot :=
  @tendsto_atTop_of_monotone_of_filter Î¹áµ’áµˆ Î±áµ’áµˆ _ _ _ _ h.dual _ hu
#align filter.tendsto_at_bot_of_monotone_of_filter Filter.tendsto_atBot_of_monotone_of_filter

/- warning: filter.tendsto_at_top_of_monotone_of_subseq -> Filter.tendsto_atTop_of_monotone_of_subseq is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î¹' : Type.{u2}} {Î± : Type.{u3}} [_inst_1 : Preorder.{u1} Î¹] [_inst_2 : Preorder.{u3} Î±] {u : Î¹ -> Î±} {Ï† : Î¹' -> Î¹}, (Monotone.{u1, u3} Î¹ Î± _inst_1 _inst_2 u) -> (forall {l : Filter.{u2} Î¹'} [_inst_3 : Filter.NeBot.{u2} Î¹' l], (Filter.Tendsto.{u2, u3} Î¹' Î± (Function.comp.{succ u2, succ u1, succ u3} Î¹' Î¹ Î± u Ï†) l (Filter.atTop.{u3} Î± _inst_2)) -> (Filter.Tendsto.{u1, u3} Î¹ Î± u (Filter.atTop.{u1} Î¹ _inst_1) (Filter.atTop.{u3} Î± _inst_2)))
but is expected to have type
  forall {Î¹ : Type.{u3}} {Î¹' : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u3} Î¹] [_inst_2 : Preorder.{u2} Î±] {u : Î¹ -> Î±} {Ï† : Î¹' -> Î¹}, (Monotone.{u3, u2} Î¹ Î± _inst_1 _inst_2 u) -> (forall {l : Filter.{u1} Î¹'} [_inst_3 : Filter.NeBot.{u1} Î¹' l], (Filter.Tendsto.{u1, u2} Î¹' Î± (Function.comp.{succ u1, succ u3, succ u2} Î¹' Î¹ Î± u Ï†) l (Filter.atTop.{u2} Î± _inst_2)) -> (Filter.Tendsto.{u3, u2} Î¹ Î± u (Filter.atTop.{u3} Î¹ _inst_1) (Filter.atTop.{u2} Î± _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_top_of_monotone_of_subseq Filter.tendsto_atTop_of_monotone_of_subseqâ‚“'. -/
theorem tendsto_atTop_of_monotone_of_subseq [Preorder Î¹] [Preorder Î±] {u : Î¹ â†’ Î±} {Ï† : Î¹' â†’ Î¹}
    (h : Monotone u) {l : Filter Î¹'} [NeBot l] (H : Tendsto (u âˆ˜ Ï†) l atTop) :
    Tendsto u atTop atTop :=
  tendsto_atTop_of_monotone_of_filter h (tendsto_map' H)
#align filter.tendsto_at_top_of_monotone_of_subseq Filter.tendsto_atTop_of_monotone_of_subseq

/- warning: filter.tendsto_at_bot_of_monotone_of_subseq -> Filter.tendsto_atBot_of_monotone_of_subseq is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î¹' : Type.{u2}} {Î± : Type.{u3}} [_inst_1 : Preorder.{u1} Î¹] [_inst_2 : Preorder.{u3} Î±] {u : Î¹ -> Î±} {Ï† : Î¹' -> Î¹}, (Monotone.{u1, u3} Î¹ Î± _inst_1 _inst_2 u) -> (forall {l : Filter.{u2} Î¹'} [_inst_3 : Filter.NeBot.{u2} Î¹' l], (Filter.Tendsto.{u2, u3} Î¹' Î± (Function.comp.{succ u2, succ u1, succ u3} Î¹' Î¹ Î± u Ï†) l (Filter.atBot.{u3} Î± _inst_2)) -> (Filter.Tendsto.{u1, u3} Î¹ Î± u (Filter.atBot.{u1} Î¹ _inst_1) (Filter.atBot.{u3} Î± _inst_2)))
but is expected to have type
  forall {Î¹ : Type.{u3}} {Î¹' : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u3} Î¹] [_inst_2 : Preorder.{u2} Î±] {u : Î¹ -> Î±} {Ï† : Î¹' -> Î¹}, (Monotone.{u3, u2} Î¹ Î± _inst_1 _inst_2 u) -> (forall {l : Filter.{u1} Î¹'} [_inst_3 : Filter.NeBot.{u1} Î¹' l], (Filter.Tendsto.{u1, u2} Î¹' Î± (Function.comp.{succ u1, succ u3, succ u2} Î¹' Î¹ Î± u Ï†) l (Filter.atBot.{u2} Î± _inst_2)) -> (Filter.Tendsto.{u3, u2} Î¹ Î± u (Filter.atBot.{u3} Î¹ _inst_1) (Filter.atBot.{u2} Î± _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_at_bot_of_monotone_of_subseq Filter.tendsto_atBot_of_monotone_of_subseqâ‚“'. -/
theorem tendsto_atBot_of_monotone_of_subseq [Preorder Î¹] [Preorder Î±] {u : Î¹ â†’ Î±} {Ï† : Î¹' â†’ Î¹}
    (h : Monotone u) {l : Filter Î¹'} [NeBot l] (H : Tendsto (u âˆ˜ Ï†) l atBot) :
    Tendsto u atBot atBot :=
  tendsto_atBot_of_monotone_of_filter h (tendsto_map' H)
#align filter.tendsto_at_bot_of_monotone_of_subseq Filter.tendsto_atBot_of_monotone_of_subseq

/- warning: filter.map_at_top_finset_prod_le_of_prod_eq -> Filter.map_atTop_finset_prod_le_of_prod_eq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : CommMonoid.{u1} Î±] {f : Î² -> Î±} {g : Î³ -> Î±}, (forall (u : Finset.{u3} Î³), Exists.{succ u2} (Finset.{u2} Î²) (fun (v : Finset.{u2} Î²) => forall (v' : Finset.{u2} Î²), (HasSubset.Subset.{u2} (Finset.{u2} Î²) (Finset.hasSubset.{u2} Î²) v v') -> (Exists.{succ u3} (Finset.{u3} Î³) (fun (u' : Finset.{u3} Î³) => And (HasSubset.Subset.{u3} (Finset.{u3} Î³) (Finset.hasSubset.{u3} Î³) u u') (Eq.{succ u1} Î± (Finset.prod.{u1, u3} Î± Î³ _inst_1 u' (fun (x : Î³) => g x)) (Finset.prod.{u1, u2} Î± Î² _inst_1 v' (fun (b : Î²) => f b))))))) -> (LE.le.{u1} (Filter.{u1} Î±) (Preorder.toHasLe.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (Filter.map.{u2, u1} (Finset.{u2} Î²) Î± (fun (s : Finset.{u2} Î²) => Finset.prod.{u1, u2} Î± Î² _inst_1 s (fun (b : Î²) => f b)) (Filter.atTop.{u2} (Finset.{u2} Î²) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î²) (Finset.partialOrder.{u2} Î²)))) (Filter.map.{u3, u1} (Finset.{u3} Î³) Î± (fun (s : Finset.{u3} Î³) => Finset.prod.{u1, u3} Î± Î³ _inst_1 s (fun (x : Î³) => g x)) (Filter.atTop.{u3} (Finset.{u3} Î³) (PartialOrder.toPreorder.{u3} (Finset.{u3} Î³) (Finset.partialOrder.{u3} Î³)))))
but is expected to have type
  forall {Î± : Type.{u3}} {Î² : Type.{u1}} {Î³ : Type.{u2}} [_inst_1 : CommMonoid.{u3} Î±] {f : Î² -> Î±} {g : Î³ -> Î±}, (forall (u : Finset.{u2} Î³), Exists.{succ u1} (Finset.{u1} Î²) (fun (v : Finset.{u1} Î²) => forall (v' : Finset.{u1} Î²), (HasSubset.Subset.{u1} (Finset.{u1} Î²) (Finset.instHasSubsetFinset.{u1} Î²) v v') -> (Exists.{succ u2} (Finset.{u2} Î³) (fun (u' : Finset.{u2} Î³) => And (HasSubset.Subset.{u2} (Finset.{u2} Î³) (Finset.instHasSubsetFinset.{u2} Î³) u u') (Eq.{succ u3} Î± (Finset.prod.{u3, u2} Î± Î³ _inst_1 u' (fun (x : Î³) => g x)) (Finset.prod.{u3, u1} Î± Î² _inst_1 v' (fun (b : Î²) => f b))))))) -> (LE.le.{u3} (Filter.{u3} Î±) (Preorder.toLE.{u3} (Filter.{u3} Î±) (PartialOrder.toPreorder.{u3} (Filter.{u3} Î±) (Filter.instPartialOrderFilter.{u3} Î±))) (Filter.map.{u1, u3} (Finset.{u1} Î²) Î± (fun (s : Finset.{u1} Î²) => Finset.prod.{u3, u1} Î± Î² _inst_1 s (fun (b : Î²) => f b)) (Filter.atTop.{u1} (Finset.{u1} Î²) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î²) (Finset.partialOrder.{u1} Î²)))) (Filter.map.{u2, u3} (Finset.{u2} Î³) Î± (fun (s : Finset.{u2} Î³) => Finset.prod.{u3, u2} Î± Î³ _inst_1 s (fun (x : Î³) => g x)) (Filter.atTop.{u2} (Finset.{u2} Î³) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î³) (Finset.partialOrder.{u2} Î³)))))
Case conversion may be inaccurate. Consider using '#align filter.map_at_top_finset_prod_le_of_prod_eq Filter.map_atTop_finset_prod_le_of_prod_eqâ‚“'. -/
/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (Î» s, âˆ b in s, f b)` with
`at_top.map (Î» s, âˆ b in s, g b)`. This is useful to compare the set of limit points of
`Î  b in s, f b` as `s â†’ at_top` with the similar set for `g`. -/
@[to_additive
      "Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\na sufficient condition for comparison of the filter `at_top.map (Î» s, âˆ‘ b in s, f b)` with\n`at_top.map (Î» s, âˆ‘ b in s, g b)`. This is useful to compare the set of limit points of\n`âˆ‘ b in s, f b` as `s â†’ at_top` with the similar set for `g`."]
theorem map_atTop_finset_prod_le_of_prod_eq [CommMonoid Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±}
    (h_eq :
      âˆ€ u : Finset Î³,
        âˆƒ v : Finset Î², âˆ€ v', v âŠ† v' â†’ âˆƒ u', u âŠ† u' âˆ§ (âˆ x in u', g x) = âˆ b in v', f b) :
    (atTop.map fun s : Finset Î² => âˆ b in s, f b) â‰¤ atTop.map fun s : Finset Î³ => âˆ x in s, g x :=
  by
  rw [map_at_top_eq, map_at_top_eq] <;>
    exact
      le_iInf fun b =>
        let âŸ¨v, hvâŸ© := h_eq b
        iInf_le_of_le v <| by simp [Set.image_subset_iff] <;> exact hv
#align filter.map_at_top_finset_prod_le_of_prod_eq Filter.map_atTop_finset_prod_le_of_prod_eq
#align filter.map_at_top_finset_sum_le_of_sum_eq Filter.map_atTop_finset_sum_le_of_sum_eq

/- warning: filter.has_antitone_basis.eventually_subset -> Filter.HasAntitoneBasis.eventually_subset is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u1} Î¹] {l : Filter.{u2} Î±} {s : Î¹ -> (Set.{u2} Î±)}, (Filter.HasAntitoneBasis.{u2, u1} Î± Î¹ _inst_1 l s) -> (forall {t : Set.{u2} Î±}, (Membership.Mem.{u2, u2} (Set.{u2} Î±) (Filter.{u2} Î±) (Filter.hasMem.{u2} Î±) t l) -> (Filter.Eventually.{u1} Î¹ (fun (i : Î¹) => HasSubset.Subset.{u2} (Set.{u2} Î±) (Set.hasSubset.{u2} Î±) (s i) t) (Filter.atTop.{u1} Î¹ _inst_1)))
but is expected to have type
  forall {Î¹ : Type.{u2}} {Î± : Type.{u1}} [_inst_1 : Preorder.{u2} Î¹] {l : Filter.{u1} Î±} {s : Î¹ -> (Set.{u1} Î±)}, (Filter.HasAntitoneBasis.{u1, u2} Î± Î¹ _inst_1 l s) -> (forall {t : Set.{u1} Î±}, (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) t l) -> (Filter.Eventually.{u2} Î¹ (fun (i : Î¹) => HasSubset.Subset.{u1} (Set.{u1} Î±) (Set.instHasSubsetSet.{u1} Î±) (s i) t) (Filter.atTop.{u2} Î¹ _inst_1)))
Case conversion may be inaccurate. Consider using '#align filter.has_antitone_basis.eventually_subset Filter.HasAntitoneBasis.eventually_subsetâ‚“'. -/
theorem HasAntitoneBasis.eventually_subset [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}
    (hl : l.HasAntitoneBasis s) {t : Set Î±} (ht : t âˆˆ l) : âˆ€á¶  i in atTop, s i âŠ† t :=
  let âŸ¨i, _, hiâŸ© := hl.to_hasBasis.mem_iff.1 ht
  (eventually_ge_atTop i).mono fun j hj => (hl.Antitone hj).trans hi
#align filter.has_antitone_basis.eventually_subset Filter.HasAntitoneBasis.eventually_subset

/- warning: filter.has_antitone_basis.tendsto -> Filter.HasAntitoneBasis.tendsto is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î± : Type.{u2}} [_inst_1 : Preorder.{u1} Î¹] {l : Filter.{u2} Î±} {s : Î¹ -> (Set.{u2} Î±)}, (Filter.HasAntitoneBasis.{u2, u1} Î± Î¹ _inst_1 l s) -> (forall {Ï† : Î¹ -> Î±}, (forall (i : Î¹), Membership.Mem.{u2, u2} Î± (Set.{u2} Î±) (Set.hasMem.{u2} Î±) (Ï† i) (s i)) -> (Filter.Tendsto.{u1, u2} Î¹ Î± Ï† (Filter.atTop.{u1} Î¹ _inst_1) l))
but is expected to have type
  forall {Î¹ : Type.{u2}} {Î± : Type.{u1}} [_inst_1 : Preorder.{u2} Î¹] {l : Filter.{u1} Î±} {s : Î¹ -> (Set.{u1} Î±)}, (Filter.HasAntitoneBasis.{u1, u2} Î± Î¹ _inst_1 l s) -> (forall {Ï† : Î¹ -> Î±}, (forall (i : Î¹), Membership.mem.{u1, u1} Î± (Set.{u1} Î±) (Set.instMembershipSet.{u1} Î±) (Ï† i) (s i)) -> (Filter.Tendsto.{u2, u1} Î¹ Î± Ï† (Filter.atTop.{u2} Î¹ _inst_1) l))
Case conversion may be inaccurate. Consider using '#align filter.has_antitone_basis.tendsto Filter.HasAntitoneBasis.tendstoâ‚“'. -/
protected theorem HasAntitoneBasis.tendsto [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}
    (hl : l.HasAntitoneBasis s) {Ï† : Î¹ â†’ Î±} (h : âˆ€ i : Î¹, Ï† i âˆˆ s i) : Tendsto Ï† atTop l :=
  fun t ht => mem_map.2 <| (hl.eventually_subset ht).mono fun i hi => hi (h i)
#align filter.has_antitone_basis.tendsto Filter.HasAntitoneBasis.tendsto

/- warning: filter.has_antitone_basis.comp_mono -> Filter.HasAntitoneBasis.comp_mono is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {Î¹' : Type.{u2}} {Î± : Type.{u3}} [_inst_1 : SemilatticeSup.{u1} Î¹] [_inst_2 : Nonempty.{succ u1} Î¹] [_inst_3 : Preorder.{u2} Î¹'] {l : Filter.{u3} Î±} {s : Î¹' -> (Set.{u3} Î±)}, (Filter.HasAntitoneBasis.{u3, u2} Î± Î¹' _inst_3 l s) -> (forall {Ï† : Î¹ -> Î¹'}, (Monotone.{u1, u2} Î¹ Î¹' (PartialOrder.toPreorder.{u1} Î¹ (SemilatticeSup.toPartialOrder.{u1} Î¹ _inst_1)) _inst_3 Ï†) -> (Filter.Tendsto.{u1, u2} Î¹ Î¹' Ï† (Filter.atTop.{u1} Î¹ (PartialOrder.toPreorder.{u1} Î¹ (SemilatticeSup.toPartialOrder.{u1} Î¹ _inst_1))) (Filter.atTop.{u2} Î¹' _inst_3)) -> (Filter.HasAntitoneBasis.{u3, u1} Î± Î¹ (PartialOrder.toPreorder.{u1} Î¹ (SemilatticeSup.toPartialOrder.{u1} Î¹ _inst_1)) l (Function.comp.{succ u1, succ u2, succ u3} Î¹ Î¹' (Set.{u3} Î±) s Ï†)))
but is expected to have type
  forall {Î¹ : Type.{u3}} {Î¹' : Type.{u2}} {Î± : Type.{u1}} [_inst_1 : SemilatticeSup.{u3} Î¹] [_inst_2 : Nonempty.{succ u3} Î¹] [_inst_3 : Preorder.{u2} Î¹'] {l : Filter.{u1} Î±} {s : Î¹' -> (Set.{u1} Î±)}, (Filter.HasAntitoneBasis.{u1, u2} Î± Î¹' _inst_3 l s) -> (forall {Ï† : Î¹ -> Î¹'}, (Monotone.{u3, u2} Î¹ Î¹' (PartialOrder.toPreorder.{u3} Î¹ (SemilatticeSup.toPartialOrder.{u3} Î¹ _inst_1)) _inst_3 Ï†) -> (Filter.Tendsto.{u3, u2} Î¹ Î¹' Ï† (Filter.atTop.{u3} Î¹ (PartialOrder.toPreorder.{u3} Î¹ (SemilatticeSup.toPartialOrder.{u3} Î¹ _inst_1))) (Filter.atTop.{u2} Î¹' _inst_3)) -> (Filter.HasAntitoneBasis.{u1, u3} Î± Î¹ (PartialOrder.toPreorder.{u3} Î¹ (SemilatticeSup.toPartialOrder.{u3} Î¹ _inst_1)) l (Function.comp.{succ u3, succ u2, succ u1} Î¹ Î¹' (Set.{u1} Î±) s Ï†)))
Case conversion may be inaccurate. Consider using '#align filter.has_antitone_basis.comp_mono Filter.HasAntitoneBasis.comp_monoâ‚“'. -/
theorem HasAntitoneBasis.comp_mono [SemilatticeSup Î¹] [Nonempty Î¹] [Preorder Î¹'] {l : Filter Î±}
    {s : Î¹' â†’ Set Î±} (hs : l.HasAntitoneBasis s) {Ï† : Î¹ â†’ Î¹'} (Ï†_mono : Monotone Ï†)
    (hÏ† : Tendsto Ï† atTop atTop) : l.HasAntitoneBasis (s âˆ˜ Ï†) :=
  âŸ¨hs.to_hasBasis.to_hasBasis
      (fun n hn =>
        (hÏ†.Eventually (eventually_ge_atTop n)).exists.imp fun m hm => âŸ¨trivial, hs.Antitone hmâŸ©)
      fun n hn => âŸ¨Ï† n, trivial, Subset.rflâŸ©,
    hs.Antitone.comp_monotone Ï†_monoâŸ©
#align filter.has_antitone_basis.comp_mono Filter.HasAntitoneBasis.comp_mono

#print Filter.HasAntitoneBasis.comp_strictMono /-
theorem HasAntitoneBasis.comp_strictMono {l : Filter Î±} {s : â„• â†’ Set Î±} (hs : l.HasAntitoneBasis s)
    {Ï† : â„• â†’ â„•} (hÏ† : StrictMono Ï†) : l.HasAntitoneBasis (s âˆ˜ Ï†) :=
  hs.comp_mono hÏ†.Monotone hÏ†.tendsto_atTop
#align filter.has_antitone_basis.comp_strict_mono Filter.HasAntitoneBasis.comp_strictMono
-/

#print Filter.HasAntitoneBasis.subbasis_with_rel /-
/-- Given an antitone basis `s : â„• â†’ set Î±` of a filter, extract an antitone subbasis `s âˆ˜ Ï†`,
`Ï† : â„• â†’ â„•`, such that `m < n` implies `r (Ï† m) (Ï† n)`. This lemma can be used to extract an
antitone basis with basis sets decreasing "sufficiently fast". -/
theorem HasAntitoneBasis.subbasis_with_rel {f : Filter Î±} {s : â„• â†’ Set Î±}
    (hs : f.HasAntitoneBasis s) {r : â„• â†’ â„• â†’ Prop} (hr : âˆ€ m, âˆ€á¶  n in atTop, r m n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ (âˆ€ â¦ƒm nâ¦„, m < n â†’ r (Ï† m) (Ï† n)) âˆ§ f.HasAntitoneBasis (s âˆ˜ Ï†) :=
  by
  rsuffices âŸ¨Ï†, hÏ†, hrÏ†âŸ© : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ m n, m < n â†’ r (Ï† m) (Ï† n)
  Â· exact âŸ¨Ï†, hÏ†, hrÏ†, hs.comp_strict_mono hÏ†âŸ©
  have : âˆ€ t : Set â„•, t.Finite â†’ âˆ€á¶  n in at_top, âˆ€ m âˆˆ t, m < n âˆ§ r m n := fun t ht =>
    (eventually_all_finite ht).2 fun m hm => (eventually_gt_at_top m).And (hr _)
  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with âŸ¨Ï†, hÏ†âŸ©
  simp only [ball_image_iff, forall_and, mem_Iio] at hÏ†
  exact âŸ¨Ï†, forall_swap.2 hÏ†.1, forall_swap.2 hÏ†.2âŸ©
#align filter.has_antitone_basis.subbasis_with_rel Filter.HasAntitoneBasis.subbasis_with_rel
-/

#print Filter.exists_seq_tendsto /-
/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges
to `f`. -/
theorem exists_seq_tendsto (f : Filter Î±) [IsCountablyGenerated f] [NeBot f] :
    âˆƒ x : â„• â†’ Î±, Tendsto x atTop f :=
  by
  obtain âŸ¨B, hâŸ© := f.exists_antitone_basis
  choose x hx using fun n => Filter.nonempty_of_mem (h.mem n)
  exact âŸ¨x, h.tendsto hxâŸ©
#align filter.exists_seq_tendsto Filter.exists_seq_tendsto
-/

/- warning: filter.tendsto_iff_seq_tendsto -> Filter.tendsto_iff_seq_tendsto is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {f : Î± -> Î²} {k : Filter.{u1} Î±} {l : Filter.{u2} Î²} [_inst_1 : Filter.IsCountablyGenerated.{u1} Î± k], Iff (Filter.Tendsto.{u1, u2} Î± Î² f k l) (forall (x : Nat -> Î±), (Filter.Tendsto.{0, u1} Nat Î± x (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) k) -> (Filter.Tendsto.{0, u2} Nat Î² (Function.comp.{1, succ u1, succ u2} Nat Î± Î² f x) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) l))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {f : Î± -> Î²} {k : Filter.{u2} Î±} {l : Filter.{u1} Î²} [_inst_1 : Filter.IsCountablyGenerated.{u2} Î± k], Iff (Filter.Tendsto.{u2, u1} Î± Î² f k l) (forall (x : Nat -> Î±), (Filter.Tendsto.{0, u2} Nat Î± x (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) k) -> (Filter.Tendsto.{0, u1} Nat Î² (Function.comp.{1, succ u2, succ u1} Nat Î± Î² f x) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) l))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_iff_seq_tendsto Filter.tendsto_iff_seq_tendstoâ‚“'. -/
/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`
converging to `k`, `f âˆ˜ u` tends to `l`. -/
theorem tendsto_iff_seq_tendsto {f : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k.IsCountablyGenerated] :
    Tendsto f k l â†” âˆ€ x : â„• â†’ Î±, Tendsto x atTop k â†’ Tendsto (f âˆ˜ x) atTop l :=
  by
  refine' âŸ¨fun h x hx => h.comp hx, fun H s hs => _âŸ©
  contrapose! H
  have : ne_bot (k âŠ“ ð“Ÿ (f â»Â¹' sá¶œ)) := by simpa [ne_bot_iff, inf_principal_eq_bot]
  rcases(k âŠ“ ð“Ÿ (f â»Â¹' sá¶œ)).exists_seq_tendsto with âŸ¨x, hxâŸ©
  rw [tendsto_inf, tendsto_principal] at hx
  refine' âŸ¨x, hx.1, fun h => _âŸ©
  rcases(hx.2.And (h hs)).exists with âŸ¨N, hnmem, hmemâŸ©
  exact hnmem hmem
#align filter.tendsto_iff_seq_tendsto Filter.tendsto_iff_seq_tendsto

/- warning: filter.tendsto_of_seq_tendsto -> Filter.tendsto_of_seq_tendsto is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {f : Î± -> Î²} {k : Filter.{u1} Î±} {l : Filter.{u2} Î²} [_inst_1 : Filter.IsCountablyGenerated.{u1} Î± k], (forall (x : Nat -> Î±), (Filter.Tendsto.{0, u1} Nat Î± x (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) k) -> (Filter.Tendsto.{0, u2} Nat Î² (Function.comp.{1, succ u1, succ u2} Nat Î± Î² f x) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) l)) -> (Filter.Tendsto.{u1, u2} Î± Î² f k l)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {f : Î± -> Î²} {k : Filter.{u2} Î±} {l : Filter.{u1} Î²} [_inst_1 : Filter.IsCountablyGenerated.{u2} Î± k], (forall (x : Nat -> Î±), (Filter.Tendsto.{0, u2} Nat Î± x (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) k) -> (Filter.Tendsto.{0, u1} Nat Î² (Function.comp.{1, succ u2, succ u1} Nat Î± Î² f x) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) l)) -> (Filter.Tendsto.{u2, u1} Î± Î² f k l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_of_seq_tendsto Filter.tendsto_of_seq_tendstoâ‚“'. -/
theorem tendsto_of_seq_tendsto {f : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k.IsCountablyGenerated] :
    (âˆ€ x : â„• â†’ Î±, Tendsto x atTop k â†’ Tendsto (f âˆ˜ x) atTop l) â†’ Tendsto f k l :=
  tendsto_iff_seq_tendsto.2
#align filter.tendsto_of_seq_tendsto Filter.tendsto_of_seq_tendsto

/- warning: filter.tendsto_iff_forall_eventually_mem -> Filter.tendsto_iff_forall_eventually_mem is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î¹ : Type.{u2}} {x : Î¹ -> Î±} {f : Filter.{u1} Î±} {l : Filter.{u2} Î¹}, Iff (Filter.Tendsto.{u2, u1} Î¹ Î± x l f) (forall (s : Set.{u1} Î±), (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) s f) -> (Filter.Eventually.{u2} Î¹ (fun (n : Î¹) => Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) (x n) s) l))
but is expected to have type
  forall {Î± : Type.{u1}} {Î¹ : Type.{u2}} {x : Î± -> Î¹} {f : Filter.{u2} Î¹} {l : Filter.{u1} Î±}, Iff (Filter.Tendsto.{u1, u2} Î± Î¹ x l f) (forall (s : Set.{u2} Î¹), (Membership.mem.{u2, u2} (Set.{u2} Î¹) (Filter.{u2} Î¹) (instMembershipSetFilter.{u2} Î¹) s f) -> (Filter.Eventually.{u1} Î± (fun (n : Î±) => Membership.mem.{u2, u2} Î¹ (Set.{u2} Î¹) (Set.instMembershipSet.{u2} Î¹) (x n) s) l))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_iff_forall_eventually_mem Filter.tendsto_iff_forall_eventually_memâ‚“'. -/
theorem tendsto_iff_forall_eventually_mem {Î± Î¹ : Type _} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} :
    Tendsto x l f â†” âˆ€ s âˆˆ f, âˆ€á¶  n in l, x n âˆˆ s :=
  by
  rw [tendsto_def]
  refine' forall_congr' fun s => imp_congr_right fun hsf => _
  rfl
#align filter.tendsto_iff_forall_eventually_mem Filter.tendsto_iff_forall_eventually_mem

/- warning: filter.not_tendsto_iff_exists_frequently_nmem -> Filter.not_tendsto_iff_exists_frequently_nmem is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î¹ : Type.{u2}} {x : Î¹ -> Î±} {f : Filter.{u1} Î±} {l : Filter.{u2} Î¹}, Iff (Not (Filter.Tendsto.{u2, u1} Î¹ Î± x l f)) (Exists.{succ u1} (Set.{u1} Î±) (fun (s : Set.{u1} Î±) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) s f) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) s f) => Filter.Frequently.{u2} Î¹ (fun (n : Î¹) => Not (Membership.Mem.{u1, u1} Î± (Set.{u1} Î±) (Set.hasMem.{u1} Î±) (x n) s)) l)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î¹ : Type.{u2}} {x : Î± -> Î¹} {f : Filter.{u2} Î¹} {l : Filter.{u1} Î±}, Iff (Not (Filter.Tendsto.{u1, u2} Î± Î¹ x l f)) (Exists.{succ u2} (Set.{u2} Î¹) (fun (s : Set.{u2} Î¹) => And (Membership.mem.{u2, u2} (Set.{u2} Î¹) (Filter.{u2} Î¹) (instMembershipSetFilter.{u2} Î¹) s f) (Filter.Frequently.{u1} Î± (fun (n : Î±) => Not (Membership.mem.{u2, u2} Î¹ (Set.{u2} Î¹) (Set.instMembershipSet.{u2} Î¹) (x n) s)) l)))
Case conversion may be inaccurate. Consider using '#align filter.not_tendsto_iff_exists_frequently_nmem Filter.not_tendsto_iff_exists_frequently_nmemâ‚“'. -/
theorem not_tendsto_iff_exists_frequently_nmem {Î± Î¹ : Type _} {x : Î¹ â†’ Î±} {f : Filter Î±}
    {l : Filter Î¹} : Â¬Tendsto x l f â†” âˆƒ s âˆˆ f, âˆƒá¶  n in l, x n âˆ‰ s :=
  by
  rw [tendsto_iff_forall_eventually_mem]
  push_neg
  refine' exists_congr fun s => _
  rw [not_eventually, exists_prop]
#align filter.not_tendsto_iff_exists_frequently_nmem Filter.not_tendsto_iff_exists_frequently_nmem

#print Filter.frequently_iff_seq_frequently /-
theorem frequently_iff_seq_frequently {Î¹ : Type _} {l : Filter Î¹} {p : Î¹ â†’ Prop}
    [hl : l.IsCountablyGenerated] :
    (âˆƒá¶  n in l, p n) â†” âˆƒ x : â„• â†’ Î¹, Tendsto x atTop l âˆ§ âˆƒá¶  n : â„• in atTop, p (x n) :=
  by
  refine' âŸ¨fun h_freq => _, fun h_exists_freq => _âŸ©
  Â· have : ne_bot (l âŠ“ ð“Ÿ { x : Î¹ | p x }) := by simpa [ne_bot_iff, inf_principal_eq_bot]
    obtain âŸ¨x, hxâŸ© := exists_seq_tendsto (l âŠ“ ð“Ÿ { x : Î¹ | p x })
    rw [tendsto_inf] at hx
    cases' hx with hx_l hx_p
    refine' âŸ¨x, hx_l, _âŸ©
    rw [tendsto_principal] at hx_p
    exact hx_p.frequently
  Â· obtain âŸ¨x, hx_tendsto, hx_freqâŸ© := h_exists_freq
    simp_rw [Filter.Frequently, Filter.Eventually] at hx_freqâŠ¢
    have : { n : â„• | Â¬p (x n) } = { n | x n âˆˆ { y | Â¬p y } } := rfl
    rw [this, â† mem_map'] at hx_freq
    contrapose! hx_freq
    exact hx_tendsto hx_freq
#align filter.frequently_iff_seq_frequently Filter.frequently_iff_seq_frequently
-/

#print Filter.eventually_iff_seq_eventually /-
theorem eventually_iff_seq_eventually {Î¹ : Type _} {l : Filter Î¹} {p : Î¹ â†’ Prop}
    [hl : l.IsCountablyGenerated] :
    (âˆ€á¶  n in l, p n) â†” âˆ€ x : â„• â†’ Î¹, Tendsto x atTop l â†’ âˆ€á¶  n : â„• in atTop, p (x n) :=
  by
  have : (âˆ€á¶  n in l, p n) â†” Â¬âˆƒá¶  n in l, Â¬p n :=
    by
    rw [not_frequently]
    simp_rw [Classical.not_not]
  rw [this, frequently_iff_seq_frequently]
  push_neg
  simp_rw [not_frequently, Classical.not_not]
#align filter.eventually_iff_seq_eventually Filter.eventually_iff_seq_eventually
-/

#print Filter.subseq_forall_of_frequently /-
theorem subseq_forall_of_frequently {Î¹ : Type _} {x : â„• â†’ Î¹} {p : Î¹ â†’ Prop} {l : Filter Î¹}
    (h_tendsto : Tendsto x atTop l) (h : âˆƒá¶  n in atTop, p (x n)) :
    âˆƒ ns : â„• â†’ â„•, Tendsto (fun n => x (ns n)) atTop l âˆ§ âˆ€ n, p (x (ns n)) :=
  by
  rw [tendsto_iff_seq_tendsto] at h_tendsto
  choose ns hge hns using frequently_at_top.1 h
  exact âŸ¨ns, h_tendsto ns (tendsto_at_top_mono hge tendsto_id), hnsâŸ©
#align filter.subseq_forall_of_frequently Filter.subseq_forall_of_frequently
-/

#print Filter.exists_seq_forall_of_frequently /-
theorem exists_seq_forall_of_frequently {Î¹ : Type _} {l : Filter Î¹} {p : Î¹ â†’ Prop}
    [hl : l.IsCountablyGenerated] (h : âˆƒá¶  n in l, p n) :
    âˆƒ ns : â„• â†’ Î¹, Tendsto ns atTop l âˆ§ âˆ€ n, p (ns n) :=
  by
  rw [frequently_iff_seq_frequently] at h
  obtain âŸ¨x, hx_tendsto, hx_freqâŸ© := h
  obtain âŸ¨n_to_n, h_tendsto, h_freqâŸ© := subseq_forall_of_frequently hx_tendsto hx_freq
  exact âŸ¨x âˆ˜ n_to_n, h_tendsto, h_freqâŸ©
#align filter.exists_seq_forall_of_frequently Filter.exists_seq_forall_of_frequently
-/

/- warning: filter.tendsto_of_subseq_tendsto -> Filter.tendsto_of_subseq_tendsto is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î¹ : Type.{u2}} {x : Î¹ -> Î±} {f : Filter.{u1} Î±} {l : Filter.{u2} Î¹} [_inst_1 : Filter.IsCountablyGenerated.{u2} Î¹ l], (forall (ns : Nat -> Î¹), (Filter.Tendsto.{0, u2} Nat Î¹ ns (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) l) -> (Exists.{1} (Nat -> Nat) (fun (ms : Nat -> Nat) => Filter.Tendsto.{0, u1} Nat Î± (fun (n : Nat) => x (ns (ms n))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) f))) -> (Filter.Tendsto.{u2, u1} Î¹ Î± x l f)
but is expected to have type
  forall {Î± : Type.{u2}} {Î¹ : Type.{u1}} {x : Î¹ -> Î±} {f : Filter.{u2} Î±} {l : Filter.{u1} Î¹} [_inst_1 : Filter.IsCountablyGenerated.{u1} Î¹ l], (forall (ns : Nat -> Î¹), (Filter.Tendsto.{0, u1} Nat Î¹ ns (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) l) -> (Exists.{1} (Nat -> Nat) (fun (ms : Nat -> Nat) => Filter.Tendsto.{0, u2} Nat Î± (fun (n : Nat) => x (ns (ms n))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) f))) -> (Filter.Tendsto.{u1, u2} Î¹ Î± x l f)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_of_subseq_tendsto Filter.tendsto_of_subseq_tendstoâ‚“'. -/
/-- A sequence converges if every subsequence has a convergent subsequence. -/
theorem tendsto_of_subseq_tendsto {Î± Î¹ : Type _} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹}
    [l.IsCountablyGenerated]
    (hxy :
      âˆ€ ns : â„• â†’ Î¹, Tendsto ns atTop l â†’ âˆƒ ms : â„• â†’ â„•, Tendsto (fun n => x (ns <| ms n)) atTop f) :
    Tendsto x l f := by
  by_contra h
  obtain âŸ¨s, hs, hfreqâŸ© : âˆƒ s âˆˆ f, âˆƒá¶  n in l, x n âˆ‰ s := by
    rwa [not_tendsto_iff_exists_frequently_nmem] at h
  obtain âŸ¨y, hy_tendsto, hy_freqâŸ© := exists_seq_forall_of_frequently hfreq
  specialize hxy y hy_tendsto
  obtain âŸ¨ms, hms_tendstoâŸ© := hxy
  specialize hms_tendsto hs
  rw [mem_map] at hms_tendsto
  have hms_freq : âˆ€ n : â„•, x (y (ms n)) âˆ‰ s := fun n => hy_freq (ms n)
  have h_empty : (fun n : â„• => x (y (ms n))) â»Â¹' s = âˆ… :=
    by
    ext1 n
    simp only [Set.mem_preimage, Set.mem_empty_iff_false, iff_false_iff]
    exact hms_freq n
  rw [h_empty] at hms_tendsto
  exact empty_not_mem at_top hms_tendsto
#align filter.tendsto_of_subseq_tendsto Filter.tendsto_of_subseq_tendsto

/- warning: filter.subseq_tendsto_of_ne_bot -> Filter.subseq_tendsto_of_neBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {f : Filter.{u1} Î±} [_inst_1 : Filter.IsCountablyGenerated.{u1} Î± f] {u : Nat -> Î±}, (Filter.NeBot.{u1} Î± (Inf.inf.{u1} (Filter.{u1} Î±) (Filter.hasInf.{u1} Î±) f (Filter.map.{0, u1} Nat Î± u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))))) -> (Exists.{1} (Nat -> Nat) (fun (Î¸ : Nat -> Nat) => And (StrictMono.{0, 0} Nat Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) Î¸) (Filter.Tendsto.{0, u1} Nat Î± (Function.comp.{1, 1, succ u1} Nat Nat Î± u Î¸) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) f)))
but is expected to have type
  forall {Î± : Type.{u1}} {f : Filter.{u1} Î±} [_inst_1 : Filter.IsCountablyGenerated.{u1} Î± f] {u : Nat -> Î±}, (Filter.NeBot.{u1} Î± (Inf.inf.{u1} (Filter.{u1} Î±) (Filter.instInfFilter.{u1} Î±) f (Filter.map.{0, u1} Nat Î± u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))))) -> (Exists.{1} (Nat -> Nat) (fun (Î¸ : Nat -> Nat) => And (StrictMono.{0, 0} Nat Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) Î¸) (Filter.Tendsto.{0, u1} Nat Î± (Function.comp.{1, 1, succ u1} Nat Nat Î± u Î¸) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) f)))
Case conversion may be inaccurate. Consider using '#align filter.subseq_tendsto_of_ne_bot Filter.subseq_tendsto_of_neBotâ‚“'. -/
theorem subseq_tendsto_of_neBot {f : Filter Î±} [IsCountablyGenerated f] {u : â„• â†’ Î±}
    (hx : NeBot (f âŠ“ map u atTop)) : âˆƒ Î¸ : â„• â†’ â„•, StrictMono Î¸ âˆ§ Tendsto (u âˆ˜ Î¸) atTop f :=
  by
  obtain âŸ¨B, hâŸ© := f.exists_antitone_basis
  have : âˆ€ N, âˆƒ n â‰¥ N, u n âˆˆ B N := fun N =>
    filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial) N
  choose Ï† hÏ† using this
  cases' forall_and_distrib.mp hÏ† with Ï†_ge Ï†_in
  have lim_uÏ† : tendsto (u âˆ˜ Ï†) at_top f := h.tendsto Ï†_in
  have lim_Ï† : tendsto Ï† at_top at_top := tendsto_at_top_mono Ï†_ge tendsto_id
  obtain âŸ¨Ïˆ, hÏˆ, hÏˆÏ†âŸ© : âˆƒ Ïˆ : â„• â†’ â„•, StrictMono Ïˆ âˆ§ StrictMono (Ï† âˆ˜ Ïˆ)
  exact strict_mono_subseq_of_tendsto_at_top lim_Ï†
  exact âŸ¨Ï† âˆ˜ Ïˆ, hÏˆÏ†, lim_uÏ†.comp hÏˆ.tendsto_at_topâŸ©
#align filter.subseq_tendsto_of_ne_bot Filter.subseq_tendsto_of_neBot

end Filter

open Filter Finset

section

variable {R : Type _} [LinearOrderedSemiring R]

/- warning: exists_lt_mul_self -> exists_lt_mul_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} R] (a : R), Exists.{succ u1} R (fun (x : R) => Exists.{0} (GE.ge.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))))))) (fun (H : GE.ge.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))))))) => LT.lt.{u1} R (Preorder.toHasLt.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))) x x)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} R] (a : R), Exists.{succ u1} R (fun (x : R) => And (GE.ge.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))) x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))) (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) x x)))
Case conversion may be inaccurate. Consider using '#align exists_lt_mul_self exists_lt_mul_selfâ‚“'. -/
theorem exists_lt_mul_self (a : R) : âˆƒ x â‰¥ 0, a < x * x :=
  let âŸ¨x, hxa, hx0âŸ© :=
    ((tendsto_mul_self_atTop.Eventually (eventually_gt_atTop a)).And (eventually_ge_atTop 0)).exists
  âŸ¨x, hx0, hxaâŸ©
#align exists_lt_mul_self exists_lt_mul_self

/- warning: exists_le_mul_self -> exists_le_mul_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} R] (a : R), Exists.{succ u1} R (fun (x : R) => Exists.{0} (GE.ge.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))))))) (fun (H : GE.ge.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))))))) => LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))) x x)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} R] (a : R), Exists.{succ u1} R (fun (x : R) => And (GE.ge.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))) x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))) (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) x x)))
Case conversion may be inaccurate. Consider using '#align exists_le_mul_self exists_le_mul_selfâ‚“'. -/
theorem exists_le_mul_self (a : R) : âˆƒ x â‰¥ 0, a â‰¤ x * x :=
  let âŸ¨x, hx0, hxaâŸ© := exists_lt_mul_self a
  âŸ¨x, hx0, hxa.leâŸ©
#align exists_le_mul_self exists_le_mul_self

end

/- warning: function.injective.map_at_top_finset_prod_eq -> Function.Injective.map_atTop_finset_prod_eq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : CommMonoid.{u1} Î±] {g : Î³ -> Î²}, (Function.Injective.{succ u3, succ u2} Î³ Î² g) -> (forall {f : Î² -> Î±}, (forall (x : Î²), (Not (Membership.Mem.{u2, u2} Î² (Set.{u2} Î²) (Set.hasMem.{u2} Î²) x (Set.range.{u2, succ u3} Î² Î³ g))) -> (Eq.{succ u1} Î± (f x) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± (CommMonoid.toMonoid.{u1} Î± _inst_1)))))))) -> (Eq.{succ u1} (Filter.{u1} Î±) (Filter.map.{u3, u1} (Finset.{u3} Î³) Î± (fun (s : Finset.{u3} Î³) => Finset.prod.{u1, u3} Î± Î³ _inst_1 s (fun (i : Î³) => f (g i))) (Filter.atTop.{u3} (Finset.{u3} Î³) (PartialOrder.toPreorder.{u3} (Finset.{u3} Î³) (Finset.partialOrder.{u3} Î³)))) (Filter.map.{u2, u1} (Finset.{u2} Î²) Î± (fun (s : Finset.{u2} Î²) => Finset.prod.{u1, u2} Î± Î² _inst_1 s (fun (i : Î²) => f i)) (Filter.atTop.{u2} (Finset.{u2} Î²) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î²) (Finset.partialOrder.{u2} Î²))))))
but is expected to have type
  forall {Î± : Type.{u3}} {Î² : Type.{u1}} {Î³ : Type.{u2}} [_inst_1 : CommMonoid.{u3} Î±] {g : Î³ -> Î²}, (Function.Injective.{succ u2, succ u1} Î³ Î² g) -> (forall {f : Î² -> Î±}, (forall (x : Î²), (Not (Membership.mem.{u1, u1} Î² (Set.{u1} Î²) (Set.instMembershipSet.{u1} Î²) x (Set.range.{u1, succ u2} Î² Î³ g))) -> (Eq.{succ u3} Î± (f x) (OfNat.ofNat.{u3} Î± 1 (One.toOfNat1.{u3} Î± (Monoid.toOne.{u3} Î± (CommMonoid.toMonoid.{u3} Î± _inst_1)))))) -> (Eq.{succ u3} (Filter.{u3} Î±) (Filter.map.{u2, u3} (Finset.{u2} Î³) Î± (fun (s : Finset.{u2} Î³) => Finset.prod.{u3, u2} Î± Î³ _inst_1 s (fun (i : Î³) => f (g i))) (Filter.atTop.{u2} (Finset.{u2} Î³) (PartialOrder.toPreorder.{u2} (Finset.{u2} Î³) (Finset.partialOrder.{u2} Î³)))) (Filter.map.{u1, u3} (Finset.{u1} Î²) Î± (fun (s : Finset.{u1} Î²) => Finset.prod.{u3, u1} Î± Î² _inst_1 s (fun (i : Î²) => f i)) (Filter.atTop.{u1} (Finset.{u1} Î²) (PartialOrder.toPreorder.{u1} (Finset.{u1} Î²) (Finset.partialOrder.{u1} Î²))))))
Case conversion may be inaccurate. Consider using '#align function.injective.map_at_top_finset_prod_eq Function.Injective.map_atTop_finset_prod_eqâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» set.range[set.range] g) -/
/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (Î» s, âˆ i in s, f (g i))` and `at_top.map (Î» s, âˆ i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
@[to_additive]
theorem Function.Injective.map_atTop_finset_prod_eq [CommMonoid Î±] {g : Î³ â†’ Î²}
    (hg : Function.Injective g) {f : Î² â†’ Î±} (hf : âˆ€ (x) (_ : x âˆ‰ Set.range g), f x = 1) :
    map (fun s => âˆ i in s, f (g i)) atTop = map (fun s => âˆ i in s, f i) atTop :=
  by
  apply le_antisymm <;> refine' map_at_top_finset_prod_le_of_prod_eq fun s => _
  Â· refine' âŸ¨s.preimage g (hg.inj_on _), fun t ht => _âŸ©
    refine' âŸ¨t.image g âˆª s, Finset.subset_union_right _ _, _âŸ©
    rw [â† Finset.prod_image (hg.inj_on _)]
    refine' (prod_subset (subset_union_left _ _) _).symm
    simp only [Finset.mem_union, Finset.mem_image]
    refine' fun y hy hyt => hf y (mt _ hyt)
    rintro âŸ¨x, rflâŸ©
    exact âŸ¨x, ht (Finset.mem_preimage.2 <| hy.resolve_left hyt), rflâŸ©
  Â· refine' âŸ¨s.image g, fun t ht => _âŸ©
    simp only [â† prod_preimage _ _ (hg.inj_on _) _ fun x _ => hf x]
    exact âŸ¨_, (image_subset_iff_subset_preimage _).1 ht, rflâŸ©
#align function.injective.map_at_top_finset_prod_eq Function.Injective.map_atTop_finset_prod_eq
#align function.injective.map_at_top_finset_sum_eq Function.Injective.map_atTop_finset_sum_eq

/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `at_top.map (Î» s, âˆ‘ i in s, f (g i))` and `at_top.map (Î» s, âˆ‘ i in s, f i)` coincide.

This lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
add_decl_doc Function.Injective.map_atTop_finset_sum_eq

