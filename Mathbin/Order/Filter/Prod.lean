/-
Copyright (c) 2022 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johanes HÃ¶lzl, Patrick Massot, Yury Kudryashov, Kevin Wilson, Heather Macbeth
-/
import Mathbin.Order.Filter.Basic

/-!
# Product and coproduct filters

In this file we define `filter.prod f g` (notation: `f Ã—á¶  g`) and `filter.coprod f g`. The product
of two filters is the largest filter `l` such that `filter.tendsto prod.fst l f` and
`filter.tendsto prod.snd l g`.

## Implementation details

The product filter cannot be defined using the monad structure on filters. For example:

```lean
F := do {x â† seq, y â† top, return (x, y)}
G := do {y â† top, x â† seq, return (x, y)}
```
hence:
```lean
s âˆˆ F  â†”  âˆƒ n, [n..âˆ] Ã— univ âŠ† s
s âˆˆ G  â†”  âˆ€ i:â„•, âˆƒ n, [n..âˆ] Ã— {i} âŠ† s
```
Now `â‹ƒ i, [i..âˆ] Ã— {i}` is in `G` but not in `F`.
As product filter we want to have `F` as result.

## Notations

* `f Ã—á¶  g` : `filter.prod f g`, localized in `filter`.

-/


open Set

open Filter

namespace Filter

variable {Î± Î² Î³ Î´ : Type _} {Î¹ : Sort _}

section Prod

variable {s : Set Î±} {t : Set Î²} {f : Filter Î±} {g : Filter Î²}

/-- Product of filters. This is the filter generated by cartesian products
of elements of the component filters. -/
protected def prod (f : Filter Î±) (g : Filter Î²) : Filter (Î± Ã— Î²) :=
  f.comap Prod.fstâŠ“g.comap Prod.snd

-- mathport name: Â«expr Ã—á¶  Â»
localized [Filter] infixl:60 " Ã—á¶  " => Filter.prod

theorem prod_mem_prod {s : Set Î±} {t : Set Î²} {f : Filter Î±} {g : Filter Î²} (hs : s âˆˆ f) (ht : t âˆˆ g) :
    s Ã—Ë¢ t âˆˆ f Ã—á¶  g :=
  inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)

theorem mem_prod_iff {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²} : s âˆˆ f Ã—á¶  g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ Ã—Ë¢ tâ‚‚ âŠ† s :=
  by
  simp only [Filter.prod]
  constructor
  Â· rintro âŸ¨tâ‚, âŸ¨sâ‚, hsâ‚, htsâ‚âŸ©, tâ‚‚, âŸ¨sâ‚‚, hsâ‚‚, htsâ‚‚âŸ©, rflâŸ©
    exact âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, fun p âŸ¨h, h'âŸ© => âŸ¨htsâ‚ h, htsâ‚‚ h'âŸ©âŸ©
    
  Â· rintro âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, hâŸ©
    exact mem_inf_of_inter (preimage_mem_comap htâ‚) (preimage_mem_comap htâ‚‚) h
    

@[simp]
theorem prod_mem_prod_iff {s : Set Î±} {t : Set Î²} {f : Filter Î±} {g : Filter Î²} [f.ne_bot] [g.ne_bot] :
    s Ã—Ë¢ t âˆˆ f Ã—á¶  g â†” s âˆˆ f âˆ§ t âˆˆ g :=
  âŸ¨fun h =>
    let âŸ¨s', hs', t', ht', HâŸ© := mem_prod_iff.1 h
    (prod_subset_prod_iff.1 H).elim (fun âŸ¨hs's, ht'tâŸ© => âŸ¨mem_of_superset hs' hs's, mem_of_superset ht' ht'tâŸ©) fun h =>
      h.elim (fun hs'e => absurd hs'e (nonempty_of_mem hs').ne_empty) fun ht'e =>
        absurd ht'e (nonempty_of_mem ht').ne_empty,
    fun h => prod_mem_prod h.1 h.2âŸ©

theorem mem_prod_principal {f : Filter Î±} {s : Set (Î± Ã— Î²)} {t : Set Î²} :
    s âˆˆ f Ã—á¶  ğ“Ÿ t â†” { a | âˆ€ b âˆˆ t, (a, b) âˆˆ s } âˆˆ f := by
  rw [â† @exists_mem_subset_iff _ f, mem_prod_iff]
  refine' existsâ‚‚_congrâ‚“ fun u u_in => âŸ¨_, fun h => âŸ¨t, mem_principal_self t, _âŸ©âŸ©
  Â· rintro âŸ¨v, v_in, hvâŸ© a a_in b b_in
    exact hv (mk_mem_prod a_in <| v_in b_in)
    
  Â· rintro âŸ¨x, yâŸ© âŸ¨hx, hyâŸ©
    exact h hx y hy
    

theorem mem_prod_top {f : Filter Î±} {s : Set (Î± Ã— Î²)} : s âˆˆ f Ã—á¶  (âŠ¤ : Filter Î²) â†” { a | âˆ€ b, (a, b) âˆˆ s } âˆˆ f := by
  rw [â† principal_univ, mem_prod_principal]
  simp only [mem_univ, forall_true_left]

theorem comap_prod (f : Î± â†’ Î² Ã— Î³) (b : Filter Î²) (c : Filter Î³) :
    comap f (b Ã—á¶  c) = comap (Prod.fst âˆ˜ f) bâŠ“comap (Prod.snd âˆ˜ f) c := by
  erw [comap_inf, Filter.comap_comap, Filter.comap_comap]

theorem prod_top {f : Filter Î±} : f Ã—á¶  (âŠ¤ : Filter Î²) = f.comap Prod.fst := by
  rw [Filter.prod, comap_top, inf_top_eq]

theorem sup_prod (fâ‚ fâ‚‚ : Filter Î±) (g : Filter Î²) : fâ‚âŠ”fâ‚‚ Ã—á¶  g = (fâ‚ Ã—á¶  g)âŠ”(fâ‚‚ Ã—á¶  g) := by
  rw [Filter.prod, comap_sup, inf_sup_right, â† Filter.prod, â† Filter.prod]

theorem prod_sup (f : Filter Î±) (gâ‚ gâ‚‚ : Filter Î²) : f Ã—á¶  gâ‚âŠ”gâ‚‚ = (f Ã—á¶  gâ‚)âŠ”(f Ã—á¶  gâ‚‚) := by
  rw [Filter.prod, comap_sup, inf_sup_left, â† Filter.prod, â† Filter.prod]

theorem eventually_prod_iff {p : Î± Ã— Î² â†’ Prop} {f : Filter Î±} {g : Filter Î²} :
    (âˆ€á¶  x in f Ã—á¶  g, p x) â†”
      âˆƒ (pa : Î± â†’ Prop)(ha : âˆ€á¶  x in f, pa x)(pb : Î² â†’ Prop)(hb : âˆ€á¶  y in g, pb y),
        âˆ€ {x}, pa x â†’ âˆ€ {y}, pb y â†’ p (x, y) :=
  by
  simpa only [Set.prod_subset_iff] using @mem_prod_iff Î± Î² p f g

theorem tendsto_fst {f : Filter Î±} {g : Filter Î²} : Tendsto Prod.fst (f Ã—á¶  g) f :=
  tendsto_inf_left tendsto_comap

theorem tendsto_snd {f : Filter Î±} {g : Filter Î²} : Tendsto Prod.snd (f Ã—á¶  g) g :=
  tendsto_inf_right tendsto_comap

theorem Tendsto.prod_mk {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} {mâ‚ : Î± â†’ Î²} {mâ‚‚ : Î± â†’ Î³} (hâ‚ : Tendsto mâ‚ f g)
    (hâ‚‚ : Tendsto mâ‚‚ f h) : Tendsto (fun x => (mâ‚ x, mâ‚‚ x)) f (g Ã—á¶  h) :=
  tendsto_inf.2 âŸ¨tendsto_comap_iff.2 hâ‚, tendsto_comap_iff.2 hâ‚‚âŸ©

theorem tendsto_prod_swap {Î±1 Î±2 : Type _} {a1 : Filter Î±1} {a2 : Filter Î±2} :
    Tendsto (Prod.swap : Î±1 Ã— Î±2 â†’ Î±2 Ã— Î±1) (a1 Ã—á¶  a2) (a2 Ã—á¶  a1) :=
  tendsto_snd.prod_mk tendsto_fst

theorem Eventually.prod_inl {la : Filter Î±} {p : Î± â†’ Prop} (h : âˆ€á¶  x in la, p x) (lb : Filter Î²) :
    âˆ€á¶  x in la Ã—á¶  lb, p (x : Î± Ã— Î²).1 :=
  tendsto_fst.Eventually h

theorem Eventually.prod_inr {lb : Filter Î²} {p : Î² â†’ Prop} (h : âˆ€á¶  x in lb, p x) (la : Filter Î±) :
    âˆ€á¶  x in la Ã—á¶  lb, p (x : Î± Ã— Î²).2 :=
  tendsto_snd.Eventually h

theorem Eventually.prod_mk {la : Filter Î±} {pa : Î± â†’ Prop} (ha : âˆ€á¶  x in la, pa x) {lb : Filter Î²} {pb : Î² â†’ Prop}
    (hb : âˆ€á¶  y in lb, pb y) : âˆ€á¶  p in la Ã—á¶  lb, pa (p : Î± Ã— Î²).1 âˆ§ pb p.2 :=
  (ha.prod_inl lb).And (hb.prod_inr la)

theorem EventuallyEq.prod_map {Î´} {la : Filter Î±} {fa ga : Î± â†’ Î³} (ha : fa =á¶ [la] ga) {lb : Filter Î²} {fb gb : Î² â†’ Î´}
    (hb : fb =á¶ [lb] gb) : Prod.map fa fb =á¶ [la Ã—á¶  lb] Prod.map ga gb :=
  (Eventually.prod_mk ha hb).mono fun x h => Prod.extâ‚“ h.1 h.2

theorem EventuallyLe.prod_map {Î´} [LE Î³] [LE Î´] {la : Filter Î±} {fa ga : Î± â†’ Î³} (ha : fa â‰¤á¶ [la] ga) {lb : Filter Î²}
    {fb gb : Î² â†’ Î´} (hb : fb â‰¤á¶ [lb] gb) : Prod.map fa fb â‰¤á¶ [la Ã—á¶  lb] Prod.map ga gb :=
  Eventually.prod_mk ha hb

theorem Eventually.curry {la : Filter Î±} {lb : Filter Î²} {p : Î± Ã— Î² â†’ Prop} (h : âˆ€á¶  x in la Ã—á¶  lb, p x) :
    âˆ€á¶  x in la, âˆ€á¶  y in lb, p (x, y) := by
  rcases eventually_prod_iff.1 h with âŸ¨pa, ha, pb, hb, hâŸ©
  exact ha.mono fun a ha => hb.mono fun b hb => h ha hb

/-- A fact that is eventually true about all pairs `l Ã—á¶  l` is eventually true about
all diagonal pairs `(i, i)` -/
theorem Eventually.diag_of_prod {f : Filter Î±} {p : Î± Ã— Î± â†’ Prop} (h : âˆ€á¶  i in f Ã—á¶  f, p i) : âˆ€á¶  i in f, p (i, i) := by
  obtain âŸ¨t, ht, s, hs, hstâŸ© := eventually_prod_iff.1 h
  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2

theorem tendsto_diag : Tendsto (fun i => (i, i)) f (f Ã—á¶  f) :=
  tendsto_iff_eventually.mpr fun _ hpr => hpr.diag_of_prod

theorem prod_infi_left [Nonempty Î¹] {f : Î¹ â†’ Filter Î±} {g : Filter Î²} : (â¨… i, f i) Ã—á¶  g = â¨… i, f i Ã—á¶  g := by
  rw [Filter.prod, comap_infi, infi_inf]
  simp only [Filter.prod, eq_self_iff_true]

theorem prod_infi_right [Nonempty Î¹] {f : Filter Î±} {g : Î¹ â†’ Filter Î²} : (f Ã—á¶  â¨… i, g i) = â¨… i, f Ã—á¶  g i := by
  rw [Filter.prod, comap_infi, inf_infi]
  simp only [Filter.prod, eq_self_iff_true]

@[mono]
theorem prod_mono {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) : fâ‚ Ã—á¶  gâ‚ â‰¤ fâ‚‚ Ã—á¶  gâ‚‚ :=
  inf_le_inf (comap_mono hf) (comap_mono hg)

theorem prod_comap_comap_eq.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x} {fâ‚ : Filter Î±â‚}
    {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î²â‚ â†’ Î±â‚} {mâ‚‚ : Î²â‚‚ â†’ Î±â‚‚} :
    comap mâ‚ fâ‚ Ã—á¶  comap mâ‚‚ fâ‚‚ = comap (fun p : Î²â‚ Ã— Î²â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) (fâ‚ Ã—á¶  fâ‚‚) := by
  simp only [Filter.prod, comap_comap, eq_self_iff_true, comap_inf]

theorem prod_comm' : f Ã—á¶  g = comap Prod.swap (g Ã—á¶  f) := by
  simp only [Filter.prod, comap_comap, (Â· âˆ˜ Â·), inf_comm, Prod.fst_swap, eq_self_iff_true, Prod.snd_swap, comap_inf]

theorem prod_comm : f Ã—á¶  g = map (fun p : Î² Ã— Î± => (p.2, p.1)) (g Ã—á¶  f) := by
  rw [prod_comm', â† map_swap_eq_comap_swap]
  rfl

theorem prod_assoc (f : Filter Î±) (g : Filter Î²) (h : Filter Î³) :
    map (Equivâ‚“.prodAssoc Î± Î² Î³) (f Ã—á¶  g Ã—á¶  h) = f Ã—á¶  (g Ã—á¶  h) := by
  simp_rw [â† comap_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp,
    Equivâ‚“.prod_assoc_symm_apply]

theorem prod_assoc_symm (f : Filter Î±) (g : Filter Î²) (h : Filter Î³) :
    map (Equivâ‚“.prodAssoc Î± Î² Î³).symm (f Ã—á¶  (g Ã—á¶  h)) = f Ã—á¶  g Ã—á¶  h := by
  simp_rw [map_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp, Equivâ‚“.prod_assoc_apply]

theorem tendsto_prod_assoc {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} :
    Tendsto (Equivâ‚“.prodAssoc Î± Î² Î³) (f Ã—á¶  g Ã—á¶  h) (f Ã—á¶  (g Ã—á¶  h)) :=
  (prod_assoc f g h).le

theorem tendsto_prod_assoc_symm {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} :
    Tendsto (Equivâ‚“.prodAssoc Î± Î² Î³).symm (f Ã—á¶  (g Ã—á¶  h)) (f Ã—á¶  g Ã—á¶  h) :=
  (prod_assoc_symm f g h).le

/-- A useful lemma when dealing with uniformities. -/
theorem map_swap4_prod {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} {k : Filter Î´} :
    map (fun p : (Î± Ã— Î²) Ã— Î³ Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (f Ã—á¶  g Ã—á¶  (h Ã—á¶  k)) = f Ã—á¶  h Ã—á¶  (g Ã—á¶  k) := by
  simp_rw [map_swap4_eq_comap, Filter.prod, comap_inf, comap_comap, inf_assoc, inf_left_comm]

theorem tendsto_swap4_prod {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} {k : Filter Î´} :
    Tendsto (fun p : (Î± Ã— Î²) Ã— Î³ Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (f Ã—á¶  g Ã—á¶  (h Ã—á¶  k)) (f Ã—á¶  h Ã—á¶  (g Ã—á¶  k)) :=
  map_swap4_prod.le

theorem prod_map_map_eq.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x} {fâ‚ : Filter Î±â‚}
    {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î±â‚ â†’ Î²â‚} {mâ‚‚ : Î±â‚‚ â†’ Î²â‚‚} :
    map mâ‚ fâ‚ Ã—á¶  map mâ‚‚ fâ‚‚ = map (fun p : Î±â‚ Ã— Î±â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) (fâ‚ Ã—á¶  fâ‚‚) :=
  le_antisymmâ‚“
    (fun s hs =>
      let âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, hâŸ© := mem_prod_iff.mp hs
      Filter.sets_of_superset _ (prod_mem_prod (image_mem_map hsâ‚) (image_mem_map hsâ‚‚)) <|
        calc
          (mâ‚ '' sâ‚) Ã—Ë¢ (mâ‚‚ '' sâ‚‚) = (fun p : Î±â‚ Ã— Î±â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) '' sâ‚ Ã—Ë¢ sâ‚‚ := Set.prod_image_image_eq
          _ âŠ† _ := by
            rwa [image_subset_iff]
          )
    ((Tendsto.comp le_rflâ‚“ tendsto_fst).prod_mk (Tendsto.comp le_rflâ‚“ tendsto_snd))

theorem prod_map_map_eq' {Î±â‚ : Type _} {Î±â‚‚ : Type _} {Î²â‚ : Type _} {Î²â‚‚ : Type _} (f : Î±â‚ â†’ Î±â‚‚) (g : Î²â‚ â†’ Î²â‚‚)
    (F : Filter Î±â‚) (G : Filter Î²â‚) : map f F Ã—á¶  map g G = map (Prod.map f g) (F Ã—á¶  G) :=
  prod_map_map_eq

theorem le_prod_map_fst_snd {f : Filter (Î± Ã— Î²)} : f â‰¤ map Prod.fst f Ã—á¶  map Prod.snd f :=
  le_inf le_comap_map le_comap_map

theorem Tendsto.prod_map {Î´ : Type _} {f : Î± â†’ Î³} {g : Î² â†’ Î´} {a : Filter Î±} {b : Filter Î²} {c : Filter Î³}
    {d : Filter Î´} (hf : Tendsto f a c) (hg : Tendsto g b d) : Tendsto (Prod.map f g) (a Ã—á¶  b) (c Ã—á¶  d) := by
  erw [tendsto, â† prod_map_map_eq]
  exact Filter.prod_mono hf hg

protected theorem map_prod (m : Î± Ã— Î² â†’ Î³) (f : Filter Î±) (g : Filter Î²) :
    map m (f Ã—á¶  g) = (f.map fun a b => m (a, b)).seq g := by
  simp [Filter.ext_iff, mem_prod_iff, mem_map_seq_iff]
  intro s
  constructor
  exact fun âŸ¨t, ht, s, hs, hâŸ© => âŸ¨s, hs, t, ht, fun x hx y hy => @h âŸ¨x, yâŸ© âŸ¨hx, hyâŸ©âŸ©
  exact fun âŸ¨s, hs, t, ht, hâŸ© => âŸ¨t, ht, s, hs, fun âŸ¨x, yâŸ© âŸ¨hx, hyâŸ© => h x hx y hyâŸ©

theorem prod_eq {f : Filter Î±} {g : Filter Î²} : f Ã—á¶  g = (f.map Prod.mk).seq g := by
  have h := f.map_prod id g
  rwa [map_id] at h

theorem prod_inf_prod {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} : (fâ‚ Ã—á¶  gâ‚)âŠ“(fâ‚‚ Ã—á¶  gâ‚‚) = fâ‚âŠ“fâ‚‚ Ã—á¶  gâ‚âŠ“gâ‚‚ := by
  simp only [Filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]

@[simp]
theorem prod_bot {f : Filter Î±} : f Ã—á¶  (âŠ¥ : Filter Î²) = âŠ¥ := by
  simp [Filter.prod]

@[simp]
theorem bot_prod {g : Filter Î²} : (âŠ¥ : Filter Î±) Ã—á¶  g = âŠ¥ := by
  simp [Filter.prod]

@[simp]
theorem prod_principal_principal {s : Set Î±} {t : Set Î²} : ğ“Ÿ s Ã—á¶  ğ“Ÿ t = ğ“Ÿ (s Ã—Ë¢ t) := by
  simp only [Filter.prod, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal] <;> rfl

@[simp]
theorem pure_prod {a : Î±} {f : Filter Î²} : pure a Ã—á¶  f = map (Prod.mk a) f := by
  rw [prod_eq, map_pure, pure_seq_eq_map]

theorem map_pure_prod (f : Î± â†’ Î² â†’ Î³) (a : Î±) (B : Filter Î²) :
    Filter.map (Function.uncurry f) (pure a Ã—á¶  B) = Filter.map (f a) B := by
  rw [Filter.pure_prod]
  rfl

@[simp]
theorem prod_pure {f : Filter Î±} {b : Î²} : f Ã—á¶  pure b = map (fun a => (a, b)) f := by
  rw [prod_eq, seq_pure, map_map]

theorem prod_pure_pure {a : Î±} {b : Î²} : pure a Ã—á¶  pure b = pure (a, b) := by
  simp

theorem prod_eq_bot {f : Filter Î±} {g : Filter Î²} : f Ã—á¶  g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ := by
  constructor
  Â· intro h
    rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with âŸ¨s, hs, t, ht, hstâŸ©
    rw [subset_empty_iff, Set.prod_eq_empty_iff] at hst
    cases' hst with s_eq t_eq
    Â· left
      exact empty_mem_iff_bot.1 (s_eq â–¸ hs)
      
    Â· right
      exact empty_mem_iff_bot.1 (t_eq â–¸ ht)
      
    
  Â· rintro (rfl | rfl)
    exact bot_prod
    exact prod_bot
    

theorem prod_ne_bot {f : Filter Î±} {g : Filter Î²} : NeBot (f Ã—á¶  g) â†” NeBot f âˆ§ NeBot g := by
  simp only [ne_bot_iff, Ne, prod_eq_bot, not_or_distrib]

theorem NeBot.prod {f : Filter Î±} {g : Filter Î²} (hf : NeBot f) (hg : NeBot g) : NeBot (f Ã—á¶  g) :=
  prod_ne_bot.2 âŸ¨hf, hgâŸ©

instance prod_ne_bot' {f : Filter Î±} {g : Filter Î²} [hf : NeBot f] [hg : NeBot g] : NeBot (f Ã—á¶  g) :=
  hf.Prod hg

theorem tendsto_prod_iff {f : Î± Ã— Î² â†’ Î³} {x : Filter Î±} {y : Filter Î²} {z : Filter Î³} :
    Filter.Tendsto f (x Ã—á¶  y) z â†” âˆ€ W âˆˆ z, âˆƒ U âˆˆ x, âˆƒ V âˆˆ y, âˆ€ x y, x âˆˆ U â†’ y âˆˆ V â†’ f (x, y) âˆˆ W := by
  simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_selfâ‚“]

theorem tendsto_prod_iff' {f : Filter Î±} {g : Filter Î²} {g' : Filter Î³} {s : Î± â†’ Î² Ã— Î³} :
    Tendsto s f (g Ã—á¶  g') â†” Tendsto (fun n => (s n).1) f g âˆ§ Tendsto (fun n => (s n).2) f g' := by
  unfold Filter.prod
  simp only [tendsto_inf, tendsto_comap_iff, iff_selfâ‚“]

end Prod

/-! ### Coproducts of filters -/


section Coprod

variable {f : Filter Î±} {g : Filter Î²}

/-- Coproduct of filters. -/
protected def coprod (f : Filter Î±) (g : Filter Î²) : Filter (Î± Ã— Î²) :=
  f.comap Prod.fstâŠ”g.comap Prod.snd

theorem mem_coprod_iff {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²} :
    s âˆˆ f.coprod g â†” (âˆƒ tâ‚ âˆˆ f, Prod.fst â»Â¹' tâ‚ âŠ† s) âˆ§ âˆƒ tâ‚‚ âˆˆ g, Prod.snd â»Â¹' tâ‚‚ âŠ† s := by
  simp [Filter.coprod]

@[simp]
theorem bot_coprod (l : Filter Î²) : (âŠ¥ : Filter Î±).coprod l = comap Prod.snd l := by
  simp [Filter.coprod]

@[simp]
theorem coprod_bot (l : Filter Î±) : l.coprod (âŠ¥ : Filter Î²) = comap Prod.fst l := by
  simp [Filter.coprod]

theorem bot_coprod_bot : (âŠ¥ : Filter Î±).coprod (âŠ¥ : Filter Î²) = âŠ¥ := by
  simp

theorem compl_mem_coprod {s : Set (Î± Ã— Î²)} {la : Filter Î±} {lb : Filter Î²} :
    sá¶œ âˆˆ la.coprod lb â†” (Prod.fst '' s)á¶œ âˆˆ la âˆ§ (Prod.snd '' s)á¶œ âˆˆ lb := by
  simp only [Filter.coprod, mem_sup, compl_mem_comap]

@[mono]
theorem coprod_mono {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) : fâ‚.coprod gâ‚ â‰¤ fâ‚‚.coprod gâ‚‚ :=
  sup_le_sup (comap_mono hf) (comap_mono hg)

theorem coprod_ne_bot_iff : (f.coprod g).ne_bot â†” f.ne_bot âˆ§ Nonempty Î² âˆ¨ Nonempty Î± âˆ§ g.ne_bot := by
  simp [Filter.coprod]

@[instance]
theorem coprod_ne_bot_left [NeBot f] [Nonempty Î²] : (f.coprod g).ne_bot :=
  coprod_ne_bot_iff.2 (Or.inl âŸ¨â€¹_â€º, â€¹_â€ºâŸ©)

@[instance]
theorem coprod_ne_bot_right [NeBot g] [Nonempty Î±] : (f.coprod g).ne_bot :=
  coprod_ne_bot_iff.2 (Or.inr âŸ¨â€¹_â€º, â€¹_â€ºâŸ©)

theorem principal_coprod_principal (s : Set Î±) (t : Set Î²) : (ğ“Ÿ s).coprod (ğ“Ÿ t) = ğ“Ÿ ((sá¶œ Ã—Ë¢ tá¶œ)á¶œ) := by
  rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter, preimage_compl,
    preimage_compl, compl_compl, compl_compl]

-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and
-- `map_prod_map_const_id_principal_coprod_principal` below.
theorem map_prod_map_coprod_le.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x} {fâ‚ : Filter Î±â‚}
    {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î±â‚ â†’ Î²â‚} {mâ‚‚ : Î±â‚‚ â†’ Î²â‚‚} :
    map (Prod.map mâ‚ mâ‚‚) (fâ‚.coprod fâ‚‚) â‰¤ (map mâ‚ fâ‚).coprod (map mâ‚‚ fâ‚‚) := by
  intro s
  simp only [mem_map, mem_coprod_iff]
  rintro âŸ¨âŸ¨uâ‚, huâ‚, hâ‚âŸ©, uâ‚‚, huâ‚‚, hâ‚‚âŸ©
  refine' âŸ¨âŸ¨mâ‚ â»Â¹' uâ‚, huâ‚, fun _ hx => hâ‚ _âŸ©, âŸ¨mâ‚‚ â»Â¹' uâ‚‚, huâ‚‚, fun _ hx => hâ‚‚ _âŸ©âŸ© <;> convert hx

/-- Characterization of the coproduct of the `filter.map`s of two principal filters `ğ“Ÿ {a}` and
`ğ“Ÿ {i}`, the first under the constant function `Î» a, b` and the second under the identity function.
Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this provides an
example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. -/
theorem map_const_principal_coprod_map_id_principal {Î± Î² Î¹ : Type _} (a : Î±) (b : Î²) (i : Î¹) :
    (map (fun _ : Î± => b) (ğ“Ÿ {a})).coprod (map id (ğ“Ÿ {i})) = ğ“Ÿ (({b} : Set Î²) Ã—Ë¢ univ âˆª univ Ã—Ë¢ ({i} : Set Î¹)) := by
  simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton, image_id, prod_univ,
    univ_prod]

/-- Characterization of the `filter.map` of the coproduct of two principal filters `ğ“Ÿ {a}` and
`ğ“Ÿ {i}`, under the `prod.map` of two functions, respectively the constant function `Î» a, b` and the
identity function.  Together with the previous lemma,
`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality
in the lemma `map_prod_map_coprod_le` can be strict. -/
theorem map_prod_map_const_id_principal_coprod_principal {Î± Î² Î¹ : Type _} (a : Î±) (b : Î²) (i : Î¹) :
    map (Prod.map (fun _ : Î± => b) id) ((ğ“Ÿ {a}).coprod (ğ“Ÿ {i})) = ğ“Ÿ (({b} : Set Î²) Ã—Ë¢ (Univ : Set Î¹)) := by
  rw [principal_coprod_principal, map_principal]
  congr
  ext âŸ¨b', i'âŸ©
  constructor
  Â· rintro âŸ¨âŸ¨a'', i''âŸ©, hâ‚, hâ‚‚, hâ‚ƒâŸ©
    simp
    
  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©
    use (a, i')
    simpa using hâ‚.symm
    

theorem Tendsto.prod_map_coprod {Î´ : Type _} {f : Î± â†’ Î³} {g : Î² â†’ Î´} {a : Filter Î±} {b : Filter Î²} {c : Filter Î³}
    {d : Filter Î´} (hf : Tendsto f a c) (hg : Tendsto g b d) : Tendsto (Prod.map f g) (a.coprod b) (c.coprod d) :=
  map_prod_map_coprod_le.trans (coprod_mono hf hg)

end Coprod

end Filter

