/-
Copyright (c) 2022 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johanes HÃ¶lzl, Patrick Massot, Yury Kudryashov, Kevin Wilson, Heather Macbeth
-/
import Mathbin.Order.Filter.Basic

/-!
# Product and coproduct filters

In this file we define `filter.prod f g` (notation: `f Ã—á¶  g`) and `filter.coprod f g`. The product
of two filters is the largest filter `l` such that `filter.tendsto prod.fst l f` and
`filter.tendsto prod.snd l g`.

## Implementation details

The product filter cannot be defined using the monad structure on filters. For example:

```lean
F := do {x â† seq, y â† top, return (x, y)}
G := do {y â† top, x â† seq, return (x, y)}
```
hence:
```lean
s âˆˆ F  â†”  âˆƒ n, [n..âˆ] Ã— univ âŠ† s
s âˆˆ G  â†”  âˆ€ i:â„•, âˆƒ n, [n..âˆ] Ã— {i} âŠ† s
```
Now `â‹ƒ i, [i..âˆ] Ã— {i}` is in `G` but not in `F`.
As product filter we want to have `F` as result.

## Notations

* `f Ã—á¶  g` : `filter.prod f g`, localized in `filter`.

-/


open Set

open Filter

namespace Filter

variable {Î± Î² Î³ Î´ : Type _} {Î¹ : Sort _}

section Prod

variable {s : Set Î±} {t : Set Î²} {f : Filter Î±} {g : Filter Î²}

/-- Product of filters. This is the filter generated by cartesian products
of elements of the component filters. -/
protected def prod (f : Filter Î±) (g : Filter Î²) : Filter (Î± Ã— Î²) :=
  f.comap Prod.fst âŠ“ g.comap Prod.snd
#align filter.prod Filter.prod

-- mathport name: filter.prod
scoped infixl:60 " Ã—á¶  " => Filter.prod

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem prod_mem_prod {s : Set Î±} {t : Set Î²} {f : Filter Î±} {g : Filter Î²} (hs : s âˆˆ f) (ht : t âˆˆ g) :
    s Ã—Ë¢ t âˆˆ f Ã—á¶  g :=
  inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)
#align filter.prod_mem_prod Filter.prod_mem_prod

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem mem_prod_iff {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²} : s âˆˆ f Ã—á¶  g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ Ã—Ë¢ tâ‚‚ âŠ† s :=
  by
  simp only [Filter.prod]
  constructor
  Â· rintro âŸ¨tâ‚, âŸ¨sâ‚, hsâ‚, htsâ‚âŸ©, tâ‚‚, âŸ¨sâ‚‚, hsâ‚‚, htsâ‚‚âŸ©, rflâŸ©
    exact âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, fun p âŸ¨h, h'âŸ© => âŸ¨htsâ‚ h, htsâ‚‚ h'âŸ©âŸ©
    
  Â· rintro âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, hâŸ©
    exact mem_inf_of_inter (preimage_mem_comap htâ‚) (preimage_mem_comap htâ‚‚) h
    
#align filter.mem_prod_iff Filter.mem_prod_iff

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem prod_mem_prod_iff {s : Set Î±} {t : Set Î²} {f : Filter Î±} {g : Filter Î²} [f.ne_bot] [g.ne_bot] :
    s Ã—Ë¢ t âˆˆ f Ã—á¶  g â†” s âˆˆ f âˆ§ t âˆˆ g :=
  âŸ¨fun h =>
    let âŸ¨s', hs', t', ht', HâŸ© := mem_prod_iff.1 h
    (prod_subset_prod_iff.1 H).elim (fun âŸ¨hs's, ht'tâŸ© => âŸ¨mem_of_superset hs' hs's, mem_of_superset ht' ht'tâŸ©) fun h =>
      h.elim (fun hs'e => absurd hs'e (nonempty_of_mem hs').ne_empty) fun ht'e =>
        absurd ht'e (nonempty_of_mem ht').ne_empty,
    fun h => prod_mem_prod h.1 h.2âŸ©
#align filter.prod_mem_prod_iff Filter.prod_mem_prod_iff

theorem mem_prod_principal {f : Filter Î±} {s : Set (Î± Ã— Î²)} {t : Set Î²} :
    s âˆˆ f Ã—á¶  ğ“Ÿ t â†” { a | âˆ€ b âˆˆ t, (a, b) âˆˆ s } âˆˆ f := by
  rw [â† @exists_mem_subset_iff _ f, mem_prod_iff]
  refine' existsâ‚‚_congr fun u u_in => âŸ¨_, fun h => âŸ¨t, mem_principal_self t, _âŸ©âŸ©
  Â· rintro âŸ¨v, v_in, hvâŸ© a a_in b b_in
    exact hv (mk_mem_prod a_in $ v_in b_in)
    
  Â· rintro âŸ¨x, yâŸ© âŸ¨hx, hyâŸ©
    exact h hx y hy
    
#align filter.mem_prod_principal Filter.mem_prod_principal

theorem mem_prod_top {f : Filter Î±} {s : Set (Î± Ã— Î²)} : s âˆˆ f Ã—á¶  (âŠ¤ : Filter Î²) â†” { a | âˆ€ b, (a, b) âˆˆ s } âˆˆ f := by
  rw [â† principal_univ, mem_prod_principal]
  simp only [mem_univ, forall_true_left]
#align filter.mem_prod_top Filter.mem_prod_top

theorem eventually_prod_principal_iff {p : Î± Ã— Î² â†’ Prop} {s : Set Î²} :
    (âˆ€á¶  x : Î± Ã— Î² in f Ã—á¶  ğ“Ÿ s, p x) â†” âˆ€á¶  x : Î± in f, âˆ€ y : Î², y âˆˆ s â†’ p (x, y) := by
  rw [eventually_iff, eventually_iff, mem_prod_principal]
  simp only [mem_set_of_eq]
#align filter.eventually_prod_principal_iff Filter.eventually_prod_principal_iff

theorem comap_prod (f : Î± â†’ Î² Ã— Î³) (b : Filter Î²) (c : Filter Î³) :
    comap f (b Ã—á¶  c) = comap (Prod.fst âˆ˜ f) b âŠ“ comap (Prod.snd âˆ˜ f) c := by
  erw [comap_inf, Filter.comap_comap, Filter.comap_comap]
#align filter.comap_prod Filter.comap_prod

theorem prod_top {f : Filter Î±} : f Ã—á¶  (âŠ¤ : Filter Î²) = f.comap Prod.fst := by rw [Filter.prod, comap_top, inf_top_eq]
#align filter.prod_top Filter.prod_top

theorem sup_prod (fâ‚ fâ‚‚ : Filter Î±) (g : Filter Î²) : fâ‚ âŠ” fâ‚‚ Ã—á¶  g = (fâ‚ Ã—á¶  g) âŠ” (fâ‚‚ Ã—á¶  g) := by
  rw [Filter.prod, comap_sup, inf_sup_right, â† Filter.prod, â† Filter.prod]
#align filter.sup_prod Filter.sup_prod

theorem prod_sup (f : Filter Î±) (gâ‚ gâ‚‚ : Filter Î²) : f Ã—á¶  gâ‚ âŠ” gâ‚‚ = (f Ã—á¶  gâ‚) âŠ” (f Ã—á¶  gâ‚‚) := by
  rw [Filter.prod, comap_sup, inf_sup_left, â† Filter.prod, â† Filter.prod]
#align filter.prod_sup Filter.prod_sup

theorem eventually_prod_iff {p : Î± Ã— Î² â†’ Prop} {f : Filter Î±} {g : Filter Î²} :
    (âˆ€á¶  x in f Ã—á¶  g, p x) â†”
      âˆƒ (pa : Î± â†’ Prop) (ha : âˆ€á¶  x in f, pa x) (pb : Î² â†’ Prop) (hb : âˆ€á¶  y in g, pb y),
        âˆ€ {x}, pa x â†’ âˆ€ {y}, pb y â†’ p (x, y) :=
  by simpa only [Set.prod_subset_iff] using @mem_prod_iff Î± Î² p f g
#align filter.eventually_prod_iff Filter.eventually_prod_iff

theorem tendsto_fst {f : Filter Î±} {g : Filter Î²} : Tendsto Prod.fst (f Ã—á¶  g) f :=
  tendsto_inf_left tendsto_comap
#align filter.tendsto_fst Filter.tendsto_fst

theorem tendsto_snd {f : Filter Î±} {g : Filter Î²} : Tendsto Prod.snd (f Ã—á¶  g) g :=
  tendsto_inf_right tendsto_comap
#align filter.tendsto_snd Filter.tendsto_snd

theorem Tendsto.prod_mk {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} {mâ‚ : Î± â†’ Î²} {mâ‚‚ : Î± â†’ Î³} (hâ‚ : Tendsto mâ‚ f g)
    (hâ‚‚ : Tendsto mâ‚‚ f h) : Tendsto (fun x => (mâ‚ x, mâ‚‚ x)) f (g Ã—á¶  h) :=
  tendsto_inf.2 âŸ¨tendsto_comap_iff.2 hâ‚, tendsto_comap_iff.2 hâ‚‚âŸ©
#align filter.tendsto.prod_mk Filter.Tendsto.prod_mk

theorem tendsto_prod_swap {Î±1 Î±2 : Type _} {a1 : Filter Î±1} {a2 : Filter Î±2} :
    Tendsto (Prod.swap : Î±1 Ã— Î±2 â†’ Î±2 Ã— Î±1) (a1 Ã—á¶  a2) (a2 Ã—á¶  a1) :=
  tendsto_snd.prod_mk tendsto_fst
#align filter.tendsto_prod_swap Filter.tendsto_prod_swap

theorem Eventually.prod_inl {la : Filter Î±} {p : Î± â†’ Prop} (h : âˆ€á¶  x in la, p x) (lb : Filter Î²) :
    âˆ€á¶  x in la Ã—á¶  lb, p (x : Î± Ã— Î²).1 :=
  tendsto_fst.Eventually h
#align filter.eventually.prod_inl Filter.Eventually.prod_inl

theorem Eventually.prod_inr {lb : Filter Î²} {p : Î² â†’ Prop} (h : âˆ€á¶  x in lb, p x) (la : Filter Î±) :
    âˆ€á¶  x in la Ã—á¶  lb, p (x : Î± Ã— Î²).2 :=
  tendsto_snd.Eventually h
#align filter.eventually.prod_inr Filter.Eventually.prod_inr

theorem Eventually.prod_mk {la : Filter Î±} {pa : Î± â†’ Prop} (ha : âˆ€á¶  x in la, pa x) {lb : Filter Î²} {pb : Î² â†’ Prop}
    (hb : âˆ€á¶  y in lb, pb y) : âˆ€á¶  p in la Ã—á¶  lb, pa (p : Î± Ã— Î²).1 âˆ§ pb p.2 :=
  (ha.prod_inl lb).And (hb.prod_inr la)
#align filter.eventually.prod_mk Filter.Eventually.prod_mk

theorem EventuallyEq.prod_map {Î´} {la : Filter Î±} {fa ga : Î± â†’ Î³} (ha : fa =á¶ [la] ga) {lb : Filter Î²} {fb gb : Î² â†’ Î´}
    (hb : fb =á¶ [lb] gb) : Prod.map fa fb =á¶ [la Ã—á¶  lb] Prod.map ga gb :=
  (Eventually.prod_mk ha hb).mono $ fun x h => Prod.ext h.1 h.2
#align filter.eventually_eq.prod_map Filter.EventuallyEq.prod_map

theorem EventuallyLe.prod_map {Î´} [LE Î³] [LE Î´] {la : Filter Î±} {fa ga : Î± â†’ Î³} (ha : fa â‰¤á¶ [la] ga) {lb : Filter Î²}
    {fb gb : Î² â†’ Î´} (hb : fb â‰¤á¶ [lb] gb) : Prod.map fa fb â‰¤á¶ [la Ã—á¶  lb] Prod.map ga gb :=
  Eventually.prod_mk ha hb
#align filter.eventually_le.prod_map Filter.EventuallyLe.prod_map

theorem Eventually.curry {la : Filter Î±} {lb : Filter Î²} {p : Î± Ã— Î² â†’ Prop} (h : âˆ€á¶  x in la Ã—á¶  lb, p x) :
    âˆ€á¶  x in la, âˆ€á¶  y in lb, p (x, y) := by
  rcases eventually_prod_iff.1 h with âŸ¨pa, ha, pb, hb, hâŸ©
  exact ha.mono fun a ha => hb.mono $ fun b hb => h ha hb
#align filter.eventually.curry Filter.Eventually.curry

/-- A fact that is eventually true about all pairs `l Ã—á¶  l` is eventually true about
all diagonal pairs `(i, i)` -/
theorem Eventually.diag_of_prod {f : Filter Î±} {p : Î± Ã— Î± â†’ Prop} (h : âˆ€á¶  i in f Ã—á¶  f, p i) : âˆ€á¶  i in f, p (i, i) := by
  obtain âŸ¨t, ht, s, hs, hstâŸ© := eventually_prod_iff.1 h
  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2
#align filter.eventually.diag_of_prod Filter.Eventually.diag_of_prod

theorem Eventually.diag_of_prod_left {f : Filter Î±} {g : Filter Î³} {p : (Î± Ã— Î±) Ã— Î³ â†’ Prop} :
    (âˆ€á¶  x in f Ã—á¶  f Ã—á¶  g, p x) â†’ âˆ€á¶  x : Î± Ã— Î³ in f Ã—á¶  g, p ((x.1, x.1), x.2) := by
  intro h
  obtain âŸ¨t, ht, s, hs, hstâŸ© := eventually_prod_iff.1 h
  refine' (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2, Prod.mk.eta]
#align filter.eventually.diag_of_prod_left Filter.Eventually.diag_of_prod_left

theorem Eventually.diag_of_prod_right {f : Filter Î±} {g : Filter Î³} {p : Î± Ã— Î³ Ã— Î³ â†’ Prop} :
    (âˆ€á¶  x in f Ã—á¶  (g Ã—á¶  g), p x) â†’ âˆ€á¶  x : Î± Ã— Î³ in f Ã—á¶  g, p (x.1, x.2, x.2) := by
  intro h
  obtain âŸ¨t, ht, s, hs, hstâŸ© := eventually_prod_iff.1 h
  refine' (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2, Prod.mk.eta]
#align filter.eventually.diag_of_prod_right Filter.Eventually.diag_of_prod_right

theorem tendsto_diag : Tendsto (fun i => (i, i)) f (f Ã—á¶  f) :=
  tendsto_iff_eventually.mpr fun _ hpr => hpr.diag_of_prod
#align filter.tendsto_diag Filter.tendsto_diag

theorem prod_infi_left [Nonempty Î¹] {f : Î¹ â†’ Filter Î±} {g : Filter Î²} : (â¨… i, f i) Ã—á¶  g = â¨… i, f i Ã—á¶  g := by
  rw [Filter.prod, comap_infi, infi_inf]
  simp only [Filter.prod, eq_self_iff_true]
#align filter.prod_infi_left Filter.prod_infi_left

theorem prod_infi_right [Nonempty Î¹] {f : Filter Î±} {g : Î¹ â†’ Filter Î²} : (f Ã—á¶  â¨… i, g i) = â¨… i, f Ã—á¶  g i := by
  rw [Filter.prod, comap_infi, inf_infi]
  simp only [Filter.prod, eq_self_iff_true]
#align filter.prod_infi_right Filter.prod_infi_right

@[mono]
theorem prod_mono {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) : fâ‚ Ã—á¶  gâ‚ â‰¤ fâ‚‚ Ã—á¶  gâ‚‚ :=
  inf_le_inf (comap_mono hf) (comap_mono hg)
#align filter.prod_mono Filter.prod_mono

theorem prod_mono_left (g : Filter Î²) {fâ‚ fâ‚‚ : Filter Î±} (hf : fâ‚ â‰¤ fâ‚‚) : fâ‚ Ã—á¶  g â‰¤ fâ‚‚ Ã—á¶  g :=
  Filter.prod_mono hf rfl.le
#align filter.prod_mono_left Filter.prod_mono_left

theorem prod_mono_right (f : Filter Î±) {gâ‚ gâ‚‚ : Filter Î²} (hf : gâ‚ â‰¤ gâ‚‚) : f Ã—á¶  gâ‚ â‰¤ f Ã—á¶  gâ‚‚ :=
  Filter.prod_mono rfl.le hf
#align filter.prod_mono_right Filter.prod_mono_right

theorem prod_comap_comap_eq.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x} {fâ‚ : Filter Î±â‚}
    {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î²â‚ â†’ Î±â‚} {mâ‚‚ : Î²â‚‚ â†’ Î±â‚‚} :
    comap mâ‚ fâ‚ Ã—á¶  comap mâ‚‚ fâ‚‚ = comap (fun p : Î²â‚ Ã— Î²â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) (fâ‚ Ã—á¶  fâ‚‚) := by
  simp only [Filter.prod, comap_comap, eq_self_iff_true, comap_inf]
#align filter.prod_comap_comap_eq Filter.prod_comap_comap_eq

theorem prod_comm' : f Ã—á¶  g = comap Prod.swap (g Ã—á¶  f) := by
  simp only [Filter.prod, comap_comap, (Â· âˆ˜ Â·), inf_comm, Prod.fst_swap, eq_self_iff_true, Prod.snd_swap, comap_inf]
#align filter.prod_comm' Filter.prod_comm'

theorem prod_comm : f Ã—á¶  g = map (fun p : Î² Ã— Î± => (p.2, p.1)) (g Ã—á¶  f) := by
  rw [prod_comm', â† map_swap_eq_comap_swap]
  rfl
#align filter.prod_comm Filter.prod_comm

@[simp]
theorem map_fst_prod (f : Filter Î±) (g : Filter Î²) [NeBot g] : map Prod.fst (f Ã—á¶  g) = f := by
  refine' le_antisymm tendsto_fst fun s hs => _
  rw [mem_map, mem_prod_iff] at hs
  rcases hs with âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hsâŸ©
  rw [â† image_subset_iff, fst_image_prod] at hs
  exacts[mem_of_superset hâ‚ hs, nonempty_of_mem hâ‚‚]
#align filter.map_fst_prod Filter.map_fst_prod

@[simp]
theorem map_snd_prod (f : Filter Î±) (g : Filter Î²) [NeBot f] : map Prod.snd (f Ã—á¶  g) = g := by
  rw [prod_comm, map_map, (Â· âˆ˜ Â·), map_fst_prod]
#align filter.map_snd_prod Filter.map_snd_prod

@[simp]
theorem prod_le_prod {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} [NeBot fâ‚] [NeBot gâ‚] :
    fâ‚ Ã—á¶  gâ‚ â‰¤ fâ‚‚ Ã—á¶  gâ‚‚ â†” fâ‚ â‰¤ fâ‚‚ âˆ§ gâ‚ â‰¤ gâ‚‚ :=
  âŸ¨fun h => âŸ¨map_fst_prod fâ‚ gâ‚ â–¸ tendsto_fst.mono_left h, map_snd_prod fâ‚ gâ‚ â–¸ tendsto_snd.mono_left hâŸ©, fun h =>
    prod_mono h.1 h.2âŸ©
#align filter.prod_le_prod Filter.prod_le_prod

@[simp]
theorem prod_inj {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} [NeBot fâ‚] [NeBot gâ‚] :
    fâ‚ Ã—á¶  gâ‚ = fâ‚‚ Ã—á¶  gâ‚‚ â†” fâ‚ = fâ‚‚ âˆ§ gâ‚ = gâ‚‚ := by
  refine' âŸ¨fun h => _, fun h => h.1 â–¸ h.2 â–¸ rflâŸ©
  have hle : fâ‚ â‰¤ fâ‚‚ âˆ§ gâ‚ â‰¤ gâ‚‚ := prod_le_prod.1 h.le
  haveI := ne_bot_of_le hle.1
  haveI := ne_bot_of_le hle.2
  exact âŸ¨hle.1.antisymm $ (prod_le_prod.1 h.ge).1, hle.2.antisymm $ (prod_le_prod.1 h.ge).2âŸ©
#align filter.prod_inj Filter.prod_inj

theorem eventually_swap_iff {p : Î± Ã— Î² â†’ Prop} : (âˆ€á¶  x : Î± Ã— Î² in f Ã—á¶  g, p x) â†” âˆ€á¶  y : Î² Ã— Î± in g Ã—á¶  f, p y.swap := by
  rw [prod_comm, eventually_map]
  simpa
#align filter.eventually_swap_iff Filter.eventually_swap_iff

theorem prod_assoc (f : Filter Î±) (g : Filter Î²) (h : Filter Î³) :
    map (Equiv.prodAssoc Î± Î² Î³) (f Ã—á¶  g Ã—á¶  h) = f Ã—á¶  (g Ã—á¶  h) := by
  simp_rw [â† comap_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp,
    Equiv.prod_assoc_symm_apply]
#align filter.prod_assoc Filter.prod_assoc

theorem prod_assoc_symm (f : Filter Î±) (g : Filter Î²) (h : Filter Î³) :
    map (Equiv.prodAssoc Î± Î² Î³).symm (f Ã—á¶  (g Ã—á¶  h)) = f Ã—á¶  g Ã—á¶  h := by
  simp_rw [map_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp, Equiv.prod_assoc_apply]
#align filter.prod_assoc_symm Filter.prod_assoc_symm

theorem tendsto_prod_assoc {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} :
    Tendsto (Equiv.prodAssoc Î± Î² Î³) (f Ã—á¶  g Ã—á¶  h) (f Ã—á¶  (g Ã—á¶  h)) :=
  (prod_assoc f g h).le
#align filter.tendsto_prod_assoc Filter.tendsto_prod_assoc

theorem tendsto_prod_assoc_symm {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} :
    Tendsto (Equiv.prodAssoc Î± Î² Î³).symm (f Ã—á¶  (g Ã—á¶  h)) (f Ã—á¶  g Ã—á¶  h) :=
  (prod_assoc_symm f g h).le
#align filter.tendsto_prod_assoc_symm Filter.tendsto_prod_assoc_symm

/-- A useful lemma when dealing with uniformities. -/
theorem map_swap4_prod {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} {k : Filter Î´} :
    map (fun p : (Î± Ã— Î²) Ã— Î³ Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (f Ã—á¶  g Ã—á¶  (h Ã—á¶  k)) = f Ã—á¶  h Ã—á¶  (g Ã—á¶  k) := by
  simp_rw [map_swap4_eq_comap, Filter.prod, comap_inf, comap_comap, inf_assoc, inf_left_comm]
#align filter.map_swap4_prod Filter.map_swap4_prod

theorem tendsto_swap4_prod {f : Filter Î±} {g : Filter Î²} {h : Filter Î³} {k : Filter Î´} :
    Tendsto (fun p : (Î± Ã— Î²) Ã— Î³ Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (f Ã—á¶  g Ã—á¶  (h Ã—á¶  k)) (f Ã—á¶  h Ã—á¶  (g Ã—á¶  k)) :=
  map_swap4_prod.le
#align filter.tendsto_swap4_prod Filter.tendsto_swap4_prod

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem prod_map_map_eq.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x} {fâ‚ : Filter Î±â‚}
    {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î±â‚ â†’ Î²â‚} {mâ‚‚ : Î±â‚‚ â†’ Î²â‚‚} :
    map mâ‚ fâ‚ Ã—á¶  map mâ‚‚ fâ‚‚ = map (fun p : Î±â‚ Ã— Î±â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) (fâ‚ Ã—á¶  fâ‚‚) :=
  le_antisymm
    (fun s hs =>
      let âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, hâŸ© := mem_prod_iff.mp hs
      Filter.sets_of_superset _ (prod_mem_prod (image_mem_map hsâ‚) (image_mem_map hsâ‚‚)) $
        calc
          (mâ‚ '' sâ‚) Ã—Ë¢ (mâ‚‚ '' sâ‚‚) = (fun p : Î±â‚ Ã— Î±â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) '' sâ‚ Ã—Ë¢ sâ‚‚ := Set.prod_image_image_eq
          _ âŠ† _ := by rwa [image_subset_iff]
          )
    ((Tendsto.comp le_rfl tendsto_fst).prod_mk (Tendsto.comp le_rfl tendsto_snd))
#align filter.prod_map_map_eq Filter.prod_map_map_eq

theorem prod_map_map_eq' {Î±â‚ : Type _} {Î±â‚‚ : Type _} {Î²â‚ : Type _} {Î²â‚‚ : Type _} (f : Î±â‚ â†’ Î±â‚‚) (g : Î²â‚ â†’ Î²â‚‚)
    (F : Filter Î±â‚) (G : Filter Î²â‚) : map f F Ã—á¶  map g G = map (Prod.map f g) (F Ã—á¶  G) :=
  prod_map_map_eq
#align filter.prod_map_map_eq' Filter.prod_map_map_eq'

theorem le_prod_map_fst_snd {f : Filter (Î± Ã— Î²)} : f â‰¤ map Prod.fst f Ã—á¶  map Prod.snd f :=
  le_inf le_comap_map le_comap_map
#align filter.le_prod_map_fst_snd Filter.le_prod_map_fst_snd

theorem Tendsto.prod_map {Î´ : Type _} {f : Î± â†’ Î³} {g : Î² â†’ Î´} {a : Filter Î±} {b : Filter Î²} {c : Filter Î³}
    {d : Filter Î´} (hf : Tendsto f a c) (hg : Tendsto g b d) : Tendsto (Prod.map f g) (a Ã—á¶  b) (c Ã—á¶  d) := by
  erw [tendsto, â† prod_map_map_eq]
  exact Filter.prod_mono hf hg
#align filter.tendsto.prod_map Filter.Tendsto.prod_map

protected theorem map_prod (m : Î± Ã— Î² â†’ Î³) (f : Filter Î±) (g : Filter Î²) :
    map m (f Ã—á¶  g) = (f.map fun a b => m (a, b)).seq g := by
  simp [Filter.ext_iff, mem_prod_iff, mem_map_seq_iff]
  intro s
  constructor
  exact fun âŸ¨t, ht, s, hs, hâŸ© => âŸ¨s, hs, t, ht, fun x hx y hy => @h âŸ¨x, yâŸ© âŸ¨hx, hyâŸ©âŸ©
  exact fun âŸ¨s, hs, t, ht, hâŸ© => âŸ¨t, ht, s, hs, fun âŸ¨x, yâŸ© âŸ¨hx, hyâŸ© => h x hx y hyâŸ©
#align filter.map_prod Filter.map_prod

theorem prod_eq {f : Filter Î±} {g : Filter Î²} : f Ã—á¶  g = (f.map Prod.mk).seq g := by
  have h := f.map_prod id g
  rwa [map_id] at h
#align filter.prod_eq Filter.prod_eq

theorem prod_inf_prod {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} : (fâ‚ Ã—á¶  gâ‚) âŠ“ (fâ‚‚ Ã—á¶  gâ‚‚) = fâ‚ âŠ“ fâ‚‚ Ã—á¶  gâ‚ âŠ“ gâ‚‚ := by
  simp only [Filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]
#align filter.prod_inf_prod Filter.prod_inf_prod

@[simp]
theorem prod_bot {f : Filter Î±} : f Ã—á¶  (âŠ¥ : Filter Î²) = âŠ¥ := by simp [Filter.prod]
#align filter.prod_bot Filter.prod_bot

@[simp]
theorem bot_prod {g : Filter Î²} : (âŠ¥ : Filter Î±) Ã—á¶  g = âŠ¥ := by simp [Filter.prod]
#align filter.bot_prod Filter.bot_prod

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem prod_principal_principal {s : Set Î±} {t : Set Î²} : ğ“Ÿ s Ã—á¶  ğ“Ÿ t = ğ“Ÿ (s Ã—Ë¢ t) := by
  simp only [Filter.prod, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal] <;> rfl
#align filter.prod_principal_principal Filter.prod_principal_principal

@[simp]
theorem pure_prod {a : Î±} {f : Filter Î²} : pure a Ã—á¶  f = map (Prod.mk a) f := by rw [prod_eq, map_pure, pure_seq_eq_map]
#align filter.pure_prod Filter.pure_prod

theorem map_pure_prod (f : Î± â†’ Î² â†’ Î³) (a : Î±) (B : Filter Î²) :
    Filter.map (Function.uncurry f) (pure a Ã—á¶  B) = Filter.map (f a) B := by
  rw [Filter.pure_prod]
  rfl
#align filter.map_pure_prod Filter.map_pure_prod

@[simp]
theorem prod_pure {f : Filter Î±} {b : Î²} : f Ã—á¶  pure b = map (fun a => (a, b)) f := by rw [prod_eq, seq_pure, map_map]
#align filter.prod_pure Filter.prod_pure

theorem prod_pure_pure {a : Î±} {b : Î²} : pure a Ã—á¶  pure b = pure (a, b) := by simp
#align filter.prod_pure_pure Filter.prod_pure_pure

theorem prod_eq_bot {f : Filter Î±} {g : Filter Î²} : f Ã—á¶  g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ := by
  constructor
  Â· intro h
    rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with âŸ¨s, hs, t, ht, hstâŸ©
    rw [subset_empty_iff, Set.prod_eq_empty_iff] at hst
    cases' hst with s_eq t_eq
    Â· left
      exact empty_mem_iff_bot.1 (s_eq â–¸ hs)
      
    Â· right
      exact empty_mem_iff_bot.1 (t_eq â–¸ ht)
      
    
  Â· rintro (rfl | rfl)
    exact bot_prod
    exact prod_bot
    
#align filter.prod_eq_bot Filter.prod_eq_bot

theorem prod_ne_bot {f : Filter Î±} {g : Filter Î²} : NeBot (f Ã—á¶  g) â†” NeBot f âˆ§ NeBot g := by
  simp only [ne_bot_iff, Ne, prod_eq_bot, not_or]
#align filter.prod_ne_bot Filter.prod_ne_bot

theorem NeBot.prod {f : Filter Î±} {g : Filter Î²} (hf : NeBot f) (hg : NeBot g) : NeBot (f Ã—á¶  g) :=
  prod_ne_bot.2 âŸ¨hf, hgâŸ©
#align filter.ne_bot.prod Filter.NeBot.prod

instance prodNeBot' {f : Filter Î±} {g : Filter Î²} [hf : NeBot f] [hg : NeBot g] : NeBot (f Ã—á¶  g) :=
  hf.Prod hg
#align filter.prod_ne_bot' Filter.prodNeBot'

theorem tendsto_prod_iff {f : Î± Ã— Î² â†’ Î³} {x : Filter Î±} {y : Filter Î²} {z : Filter Î³} :
    Filter.Tendsto f (x Ã—á¶  y) z â†” âˆ€ W âˆˆ z, âˆƒ U âˆˆ x, âˆƒ V âˆˆ y, âˆ€ x y, x âˆˆ U â†’ y âˆˆ V â†’ f (x, y) âˆˆ W := by
  simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_self_iff]
#align filter.tendsto_prod_iff Filter.tendsto_prod_iff

theorem tendsto_prod_iff' {f : Filter Î±} {g : Filter Î²} {g' : Filter Î³} {s : Î± â†’ Î² Ã— Î³} :
    Tendsto s f (g Ã—á¶  g') â†” Tendsto (fun n => (s n).1) f g âˆ§ Tendsto (fun n => (s n).2) f g' := by
  unfold Filter.prod
  simp only [tendsto_inf, tendsto_comap_iff, iff_self_iff]
#align filter.tendsto_prod_iff' Filter.tendsto_prod_iff'

end Prod

/-! ### Coproducts of filters -/


section Coprod

variable {f : Filter Î±} {g : Filter Î²}

/-- Coproduct of filters. -/
protected def coprod (f : Filter Î±) (g : Filter Î²) : Filter (Î± Ã— Î²) :=
  f.comap Prod.fst âŠ” g.comap Prod.snd
#align filter.coprod Filter.coprod

theorem mem_coprod_iff {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²} :
    s âˆˆ f.coprod g â†” (âˆƒ tâ‚ âˆˆ f, Prod.fst â»Â¹' tâ‚ âŠ† s) âˆ§ âˆƒ tâ‚‚ âˆˆ g, Prod.snd â»Â¹' tâ‚‚ âŠ† s := by simp [Filter.coprod]
#align filter.mem_coprod_iff Filter.mem_coprod_iff

@[simp]
theorem bot_coprod (l : Filter Î²) : (âŠ¥ : Filter Î±).coprod l = comap Prod.snd l := by simp [Filter.coprod]
#align filter.bot_coprod Filter.bot_coprod

@[simp]
theorem coprod_bot (l : Filter Î±) : l.coprod (âŠ¥ : Filter Î²) = comap Prod.fst l := by simp [Filter.coprod]
#align filter.coprod_bot Filter.coprod_bot

theorem bot_coprod_bot : (âŠ¥ : Filter Î±).coprod (âŠ¥ : Filter Î²) = âŠ¥ := by simp
#align filter.bot_coprod_bot Filter.bot_coprod_bot

theorem compl_mem_coprod {s : Set (Î± Ã— Î²)} {la : Filter Î±} {lb : Filter Î²} :
    sá¶œ âˆˆ la.coprod lb â†” (Prod.fst '' s)á¶œ âˆˆ la âˆ§ (Prod.snd '' s)á¶œ âˆˆ lb := by
  simp only [Filter.coprod, mem_sup, compl_mem_comap]
#align filter.compl_mem_coprod Filter.compl_mem_coprod

@[mono]
theorem coprod_mono {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) : fâ‚.coprod gâ‚ â‰¤ fâ‚‚.coprod gâ‚‚ :=
  sup_le_sup (comap_mono hf) (comap_mono hg)
#align filter.coprod_mono Filter.coprod_mono

theorem coprod_ne_bot_iff : (f.coprod g).ne_bot â†” f.ne_bot âˆ§ Nonempty Î² âˆ¨ Nonempty Î± âˆ§ g.ne_bot := by
  simp [Filter.coprod]
#align filter.coprod_ne_bot_iff Filter.coprod_ne_bot_iff

@[instance]
theorem coprodNeBotLeft [NeBot f] [Nonempty Î²] : (f.coprod g).ne_bot :=
  coprod_ne_bot_iff.2 (Or.inl âŸ¨â€¹_â€º, â€¹_â€ºâŸ©)
#align filter.coprod_ne_bot_left Filter.coprodNeBotLeft

@[instance]
theorem coprodNeBotRight [NeBot g] [Nonempty Î±] : (f.coprod g).ne_bot :=
  coprod_ne_bot_iff.2 (Or.inr âŸ¨â€¹_â€º, â€¹_â€ºâŸ©)
#align filter.coprod_ne_bot_right Filter.coprodNeBotRight

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem principal_coprod_principal (s : Set Î±) (t : Set Î²) : (ğ“Ÿ s).coprod (ğ“Ÿ t) = ğ“Ÿ ((sá¶œ Ã—Ë¢ tá¶œ)á¶œ) := by
  rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter, preimage_compl,
    preimage_compl, compl_compl, compl_compl]
#align filter.principal_coprod_principal Filter.principal_coprod_principal

-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and
-- `map_prod_map_const_id_principal_coprod_principal` below.
theorem map_prod_map_coprod_le.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x} {fâ‚ : Filter Î±â‚}
    {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î±â‚ â†’ Î²â‚} {mâ‚‚ : Î±â‚‚ â†’ Î²â‚‚} :
    map (Prod.map mâ‚ mâ‚‚) (fâ‚.coprod fâ‚‚) â‰¤ (map mâ‚ fâ‚).coprod (map mâ‚‚ fâ‚‚) := by
  intro s
  simp only [mem_map, mem_coprod_iff]
  rintro âŸ¨âŸ¨uâ‚, huâ‚, hâ‚âŸ©, uâ‚‚, huâ‚‚, hâ‚‚âŸ©
  refine' âŸ¨âŸ¨mâ‚ â»Â¹' uâ‚, huâ‚, fun _ hx => hâ‚ _âŸ©, âŸ¨mâ‚‚ â»Â¹' uâ‚‚, huâ‚‚, fun _ hx => hâ‚‚ _âŸ©âŸ© <;> convert hx
#align filter.map_prod_map_coprod_le Filter.map_prod_map_coprod_le

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Characterization of the coproduct of the `filter.map`s of two principal filters `ğ“Ÿ {a}` and
`ğ“Ÿ {i}`, the first under the constant function `Î» a, b` and the second under the identity function.
Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this provides an
example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. -/
theorem map_const_principal_coprod_map_id_principal {Î± Î² Î¹ : Type _} (a : Î±) (b : Î²) (i : Î¹) :
    (map (fun _ : Î± => b) (ğ“Ÿ {a})).coprod (map id (ğ“Ÿ {i})) = ğ“Ÿ (({b} : Set Î²) Ã—Ë¢ univ âˆª univ Ã—Ë¢ ({i} : Set Î¹)) := by
  simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton, image_id, prod_univ,
    univ_prod]
#align filter.map_const_principal_coprod_map_id_principal Filter.map_const_principal_coprod_map_id_principal

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Characterization of the `filter.map` of the coproduct of two principal filters `ğ“Ÿ {a}` and
`ğ“Ÿ {i}`, under the `prod.map` of two functions, respectively the constant function `Î» a, b` and the
identity function.  Together with the previous lemma,
`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality
in the lemma `map_prod_map_coprod_le` can be strict. -/
theorem map_prod_map_const_id_principal_coprod_principal {Î± Î² Î¹ : Type _} (a : Î±) (b : Î²) (i : Î¹) :
    map (Prod.map (fun _ : Î± => b) id) ((ğ“Ÿ {a}).coprod (ğ“Ÿ {i})) = ğ“Ÿ (({b} : Set Î²) Ã—Ë¢ (univ : Set Î¹)) := by
  rw [principal_coprod_principal, map_principal]
  congr
  ext âŸ¨b', i'âŸ©
  constructor
  Â· rintro âŸ¨âŸ¨a'', i''âŸ©, hâ‚, hâ‚‚, hâ‚ƒâŸ©
    simp
    
  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©
    use (a, i')
    simpa using hâ‚.symm
    
#align filter.map_prod_map_const_id_principal_coprod_principal Filter.map_prod_map_const_id_principal_coprod_principal

theorem Tendsto.prod_map_coprod {Î´ : Type _} {f : Î± â†’ Î³} {g : Î² â†’ Î´} {a : Filter Î±} {b : Filter Î²} {c : Filter Î³}
    {d : Filter Î´} (hf : Tendsto f a c) (hg : Tendsto g b d) : Tendsto (Prod.map f g) (a.coprod b) (c.coprod d) :=
  map_prod_map_coprod_le.trans (coprod_mono hf hg)
#align filter.tendsto.prod_map_coprod Filter.Tendsto.prod_map_coprod

end Coprod

end Filter

