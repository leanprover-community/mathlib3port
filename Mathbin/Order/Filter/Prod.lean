/-
Copyright (c) 2022 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johanes H√∂lzl, Patrick Massot, Yury Kudryashov, Kevin Wilson, Heather Macbeth
-/
import Mathbin.Order.Filter.Basic

/-!
# Product and coproduct filters

In this file we define `filter.prod f g` (notation: `f √ó·∂† g`) and `filter.coprod f g`. The product
of two filters is the largest filter `l` such that `filter.tendsto prod.fst l f` and
`filter.tendsto prod.snd l g`.

## Implementation details

The product filter cannot be defined using the monad structure on filters. For example:

```lean
F := do {x ‚Üê seq, y ‚Üê top, return (x, y)}
G := do {y ‚Üê top, x ‚Üê seq, return (x, y)}
```
hence:
```lean
s ‚àà F  ‚Üî  ‚àÉ n, [n..‚àû] √ó univ ‚äÜ s
s ‚àà G  ‚Üî  ‚àÄ i:‚Ñï, ‚àÉ n, [n..‚àû] √ó {i} ‚äÜ s
```
Now `‚ãÉ i, [i..‚àû] √ó {i}` is in `G` but not in `F`.
As product filter we want to have `F` as result.

## Notations

* `f √ó·∂† g` : `filter.prod f g`, localized in `filter`.

-/


open Set

open Filter

namespace Filter

variable {Œ± Œ≤ Œ≥ Œ¥ : Type _} {Œπ : Sort _}

section Prod

variable {s : Set Œ±} {t : Set Œ≤} {f : Filter Œ±} {g : Filter Œ≤}

/-- Product of filters. This is the filter generated by cartesian products
of elements of the component filters. -/
protected def prod (f : Filter Œ±) (g : Filter Œ≤) : Filter (Œ± √ó Œ≤) :=
  f.comap Prod.fst ‚äì g.comap Prod.snd

-- mathport name: filter.prod
localized [Filter] infixl:60 " √ó·∂† " => Filter.prod

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
theorem prod_mem_prod {s : Set Œ±} {t : Set Œ≤} {f : Filter Œ±} {g : Filter Œ≤} (hs : s ‚àà f) (ht : t ‚àà g) :
    s √óÀ¢ t ‚àà f √ó·∂† g :=
  inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
theorem mem_prod_iff {s : Set (Œ± √ó Œ≤)} {f : Filter Œ±} {g : Filter Œ≤} : s ‚àà f √ó·∂† g ‚Üî ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s :=
  by
  simp only [Filter.prod]
  constructor
  ¬∑ rintro ‚ü®t‚ÇÅ, ‚ü®s‚ÇÅ, hs‚ÇÅ, hts‚ÇÅ‚ü©, t‚ÇÇ, ‚ü®s‚ÇÇ, hs‚ÇÇ, hts‚ÇÇ‚ü©, rfl‚ü©
    exact ‚ü®s‚ÇÅ, hs‚ÇÅ, s‚ÇÇ, hs‚ÇÇ, fun p ‚ü®h, h'‚ü© => ‚ü®hts‚ÇÅ h, hts‚ÇÇ h'‚ü©‚ü©
    
  ¬∑ rintro ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, h‚ü©
    exact mem_inf_of_inter (preimage_mem_comap ht‚ÇÅ) (preimage_mem_comap ht‚ÇÇ) h
    

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
@[simp]
theorem prod_mem_prod_iff {s : Set Œ±} {t : Set Œ≤} {f : Filter Œ±} {g : Filter Œ≤} [f.ne_bot] [g.ne_bot] :
    s √óÀ¢ t ‚àà f √ó·∂† g ‚Üî s ‚àà f ‚àß t ‚àà g :=
  ‚ü®fun h =>
    let ‚ü®s', hs', t', ht', H‚ü© := mem_prod_iff.1 h
    (prod_subset_prod_iff.1 H).elim (fun ‚ü®hs's, ht't‚ü© => ‚ü®mem_of_superset hs' hs's, mem_of_superset ht' ht't‚ü©) fun h =>
      h.elim (fun hs'e => absurd hs'e (nonempty_of_mem hs').ne_empty) fun ht'e =>
        absurd ht'e (nonempty_of_mem ht').ne_empty,
    fun h => prod_mem_prod h.1 h.2‚ü©

theorem mem_prod_principal {f : Filter Œ±} {s : Set (Œ± √ó Œ≤)} {t : Set Œ≤} :
    s ‚àà f √ó·∂† ùìü t ‚Üî { a | ‚àÄ b ‚àà t, (a, b) ‚àà s } ‚àà f := by
  rw [‚Üê @exists_mem_subset_iff _ f, mem_prod_iff]
  refine' exists‚ÇÇ_congr‚Çì fun u u_in => ‚ü®_, fun h => ‚ü®t, mem_principal_self t, _‚ü©‚ü©
  ¬∑ rintro ‚ü®v, v_in, hv‚ü© a a_in b b_in
    exact hv (mk_mem_prod a_in <| v_in b_in)
    
  ¬∑ rintro ‚ü®x, y‚ü© ‚ü®hx, hy‚ü©
    exact h hx y hy
    

theorem mem_prod_top {f : Filter Œ±} {s : Set (Œ± √ó Œ≤)} : s ‚àà f √ó·∂† (‚ä§ : Filter Œ≤) ‚Üî { a | ‚àÄ b, (a, b) ‚àà s } ‚àà f := by
  rw [‚Üê principal_univ, mem_prod_principal]
  simp only [mem_univ, forall_true_left]

theorem eventually_prod_principal_iff {p : Œ± √ó Œ≤ ‚Üí Prop} {s : Set Œ≤} :
    (‚àÄ·∂† x : Œ± √ó Œ≤ in f √ó·∂† ùìü s, p x) ‚Üî ‚àÄ·∂† x : Œ± in f, ‚àÄ y : Œ≤, y ‚àà s ‚Üí p (x, y) := by
  rw [eventually_iff, eventually_iff, mem_prod_principal]
  simp only [mem_set_of_eq]

theorem comap_prod (f : Œ± ‚Üí Œ≤ √ó Œ≥) (b : Filter Œ≤) (c : Filter Œ≥) :
    comap f (b √ó·∂† c) = comap (Prod.fst ‚àò f) b ‚äì comap (Prod.snd ‚àò f) c := by
  erw [comap_inf, Filter.comap_comap, Filter.comap_comap]

theorem prod_top {f : Filter Œ±} : f √ó·∂† (‚ä§ : Filter Œ≤) = f.comap Prod.fst := by rw [Filter.prod, comap_top, inf_top_eq]

theorem sup_prod (f‚ÇÅ f‚ÇÇ : Filter Œ±) (g : Filter Œ≤) : f‚ÇÅ ‚äî f‚ÇÇ √ó·∂† g = (f‚ÇÅ √ó·∂† g) ‚äî (f‚ÇÇ √ó·∂† g) := by
  rw [Filter.prod, comap_sup, inf_sup_right, ‚Üê Filter.prod, ‚Üê Filter.prod]

theorem prod_sup (f : Filter Œ±) (g‚ÇÅ g‚ÇÇ : Filter Œ≤) : f √ó·∂† g‚ÇÅ ‚äî g‚ÇÇ = (f √ó·∂† g‚ÇÅ) ‚äî (f √ó·∂† g‚ÇÇ) := by
  rw [Filter.prod, comap_sup, inf_sup_left, ‚Üê Filter.prod, ‚Üê Filter.prod]

theorem eventually_prod_iff {p : Œ± √ó Œ≤ ‚Üí Prop} {f : Filter Œ±} {g : Filter Œ≤} :
    (‚àÄ·∂† x in f √ó·∂† g, p x) ‚Üî
      ‚àÉ (pa : Œ± ‚Üí Prop)(ha : ‚àÄ·∂† x in f, pa x)(pb : Œ≤ ‚Üí Prop)(hb : ‚àÄ·∂† y in g, pb y),
        ‚àÄ {x}, pa x ‚Üí ‚àÄ {y}, pb y ‚Üí p (x, y) :=
  by simpa only [Set.prod_subset_iff] using @mem_prod_iff Œ± Œ≤ p f g

theorem tendsto_fst {f : Filter Œ±} {g : Filter Œ≤} : Tendsto Prod.fst (f √ó·∂† g) f :=
  tendsto_inf_left tendsto_comap

theorem tendsto_snd {f : Filter Œ±} {g : Filter Œ≤} : Tendsto Prod.snd (f √ó·∂† g) g :=
  tendsto_inf_right tendsto_comap

theorem Tendsto.prod_mk {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} {m‚ÇÅ : Œ± ‚Üí Œ≤} {m‚ÇÇ : Œ± ‚Üí Œ≥} (h‚ÇÅ : Tendsto m‚ÇÅ f g)
    (h‚ÇÇ : Tendsto m‚ÇÇ f h) : Tendsto (fun x => (m‚ÇÅ x, m‚ÇÇ x)) f (g √ó·∂† h) :=
  tendsto_inf.2 ‚ü®tendsto_comap_iff.2 h‚ÇÅ, tendsto_comap_iff.2 h‚ÇÇ‚ü©

theorem tendsto_prod_swap {Œ±1 Œ±2 : Type _} {a1 : Filter Œ±1} {a2 : Filter Œ±2} :
    Tendsto (Prod.swap : Œ±1 √ó Œ±2 ‚Üí Œ±2 √ó Œ±1) (a1 √ó·∂† a2) (a2 √ó·∂† a1) :=
  tendsto_snd.prod_mk tendsto_fst

theorem Eventually.prod_inl {la : Filter Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in la, p x) (lb : Filter Œ≤) :
    ‚àÄ·∂† x in la √ó·∂† lb, p (x : Œ± √ó Œ≤).1 :=
  tendsto_fst.Eventually h

theorem Eventually.prod_inr {lb : Filter Œ≤} {p : Œ≤ ‚Üí Prop} (h : ‚àÄ·∂† x in lb, p x) (la : Filter Œ±) :
    ‚àÄ·∂† x in la √ó·∂† lb, p (x : Œ± √ó Œ≤).2 :=
  tendsto_snd.Eventually h

theorem Eventually.prod_mk {la : Filter Œ±} {pa : Œ± ‚Üí Prop} (ha : ‚àÄ·∂† x in la, pa x) {lb : Filter Œ≤} {pb : Œ≤ ‚Üí Prop}
    (hb : ‚àÄ·∂† y in lb, pb y) : ‚àÄ·∂† p in la √ó·∂† lb, pa (p : Œ± √ó Œ≤).1 ‚àß pb p.2 :=
  (ha.prod_inl lb).And (hb.prod_inr la)

theorem EventuallyEq.prod_map {Œ¥} {la : Filter Œ±} {fa ga : Œ± ‚Üí Œ≥} (ha : fa =·∂†[la] ga) {lb : Filter Œ≤} {fb gb : Œ≤ ‚Üí Œ¥}
    (hb : fb =·∂†[lb] gb) : Prod.map fa fb =·∂†[la √ó·∂† lb] Prod.map ga gb :=
  (Eventually.prod_mk ha hb).mono fun x h => Prod.ext‚Çì h.1 h.2

theorem EventuallyLe.prod_map {Œ¥} [LE Œ≥] [LE Œ¥] {la : Filter Œ±} {fa ga : Œ± ‚Üí Œ≥} (ha : fa ‚â§·∂†[la] ga) {lb : Filter Œ≤}
    {fb gb : Œ≤ ‚Üí Œ¥} (hb : fb ‚â§·∂†[lb] gb) : Prod.map fa fb ‚â§·∂†[la √ó·∂† lb] Prod.map ga gb :=
  Eventually.prod_mk ha hb

theorem Eventually.curry {la : Filter Œ±} {lb : Filter Œ≤} {p : Œ± √ó Œ≤ ‚Üí Prop} (h : ‚àÄ·∂† x in la √ó·∂† lb, p x) :
    ‚àÄ·∂† x in la, ‚àÄ·∂† y in lb, p (x, y) := by
  rcases eventually_prod_iff.1 h with ‚ü®pa, ha, pb, hb, h‚ü©
  exact ha.mono fun a ha => hb.mono fun b hb => h ha hb

/-- A fact that is eventually true about all pairs `l √ó·∂† l` is eventually true about
all diagonal pairs `(i, i)` -/
theorem Eventually.diag_of_prod {f : Filter Œ±} {p : Œ± √ó Œ± ‚Üí Prop} (h : ‚àÄ·∂† i in f √ó·∂† f, p i) : ‚àÄ·∂† i in f, p (i, i) := by
  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h
  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2

theorem Eventually.diag_of_prod_left {f : Filter Œ±} {g : Filter Œ≥} {p : (Œ± √ó Œ±) √ó Œ≥ ‚Üí Prop} :
    (‚àÄ·∂† x in f √ó·∂† f √ó·∂† g, p x) ‚Üí ‚àÄ·∂† x : Œ± √ó Œ≥ in f √ó·∂† g, p ((x.1, x.1), x.2) := by
  intro h
  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h
  refine' (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2, Prod.mk.eta‚Çì]

theorem Eventually.diag_of_prod_right {f : Filter Œ±} {g : Filter Œ≥} {p : Œ± √ó Œ≥ √ó Œ≥ ‚Üí Prop} :
    (‚àÄ·∂† x in f √ó·∂† (g √ó·∂† g), p x) ‚Üí ‚àÄ·∂† x : Œ± √ó Œ≥ in f √ó·∂† g, p (x.1, x.2, x.2) := by
  intro h
  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h
  refine' (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2, Prod.mk.eta‚Çì]

theorem tendsto_diag : Tendsto (fun i => (i, i)) f (f √ó·∂† f) :=
  tendsto_iff_eventually.mpr fun _ hpr => hpr.diag_of_prod

theorem prod_infi_left [Nonempty Œπ] {f : Œπ ‚Üí Filter Œ±} {g : Filter Œ≤} : (‚®Ö i, f i) √ó·∂† g = ‚®Ö i, f i √ó·∂† g := by
  rw [Filter.prod, comap_infi, infi_inf]
  simp only [Filter.prod, eq_self_iff_true]

theorem prod_infi_right [Nonempty Œπ] {f : Filter Œ±} {g : Œπ ‚Üí Filter Œ≤} : (f √ó·∂† ‚®Ö i, g i) = ‚®Ö i, f √ó·∂† g i := by
  rw [Filter.prod, comap_infi, inf_infi]
  simp only [Filter.prod, eq_self_iff_true]

@[mono]
theorem prod_mono {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) : f‚ÇÅ √ó·∂† g‚ÇÅ ‚â§ f‚ÇÇ √ó·∂† g‚ÇÇ :=
  inf_le_inf (comap_mono hf) (comap_mono hg)

theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √ó·∂† g ‚â§ f‚ÇÇ √ó·∂† g :=
  Filter.prod_mono hf rfl.le

theorem prod_mono_right (f : Filter Œ±) {g‚ÇÅ g‚ÇÇ : Filter Œ≤} (hf : g‚ÇÅ ‚â§ g‚ÇÇ) : f √ó·∂† g‚ÇÅ ‚â§ f √ó·∂† g‚ÇÇ :=
  Filter.prod_mono rfl.le hf

theorem prod_comap_comap_eq.{u, v, w, x} {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x} {f‚ÇÅ : Filter Œ±‚ÇÅ}
    {f‚ÇÇ : Filter Œ±‚ÇÇ} {m‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ} {m‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ} :
    comap m‚ÇÅ f‚ÇÅ √ó·∂† comap m‚ÇÇ f‚ÇÇ = comap (fun p : Œ≤‚ÇÅ √ó Œ≤‚ÇÇ => (m‚ÇÅ p.1, m‚ÇÇ p.2)) (f‚ÇÅ √ó·∂† f‚ÇÇ) := by
  simp only [Filter.prod, comap_comap, eq_self_iff_true, comap_inf]

theorem prod_comm' : f √ó·∂† g = comap Prod.swap (g √ó·∂† f) := by
  simp only [Filter.prod, comap_comap, (¬∑ ‚àò ¬∑), inf_comm, Prod.fst_swap‚Çì, eq_self_iff_true, Prod.snd_swap‚Çì, comap_inf]

theorem prod_comm : f √ó·∂† g = map (fun p : Œ≤ √ó Œ± => (p.2, p.1)) (g √ó·∂† f) := by
  rw [prod_comm', ‚Üê map_swap_eq_comap_swap]
  rfl

@[simp]
theorem map_fst_prod (f : Filter Œ±) (g : Filter Œ≤) [NeBot g] : map Prod.fst (f √ó·∂† g) = f := by
  refine' le_antisymm‚Çì tendsto_fst fun s hs => _
  rw [mem_map, mem_prod_iff] at hs
  rcases hs with ‚ü®t‚ÇÅ, h‚ÇÅ, t‚ÇÇ, h‚ÇÇ, hs‚ü©
  rw [‚Üê image_subset_iff, fst_image_prod] at hs
  exacts[mem_of_superset h‚ÇÅ hs, nonempty_of_mem h‚ÇÇ]

@[simp]
theorem map_snd_prod (f : Filter Œ±) (g : Filter Œ≤) [NeBot f] : map Prod.snd (f √ó·∂† g) = g := by
  rw [prod_comm, map_map, (¬∑ ‚àò ¬∑), map_fst_prod]

@[simp]
theorem prod_le_prod {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} [NeBot f‚ÇÅ] [NeBot g‚ÇÅ] :
    f‚ÇÅ √ó·∂† g‚ÇÅ ‚â§ f‚ÇÇ √ó·∂† g‚ÇÇ ‚Üî f‚ÇÅ ‚â§ f‚ÇÇ ‚àß g‚ÇÅ ‚â§ g‚ÇÇ :=
  ‚ü®fun h => ‚ü®map_fst_prod f‚ÇÅ g‚ÇÅ ‚ñ∏ tendsto_fst.mono_left h, map_snd_prod f‚ÇÅ g‚ÇÅ ‚ñ∏ tendsto_snd.mono_left h‚ü©, fun h =>
    prod_mono h.1 h.2‚ü©

@[simp]
theorem prod_inj {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} [NeBot f‚ÇÅ] [NeBot g‚ÇÅ] :
    f‚ÇÅ √ó·∂† g‚ÇÅ = f‚ÇÇ √ó·∂† g‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ ‚àß g‚ÇÅ = g‚ÇÇ := by
  refine' ‚ü®fun h => _, fun h => h.1 ‚ñ∏ h.2 ‚ñ∏ rfl‚ü©
  have hle : f‚ÇÅ ‚â§ f‚ÇÇ ‚àß g‚ÇÅ ‚â§ g‚ÇÇ := prod_le_prod.1 h.le
  haveI := ne_bot_of_le hle.1
  haveI := ne_bot_of_le hle.2
  exact ‚ü®hle.1.antisymm <| (prod_le_prod.1 h.ge).1, hle.2.antisymm <| (prod_le_prod.1 h.ge).2‚ü©

theorem eventually_swap_iff {p : Œ± √ó Œ≤ ‚Üí Prop} : (‚àÄ·∂† x : Œ± √ó Œ≤ in f √ó·∂† g, p x) ‚Üî ‚àÄ·∂† y : Œ≤ √ó Œ± in g √ó·∂† f, p y.swap := by
  rw [prod_comm, eventually_map]
  simpa

theorem prod_assoc (f : Filter Œ±) (g : Filter Œ≤) (h : Filter Œ≥) :
    map (Equiv‚Çì.prodAssoc Œ± Œ≤ Œ≥) (f √ó·∂† g √ó·∂† h) = f √ó·∂† (g √ó·∂† h) := by
  simp_rw [‚Üê comap_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp,
    Equiv‚Çì.prod_assoc_symm_apply]

theorem prod_assoc_symm (f : Filter Œ±) (g : Filter Œ≤) (h : Filter Œ≥) :
    map (Equiv‚Çì.prodAssoc Œ± Œ≤ Œ≥).symm (f √ó·∂† (g √ó·∂† h)) = f √ó·∂† g √ó·∂† h := by
  simp_rw [map_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp, Equiv‚Çì.prod_assoc_apply]

theorem tendsto_prod_assoc {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} :
    Tendsto (Equiv‚Çì.prodAssoc Œ± Œ≤ Œ≥) (f √ó·∂† g √ó·∂† h) (f √ó·∂† (g √ó·∂† h)) :=
  (prod_assoc f g h).le

theorem tendsto_prod_assoc_symm {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} :
    Tendsto (Equiv‚Çì.prodAssoc Œ± Œ≤ Œ≥).symm (f √ó·∂† (g √ó·∂† h)) (f √ó·∂† g √ó·∂† h) :=
  (prod_assoc_symm f g h).le

/-- A useful lemma when dealing with uniformities. -/
theorem map_swap4_prod {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} {k : Filter Œ¥} :
    map (fun p : (Œ± √ó Œ≤) √ó Œ≥ √ó Œ¥ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (f √ó·∂† g √ó·∂† (h √ó·∂† k)) = f √ó·∂† h √ó·∂† (g √ó·∂† k) := by
  simp_rw [map_swap4_eq_comap, Filter.prod, comap_inf, comap_comap, inf_assoc, inf_left_comm]

theorem tendsto_swap4_prod {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} {k : Filter Œ¥} :
    Tendsto (fun p : (Œ± √ó Œ≤) √ó Œ≥ √ó Œ¥ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (f √ó·∂† g √ó·∂† (h √ó·∂† k)) (f √ó·∂† h √ó·∂† (g √ó·∂† k)) :=
  map_swap4_prod.le

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
theorem prod_map_map_eq.{u, v, w, x} {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x} {f‚ÇÅ : Filter Œ±‚ÇÅ}
    {f‚ÇÇ : Filter Œ±‚ÇÇ} {m‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ} {m‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ} :
    map m‚ÇÅ f‚ÇÅ √ó·∂† map m‚ÇÇ f‚ÇÇ = map (fun p : Œ±‚ÇÅ √ó Œ±‚ÇÇ => (m‚ÇÅ p.1, m‚ÇÇ p.2)) (f‚ÇÅ √ó·∂† f‚ÇÇ) :=
  le_antisymm‚Çì
    (fun s hs =>
      let ‚ü®s‚ÇÅ, hs‚ÇÅ, s‚ÇÇ, hs‚ÇÇ, h‚ü© := mem_prod_iff.mp hs
      Filter.sets_of_superset _ (prod_mem_prod (image_mem_map hs‚ÇÅ) (image_mem_map hs‚ÇÇ)) <|
        calc
          (m‚ÇÅ '' s‚ÇÅ) √óÀ¢ (m‚ÇÇ '' s‚ÇÇ) = (fun p : Œ±‚ÇÅ √ó Œ±‚ÇÇ => (m‚ÇÅ p.1, m‚ÇÇ p.2)) '' s‚ÇÅ √óÀ¢ s‚ÇÇ := Set.prod_image_image_eq
          _ ‚äÜ _ := by rwa [image_subset_iff]
          )
    ((Tendsto.comp le_rfl‚Çì tendsto_fst).prod_mk (Tendsto.comp le_rfl‚Çì tendsto_snd))

theorem prod_map_map_eq' {Œ±‚ÇÅ : Type _} {Œ±‚ÇÇ : Type _} {Œ≤‚ÇÅ : Type _} {Œ≤‚ÇÇ : Type _} (f : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ) (g : Œ≤‚ÇÅ ‚Üí Œ≤‚ÇÇ)
    (F : Filter Œ±‚ÇÅ) (G : Filter Œ≤‚ÇÅ) : map f F √ó·∂† map g G = map (Prod.map f g) (F √ó·∂† G) :=
  prod_map_map_eq

theorem le_prod_map_fst_snd {f : Filter (Œ± √ó Œ≤)} : f ‚â§ map Prod.fst f √ó·∂† map Prod.snd f :=
  le_inf le_comap_map le_comap_map

theorem Tendsto.prod_map {Œ¥ : Type _} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {a : Filter Œ±} {b : Filter Œ≤} {c : Filter Œ≥}
    {d : Filter Œ¥} (hf : Tendsto f a c) (hg : Tendsto g b d) : Tendsto (Prod.map f g) (a √ó·∂† b) (c √ó·∂† d) := by
  erw [tendsto, ‚Üê prod_map_map_eq]
  exact Filter.prod_mono hf hg

protected theorem map_prod (m : Œ± √ó Œ≤ ‚Üí Œ≥) (f : Filter Œ±) (g : Filter Œ≤) :
    map m (f √ó·∂† g) = (f.map fun a b => m (a, b)).seq g := by
  simp [Filter.ext_iff, mem_prod_iff, mem_map_seq_iff]
  intro s
  constructor
  exact fun ‚ü®t, ht, s, hs, h‚ü© => ‚ü®s, hs, t, ht, fun x hx y hy => @h ‚ü®x, y‚ü© ‚ü®hx, hy‚ü©‚ü©
  exact fun ‚ü®s, hs, t, ht, h‚ü© => ‚ü®t, ht, s, hs, fun ‚ü®x, y‚ü© ‚ü®hx, hy‚ü© => h x hx y hy‚ü©

theorem prod_eq {f : Filter Œ±} {g : Filter Œ≤} : f √ó·∂† g = (f.map Prod.mk).seq g := by
  have h := f.map_prod id g
  rwa [map_id] at h

theorem prod_inf_prod {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} : (f‚ÇÅ √ó·∂† g‚ÇÅ) ‚äì (f‚ÇÇ √ó·∂† g‚ÇÇ) = f‚ÇÅ ‚äì f‚ÇÇ √ó·∂† g‚ÇÅ ‚äì g‚ÇÇ := by
  simp only [Filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]

@[simp]
theorem prod_bot {f : Filter Œ±} : f √ó·∂† (‚ä• : Filter Œ≤) = ‚ä• := by simp [Filter.prod]

@[simp]
theorem bot_prod {g : Filter Œ≤} : (‚ä• : Filter Œ±) √ó·∂† g = ‚ä• := by simp [Filter.prod]

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
@[simp]
theorem prod_principal_principal {s : Set Œ±} {t : Set Œ≤} : ùìü s √ó·∂† ùìü t = ùìü (s √óÀ¢ t) := by
  simp only [Filter.prod, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal] <;> rfl

@[simp]
theorem pure_prod {a : Œ±} {f : Filter Œ≤} : pure a √ó·∂† f = map (Prod.mk a) f := by rw [prod_eq, map_pure, pure_seq_eq_map]

theorem map_pure_prod (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (B : Filter Œ≤) :
    Filter.map (Function.uncurry f) (pure a √ó·∂† B) = Filter.map (f a) B := by
  rw [Filter.pure_prod]
  rfl

@[simp]
theorem prod_pure {f : Filter Œ±} {b : Œ≤} : f √ó·∂† pure b = map (fun a => (a, b)) f := by rw [prod_eq, seq_pure, map_map]

theorem prod_pure_pure {a : Œ±} {b : Œ≤} : pure a √ó·∂† pure b = pure (a, b) := by simp

theorem prod_eq_bot {f : Filter Œ±} {g : Filter Œ≤} : f √ó·∂† g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := by
  constructor
  ¬∑ intro h
    rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with ‚ü®s, hs, t, ht, hst‚ü©
    rw [subset_empty_iff, Set.prod_eq_empty_iff] at hst
    cases' hst with s_eq t_eq
    ¬∑ left
      exact empty_mem_iff_bot.1 (s_eq ‚ñ∏ hs)
      
    ¬∑ right
      exact empty_mem_iff_bot.1 (t_eq ‚ñ∏ ht)
      
    
  ¬∑ rintro (rfl | rfl)
    exact bot_prod
    exact prod_bot
    

theorem prod_ne_bot {f : Filter Œ±} {g : Filter Œ≤} : NeBot (f √ó·∂† g) ‚Üî NeBot f ‚àß NeBot g := by
  simp only [ne_bot_iff, Ne, prod_eq_bot, not_or_distrib]

theorem NeBot.prod {f : Filter Œ±} {g : Filter Œ≤} (hf : NeBot f) (hg : NeBot g) : NeBot (f √ó·∂† g) :=
  prod_ne_bot.2 ‚ü®hf, hg‚ü©

instance prod_ne_bot' {f : Filter Œ±} {g : Filter Œ≤} [hf : NeBot f] [hg : NeBot g] : NeBot (f √ó·∂† g) :=
  hf.Prod hg

theorem tendsto_prod_iff {f : Œ± √ó Œ≤ ‚Üí Œ≥} {x : Filter Œ±} {y : Filter Œ≤} {z : Filter Œ≥} :
    Filter.Tendsto f (x √ó·∂† y) z ‚Üî ‚àÄ W ‚àà z, ‚àÉ U ‚àà x, ‚àÉ V ‚àà y, ‚àÄ x y, x ‚àà U ‚Üí y ‚àà V ‚Üí f (x, y) ‚àà W := by
  simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop‚Çì, iff_self‚Çì]

theorem tendsto_prod_iff' {f : Filter Œ±} {g : Filter Œ≤} {g' : Filter Œ≥} {s : Œ± ‚Üí Œ≤ √ó Œ≥} :
    Tendsto s f (g √ó·∂† g') ‚Üî Tendsto (fun n => (s n).1) f g ‚àß Tendsto (fun n => (s n).2) f g' := by
  unfold Filter.prod
  simp only [tendsto_inf, tendsto_comap_iff, iff_self‚Çì]

end Prod

/-! ### Coproducts of filters -/


section Coprod

variable {f : Filter Œ±} {g : Filter Œ≤}

/-- Coproduct of filters. -/
protected def coprod (f : Filter Œ±) (g : Filter Œ≤) : Filter (Œ± √ó Œ≤) :=
  f.comap Prod.fst ‚äî g.comap Prod.snd

theorem mem_coprod_iff {s : Set (Œ± √ó Œ≤)} {f : Filter Œ±} {g : Filter Œ≤} :
    s ‚àà f.coprod g ‚Üî (‚àÉ t‚ÇÅ ‚àà f, Prod.fst ‚Åª¬π' t‚ÇÅ ‚äÜ s) ‚àß ‚àÉ t‚ÇÇ ‚àà g, Prod.snd ‚Åª¬π' t‚ÇÇ ‚äÜ s := by simp [Filter.coprod]

@[simp]
theorem bot_coprod (l : Filter Œ≤) : (‚ä• : Filter Œ±).coprod l = comap Prod.snd l := by simp [Filter.coprod]

@[simp]
theorem coprod_bot (l : Filter Œ±) : l.coprod (‚ä• : Filter Œ≤) = comap Prod.fst l := by simp [Filter.coprod]

theorem bot_coprod_bot : (‚ä• : Filter Œ±).coprod (‚ä• : Filter Œ≤) = ‚ä• := by simp

theorem compl_mem_coprod {s : Set (Œ± √ó Œ≤)} {la : Filter Œ±} {lb : Filter Œ≤} :
    s·∂ú ‚àà la.coprod lb ‚Üî (Prod.fst '' s)·∂ú ‚àà la ‚àß (Prod.snd '' s)·∂ú ‚àà lb := by
  simp only [Filter.coprod, mem_sup, compl_mem_comap]

@[mono]
theorem coprod_mono {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) : f‚ÇÅ.coprod g‚ÇÅ ‚â§ f‚ÇÇ.coprod g‚ÇÇ :=
  sup_le_sup (comap_mono hf) (comap_mono hg)

theorem coprod_ne_bot_iff : (f.coprod g).ne_bot ‚Üî f.ne_bot ‚àß Nonempty Œ≤ ‚à® Nonempty Œ± ‚àß g.ne_bot := by
  simp [Filter.coprod]

@[instance]
theorem coprod_ne_bot_left [NeBot f] [Nonempty Œ≤] : (f.coprod g).ne_bot :=
  coprod_ne_bot_iff.2 (Or.inl ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)

@[instance]
theorem coprod_ne_bot_right [NeBot g] [Nonempty Œ±] : (f.coprod g).ne_bot :=
  coprod_ne_bot_iff.2 (Or.inr ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
theorem principal_coprod_principal (s : Set Œ±) (t : Set Œ≤) : (ùìü s).coprod (ùìü t) = ùìü ((s·∂ú √óÀ¢ t·∂ú)·∂ú) := by
  rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter, preimage_compl,
    preimage_compl, compl_compl, compl_compl]

-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and
-- `map_prod_map_const_id_principal_coprod_principal` below.
theorem map_prod_map_coprod_le.{u, v, w, x} {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x} {f‚ÇÅ : Filter Œ±‚ÇÅ}
    {f‚ÇÇ : Filter Œ±‚ÇÇ} {m‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ} {m‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ} :
    map (Prod.map m‚ÇÅ m‚ÇÇ) (f‚ÇÅ.coprod f‚ÇÇ) ‚â§ (map m‚ÇÅ f‚ÇÅ).coprod (map m‚ÇÇ f‚ÇÇ) := by
  intro s
  simp only [mem_map, mem_coprod_iff]
  rintro ‚ü®‚ü®u‚ÇÅ, hu‚ÇÅ, h‚ÇÅ‚ü©, u‚ÇÇ, hu‚ÇÇ, h‚ÇÇ‚ü©
  refine' ‚ü®‚ü®m‚ÇÅ ‚Åª¬π' u‚ÇÅ, hu‚ÇÅ, fun _ hx => h‚ÇÅ _‚ü©, ‚ü®m‚ÇÇ ‚Åª¬π' u‚ÇÇ, hu‚ÇÇ, fun _ hx => h‚ÇÇ _‚ü©‚ü© <;> convert hx

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
/-- Characterization of the coproduct of the `filter.map`s of two principal filters `ùìü {a}` and
`ùìü {i}`, the first under the constant function `Œª a, b` and the second under the identity function.
Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this provides an
example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. -/
theorem map_const_principal_coprod_map_id_principal {Œ± Œ≤ Œπ : Type _} (a : Œ±) (b : Œ≤) (i : Œπ) :
    (map (fun _ : Œ± => b) (ùìü {a})).coprod (map id (ùìü {i})) = ùìü (({b} : Set Œ≤) √óÀ¢ univ ‚à™ univ √óÀ¢ ({i} : Set Œπ)) := by
  simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton, image_id, prod_univ,
    univ_prod]

-- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation
/-- Characterization of the `filter.map` of the coproduct of two principal filters `ùìü {a}` and
`ùìü {i}`, under the `prod.map` of two functions, respectively the constant function `Œª a, b` and the
identity function.  Together with the previous lemma,
`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality
in the lemma `map_prod_map_coprod_le` can be strict. -/
theorem map_prod_map_const_id_principal_coprod_principal {Œ± Œ≤ Œπ : Type _} (a : Œ±) (b : Œ≤) (i : Œπ) :
    map (Prod.map (fun _ : Œ± => b) id) ((ùìü {a}).coprod (ùìü {i})) = ùìü (({b} : Set Œ≤) √óÀ¢ (Univ : Set Œπ)) := by
  rw [principal_coprod_principal, map_principal]
  congr
  ext ‚ü®b', i'‚ü©
  constructor
  ¬∑ rintro ‚ü®‚ü®a'', i''‚ü©, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
    simp
    
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use (a, i')
    simpa using h‚ÇÅ.symm
    

theorem Tendsto.prod_map_coprod {Œ¥ : Type _} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {a : Filter Œ±} {b : Filter Œ≤} {c : Filter Œ≥}
    {d : Filter Œ¥} (hf : Tendsto f a c) (hg : Tendsto g b d) : Tendsto (Prod.map f g) (a.coprod b) (c.coprod d) :=
  map_prod_map_coprod_le.trans (coprod_mono hf hg)

end Coprod

end Filter

