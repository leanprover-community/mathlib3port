/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, YaÃ«l Dillies
-/
import Mathbin.Data.Set.Pointwise
import Mathbin.Order.Filter.NAry

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(fâ‚ * fâ‚‚).map m  = fâ‚.map m * fâ‚‚.map m`
* `ğ“ (x * y) = ğ“ x * ğ“ y`

## Main declarations

* `0` (`filter.has_zero`): Principal filter at `0 : Î±`.
* `1` (`filter.has_one`): Principal filter at `1 : Î±`.
* `f + g` (`filter.has_add`): Addition, filter generated by all `s + t` where `s âˆˆ f` and `t âˆˆ g`.
* `f * g` (`filter.has_mul`): Multiplication, filter generated by all `s * t` where `s âˆˆ f` and
  `t âˆˆ g`.
* `-f` (`filter.has_neg`): Negation, filter of all `-s` where `s âˆˆ f`.
* `fâ»Â¹` (`filter.has_inv`): Inversion, filter of all `xâ»Â¹` where `s âˆˆ f`.
* `f - g` (`filter.has_sub`): Subtraction, filter generated by all `x - y` where `s âˆˆ f` and
  `t âˆˆ g`.
* `f / g` (`filter.has_div`): Division, filter generated by all `x / y` where `s âˆˆ f` and `t âˆˆ g`.
* `f +áµ¥ g` (`filter.has_vadd`): Scalar addition, filter generated by all `x +áµ¥ y` where `s âˆˆ f` and
  `t âˆˆ g`.
* `f -áµ¥ g` (`filter.has_vsub`): Scalar subtraction, filter generated by all `x -áµ¥ y` where `s âˆˆ f`
  and `t âˆˆ g`.
* `f â€¢ g` (`filter.has_smul`): Scalar multiplication, filter generated by all `x â€¢ y` where `s âˆˆ f`
  and `t âˆˆ g`.
* `a +áµ¥ f` (`filter.has_vadd_filter`): Translation, filter of all `a +áµ¥ x` where `s âˆˆ f`.
* `a â€¢ f` (`filter.has_smul_filter`): Scaling, filter of all `a â€¢ s` where `s âˆˆ f`.

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/


open Function Set

open Filter Pointwise

variable {F Î± Î² Î³ Î´ Îµ : Type _}

namespace Filter

/-! ### `0`/`1` as filters -/


section One

variable [One Î±] {f : Filter Î±} {s : Set Î±}

/-- `1 : filter Î±` is the set of sets containing `1 : Î±`. -/
@[to_additive "`0 : filter Î±` is the set of sets containing `0 : Î±`."]
instance : One (Filter Î±) :=
  âŸ¨principal 1âŸ©

@[simp, to_additive]
theorem mem_one : s âˆˆ (1 : Filter Î±) â†” (1 : Î±) âˆˆ s :=
  one_subset

@[to_additive]
theorem one_mem_one : (1 : Set Î±) âˆˆ (1 : Filter Î±) :=
  mem_principal_self _

@[simp, to_additive]
theorem principal_one : ğ“Ÿ 1 = (1 : Filter Î±) :=
  rfl

@[simp, to_additive]
theorem pure_one : pure 1 = (1 : Filter Î±) :=
  (principal_singleton _).symm

@[simp, to_additive]
theorem le_one_iff : f â‰¤ 1 â†” (1 : Set Î±) âˆˆ f :=
  le_principal_iff

@[simp, to_additive]
theorem eventually_one {p : Î± â†’ Prop} : (âˆ€á¶  x in 1, p x) â†” p 1 := by
  rw [â† pure_one, eventually_pure]

@[simp, to_additive]
theorem tendsto_one {a : Filter Î²} {f : Î² â†’ Î±} : Tendsto f a 1 â†” âˆ€á¶  x in a, f x = 1 := by
  rw [â† pure_one, tendsto_pure]

variable [One Î²]

@[simp, to_additive]
protected theorem map_one [OneHomClass F Î± Î²] (Ï† : F) : map Ï† 1 = 1 :=
  le_antisymmâ‚“
    (le_principal_iff.2 <|
      mem_map_iff_exists_image.2
        âŸ¨1, one_mem_one, fun x => by
          simp [map_one Ï†]âŸ©)
    (le_map fun s hs => mem_one.2 âŸ¨1, mem_one.1 hs, map_one Ï†âŸ©)

end One

/-! ### Filter addition/multiplication -/


section Mul

variable [Mul Î±] [Mul Î²] {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ h : Filter Î±} {s t : Set Î±}

@[to_additive]
instance : Mul (Filter Î±) :=
  âŸ¨mapâ‚‚ (Â· * Â·)âŸ©

@[simp, to_additive]
theorem mapâ‚‚_mul : mapâ‚‚ (Â· * Â·) f g = f * g :=
  rfl

@[to_additive]
theorem mem_mul_iff : s âˆˆ f * g â†” âˆƒ tâ‚ tâ‚‚, tâ‚ âˆˆ f âˆ§ tâ‚‚ âˆˆ g âˆ§ tâ‚ * tâ‚‚ âŠ† s :=
  Iff.rfl

@[to_additive]
theorem mul_mem_mul : s âˆˆ f â†’ t âˆˆ g â†’ s * t âˆˆ f * g :=
  image2_mem_mapâ‚‚

@[simp, to_additive]
theorem bot_mul : âŠ¥ * g = âŠ¥ :=
  mapâ‚‚_bot_left

@[simp, to_additive]
theorem mul_bot : f * âŠ¥ = âŠ¥ :=
  mapâ‚‚_bot_right

@[simp, to_additive]
theorem mul_eq_bot_iff : f * g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[simp, to_additive]
theorem mul_ne_bot_iff : (f * g).ne_bot â†” f.ne_bot âˆ§ g.ne_bot :=
  mapâ‚‚_ne_bot_iff

@[to_additive]
theorem NeBot.mul : NeBot f â†’ NeBot g â†’ NeBot (f * g) :=
  ne_bot.mapâ‚‚

@[simp, to_additive]
theorem le_mul_iff : h â‰¤ f * g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s * t âˆˆ h :=
  le_mapâ‚‚_iff

@[to_additive]
instance covariant_mul : CovariantClass (Filter Î±) (Filter Î±) (Â· * Â·) (Â· â‰¤ Â·) :=
  âŸ¨fun f g h => mapâ‚‚_mono_leftâŸ©

@[to_additive]
instance covariant_swap_mul : CovariantClass (Filter Î±) (Filter Î±) (swap (Â· * Â·)) (Â· â‰¤ Â·) :=
  âŸ¨fun f g h => mapâ‚‚_mono_rightâŸ©

@[to_additive]
protected theorem map_mul [MulHomClass F Î± Î²] (m : F) : (fâ‚ * fâ‚‚).map m = fâ‚.map m * fâ‚‚.map m :=
  map_mapâ‚‚_distrib <| map_mul m

end Mul

@[to_additive]
instance [Semigroupâ‚“ Î±] : Semigroupâ‚“ (Filter Î±) where
  mul := (Â· * Â·)
  mul_assoc := fun f g h => mapâ‚‚_assoc mul_assoc

@[to_additive]
instance [CommSemigroupâ‚“ Î±] : CommSemigroupâ‚“ (Filter Î±) :=
  { Filter.semigroup with mul_comm := fun f g => mapâ‚‚_comm mul_comm }

@[to_additive]
instance [MulOneClassâ‚“ Î±] : MulOneClassâ‚“ (Filter Î±) where
  one := 1
  mul := (Â· * Â·)
  one_mul := fun f => by
    simp only [â† pure_one, â† mapâ‚‚_mul, mapâ‚‚_pure_left, one_mulâ‚“, map_id']
  mul_one := fun f => by
    simp only [â† pure_one, â† mapâ‚‚_mul, mapâ‚‚_pure_right, mul_oneâ‚“, map_id']

@[to_additive]
instance [Monoidâ‚“ Î±] : Monoidâ‚“ (Filter Î±) :=
  { Filter.mulOneClass, Filter.semigroup with }

@[to_additive]
instance [CommMonoidâ‚“ Î±] : CommMonoidâ‚“ (Filter Î±) :=
  { Filter.mulOneClass, Filter.commSemigroup with }

section Map

variable [MulOneClassâ‚“ Î±] [MulOneClassâ‚“ Î²]

/-- If `Ï† : Î± â†’* Î²` then `map_monoid_hom Ï†` is the monoid homomorphism
`filter Î± â†’* filter Î²` induced by `map Ï†`. -/
@[to_additive
      "If `Ï† : Î± â†’+ Î²` then `map_add_monoid_hom Ï†` is the monoid homomorphism\n`filter Î± â†’+ filter Î²` induced by `map Ï†`."]
def mapMonoidHom [MonoidHomClass F Î± Î²] (Ï† : F) : Filter Î± â†’* Filter Î² where
  toFun := map Ï†
  map_one' := Filter.map_one Ï†
  map_mul' := fun _ _ => Filter.map_mul Ï†

-- The other direction does not hold in general.
@[to_additive]
theorem comap_mul_comap_le [MulHomClass F Î± Î²] (m : F) {fâ‚ fâ‚‚ : Filter Î²} :
    fâ‚.comap m * fâ‚‚.comap m â‰¤ (fâ‚ * fâ‚‚).comap m := fun s âŸ¨t, âŸ¨tâ‚, tâ‚‚, htâ‚, htâ‚‚, tâ‚tâ‚‚âŸ©, mtâŸ© =>
  âŸ¨m â»Â¹' tâ‚, m â»Â¹' tâ‚‚, âŸ¨tâ‚, htâ‚, Subset.rflâŸ©, âŸ¨tâ‚‚, htâ‚‚, Subset.rflâŸ©,
    (preimage_mul_preimage_subset _).trans <| (preimage_mono tâ‚tâ‚‚).trans mtâŸ©

@[to_additive]
theorem Tendsto.mul_mul [MulHomClass F Î± Î²] (m : F) {fâ‚ gâ‚ : Filter Î±} {fâ‚‚ gâ‚‚ : Filter Î²} :
    Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m gâ‚ gâ‚‚ â†’ Tendsto m (fâ‚ * gâ‚) (fâ‚‚ * gâ‚‚) := fun hf hg =>
  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg

end Map

/-! ### Filter negation/inversion -/


section Inv

variable [Inv Î±] {f g : Filter Î±} {s : Set Î±}

/-- The inverse of a filter is the pointwise preimage under `â»Â¹` of its sets. -/
@[to_additive "The negation of a filter is the pointwise preimage under `-` of its sets."]
instance : Inv (Filter Î±) :=
  âŸ¨map Inv.invâŸ©

@[simp, to_additive]
protected theorem map_inv : f.map Inv.inv = fâ»Â¹ :=
  rfl

@[to_additive]
theorem mem_inv : s âˆˆ fâ»Â¹ â†” Inv.inv â»Â¹' s âˆˆ f :=
  Iff.rfl

@[to_additive]
protected theorem inv_le_inv (hf : f â‰¤ g) : fâ»Â¹ â‰¤ gâ»Â¹ :=
  map_mono hf

@[simp, to_additive]
theorem ne_bot_inv_iff : fâ»Â¹.ne_bot â†” NeBot f :=
  map_ne_bot_iff _

@[to_additive]
theorem NeBot.inv : f.ne_bot â†’ fâ»Â¹.ne_bot := fun h => h.map _

end Inv

section HasInvolutiveInv

variable [HasInvolutiveInv Î±] {f : Filter Î±} {s : Set Î±}

@[to_additive]
theorem inv_mem_inv (hs : s âˆˆ f) : sâ»Â¹ âˆˆ fâ»Â¹ := by
  rwa [mem_inv, inv_preimage, inv_invâ‚“]

instance : HasInvolutiveInv (Filter Î±) :=
  { Filter.hasInv with
    inv_inv := fun f =>
      map_map.trans <| by
        rw [inv_involutive.comp_self, map_id] }

end HasInvolutiveInv

section Groupâ‚“

variable [Groupâ‚“ Î±] [Groupâ‚“ Î²]

@[to_additive]
theorem map_inv' [MonoidHomClass F Î± Î²] (m : F) {f : Filter Î±} : fâ»Â¹.map m = (f.map m)â»Â¹ :=
  map_comm (funext <| map_inv m) _

@[to_additive]
theorem Tendsto.inv_inv [MonoidHomClass F Î± Î²] (m : F) {fâ‚ : Filter Î±} {fâ‚‚ : Filter Î²} :
    Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m fâ‚â»Â¹ fâ‚‚â»Â¹ := fun hf => (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf

end Groupâ‚“

/-! ### Filter subtraction/division -/


section Div

variable [Div Î±] {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ h : Filter Î±} {s t : Set Î±}

@[to_additive]
instance : Div (Filter Î±) :=
  âŸ¨mapâ‚‚ (Â· / Â·)âŸ©

@[simp, to_additive]
theorem mapâ‚‚_div : mapâ‚‚ (Â· / Â·) f g = f / g :=
  rfl

@[to_additive]
theorem mem_div : s âˆˆ f / g â†” âˆƒ tâ‚ tâ‚‚, tâ‚ âˆˆ f âˆ§ tâ‚‚ âˆˆ g âˆ§ tâ‚ / tâ‚‚ âŠ† s :=
  Iff.rfl

@[to_additive]
theorem div_mem_div : s âˆˆ f â†’ t âˆˆ g â†’ s / t âˆˆ f / g :=
  image2_mem_mapâ‚‚

@[simp, to_additive]
theorem bot_div : âŠ¥ / g = âŠ¥ :=
  mapâ‚‚_bot_left

@[simp, to_additive]
theorem div_bot : f / âŠ¥ = âŠ¥ :=
  mapâ‚‚_bot_right

@[simp, to_additive]
theorem div_eq_bot_iff : f / g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[simp, to_additive]
theorem div_ne_bot_iff : (f / g).ne_bot â†” f.ne_bot âˆ§ g.ne_bot :=
  mapâ‚‚_ne_bot_iff

@[to_additive]
theorem NeBot.div : NeBot f â†’ NeBot g â†’ NeBot (f / g) :=
  ne_bot.mapâ‚‚

@[simp, to_additive]
protected theorem le_div_iff : h â‰¤ f / g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s / t âˆˆ h :=
  le_mapâ‚‚_iff

@[to_additive]
protected theorem div_le_div : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ / gâ‚ â‰¤ fâ‚‚ / gâ‚‚ :=
  mapâ‚‚_mono

@[to_additive]
protected theorem div_le_div_left : gâ‚ â‰¤ gâ‚‚ â†’ f / gâ‚ â‰¤ f / gâ‚‚ :=
  mapâ‚‚_mono_left

@[to_additive]
protected theorem div_le_div_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ / g â‰¤ fâ‚‚ / g :=
  mapâ‚‚_mono_right

@[to_additive]
instance covariant_div : CovariantClass (Filter Î±) (Filter Î±) (Â· / Â·) (Â· â‰¤ Â·) :=
  âŸ¨fun f g h => mapâ‚‚_mono_leftâŸ©

@[to_additive]
instance covariant_swap_div : CovariantClass (Filter Î±) (Filter Î±) (swap (Â· / Â·)) (Â· â‰¤ Â·) :=
  âŸ¨fun f g h => mapâ‚‚_mono_rightâŸ©

end Div

section Groupâ‚“

variable [Groupâ‚“ Î±] [Groupâ‚“ Î²] {f g : Filter Î±} {fâ‚‚ : Filter Î²}

@[to_additive]
protected theorem map_div [MonoidHomClass F Î± Î²] (m : F) : (f / g).map m = f.map m / g.map m :=
  map_mapâ‚‚_distrib <| map_div m

@[to_additive]
theorem Tendsto.div_div [MonoidHomClass F Î± Î²] (m : F) {fâ‚ gâ‚ : Filter Î±} {fâ‚‚ gâ‚‚ : Filter Î²} :
    Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m gâ‚ gâ‚‚ â†’ Tendsto m (fâ‚ / gâ‚) (fâ‚‚ / gâ‚‚) := fun hf hg =>
  (Filter.map_div m).trans_le <| Filter.div_le_div hf hg

end Groupâ‚“

/-- `f / g = f * gâ»Â¹` for all `f g : filter Î±` if `a / b = a * bâ»Â¹` for all `a b : Î±`. -/
/-TODO: The below instances are duplicate because there is no typeclass greater than
`div_inv_monoid` and `has_involutive_inv` but smaller than `group` and `group_with_zero`. -/
@[to_additive "`f - g = f + -g` for all `f g : filter Î±` if `a - b = a + -b` for all `a b : Î±`."]
instance divInvMonoid [Groupâ‚“ Î±] : DivInvMonoidâ‚“ (Filter Î±) :=
  { Filter.monoid, Filter.hasInv, Filter.hasDiv with
    div_eq_mul_inv := fun f g => map_mapâ‚‚_distrib_right div_eq_mul_inv }

/-- `f / g = f * gâ»Â¹` for all `f g : filter Î±` if `a / b = a * bâ»Â¹` for all `a b : Î±`. -/
instance divInvMonoid' [GroupWithZeroâ‚“ Î±] : DivInvMonoidâ‚“ (Filter Î±) :=
  { Filter.monoid, Filter.hasInv, Filter.hasDiv with
    div_eq_mul_inv := fun f g => map_mapâ‚‚_distrib_right div_eq_mul_inv }

/-! ### Scalar addition/multiplication of filters -/


section Smul

variable [HasScalar Î± Î²] {f fâ‚ fâ‚‚ : Filter Î±} {g gâ‚ gâ‚‚ h : Filter Î²} {s : Set Î±} {t : Set Î²}

@[to_additive Filter.hasVadd]
instance : HasScalar (Filter Î±) (Filter Î²) :=
  âŸ¨mapâ‚‚ (Â· â€¢ Â·)âŸ©

@[simp, to_additive]
theorem mapâ‚‚_smul : mapâ‚‚ (Â· â€¢ Â·) f g = f â€¢ g :=
  rfl

@[to_additive]
theorem mem_smul : t âˆˆ f â€¢ g â†” âˆƒ tâ‚ tâ‚‚, tâ‚ âˆˆ f âˆ§ tâ‚‚ âˆˆ g âˆ§ tâ‚ â€¢ tâ‚‚ âŠ† t :=
  Iff.rfl

@[to_additive]
theorem smul_mem_smul : s âˆˆ f â†’ t âˆˆ g â†’ s â€¢ t âˆˆ f â€¢ g :=
  image2_mem_mapâ‚‚

@[simp, to_additive]
theorem bot_smul : (âŠ¥ : Filter Î±) â€¢ g = âŠ¥ :=
  mapâ‚‚_bot_left

@[simp, to_additive]
theorem smul_bot : f â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=
  mapâ‚‚_bot_right

@[simp, to_additive]
theorem smul_eq_bot_iff : f â€¢ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[simp, to_additive]
theorem smul_ne_bot_iff : (f â€¢ g).ne_bot â†” f.ne_bot âˆ§ g.ne_bot :=
  mapâ‚‚_ne_bot_iff

@[to_additive]
theorem NeBot.smul : NeBot f â†’ NeBot g â†’ NeBot (f â€¢ g) :=
  ne_bot.mapâ‚‚

@[simp, to_additive]
theorem le_smul_iff : h â‰¤ f â€¢ g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s â€¢ t âˆˆ h :=
  le_mapâ‚‚_iff

@[to_additive]
theorem smul_le_smul : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ â€¢ gâ‚ â‰¤ fâ‚‚ â€¢ gâ‚‚ :=
  mapâ‚‚_mono

@[to_additive]
theorem smul_le_smul_left : gâ‚ â‰¤ gâ‚‚ â†’ f â€¢ gâ‚ â‰¤ f â€¢ gâ‚‚ :=
  mapâ‚‚_mono_left

@[to_additive]
theorem smul_le_smul_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ â€¢ g â‰¤ fâ‚‚ â€¢ g :=
  mapâ‚‚_mono_right

@[to_additive]
instance covariant_smul : CovariantClass (Filter Î±) (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=
  âŸ¨fun f g h => mapâ‚‚_mono_leftâŸ©

end Smul

@[to_additive]
instance [Monoidâ‚“ Î±] [MulAction Î± Î²] : MulAction (Filter Î±) (Filter Î²) where
  one_smul := fun f => by
    simp only [â† pure_one, â† mapâ‚‚_smul, mapâ‚‚_pure_left, one_smul, map_id']
  mul_smul := fun f g h => mapâ‚‚_assoc mul_smul

/-! ### Scalar subtraction of filters -/


section Vsub

variable [HasVsub Î± Î²] {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ : Filter Î²} {h : Filter Î±} {s t : Set Î²}

include Î±

instance : HasVsub (Filter Î±) (Filter Î²) :=
  âŸ¨mapâ‚‚ (Â· -áµ¥ Â·)âŸ©

@[simp]
theorem mapâ‚‚_vsub : mapâ‚‚ (Â· -áµ¥ Â·) f g = f -áµ¥ g :=
  rfl

theorem mem_vsub {s : Set Î±} : s âˆˆ f -áµ¥ g â†” âˆƒ tâ‚ tâ‚‚, tâ‚ âˆˆ f âˆ§ tâ‚‚ âˆˆ g âˆ§ tâ‚ -áµ¥ tâ‚‚ âŠ† s :=
  Iff.rfl

theorem vsub_mem_vsub : s âˆˆ f â†’ t âˆˆ g â†’ s -áµ¥ t âˆˆ f -áµ¥ g :=
  image2_mem_mapâ‚‚

@[simp]
theorem bot_vsub : (âŠ¥ : Filter Î²) -áµ¥ g = âŠ¥ :=
  mapâ‚‚_bot_left

@[simp]
theorem vsub_bot : f -áµ¥ (âŠ¥ : Filter Î²) = âŠ¥ :=
  mapâ‚‚_bot_right

@[simp]
theorem vsub_eq_bot_iff : f -áµ¥ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[simp]
theorem vsub_ne_bot_iff : (f -áµ¥ g : Filter Î±).ne_bot â†” f.ne_bot âˆ§ g.ne_bot :=
  mapâ‚‚_ne_bot_iff

theorem NeBot.vsub : NeBot f â†’ NeBot g â†’ NeBot (f -áµ¥ g) :=
  ne_bot.mapâ‚‚

@[simp]
theorem le_vsub_iff : h â‰¤ f -áµ¥ g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s -áµ¥ t âˆˆ h :=
  le_mapâ‚‚_iff

theorem vsub_le_vsub : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ -áµ¥ gâ‚ â‰¤ fâ‚‚ -áµ¥ gâ‚‚ :=
  mapâ‚‚_mono

theorem vsub_le_vsub_left : gâ‚ â‰¤ gâ‚‚ â†’ f -áµ¥ gâ‚ â‰¤ f -áµ¥ gâ‚‚ :=
  mapâ‚‚_mono_left

theorem vsub_le_vsub_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ -áµ¥ g â‰¤ fâ‚‚ -áµ¥ g :=
  mapâ‚‚_mono_right

end Vsub

/-! ### Translation/scaling of filters -/


section Smul

variable [HasScalar Î± Î²] {f fâ‚ fâ‚‚ : Filter Î²} {s : Set Î²} {a : Î±}

@[to_additive Filter.hasVaddFilter]
instance hasScalarFilter : HasScalar Î± (Filter Î²) :=
  âŸ¨fun a => map ((Â· â€¢ Â·) a)âŸ©

@[simp, to_additive]
theorem map_smul : map (fun b => a â€¢ b) f = a â€¢ f :=
  rfl

@[to_additive]
theorem mem_smul_filter : s âˆˆ a â€¢ f â†” (Â· â€¢ Â·) a â»Â¹' s âˆˆ f :=
  Iff.rfl

@[to_additive]
theorem smul_set_mem_smul_filter : s âˆˆ f â†’ a â€¢ s âˆˆ a â€¢ f :=
  image_mem_map

@[simp, to_additive]
theorem smul_filter_bot : a â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=
  map_bot

@[simp, to_additive]
theorem smul_filter_eq_bot_iff : a â€¢ f = âŠ¥ â†” f = âŠ¥ :=
  map_eq_bot_iff

@[simp, to_additive]
theorem smul_filter_ne_bot_iff : (a â€¢ f).ne_bot â†” f.ne_bot :=
  map_ne_bot_iff _

@[to_additive]
theorem NeBot.smul_filter : f.ne_bot â†’ (a â€¢ f).ne_bot := fun h => h.map _

@[to_additive]
theorem smul_filter_le_smul_filter (hf : fâ‚ â‰¤ fâ‚‚) : a â€¢ fâ‚ â‰¤ a â€¢ fâ‚‚ :=
  map_mono hf

@[to_additive]
instance covariant_smul_filter : CovariantClass Î± (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=
  âŸ¨fun f => map_monoâŸ©

end Smul

@[to_additive]
instance smul_comm_class_filter [HasScalar Î± Î³] [HasScalar Î² Î³] [SmulCommClass Î± Î² Î³] :
    SmulCommClass Î± (Filter Î²) (Filter Î³) :=
  âŸ¨fun a f g => map_mapâ‚‚_distrib_right <| smul_comm aâŸ©

@[to_additive]
instance smul_comm_class_filter' [HasScalar Î± Î³] [HasScalar Î² Î³] [SmulCommClass Î± Î² Î³] :
    SmulCommClass (Filter Î±) Î² (Filter Î³) :=
  have := SmulCommClass.symm Î± Î² Î³
  SmulCommClass.symm _ _ _

@[to_additive]
instance smul_comm_class [HasScalar Î± Î³] [HasScalar Î² Î³] [SmulCommClass Î± Î² Î³] :
    SmulCommClass (Filter Î±) (Filter Î²) (Filter Î³) :=
  âŸ¨fun f g h => mapâ‚‚_left_comm smul_commâŸ©

instance is_scalar_tower [HasScalar Î± Î²] [HasScalar Î± Î³] [HasScalar Î² Î³] [IsScalarTower Î± Î² Î³] :
    IsScalarTower Î± Î² (Filter Î³) :=
  âŸ¨fun a b f => by
    simp only [â† map_smul, map_map, smul_assoc]âŸ©

instance is_scalar_tower' [HasScalar Î± Î²] [HasScalar Î± Î³] [HasScalar Î² Î³] [IsScalarTower Î± Î² Î³] :
    IsScalarTower Î± (Filter Î²) (Filter Î³) :=
  âŸ¨fun a f g => by
    refine' (map_mapâ‚‚_distrib_left fun _ _ => _).symm
    exact (smul_assoc a _ _).symmâŸ©

instance is_scalar_tower'' [HasScalar Î± Î²] [HasScalar Î± Î³] [HasScalar Î² Î³] [IsScalarTower Î± Î² Î³] :
    IsScalarTower (Filter Î±) (Filter Î²) (Filter Î³) :=
  âŸ¨fun f g h => mapâ‚‚_assoc smul_assocâŸ©

instance is_central_scalar [HasScalar Î± Î²] [HasScalar Î±áµáµ’áµ– Î²] [IsCentralScalar Î± Î²] : IsCentralScalar Î± (Filter Î²) :=
  âŸ¨fun a f => (congr_argâ‚“ fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _âŸ©

end Filter

