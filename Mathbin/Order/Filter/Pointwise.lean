/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Ya√´l Dillies

! This file was ported from Lean 3 source module order.filter.pointwise
! leanprover-community/mathlib commit 13a5329a8625701af92e9a96ffc90fa787fff24d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Set.Pointwise.Smul
import Mathbin.Order.Filter.NAry
import Mathbin.Order.Filter.Ultrafilter

/-!
# Pointwise operations on filters

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(f‚ÇÅ * f‚ÇÇ).map m  = f‚ÇÅ.map m * f‚ÇÇ.map m`
* `ùìù (x * y) = ùìù x * ùìù y`

## Main declarations

* `0` (`filter.has_zero`): Pure filter at `0 : Œ±`, or alternatively principal filter at `0 : set Œ±`.
* `1` (`filter.has_one`): Pure filter at `1 : Œ±`, or alternatively principal filter at `1 : set Œ±`.
* `f + g` (`filter.has_add`): Addition, filter generated by all `s + t` where `s ‚àà f` and `t ‚àà g`.
* `f * g` (`filter.has_mul`): Multiplication, filter generated by all `s * t` where `s ‚àà f` and
  `t ‚àà g`.
* `-f` (`filter.has_neg`): Negation, filter of all `-s` where `s ‚àà f`.
* `f‚Åª¬π` (`filter.has_inv`): Inversion, filter of all `s‚Åª¬π` where `s ‚àà f`.
* `f - g` (`filter.has_sub`): Subtraction, filter generated by all `s - t` where `s ‚àà f` and
  `t ‚àà g`.
* `f / g` (`filter.has_div`): Division, filter generated by all `s / t` where `s ‚àà f` and `t ‚àà g`.
* `f +·µ• g` (`filter.has_vadd`): Scalar addition, filter generated by all `s +·µ• t` where `s ‚àà f` and
  `t ‚àà g`.
* `f -·µ• g` (`filter.has_vsub`): Scalar subtraction, filter generated by all `s -·µ• t` where `s ‚àà f`
  and `t ‚àà g`.
* `f ‚Ä¢ g` (`filter.has_smul`): Scalar multiplication, filter generated by all `s ‚Ä¢ t` where
  `s ‚àà f` and `t ‚àà g`.
* `a +·µ• f` (`filter.has_vadd_filter`): Translation, filter of all `a +·µ• s` where `s ‚àà f`.
* `a ‚Ä¢ f` (`filter.has_smul_filter`): Scaling, filter of all `a ‚Ä¢ s` where `s ‚àà f`.

For `Œ±` a semigroup/monoid, `filter Œ±` is a semigroup/monoid.
As an unfortunate side effect, this means that `n ‚Ä¢ f`, where `n : ‚Ñï`, is ambiguous between
pointwise scaling and repeated pointwise addition. See note [pointwise nat action].

## Implementation notes

We put all instances in the locale `pointwise`, so that these instances are not available by
default. Note that we do not mark them as reducible (as argued by note [reducible non-instances])
since we expect the locale to be open whenever the instances are actually used (and making the
instances reducible changes the behavior of `simp`.

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/


open Function Set

open Filter Pointwise

variable {F Œ± Œ≤ Œ≥ Œ¥ Œµ : Type _}

namespace Filter

/-! ### `0`/`1` as filters -/


section One

variable [One Œ±] {f : Filter Œ±} {s : Set Œ±}

#print Filter.instOne /-
/-- `1 : filter Œ±` is defined as the filter of sets containing `1 : Œ±` in locale `pointwise`. -/
@[to_additive
      "`0 : filter Œ±` is defined as the filter of sets containing `0 : Œ±` in locale\n`pointwise`."]
protected def instOne : One (Filter Œ±) :=
  ‚ü®pure 1‚ü©
#align filter.has_one Filter.instOne
#align filter.has_zero Filter.instZero
-/

scoped[Pointwise] attribute [instance] Filter.instOne Filter.instZero

#print Filter.mem_one /-
@[simp, to_additive]
theorem mem_one : s ‚àà (1 : Filter Œ±) ‚Üî (1 : Œ±) ‚àà s :=
  mem_pure
#align filter.mem_one Filter.mem_one
#align filter.mem_zero Filter.mem_zero
-/

#print Filter.one_mem_one /-
@[to_additive]
theorem one_mem_one : (1 : Set Œ±) ‚àà (1 : Filter Œ±) :=
  mem_pure.2 one_mem_one
#align filter.one_mem_one Filter.one_mem_one
#align filter.zero_mem_zero Filter.zero_mem_zero
-/

#print Filter.pure_one /-
@[simp, to_additive]
theorem pure_one : pure 1 = (1 : Filter Œ±) :=
  rfl
#align filter.pure_one Filter.pure_one
#align filter.pure_zero Filter.pure_zero
-/

#print Filter.principal_one /-
@[simp, to_additive]
theorem principal_one : ùìü 1 = (1 : Filter Œ±) :=
  principal_singleton _
#align filter.principal_one Filter.principal_one
#align filter.principal_zero Filter.principal_zero
-/

#print Filter.one_neBot /-
@[to_additive]
theorem one_neBot : (1 : Filter Œ±).ne_bot :=
  Filter.pure_neBot
#align filter.one_ne_bot Filter.one_neBot
#align filter.zero_ne_bot Filter.zero_neBot
-/

#print Filter.map_one' /-
@[simp, to_additive]
protected theorem map_one' (f : Œ± ‚Üí Œ≤) : (1 : Filter Œ±).map f = pure (f 1) :=
  rfl
#align filter.map_one' Filter.map_one'
#align filter.map_zero' Filter.map_zero'
-/

/- warning: filter.le_one_iff -> Filter.le_one_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : One.{u1} Œ±] {f : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± _inst_1))))) (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (OfNat.ofNat.{u1} (Set.{u1} Œ±) 1 (OfNat.mk.{u1} (Set.{u1} Œ±) 1 (One.one.{u1} (Set.{u1} Œ±) (Set.one.{u1} Œ± _inst_1)))) f)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : One.{u1} Œ±] {f : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± _inst_1)))) (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (OfNat.ofNat.{u1} (Set.{u1} Œ±) 1 (One.toOfNat1.{u1} (Set.{u1} Œ±) (Set.one.{u1} Œ± _inst_1))) f)
Case conversion may be inaccurate. Consider using '#align filter.le_one_iff Filter.le_one_iff‚Çì'. -/
@[simp, to_additive]
theorem le_one_iff : f ‚â§ 1 ‚Üî (1 : Set Œ±) ‚àà f :=
  le_pure_iff
#align filter.le_one_iff Filter.le_one_iff
#align filter.nonpos_iff Filter.nonpos_iff

/- warning: filter.ne_bot.le_one_iff -> Filter.NeBot.le_one_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : One.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± _inst_1))))) (Eq.{succ u1} (Filter.{u1} Œ±) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± _inst_1))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : One.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± _inst_1)))) (Eq.{succ u1} (Filter.{u1} Œ±) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± _inst_1)))))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.le_one_iff Filter.NeBot.le_one_iff‚Çì'. -/
@[to_additive]
protected theorem NeBot.le_one_iff (h : f.ne_bot) : f ‚â§ 1 ‚Üî f = 1 :=
  h.le_pure_iff
#align filter.ne_bot.le_one_iff Filter.NeBot.le_one_iff
#align filter.ne_bot.nonpos_iff Filter.NeBot.nonpos_iff

#print Filter.eventually_one /-
@[simp, to_additive]
theorem eventually_one {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in 1, p x) ‚Üî p 1 :=
  eventually_pure
#align filter.eventually_one Filter.eventually_one
#align filter.eventually_zero Filter.eventually_zero
-/

#print Filter.tendsto_one /-
@[simp, to_additive]
theorem tendsto_one {a : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} : Tendsto f a 1 ‚Üî ‚àÄ·∂† x in a, f x = 1 :=
  tendsto_pure
#align filter.tendsto_one Filter.tendsto_one
#align filter.tendsto_zero Filter.tendsto_zero
-/

#print Filter.one_prod_one /-
@[simp, to_additive]
theorem one_prod_one [One Œ≤] : (1 : Filter Œ±) √ó·∂† (1 : Filter Œ≤) = 1 :=
  prod_pure_pure
#align filter.one_prod_one Filter.one_prod_one
#align filter.zero_sum_zero Filter.zero_sum_zero
-/

#print Filter.pureOneHom /-
/-- `pure` as a `one_hom`. -/
@[to_additive "`pure` as a `zero_hom`."]
def pureOneHom : OneHom Œ± (Filter Œ±) :=
  ‚ü®pure, pure_one‚ü©
#align filter.pure_one_hom Filter.pureOneHom
#align filter.pure_zero_hom Filter.pureZeroHom
-/

#print Filter.coe_pureOneHom /-
@[simp, to_additive]
theorem coe_pureOneHom : (pureOneHom : Œ± ‚Üí Filter Œ±) = pure :=
  rfl
#align filter.coe_pure_one_hom Filter.coe_pureOneHom
#align filter.coe_pure_zero_hom Filter.coe_pureZeroHom
-/

#print Filter.pureOneHom_apply /-
@[simp, to_additive]
theorem pureOneHom_apply (a : Œ±) : pureOneHom a = pure a :=
  rfl
#align filter.pure_one_hom_apply Filter.pureOneHom_apply
#align filter.pure_zero_hom_apply Filter.pureZeroHom_apply
-/

variable [One Œ≤]

/- warning: filter.map_one -> Filter.map_one is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : One.{u2} Œ±] [_inst_2 : One.{u3} Œ≤] [_inst_3 : OneHomClass.{u1, u2, u3} F Œ± Œ≤ _inst_1 _inst_2] (œÜ : F), Eq.{succ u3} (Filter.{u3} Œ≤) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (OneHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ _inst_1 _inst_2 _inst_3)) œÜ) (OfNat.ofNat.{u2} (Filter.{u2} Œ±) 1 (OfNat.mk.{u2} (Filter.{u2} Œ±) 1 (One.one.{u2} (Filter.{u2} Œ±) (Filter.instOne.{u2} Œ± _inst_1))))) (OfNat.ofNat.{u3} (Filter.{u3} Œ≤) 1 (OfNat.mk.{u3} (Filter.{u3} Œ≤) 1 (One.one.{u3} (Filter.{u3} Œ≤) (Filter.instOne.{u3} Œ≤ _inst_2))))
but is expected to have type
  forall {F : Type.{u3}} {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : One.{u2} Œ±] [_inst_2 : One.{u1} Œ≤] [_inst_3 : OneHomClass.{u3, u2, u1} F Œ± Œ≤ _inst_1 _inst_2] (œÜ : F), Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.1262 : Œ±) => Œ≤) _x) (OneHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ _inst_1 _inst_2 _inst_3) œÜ) (OfNat.ofNat.{u2} (Filter.{u2} Œ±) 1 (One.toOfNat1.{u2} (Filter.{u2} Œ±) (Filter.instOne.{u2} Œ± _inst_1)))) (OfNat.ofNat.{u1} (Filter.{u1} Œ≤) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ≤) (Filter.instOne.{u1} Œ≤ _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.map_one Filter.map_one‚Çì'. -/
@[simp, to_additive]
protected theorem map_one [OneHomClass F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 := by
  rw [Filter.map_one', map_one, pure_one]
#align filter.map_one Filter.map_one
#align filter.map_zero Filter.map_zero

end One

/-! ### Filter negation/inversion -/


section Inv

variable [Inv Œ±] {f g : Filter Œ±} {s : Set Œ±} {a : Œ±}

/-- The inverse of a filter is the pointwise preimage under `‚Åª¬π` of its sets. -/
@[to_additive "The negation of a filter is the pointwise preimage under `-` of its sets."]
instance : Inv (Filter Œ±) :=
  ‚ü®map Inv.inv‚ü©

#print Filter.map_inv /-
@[simp, to_additive]
protected theorem map_inv : f.map Inv.inv = f‚Åª¬π :=
  rfl
#align filter.map_inv Filter.map_inv
#align filter.map_neg Filter.map_neg
-/

#print Filter.mem_inv /-
@[to_additive]
theorem mem_inv : s ‚àà f‚Åª¬π ‚Üî Inv.inv ‚Åª¬π' s ‚àà f :=
  Iff.rfl
#align filter.mem_inv Filter.mem_inv
#align filter.mem_neg Filter.mem_neg
-/

/- warning: filter.inv_le_inv -> Filter.inv_le_inv is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Inv.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f g) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± _inst_1) f) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± _inst_1) g))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Inv.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f g) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± _inst_1) f) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± _inst_1) g))
Case conversion may be inaccurate. Consider using '#align filter.inv_le_inv Filter.inv_le_inv‚Çì'. -/
@[to_additive]
protected theorem inv_le_inv (hf : f ‚â§ g) : f‚Åª¬π ‚â§ g‚Åª¬π :=
  map_mono hf
#align filter.inv_le_inv Filter.inv_le_inv
#align filter.neg_le_neg Filter.neg_le_neg

#print Filter.inv_pure /-
@[simp, to_additive]
theorem inv_pure : (pure a : Filter Œ±)‚Åª¬π = pure a‚Åª¬π :=
  rfl
#align filter.inv_pure Filter.inv_pure
#align filter.neg_pure Filter.neg_pure
-/

/- warning: filter.inv_eq_bot_iff -> Filter.inv_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Inv.{u1} Œ±] {f : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± _inst_1) f) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Inv.{u1} Œ±] {f : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± _inst_1) f) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))))
Case conversion may be inaccurate. Consider using '#align filter.inv_eq_bot_iff Filter.inv_eq_bot_iff‚Çì'. -/
@[simp, to_additive]
theorem inv_eq_bot_iff : f‚Åª¬π = ‚ä• ‚Üî f = ‚ä• :=
  map_eq_bot_iff
#align filter.inv_eq_bot_iff Filter.inv_eq_bot_iff
#align filter.neg_eq_bot_iff Filter.neg_eq_bot_iff

#print Filter.neBot_inv_iff /-
@[simp, to_additive]
theorem neBot_inv_iff : f‚Åª¬π.ne_bot ‚Üî NeBot f :=
  map_neBot_iff _
#align filter.ne_bot_inv_iff Filter.neBot_inv_iff
#align filter.ne_bot_neg_iff Filter.neBot_neg_iff
-/

#print Filter.NeBot.inv /-
@[to_additive]
theorem NeBot.inv : f.ne_bot ‚Üí f‚Åª¬π.ne_bot := fun h => h.map _
#align filter.ne_bot.inv Filter.NeBot.inv
#align filter.ne_bot.neg Filter.NeBot.neg
-/

end Inv

section InvolutiveInv

variable [InvolutiveInv Œ±] {f g : Filter Œ±} {s : Set Œ±}

/- warning: filter.inv_mem_inv -> Filter.inv_mem_inv is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (Inv.inv.{u1} (Set.{u1} Œ±) (Set.inv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) s) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) f))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s f) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (Inv.inv.{u1} (Set.{u1} Œ±) (Set.inv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) s) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) f))
Case conversion may be inaccurate. Consider using '#align filter.inv_mem_inv Filter.inv_mem_inv‚Çì'. -/
@[to_additive]
theorem inv_mem_inv (hs : s ‚àà f) : s‚Åª¬π ‚àà f‚Åª¬π := by rwa [mem_inv, inv_preimage, inv_inv]
#align filter.inv_mem_inv Filter.inv_mem_inv
#align filter.neg_mem_neg Filter.neg_mem_neg

#print Filter.instInvolutiveInv /-
/-- Inversion is involutive on `filter Œ±` if it is on `Œ±`. -/
@[to_additive "Negation is involutive on `filter Œ±` if it is on `Œ±`."]
protected def instInvolutiveInv : InvolutiveInv (Filter Œ±) :=
  { Filter.hasInv with
    inv_inv := fun f => map_map.trans <| by rw [inv_involutive.comp_self, map_id] }
#align filter.has_involutive_inv Filter.instInvolutiveInv
#align filter.has_involutive_neg Filter.instInvolutiveNeg
-/

scoped[Pointwise] attribute [instance] Filter.instInvolutiveInv Filter.instInvolutiveNeg

/- warning: filter.inv_le_inv_iff -> Filter.inv_le_inv_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) f) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) g)) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f g)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) f) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) g)) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f g)
Case conversion may be inaccurate. Consider using '#align filter.inv_le_inv_iff Filter.inv_le_inv_iff‚Çì'. -/
@[simp, to_additive]
protected theorem inv_le_inv_iff : f‚Åª¬π ‚â§ g‚Åª¬π ‚Üî f ‚â§ g :=
  ‚ü®fun h => inv_inv f ‚ñ∏ inv_inv g ‚ñ∏ Filter.inv_le_inv h, Filter.inv_le_inv‚ü©
#align filter.inv_le_inv_iff Filter.inv_le_inv_iff
#align filter.neg_le_neg_iff Filter.neg_le_neg_iff

/- warning: filter.inv_le_iff_le_inv -> Filter.inv_le_iff_le_inv is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) f) g) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) g))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) f) g) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) g))
Case conversion may be inaccurate. Consider using '#align filter.inv_le_iff_le_inv Filter.inv_le_iff_le_inv‚Çì'. -/
@[to_additive]
theorem inv_le_iff_le_inv : f‚Åª¬π ‚â§ g ‚Üî f ‚â§ g‚Åª¬π := by rw [‚Üê Filter.inv_le_inv_iff, inv_inv]
#align filter.inv_le_iff_le_inv Filter.inv_le_iff_le_inv
#align filter.neg_le_iff_le_neg Filter.neg_le_iff_le_neg

/- warning: filter.inv_le_self -> Filter.inv_le_self is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) f) f) (Eq.{succ u1} (Filter.{u1} Œ±) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.hasInv.{u1} Œ± (InvolutiveInv.toHasInv.{u1} Œ± _inst_1)) f) f)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : InvolutiveInv.{u1} Œ±] {f : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) f) f) (Eq.{succ u1} (Filter.{u1} Œ±) (Inv.inv.{u1} (Filter.{u1} Œ±) (Filter.instInv.{u1} Œ± (InvolutiveInv.toInv.{u1} Œ± _inst_1)) f) f)
Case conversion may be inaccurate. Consider using '#align filter.inv_le_self Filter.inv_le_self‚Çì'. -/
@[simp, to_additive]
theorem inv_le_self : f‚Åª¬π ‚â§ f ‚Üî f‚Åª¬π = f :=
  ‚ü®fun h => h.antisymm <| inv_le_iff_le_inv.1 h, Eq.le‚ü©
#align filter.inv_le_self Filter.inv_le_self
#align filter.neg_le_self Filter.neg_le_self

end InvolutiveInv

/-! ### Filter addition/multiplication -/


section Mul

variable [Mul Œ±] [Mul Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : Filter Œ±} {s t : Set Œ±} {a b : Œ±}

#print Filter.instMul /-
/-- The filter `f * g` is generated by `{s * t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive "The filter `f + g` is generated by `{s + t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def instMul : Mul (Filter Œ±) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (*) f g`, but the hypothesis unfolds to `t‚ÇÅ * t‚ÇÇ ‚äÜ s` rather than all the
  way to `set.image2 (*) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ * ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s } }‚ü©
#align filter.has_mul Filter.instMul
#align filter.has_add Filter.instAdd
-/

scoped[Pointwise] attribute [instance] Filter.instMul Filter.instAdd

#print Filter.map‚ÇÇ_mul /-
@[simp, to_additive]
theorem map‚ÇÇ_mul : map‚ÇÇ (¬∑ * ¬∑) f g = f * g :=
  rfl
#align filter.map‚ÇÇ_mul Filter.map‚ÇÇ_mul
#align filter.map‚ÇÇ_add Filter.map‚ÇÇ_add
-/

#print Filter.mem_mul /-
@[to_additive]
theorem mem_mul : s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s :=
  Iff.rfl
#align filter.mem_mul Filter.mem_mul
#align filter.mem_add Filter.mem_add
-/

#print Filter.mul_mem_mul /-
@[to_additive]
theorem mul_mem_mul : s ‚àà f ‚Üí t ‚àà g ‚Üí s * t ‚àà f * g :=
  image2_mem_map‚ÇÇ
#align filter.mul_mem_mul Filter.mul_mem_mul
#align filter.add_mem_add Filter.add_mem_add
-/

/- warning: filter.bot_mul -> Filter.bot_mul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {g : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {g : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.bot_mul Filter.bot_mul‚Çì'. -/
@[simp, to_additive]
theorem bot_mul : ‚ä• * g = ‚ä• :=
  map‚ÇÇ_bot_left
#align filter.bot_mul Filter.bot_mul
#align filter.bot_add Filter.bot_add

/- warning: filter.mul_bot -> Filter.mul_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {f : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {f : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.mul_bot Filter.mul_bot‚Çì'. -/
@[simp, to_additive]
theorem mul_bot : f * ‚ä• = ‚ä• :=
  map‚ÇÇ_bot_right
#align filter.mul_bot Filter.mul_bot
#align filter.add_bot Filter.add_bot

/- warning: filter.mul_eq_bot_iff -> Filter.mul_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) f g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Or (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Eq.{succ u1} (Filter.{u1} Œ±) g (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) f g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Or (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Eq.{succ u1} (Filter.{u1} Œ±) g (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))))
Case conversion may be inaccurate. Consider using '#align filter.mul_eq_bot_iff Filter.mul_eq_bot_iff‚Çì'. -/
@[simp, to_additive]
theorem mul_eq_bot_iff : f * g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff
#align filter.mul_eq_bot_iff Filter.mul_eq_bot_iff
#align filter.add_eq_bot_iff Filter.add_eq_bot_iff

#print Filter.mul_neBot_iff /-
@[simp, to_additive]
theorem mul_neBot_iff : (f * g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot :=
  map‚ÇÇ_neBot_iff
#align filter.mul_ne_bot_iff Filter.mul_neBot_iff
#align filter.add_ne_bot_iff Filter.add_neBot_iff
-/

#print Filter.NeBot.mul /-
@[to_additive]
theorem NeBot.mul : NeBot f ‚Üí NeBot g ‚Üí NeBot (f * g) :=
  NeBot.map‚ÇÇ
#align filter.ne_bot.mul Filter.NeBot.mul
#align filter.ne_bot.add Filter.NeBot.add
-/

#print Filter.NeBot.of_mul_left /-
@[to_additive]
theorem NeBot.of_mul_left : (f * g).ne_bot ‚Üí f.ne_bot :=
  NeBot.of_map‚ÇÇ_left
#align filter.ne_bot.of_mul_left Filter.NeBot.of_mul_left
#align filter.ne_bot.of_add_left Filter.NeBot.of_add_left
-/

#print Filter.NeBot.of_mul_right /-
@[to_additive]
theorem NeBot.of_mul_right : (f * g).ne_bot ‚Üí g.ne_bot :=
  NeBot.of_map‚ÇÇ_right
#align filter.ne_bot.of_mul_right Filter.NeBot.of_mul_right
#align filter.ne_bot.of_add_right Filter.NeBot.of_add_right
-/

#print Filter.pure_mul /-
@[simp, to_additive]
theorem pure_mul : pure a * g = g.map ((¬∑ * ¬∑) a) :=
  map‚ÇÇ_pure_left
#align filter.pure_mul Filter.pure_mul
#align filter.pure_add Filter.pure_add
-/

#print Filter.mul_pure /-
@[simp, to_additive]
theorem mul_pure : f * pure b = f.map (¬∑ * b) :=
  map‚ÇÇ_pure_right
#align filter.mul_pure Filter.mul_pure
#align filter.add_pure Filter.add_pure
-/

#print Filter.pure_mul_pure /-
@[simp, to_additive]
theorem pure_mul_pure : (pure a : Filter Œ±) * pure b = pure (a * b) :=
  map‚ÇÇ_pure
#align filter.pure_mul_pure Filter.pure_mul_pure
#align filter.pure_add_pure Filter.pure_add_pure
-/

/- warning: filter.le_mul_iff -> Filter.le_mul_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) h (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) f g)) (forall {{s : Set.{u1} Œ±}}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (forall {{t : Set.{u1} Œ±}}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) t g) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Set.{u1} Œ±) (Set.{u1} Œ±) (Set.{u1} Œ±) (instHMul.{u1} (Set.{u1} Œ±) (Set.mul.{u1} Œ± _inst_1)) s t) h)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) h (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) f g)) (forall {{s : Set.{u1} Œ±}}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s f) -> (forall {{t : Set.{u1} Œ±}}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) t g) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Set.{u1} Œ±) (Set.{u1} Œ±) (Set.{u1} Œ±) (instHMul.{u1} (Set.{u1} Œ±) (Set.mul.{u1} Œ± _inst_1)) s t) h)))
Case conversion may be inaccurate. Consider using '#align filter.le_mul_iff Filter.le_mul_iff‚Çì'. -/
@[simp, to_additive]
theorem le_mul_iff : h ‚â§ f * g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s * t ‚àà h :=
  le_map‚ÇÇ_iff
#align filter.le_mul_iff Filter.le_mul_iff
#align filter.le_add_iff Filter.le_add_iff

/- warning: filter.covariant_mul -> Filter.covariant_mul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1))) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.2294 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.2296 : Filter.{u1} Œ±) => HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) x._@.Mathlib.Order.Filter.Pointwise._hyg.2294 x._@.Mathlib.Order.Filter.Pointwise._hyg.2296) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.2309 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.2311 : Filter.{u1} Œ±) => LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) x._@.Mathlib.Order.Filter.Pointwise._hyg.2309 x._@.Mathlib.Order.Filter.Pointwise._hyg.2311)
Case conversion may be inaccurate. Consider using '#align filter.covariant_mul Filter.covariant_mul‚Çì'. -/
@[to_additive]
instance covariant_mul : CovariantClass (Filter Œ±) (Filter Œ±) (¬∑ * ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun f g h => map‚ÇÇ_mono_left‚ü©
#align filter.covariant_mul Filter.covariant_mul
#align filter.covariant_add Filter.covariant_add

/- warning: filter.covariant_swap_mul -> Filter.covariant_swap_mul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Function.swap.{succ u1, succ u1, succ u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (fun (·æ∞ : Filter.{u1} Œ±) (·æ∞ : Filter.{u1} Œ±) => Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)))) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Mul.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Function.swap.{succ u1, succ u1, succ u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (fun (·æ∞ : Filter.{u1} Œ±) (·æ∞ : Filter.{u1} Œ±) => Filter.{u1} Œ±) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.2382 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.2384 : Filter.{u1} Œ±) => HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± _inst_1)) x._@.Mathlib.Order.Filter.Pointwise._hyg.2382 x._@.Mathlib.Order.Filter.Pointwise._hyg.2384)) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.2397 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.2399 : Filter.{u1} Œ±) => LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) x._@.Mathlib.Order.Filter.Pointwise._hyg.2397 x._@.Mathlib.Order.Filter.Pointwise._hyg.2399)
Case conversion may be inaccurate. Consider using '#align filter.covariant_swap_mul Filter.covariant_swap_mul‚Çì'. -/
@[to_additive]
instance covariant_swap_mul : CovariantClass (Filter Œ±) (Filter Œ±) (swap (¬∑ * ¬∑)) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun f g h => map‚ÇÇ_mono_right‚ü©
#align filter.covariant_swap_mul Filter.covariant_swap_mul
#align filter.covariant_swap_add Filter.covariant_swap_add

/- warning: filter.map_mul -> Filter.map_mul is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : Mul.{u2} Œ±] [_inst_2 : Mul.{u3} Œ≤] {f‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u2} Œ±} [_inst_3 : MulHomClass.{u1, u2, u3} F Œ± Œ≤ _inst_1 _inst_2] (m : F), Eq.{succ u3} (Filter.{u3} Œ≤) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ _inst_1 _inst_2 _inst_3)) m) (HMul.hMul.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHMul.{u2} (Filter.{u2} Œ±) (Filter.instMul.{u2} Œ± _inst_1)) f‚ÇÅ f‚ÇÇ)) (HMul.hMul.{u3, u3, u3} (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (instHMul.{u3} (Filter.{u3} Œ≤) (Filter.instMul.{u3} Œ≤ _inst_2)) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ _inst_1 _inst_2 _inst_3)) m) f‚ÇÅ) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ _inst_1 _inst_2 _inst_3)) m) f‚ÇÇ))
but is expected to have type
  forall {F : Type.{u3}} {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : Mul.{u2} Œ±] [_inst_2 : Mul.{u1} Œ≤] {f‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u2} Œ±} [_inst_3 : MulHomClass.{u3, u2, u1} F Œ± Œ≤ _inst_1 _inst_2] (m : F), Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ _inst_1 _inst_2 _inst_3) m) (HMul.hMul.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHMul.{u2} (Filter.{u2} Œ±) (Filter.instMul.{u2} Œ± _inst_1)) f‚ÇÅ f‚ÇÇ)) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHMul.{u1} (Filter.{u1} Œ≤) (Filter.instMul.{u1} Œ≤ _inst_2)) (Filter.map.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ _inst_1 _inst_2 _inst_3) m) f‚ÇÅ) (Filter.map.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ _inst_1 _inst_2 _inst_3) m) f‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.map_mul Filter.map_mul‚Çì'. -/
@[to_additive]
protected theorem map_mul [MulHomClass F Œ± Œ≤] (m : F) : (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
  map_map‚ÇÇ_distrib <| map_mul m
#align filter.map_mul Filter.map_mul
#align filter.map_add Filter.map_add

#print Filter.pureMulHom /-
/-- `pure` operation as a `mul_hom`. -/
@[to_additive "The singleton operation as an `add_hom`."]
def pureMulHom : Œ± ‚Üí‚Çô* Filter Œ± :=
  ‚ü®pure, fun a b => pure_mul_pure.symm‚ü©
#align filter.pure_mul_hom Filter.pureMulHom
#align filter.pure_add_hom Filter.pureAddHom
-/

#print Filter.coe_pureMulHom /-
@[simp, to_additive]
theorem coe_pureMulHom : (pureMulHom : Œ± ‚Üí Filter Œ±) = pure :=
  rfl
#align filter.coe_pure_mul_hom Filter.coe_pureMulHom
-/

#print Filter.pureMulHom_apply /-
@[simp, to_additive]
theorem pureMulHom_apply (a : Œ±) : pureMulHom a = pure a :=
  rfl
#align filter.pure_mul_hom_apply Filter.pureMulHom_apply
-/

end Mul

/-! ### Filter subtraction/division -/


section Div

variable [Div Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : Filter Œ±} {s t : Set Œ±} {a b : Œ±}

#print Filter.instDiv /-
/-- The filter `f / g` is generated by `{s / t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive "The filter `f - g` is generated by `{s - t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def instDiv : Div (Filter Œ±) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (/) f g`, but the hypothesis unfolds to `t‚ÇÅ / t‚ÇÇ ‚äÜ s` rather than all the
  way to `set.image2 (/) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ / ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s } }‚ü©
#align filter.has_div Filter.instDiv
#align filter.has_sub Filter.instSub
-/

scoped[Pointwise] attribute [instance] Filter.instDiv Filter.instSub

#print Filter.map‚ÇÇ_div /-
@[simp, to_additive]
theorem map‚ÇÇ_div : map‚ÇÇ (¬∑ / ¬∑) f g = f / g :=
  rfl
#align filter.map‚ÇÇ_div Filter.map‚ÇÇ_div
#align filter.map‚ÇÇ_sub Filter.map‚ÇÇ_sub
-/

#print Filter.mem_div /-
@[to_additive]
theorem mem_div : s ‚àà f / g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s :=
  Iff.rfl
#align filter.mem_div Filter.mem_div
#align filter.mem_sub Filter.mem_sub
-/

#print Filter.div_mem_div /-
@[to_additive]
theorem div_mem_div : s ‚àà f ‚Üí t ‚àà g ‚Üí s / t ‚àà f / g :=
  image2_mem_map‚ÇÇ
#align filter.div_mem_div Filter.div_mem_div
#align filter.sub_mem_sub Filter.sub_mem_sub
-/

/- warning: filter.bot_div -> Filter.bot_div is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {g : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {g : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.bot_div Filter.bot_div‚Çì'. -/
@[simp, to_additive]
theorem bot_div : ‚ä• / g = ‚ä• :=
  map‚ÇÇ_bot_left
#align filter.bot_div Filter.bot_div
#align filter.bot_sub Filter.bot_sub

/- warning: filter.div_bot -> Filter.div_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.div_bot Filter.div_bot‚Çì'. -/
@[simp, to_additive]
theorem div_bot : f / ‚ä• = ‚ä• :=
  map‚ÇÇ_bot_right
#align filter.div_bot Filter.div_bot
#align filter.sub_bot Filter.sub_bot

/- warning: filter.div_eq_bot_iff -> Filter.div_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Or (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Eq.{succ u1} (Filter.{u1} Œ±) g (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Or (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Eq.{succ u1} (Filter.{u1} Œ±) g (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))))
Case conversion may be inaccurate. Consider using '#align filter.div_eq_bot_iff Filter.div_eq_bot_iff‚Çì'. -/
@[simp, to_additive]
theorem div_eq_bot_iff : f / g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff
#align filter.div_eq_bot_iff Filter.div_eq_bot_iff
#align filter.sub_eq_bot_iff Filter.sub_eq_bot_iff

#print Filter.div_neBot_iff /-
@[simp, to_additive]
theorem div_neBot_iff : (f / g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot :=
  map‚ÇÇ_neBot_iff
#align filter.div_ne_bot_iff Filter.div_neBot_iff
#align filter.sub_ne_bot_iff Filter.sub_neBot_iff
-/

#print Filter.NeBot.div /-
@[to_additive]
theorem NeBot.div : NeBot f ‚Üí NeBot g ‚Üí NeBot (f / g) :=
  NeBot.map‚ÇÇ
#align filter.ne_bot.div Filter.NeBot.div
#align filter.ne_bot.sub Filter.NeBot.sub
-/

#print Filter.NeBot.of_div_left /-
@[to_additive]
theorem NeBot.of_div_left : (f / g).ne_bot ‚Üí f.ne_bot :=
  NeBot.of_map‚ÇÇ_left
#align filter.ne_bot.of_div_left Filter.NeBot.of_div_left
#align filter.ne_bot.of_sub_left Filter.NeBot.of_sub_left
-/

#print Filter.NeBot.of_div_right /-
@[to_additive]
theorem NeBot.of_div_right : (f / g).ne_bot ‚Üí g.ne_bot :=
  NeBot.of_map‚ÇÇ_right
#align filter.ne_bot.of_div_right Filter.NeBot.of_div_right
#align filter.ne_bot.of_sub_right Filter.NeBot.of_sub_right
-/

#print Filter.pure_div /-
@[simp, to_additive]
theorem pure_div : pure a / g = g.map ((¬∑ / ¬∑) a) :=
  map‚ÇÇ_pure_left
#align filter.pure_div Filter.pure_div
#align filter.pure_sub Filter.pure_sub
-/

#print Filter.div_pure /-
@[simp, to_additive]
theorem div_pure : f / pure b = f.map (¬∑ / b) :=
  map‚ÇÇ_pure_right
#align filter.div_pure Filter.div_pure
#align filter.sub_pure Filter.sub_pure
-/

#print Filter.pure_div_pure /-
@[simp, to_additive]
theorem pure_div_pure : (pure a : Filter Œ±) / pure b = pure (a / b) :=
  map‚ÇÇ_pure
#align filter.pure_div_pure Filter.pure_div_pure
#align filter.pure_sub_pure Filter.pure_sub_pure
-/

/- warning: filter.div_le_div -> Filter.div_le_div is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f‚ÇÅ : Filter.{u1} Œ±} {f‚ÇÇ : Filter.{u1} Œ±} {g‚ÇÅ : Filter.{u1} Œ±} {g‚ÇÇ : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÅ g‚ÇÅ) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÇ g‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f‚ÇÅ : Filter.{u1} Œ±} {f‚ÇÇ : Filter.{u1} Œ±} {g‚ÇÅ : Filter.{u1} Œ±} {g‚ÇÇ : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÅ g‚ÇÅ) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÇ g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.div_le_div Filter.div_le_div‚Çì'. -/
@[to_additive]
protected theorem div_le_div : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ / g‚ÇÅ ‚â§ f‚ÇÇ / g‚ÇÇ :=
  map‚ÇÇ_mono
#align filter.div_le_div Filter.div_le_div
#align filter.sub_le_sub Filter.sub_le_sub

/- warning: filter.div_le_div_left -> Filter.div_le_div_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±} {g‚ÇÅ : Filter.{u1} Œ±} {g‚ÇÇ : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g‚ÇÅ) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±} {g‚ÇÅ : Filter.{u1} Œ±} {g‚ÇÇ : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g‚ÇÅ) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.div_le_div_left Filter.div_le_div_left‚Çì'. -/
@[to_additive]
protected theorem div_le_div_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f / g‚ÇÅ ‚â§ f / g‚ÇÇ :=
  map‚ÇÇ_mono_left
#align filter.div_le_div_left Filter.div_le_div_left
#align filter.sub_le_sub_left Filter.sub_le_sub_left

/- warning: filter.div_le_div_right -> Filter.div_le_div_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f‚ÇÅ : Filter.{u1} Œ±} {f‚ÇÇ : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÅ g) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÇ g))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f‚ÇÅ : Filter.{u1} Œ±} {f‚ÇÇ : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÅ g) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f‚ÇÇ g))
Case conversion may be inaccurate. Consider using '#align filter.div_le_div_right Filter.div_le_div_right‚Çì'. -/
@[to_additive]
protected theorem div_le_div_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ / g ‚â§ f‚ÇÇ / g :=
  map‚ÇÇ_mono_right
#align filter.div_le_div_right Filter.div_le_div_right
#align filter.sub_le_sub_right Filter.sub_le_sub_right

/- warning: filter.le_div_iff -> Filter.le_div_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) h (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g)) (forall {{s : Set.{u1} Œ±}}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (forall {{t : Set.{u1} Œ±}}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) t g) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Set.{u1} Œ±) (Set.{u1} Œ±) (Set.{u1} Œ±) (instHDiv.{u1} (Set.{u1} Œ±) (Set.div.{u1} Œ± _inst_1)) s t) h)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) h (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) f g)) (forall {{s : Set.{u1} Œ±}}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s f) -> (forall {{t : Set.{u1} Œ±}}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) t g) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Set.{u1} Œ±) (Set.{u1} Œ±) (Set.{u1} Œ±) (instHDiv.{u1} (Set.{u1} Œ±) (Set.div.{u1} Œ± _inst_1)) s t) h)))
Case conversion may be inaccurate. Consider using '#align filter.le_div_iff Filter.le_div_iff‚Çì'. -/
@[simp, to_additive]
protected theorem le_div_iff : h ‚â§ f / g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s / t ‚àà h :=
  le_map‚ÇÇ_iff
#align filter.le_div_iff Filter.le_div_iff
#align filter.le_sub_iff Filter.le_sub_iff

/- warning: filter.covariant_div -> Filter.covariant_div is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1))) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.3763 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.3765 : Filter.{u1} Œ±) => HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) x._@.Mathlib.Order.Filter.Pointwise._hyg.3763 x._@.Mathlib.Order.Filter.Pointwise._hyg.3765) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.3778 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.3780 : Filter.{u1} Œ±) => LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) x._@.Mathlib.Order.Filter.Pointwise._hyg.3778 x._@.Mathlib.Order.Filter.Pointwise._hyg.3780)
Case conversion may be inaccurate. Consider using '#align filter.covariant_div Filter.covariant_div‚Çì'. -/
@[to_additive]
instance covariant_div : CovariantClass (Filter Œ±) (Filter Œ±) (¬∑ / ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun f g h => map‚ÇÇ_mono_left‚ü©
#align filter.covariant_div Filter.covariant_div
#align filter.covariant_sub Filter.covariant_sub

/- warning: filter.covariant_swap_div -> Filter.covariant_swap_div is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Function.swap.{succ u1, succ u1, succ u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (fun (·æ∞ : Filter.{u1} Œ±) (·æ∞ : Filter.{u1} Œ±) => Filter.{u1} Œ±) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)))) (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Div.{u1} Œ±], CovariantClass.{u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Function.swap.{succ u1, succ u1, succ u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (fun (·æ∞ : Filter.{u1} Œ±) (·æ∞ : Filter.{u1} Œ±) => Filter.{u1} Œ±) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.3848 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.3850 : Filter.{u1} Œ±) => HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± _inst_1)) x._@.Mathlib.Order.Filter.Pointwise._hyg.3848 x._@.Mathlib.Order.Filter.Pointwise._hyg.3850)) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.3863 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.3865 : Filter.{u1} Œ±) => LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) x._@.Mathlib.Order.Filter.Pointwise._hyg.3863 x._@.Mathlib.Order.Filter.Pointwise._hyg.3865)
Case conversion may be inaccurate. Consider using '#align filter.covariant_swap_div Filter.covariant_swap_div‚Çì'. -/
@[to_additive]
instance covariant_swap_div : CovariantClass (Filter Œ±) (Filter Œ±) (swap (¬∑ / ¬∑)) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun f g h => map‚ÇÇ_mono_right‚ü©
#align filter.covariant_swap_div Filter.covariant_swap_div
#align filter.covariant_swap_sub Filter.covariant_swap_sub

end Div

open Pointwise

#print Filter.instNSMul /-
/-- Repeated pointwise addition (not the same as pointwise repeated addition!) of a `filter`. See
Note [pointwise nat action].-/
protected def instNSMul [Zero Œ±] [Add Œ±] : SMul ‚Ñï (Filter Œ±) :=
  ‚ü®nsmulRec‚ü©
#align filter.has_nsmul Filter.instNSMul
-/

#print Filter.instNPow /-
/-- Repeated pointwise multiplication (not the same as pointwise repeated multiplication!) of a
`filter`. See Note [pointwise nat action]. -/
@[to_additive]
protected def instNPow [One Œ±] [Mul Œ±] : Pow (Filter Œ±) ‚Ñï :=
  ‚ü®fun s n => npowRec n s‚ü©
#align filter.has_npow Filter.instNPow
#align filter.has_nsmul Filter.instNSMul
-/

#print Filter.instZSMul /-
/-- Repeated pointwise addition/subtraction (not the same as pointwise repeated
addition/subtraction!) of a `filter`. See Note [pointwise nat action]. -/
protected def instZSMul [Zero Œ±] [Add Œ±] [Neg Œ±] : SMul ‚Ñ§ (Filter Œ±) :=
  ‚ü®zsmulRec‚ü©
#align filter.has_zsmul Filter.instZSMul
-/

#print Filter.instZPow /-
/-- Repeated pointwise multiplication/division (not the same as pointwise repeated
multiplication/division!) of a `filter`. See Note [pointwise nat action]. -/
@[to_additive]
protected def instZPow [One Œ±] [Mul Œ±] [Inv Œ±] : Pow (Filter Œ±) ‚Ñ§ :=
  ‚ü®fun s n => zpowRec n s‚ü©
#align filter.has_zpow Filter.instZPow
#align filter.has_zsmul Filter.instZSMul
-/

scoped[Pointwise]
  attribute [instance] Filter.instNSMul Filter.instNPow Filter.instZSMul Filter.instZPow

#print Filter.semigroup /-
/-- `filter Œ±` is a `semigroup` under pointwise operations if `Œ±` is.-/
@[to_additive "`filter Œ±` is an `add_semigroup` under pointwise operations if `Œ±` is."]
protected def semigroup [Semigroup Œ±] : Semigroup (Filter Œ±)
    where
  mul := (¬∑ * ¬∑)
  mul_assoc f g h := map‚ÇÇ_assoc mul_assoc
#align filter.semigroup Filter.semigroup
#align filter.add_semigroup Filter.addSemigroup
-/

#print Filter.commSemigroup /-
/-- `filter Œ±` is a `comm_semigroup` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_comm_semigroup` under pointwise operations if `Œ±` is."]
protected def commSemigroup [CommSemigroup Œ±] : CommSemigroup (Filter Œ±) :=
  { Filter.semigroup with mul_comm := fun f g => map‚ÇÇ_comm mul_comm }
#align filter.comm_semigroup Filter.commSemigroup
#align filter.add_comm_semigroup Filter.addCommSemigroup
-/

section MulOneClass

variable [MulOneClass Œ±] [MulOneClass Œ≤]

#print Filter.mulOneClass /-
/-- `filter Œ±` is a `mul_one_class` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_zero_class` under pointwise operations if `Œ±` is."]
protected def mulOneClass : MulOneClass (Filter Œ±)
    where
  one := 1
  mul := (¬∑ * ¬∑)
  one_mul := map‚ÇÇ_left_identity one_mul
  mul_one := map‚ÇÇ_right_identity mul_one
#align filter.mul_one_class Filter.mulOneClass
#align filter.add_zero_class Filter.addZeroClass
-/

scoped[Pointwise]
  attribute [instance]
    Filter.semigroup Filter.addSemigroup Filter.commSemigroup Filter.addCommSemigroup Filter.mulOneClass Filter.addZeroClass

#print Filter.mapMonoidHom /-
/-- If `œÜ : Œ± ‚Üí* Œ≤` then `map_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí* filter Œ≤` induced by `map œÜ`. -/
@[to_additive
      "If `œÜ : Œ± ‚Üí+ Œ≤` then `map_add_monoid_hom œÜ` is the monoid homomorphism\n`filter Œ± ‚Üí+ filter Œ≤` induced by `map œÜ`."]
def mapMonoidHom [MonoidHomClass F Œ± Œ≤] (œÜ : F) : Filter Œ± ‚Üí* Filter Œ≤
    where
  toFun := map œÜ
  map_one' := Filter.map_one œÜ
  map_mul' _ _ := Filter.map_mul œÜ
#align filter.map_monoid_hom Filter.mapMonoidHom
#align filter.map_add_monoid_hom Filter.mapAddMonoidHom
-/

/- warning: filter.comap_mul_comap_le -> Filter.comap_mul_comap_le is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : MulOneClass.{u2} Œ±] [_inst_2 : MulOneClass.{u3} Œ≤] [_inst_3 : MulHomClass.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2)] (m : F) {f : Filter.{u3} Œ≤} {g : Filter.{u3} Œ≤}, LE.le.{u2} (Filter.{u2} Œ±) (Preorder.toHasLe.{u2} (Filter.{u2} Œ±) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ±) (Filter.partialOrder.{u2} Œ±))) (HMul.hMul.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHMul.{u2} (Filter.{u2} Œ±) (Filter.instMul.{u2} Œ± (MulOneClass.toHasMul.{u2} Œ± _inst_1))) (Filter.comap.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2) _inst_3)) m) f) (Filter.comap.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2) _inst_3)) m) g)) (Filter.comap.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2) _inst_3)) m) (HMul.hMul.{u3, u3, u3} (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (instHMul.{u3} (Filter.{u3} Œ≤) (Filter.instMul.{u3} Œ≤ (MulOneClass.toHasMul.{u3} Œ≤ _inst_2))) f g))
but is expected to have type
  forall {F : Type.{u3}} {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MulOneClass.{u2} Œ±] [_inst_2 : MulOneClass.{u1} Œ≤] [_inst_3 : MulHomClass.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2)] (m : F) {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤}, LE.le.{u2} (Filter.{u2} Œ±) (Preorder.toLE.{u2} (Filter.{u2} Œ±) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ±) (Filter.instPartialOrderFilter.{u2} Œ±))) (HMul.hMul.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHMul.{u2} (Filter.{u2} Œ±) (Filter.instMul.{u2} Œ± (MulOneClass.toMul.{u2} Œ± _inst_1))) (Filter.comap.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2) _inst_3) m) f) (Filter.comap.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2) _inst_3) m) g)) (Filter.comap.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2) _inst_3) m) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHMul.{u1} (Filter.{u1} Œ≤) (Filter.instMul.{u1} Œ≤ (MulOneClass.toMul.{u1} Œ≤ _inst_2))) f g))
Case conversion may be inaccurate. Consider using '#align filter.comap_mul_comap_le Filter.comap_mul_comap_le‚Çì'. -/
-- The other direction does not hold in general
@[to_additive]
theorem comap_mul_comap_le [MulHomClass F Œ± Œ≤] (m : F) {f g : Filter Œ≤} :
    f.comap m * g.comap m ‚â§ (f * g).comap m := fun s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü© =>
  ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, Subset.rfl‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, Subset.rfl‚ü©,
    (preimage_mul_preimage_subset _).trans <| (preimage_mono t‚ÇÅt‚ÇÇ).trans mt‚ü©
#align filter.comap_mul_comap_le Filter.comap_mul_comap_le
#align filter.comap_add_comap_le Filter.comap_add_comap_le

/- warning: filter.tendsto.mul_mul -> Filter.Tendsto.mul_mul is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : MulOneClass.{u2} Œ±] [_inst_2 : MulOneClass.{u3} Œ≤] [_inst_3 : MulHomClass.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2)] (m : F) {f‚ÇÅ : Filter.{u2} Œ±} {g‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u3} Œ≤} {g‚ÇÇ : Filter.{u3} Œ≤}, (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2) _inst_3)) m) f‚ÇÅ f‚ÇÇ) -> (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2) _inst_3)) m) g‚ÇÅ g‚ÇÇ) -> (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± _inst_1) (MulOneClass.toHasMul.{u3} Œ≤ _inst_2) _inst_3)) m) (HMul.hMul.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHMul.{u2} (Filter.{u2} Œ±) (Filter.instMul.{u2} Œ± (MulOneClass.toHasMul.{u2} Œ± _inst_1))) f‚ÇÅ g‚ÇÅ) (HMul.hMul.{u3, u3, u3} (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (instHMul.{u3} (Filter.{u3} Œ≤) (Filter.instMul.{u3} Œ≤ (MulOneClass.toHasMul.{u3} Œ≤ _inst_2))) f‚ÇÇ g‚ÇÇ))
but is expected to have type
  forall {F : Type.{u3}} {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MulOneClass.{u2} Œ±] [_inst_2 : MulOneClass.{u1} Œ≤] [_inst_3 : MulHomClass.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2)] (m : F) {f‚ÇÅ : Filter.{u2} Œ±} {g‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u1} Œ≤} {g‚ÇÇ : Filter.{u1} Œ≤}, (Filter.Tendsto.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2) _inst_3) m) f‚ÇÅ f‚ÇÇ) -> (Filter.Tendsto.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2) _inst_3) m) g‚ÇÅ g‚ÇÇ) -> (Filter.Tendsto.{u2, u1} Œ± Œ≤ (FunLike.coe.{succ u3, succ u2, succ u1} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u3, u2, u1} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ≤ _inst_2) _inst_3) m) (HMul.hMul.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHMul.{u2} (Filter.{u2} Œ±) (Filter.instMul.{u2} Œ± (MulOneClass.toMul.{u2} Œ± _inst_1))) f‚ÇÅ g‚ÇÅ) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHMul.{u1} (Filter.{u1} Œ≤) (Filter.instMul.{u1} Œ≤ (MulOneClass.toMul.{u1} Œ≤ _inst_2))) f‚ÇÇ g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.mul_mul Filter.Tendsto.mul_mul‚Çì'. -/
@[to_additive]
theorem Tendsto.mul_mul [MulHomClass F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : Filter Œ±} {f‚ÇÇ g‚ÇÇ : Filter Œ≤} :
    Tendsto m f‚ÇÅ f‚ÇÇ ‚Üí Tendsto m g‚ÇÅ g‚ÇÇ ‚Üí Tendsto m (f‚ÇÅ * g‚ÇÅ) (f‚ÇÇ * g‚ÇÇ) := fun hf hg =>
  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg
#align filter.tendsto.mul_mul Filter.Tendsto.mul_mul
#align filter.tendsto.add_add Filter.Tendsto.add_add

#print Filter.pureMonoidHom /-
/-- `pure` as a `monoid_hom`. -/
@[to_additive "`pure` as an `add_monoid_hom`."]
def pureMonoidHom : Œ± ‚Üí* Filter Œ± :=
  { pureMulHom, pureOneHom with }
#align filter.pure_monoid_hom Filter.pureMonoidHom
#align filter.pure_add_monoid_hom Filter.pureAddMonoidHom
-/

/- warning: filter.coe_pure_monoid_hom -> Filter.coe_pureMonoidHom is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MulOneClass.{u1} Œ±], Eq.{succ u1} ((fun (_x : MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) => Œ± -> (Filter.{u1} Œ±)) (Filter.pureMonoidHom.{u1} Œ± _inst_1)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) (fun (_x : MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) => Œ± -> (Filter.{u1} Œ±)) (MonoidHom.hasCoeToFun.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) (Filter.pureMonoidHom.{u1} Œ± _inst_1)) (Pure.pure.{u1, u1} (fun {Œ± : Type.{u1}} => Filter.{u1} Œ±) Filter.hasPure.{u1} Œ±)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MulOneClass.{u1} Œ±], Eq.{succ u1} (forall (a : Œ±), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Filter.{u1} Œ±) a) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Filter.{u1} Œ±) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) Œ± (Filter.{u1} Œ±) (MulOneClass.toMul.{u1} Œ± _inst_1) (MulOneClass.toMul.{u1} (Filter.{u1} Œ±) (Filter.mulOneClass.{u1} Œ± _inst_1)) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1) (MonoidHom.monoidHomClass.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)))) (Filter.pureMonoidHom.{u1} Œ± _inst_1)) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ±)
Case conversion may be inaccurate. Consider using '#align filter.coe_pure_monoid_hom Filter.coe_pureMonoidHom‚Çì'. -/
@[simp, to_additive]
theorem coe_pureMonoidHom : (pureMonoidHom : Œ± ‚Üí Filter Œ±) = pure :=
  rfl
#align filter.coe_pure_monoid_hom Filter.coe_pureMonoidHom
#align filter.coe_pure_add_monoid_hom Filter.coe_pureAddMonoidHom

/- warning: filter.pure_monoid_hom_apply -> Filter.pureMonoidHom_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MulOneClass.{u1} Œ±] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) (fun (_x : MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) => Œ± -> (Filter.{u1} Œ±)) (MonoidHom.hasCoeToFun.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) (Filter.pureMonoidHom.{u1} Œ± _inst_1) a) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Œ± a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MulOneClass.{u1} Œ±] (a : Œ±), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Filter.{u1} Œ±) a) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Filter.{u1} Œ±) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) Œ± (Filter.{u1} Œ±) (MulOneClass.toMul.{u1} Œ± _inst_1) (MulOneClass.toMul.{u1} (Filter.{u1} Œ±) (Filter.mulOneClass.{u1} Œ± _inst_1)) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)) Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1) (MonoidHom.monoidHomClass.{u1, u1} Œ± (Filter.{u1} Œ±) _inst_1 (Filter.mulOneClass.{u1} Œ± _inst_1)))) (Filter.pureMonoidHom.{u1} Œ± _inst_1) a) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ± a)
Case conversion may be inaccurate. Consider using '#align filter.pure_monoid_hom_apply Filter.pureMonoidHom_apply‚Çì'. -/
@[simp, to_additive]
theorem pureMonoidHom_apply (a : Œ±) : pureMonoidHom a = pure a :=
  rfl
#align filter.pure_monoid_hom_apply Filter.pureMonoidHom_apply
#align filter.pure_add_monoid_hom_apply Filter.pureAddMonoidHom_apply

end MulOneClass

section Monoid

variable [Monoid Œ±] {f g : Filter Œ±} {s : Set Œ±} {a : Œ±} {m n : ‚Ñï}

#print Filter.monoid /-
/-- `filter Œ±` is a `monoid` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_monoid` under pointwise operations if `Œ±` is."]
protected def monoid : Monoid (Filter Œ±) :=
  { Filter.mulOneClass, Filter.semigroup, Filter.instNPow with }
#align filter.monoid Filter.monoid
#align filter.add_monoid Filter.addMonoid
-/

scoped[Pointwise] attribute [instance] Filter.monoid Filter.addMonoid

/- warning: filter.pow_mem_pow -> Filter.pow_mem_pow is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {f : Filter.{u1} Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (forall (n : Nat), Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (HPow.hPow.{u1, 0, u1} (Set.{u1} Œ±) Nat (Set.{u1} Œ±) (instHPow.{u1, 0} (Set.{u1} Œ±) Nat (Set.NPow.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)) (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) s n) (HPow.hPow.{u1, 0, u1} (Filter.{u1} Œ±) Nat (Filter.{u1} Œ±) (instHPow.{u1, 0} (Filter.{u1} Œ±) Nat (Filter.instNPow.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)) (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) f n))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {f : Filter.{u1} Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s f) -> (forall (n : Nat), Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (HPow.hPow.{u1, 0, u1} (Set.{u1} Œ±) Nat (Set.{u1} Œ±) (instHPow.{u1, 0} (Set.{u1} Œ±) Nat (Set.NPow.{u1} Œ± (Monoid.toOne.{u1} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) s n) (HPow.hPow.{u1, 0, u1} (Filter.{u1} Œ±) Nat (Filter.{u1} Œ±) (instHPow.{u1, 0} (Filter.{u1} Œ±) Nat (Filter.instNPow.{u1} Œ± (Monoid.toOne.{u1} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) f n))
Case conversion may be inaccurate. Consider using '#align filter.pow_mem_pow Filter.pow_mem_pow‚Çì'. -/
@[to_additive]
theorem pow_mem_pow (hs : s ‚àà f) : ‚àÄ n : ‚Ñï, s ^ n ‚àà f ^ n
  | 0 => by
    rw [pow_zero]
    exact one_mem_one
  | n + 1 => by
    rw [pow_succ]
    exact mul_mem_mul hs (pow_mem_pow _)
#align filter.pow_mem_pow Filter.pow_mem_pow
#align filter.nsmul_mem_nsmul Filter.nsmul_mem_nsmul

/- warning: filter.bot_pow -> Filter.bot_pow is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HPow.hPow.{u1, 0, u1} (Filter.{u1} Œ±) Nat (Filter.{u1} Œ±) (instHPow.{u1, 0} (Filter.{u1} Œ±) Nat (Filter.instNPow.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)) (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) n) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HPow.hPow.{u1, 0, u1} (Filter.{u1} Œ±) Nat (Filter.{u1} Œ±) (instHPow.{u1, 0} (Filter.{u1} Œ±) Nat (Filter.instNPow.{u1} Œ± (Monoid.toOne.{u1} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) n) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))))
Case conversion may be inaccurate. Consider using '#align filter.bot_pow Filter.bot_pow‚Çì'. -/
@[simp, to_additive nsmul_bot]
theorem bot_pow {n : ‚Ñï} (hn : n ‚â† 0) : (‚ä• : Filter Œ±) ^ n = ‚ä• := by
  rw [‚Üê tsub_add_cancel_of_le (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero hn), pow_succ, bot_mul]
#align filter.bot_pow Filter.bot_pow
#align filter.nsmul_bot Filter.nsmul_bot

/- warning: filter.mul_top_of_one_le -> Filter.mul_top_of_one_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {f : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))))) f) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) f (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {f : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (Monoid.toOne.{u1} Œ± _inst_1)))) f) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) f (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.mul_top_of_one_le Filter.mul_top_of_one_le‚Çì'. -/
@[to_additive]
theorem mul_top_of_one_le (hf : 1 ‚â§ f) : f * ‚ä§ = ‚ä§ :=
  by
  refine' top_le_iff.1 fun s => _
  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]
  rintro ‚ü®t, ht, hs‚ü©
  rwa [mul_univ_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs
#align filter.mul_top_of_one_le Filter.mul_top_of_one_le
#align filter.add_top_of_nonneg Filter.add_top_of_nonneg

/- warning: filter.top_mul_of_one_le -> Filter.top_mul_of_one_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {f : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))))) f) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±)) f) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {f : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (Monoid.toOne.{u1} Œ± _inst_1)))) f) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±)) f) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.top_mul_of_one_le Filter.top_mul_of_one_le‚Çì'. -/
@[to_additive]
theorem top_mul_of_one_le (hf : 1 ‚â§ f) : ‚ä§ * f = ‚ä§ :=
  by
  refine' top_le_iff.1 fun s => _
  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]
  rintro ‚ü®t, ht, hs‚ü©
  rwa [univ_mul_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs
#align filter.top_mul_of_one_le Filter.top_mul_of_one_le
#align filter.top_add_of_nonneg Filter.top_add_of_nonneg

/- warning: filter.top_mul_top -> Filter.top_mul_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±], Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±)) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±], Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±)) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±))
Case conversion may be inaccurate. Consider using '#align filter.top_mul_top Filter.top_mul_top‚Çì'. -/
@[simp, to_additive]
theorem top_mul_top : (‚ä§ : Filter Œ±) * ‚ä§ = ‚ä§ :=
  mul_top_of_one_le le_top
#align filter.top_mul_top Filter.top_mul_top
#align filter.top_add_top Filter.top_add_top

/- warning: filter.nsmul_top -> Filter.nsmul_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_2 : AddMonoid.{u1} Œ±] {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (SMul.smul.{0, u1} Nat (Filter.{u1} Œ±) (Filter.instNSMul.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± _inst_2)) (AddZeroClass.toHasAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± _inst_2))) n (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_2 : AddMonoid.{u1} Œ±] {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HSMul.hSMul.{0, u1, u1} Nat (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHSMul.{0, u1} Nat (Filter.{u1} Œ±) (Filter.instNSMul.{u1} Œ± (AddMonoid.toZero.{u1} Œ± _inst_2) (AddZeroClass.toAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± _inst_2)))) n (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.nsmul_top Filter.nsmul_top‚Çì'. -/
--TODO: `to_additive` trips up on the `1 : ‚Ñï` used in the pattern-matching.
theorem nsmul_top {Œ± : Type _} [AddMonoid Œ±] : ‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí n ‚Ä¢ (‚ä§ : Filter Œ±) = ‚ä§
  | 0 => fun h => (h rfl).elim
  | 1 => fun _ => one_nsmul _
  | n + 2 => fun _ => by rw [succ_nsmul, nsmul_top n.succ_ne_zero, top_add_top]
#align filter.nsmul_top Filter.nsmul_top

/- warning: filter.top_pow -> Filter.top_pow is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HPow.hPow.{u1, 0, u1} (Filter.{u1} Œ±) Nat (Filter.{u1} Œ±) (instHPow.{u1, 0} (Filter.{u1} Œ±) Nat (Filter.instNPow.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)) (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±)) n) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.hasTop.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Monoid.{u1} Œ±] {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (HPow.hPow.{u1, 0, u1} (Filter.{u1} Œ±) Nat (Filter.{u1} Œ±) (instHPow.{u1, 0} (Filter.{u1} Œ±) Nat (Filter.instNPow.{u1} Œ± (Monoid.toOne.{u1} Œ± _inst_1) (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± _inst_1)))) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±)) n) (Top.top.{u1} (Filter.{u1} Œ±) (Filter.instTopFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.top_pow Filter.top_pow‚Çì'. -/
@[to_additive nsmul_top]
theorem top_pow : ‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí (‚ä§ : Filter Œ±) ^ n = ‚ä§
  | 0 => fun h => (h rfl).elim
  | 1 => fun _ => pow_one _
  | n + 2 => fun _ => by rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]
#align filter.top_pow Filter.top_pow
#align filter.nsmul_top Filter.nsmul_top

#print IsUnit.filter /-
@[to_additive]
protected theorem IsUnit.filter : IsUnit a ‚Üí IsUnit (pure a : Filter Œ±) :=
  IsUnit.map (pureMonoidHom : Œ± ‚Üí* Filter Œ±)
#align is_unit.filter IsUnit.filter
#align is_add_unit.filter IsAddUnit.filter
-/

end Monoid

#print Filter.commMonoid /-
/-- `filter Œ±` is a `comm_monoid` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_comm_monoid` under pointwise operations if `Œ±` is."]
protected def commMonoid [CommMonoid Œ±] : CommMonoid (Filter Œ±) :=
  { Filter.mulOneClass, Filter.commSemigroup with }
#align filter.comm_monoid Filter.commMonoid
#align filter.add_comm_monoid Filter.addCommMonoid
-/

open Pointwise

section DivisionMonoid

variable [DivisionMonoid Œ±] {f g : Filter Œ±}

/- warning: filter.mul_eq_one_iff -> Filter.mul_eq_one_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (DivisionMonoid.toDivInvMonoid.{u1} Œ± _inst_1)))))) f g) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (DivisionMonoid.toDivInvMonoid.{u1} Œ± _inst_1))))))))) (Exists.{succ u1} Œ± (fun (a : Œ±) => Exists.{succ u1} Œ± (fun (b : Œ±) => And (Eq.{succ u1} (Filter.{u1} Œ±) f (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Œ± a)) (And (Eq.{succ u1} (Filter.{u1} Œ±) g (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Œ± b)) (Eq.{succ u1} Œ± (HMul.hMul.{u1, u1, u1} Œ± Œ± Œ± (instHMul.{u1} Œ± (MulOneClass.toHasMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (DivisionMonoid.toDivInvMonoid.{u1} Œ± _inst_1))))) a b) (OfNat.ofNat.{u1} Œ± 1 (OfNat.mk.{u1} Œ± 1 (One.one.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (DivisionMonoid.toDivInvMonoid.{u1} Œ± _inst_1))))))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (DivisionMonoid.toDivInvMonoid.{u1} Œ± _inst_1)))))) f g) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (InvOneClass.toOne.{u1} Œ± (DivInvOneMonoid.toInvOneClass.{u1} Œ± (DivisionMonoid.toDivInvOneMonoid.{u1} Œ± _inst_1))))))) (Exists.{succ u1} Œ± (fun (a : Œ±) => Exists.{succ u1} Œ± (fun (b : Œ±) => And (Eq.{succ u1} (Filter.{u1} Œ±) f (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ± a)) (And (Eq.{succ u1} (Filter.{u1} Œ±) g (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ± b)) (Eq.{succ u1} Œ± (HMul.hMul.{u1, u1, u1} Œ± Œ± Œ± (instHMul.{u1} Œ± (MulOneClass.toMul.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (DivisionMonoid.toDivInvMonoid.{u1} Œ± _inst_1))))) a b) (OfNat.ofNat.{u1} Œ± 1 (One.toOfNat1.{u1} Œ± (InvOneClass.toOne.{u1} Œ± (DivInvOneMonoid.toInvOneClass.{u1} Œ± (DivisionMonoid.toDivInvOneMonoid.{u1} Œ± _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align filter.mul_eq_one_iff Filter.mul_eq_one_iff‚Çì'. -/
@[to_additive]
protected theorem mul_eq_one_iff : f * g = 1 ‚Üî ‚àÉ a b, f = pure a ‚àß g = pure b ‚àß a * b = 1 :=
  by
  refine' ‚ü®fun hfg => _, _‚ü©
  ¬∑ obtain ‚ü®t‚ÇÅ, t‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ü© : (1 : Set Œ±) ‚àà f * g := hfg.symm.subst one_mem_one
    have hfg : (f * g).ne_bot := hfg.symm.subst one_ne_bot
    rw [(hfg.nonempty_of_mem <| mul_mem_mul h‚ÇÅ h‚ÇÇ).subset_one_iff, Set.mul_eq_one_iff] at h
    obtain ‚ü®a, b, rfl, rfl, h‚ü© := h
    refine' ‚ü®a, b, _, _, h‚ü©
    ¬∑ rwa [‚Üê hfg.of_mul_left.le_pure_iff, le_pure_iff]
    ¬∑ rwa [‚Üê hfg.of_mul_right.le_pure_iff, le_pure_iff]
  ¬∑ rintro ‚ü®a, b, rfl, rfl, h‚ü©
    rw [pure_mul_pure, h, pure_one]
#align filter.mul_eq_one_iff Filter.mul_eq_one_iff
#align filter.add_eq_zero_iff Filter.add_eq_zero_iff

#print Filter.divisionMonoid /-
/-- `filter Œ±` is a division monoid under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is a subtraction monoid under pointwise\noperations if `Œ±` is."]
protected def divisionMonoid : DivisionMonoid (Filter Œ±) :=
  { Filter.monoid, Filter.instInvolutiveInv, Filter.instDiv,
    Filter.instZPow with
    mul_inv_rev := fun s t => map_map‚ÇÇ_antidistrib mul_inv_rev
    inv_eq_of_mul := fun s t h =>
      by
      obtain ‚ü®a, b, rfl, rfl, hab‚ü© := Filter.mul_eq_one_iff.1 h
      rw [inv_pure, inv_eq_of_mul_eq_one_right hab]
    div_eq_mul_inv := fun f g => map_map‚ÇÇ_distrib_right div_eq_mul_inv }
#align filter.division_monoid Filter.divisionMonoid
#align filter.subtraction_monoid Filter.subtractionMonoid
-/

#print Filter.isUnit_iff /-
@[to_additive]
theorem isUnit_iff : IsUnit f ‚Üî ‚àÉ a, f = pure a ‚àß IsUnit a :=
  by
  constructor
  ¬∑ rintro ‚ü®u, rfl‚ü©
    obtain ‚ü®a, b, ha, hb, h‚ü© := Filter.mul_eq_one_iff.1 u.mul_inv
    refine' ‚ü®a, ha, ‚ü®a, b, h, pure_injective _‚ü©, rfl‚ü©
    rw [‚Üê pure_mul_pure, ‚Üê ha, ‚Üê hb]
    exact u.inv_mul
  ¬∑ rintro ‚ü®a, rfl, ha‚ü©
    exact ha.filter
#align filter.is_unit_iff Filter.isUnit_iff
#align filter.is_add_unit_iff Filter.isAddUnit_iff
-/

end DivisionMonoid

#print Filter.divisionCommMonoid /-
/-- `filter Œ±` is a commutative division monoid under pointwise operations if `Œ±` is. -/
@[to_additive SubtractionCommMonoid
      "`filter Œ±` is a commutative subtraction monoid under\npointwise operations if `Œ±` is."]
protected def divisionCommMonoid [DivisionCommMonoid Œ±] : DivisionCommMonoid (Filter Œ±) :=
  { Filter.divisionMonoid, Filter.commSemigroup with }
#align filter.division_comm_monoid Filter.divisionCommMonoid
#align filter.subtraction_comm_monoid Filter.subtractionCommMonoid
-/

#print Filter.instDistribNeg /-
/-- `filter Œ±` has distributive negation if `Œ±` has. -/
protected def instDistribNeg [Mul Œ±] [HasDistribNeg Œ±] : HasDistribNeg (Filter Œ±) :=
  {
    Filter.instInvolutiveNeg with
    neg_mul := fun _ _ => map‚ÇÇ_map_left_comm neg_mul
    mul_neg := fun _ _ => map_map‚ÇÇ_right_comm mul_neg }
#align filter.has_distrib_neg Filter.instDistribNeg
-/

scoped[Pointwise]
  attribute [instance]
    Filter.commMonoid Filter.addCommMonoid Filter.divisionMonoid Filter.subtractionMonoid Filter.divisionCommMonoid Filter.subtractionCommMonoid Filter.instDistribNeg

section Distrib

variable [Distrib Œ±] {f g h : Filter Œ±}

/-!
Note that `filter Œ±` is not a `distrib` because `f * g + f * h` has cross terms that `f * (g + h)`
lacks.
-/


/- warning: filter.mul_add_subset -> Filter.mul_add_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Distrib.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toHasMul.{u1} Œ± _inst_1))) f (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toHasAdd.{u1} Œ± _inst_1))) g h)) (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toHasAdd.{u1} Œ± _inst_1))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toHasMul.{u1} Œ± _inst_1))) f g) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toHasMul.{u1} Œ± _inst_1))) f h))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Distrib.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toMul.{u1} Œ± _inst_1))) f (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toAdd.{u1} Œ± _inst_1))) g h)) (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toAdd.{u1} Œ± _inst_1))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toMul.{u1} Œ± _inst_1))) f g) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toMul.{u1} Œ± _inst_1))) f h))
Case conversion may be inaccurate. Consider using '#align filter.mul_add_subset Filter.mul_add_subset‚Çì'. -/
theorem mul_add_subset : f * (g + h) ‚â§ f * g + f * h :=
  map‚ÇÇ_distrib_le_left mul_add
#align filter.mul_add_subset Filter.mul_add_subset

/- warning: filter.add_mul_subset -> Filter.add_mul_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Distrib.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toHasMul.{u1} Œ± _inst_1))) (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toHasAdd.{u1} Œ± _inst_1))) f g) h) (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toHasAdd.{u1} Œ± _inst_1))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toHasMul.{u1} Œ± _inst_1))) f h) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toHasMul.{u1} Œ± _inst_1))) g h))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Distrib.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±} {h : Filter.{u1} Œ±}, LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toMul.{u1} Œ± _inst_1))) (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toAdd.{u1} Œ± _inst_1))) f g) h) (HAdd.hAdd.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHAdd.{u1} (Filter.{u1} Œ±) (Filter.instAdd.{u1} Œ± (Distrib.toAdd.{u1} Œ± _inst_1))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toMul.{u1} Œ± _inst_1))) f h) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (Distrib.toMul.{u1} Œ± _inst_1))) g h))
Case conversion may be inaccurate. Consider using '#align filter.add_mul_subset Filter.add_mul_subset‚Çì'. -/
theorem add_mul_subset : (f + g) * h ‚â§ f * h + g * h :=
  map‚ÇÇ_distrib_le_right add_mul
#align filter.add_mul_subset Filter.add_mul_subset

end Distrib

section MulZeroClass

variable [MulZeroClass Œ±] {f g : Filter Œ±}

/-! Note that `filter` is not a `mul_zero_class` because `0 * ‚ä• ‚â† 0`. -/


/- warning: filter.ne_bot.mul_zero_nonneg -> Filter.NeBot.mul_zero_nonneg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MulZeroClass.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± _inst_1))))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulZeroClass.toHasMul.{u1} Œ± _inst_1))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± _inst_1)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MulZeroClass.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toZero.{u1} Œ± _inst_1)))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulZeroClass.toMul.{u1} Œ± _inst_1))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toZero.{u1} Œ± _inst_1))))))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.mul_zero_nonneg Filter.NeBot.mul_zero_nonneg‚Çì'. -/
theorem NeBot.mul_zero_nonneg (hf : f.ne_bot) : 0 ‚â§ f * 0 :=
  le_mul_iff.2 fun t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ =>
    let ‚ü®a, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ
    ‚ü®_, _, ha, h‚ÇÇ, MulZeroClass.mul_zero _‚ü©
#align filter.ne_bot.mul_zero_nonneg Filter.NeBot.mul_zero_nonneg

/- warning: filter.ne_bot.zero_mul_nonneg -> Filter.NeBot.zero_mul_nonneg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MulZeroClass.{u1} Œ±] {g : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± g) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± _inst_1))))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulZeroClass.toHasMul.{u1} Œ± _inst_1))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± _inst_1))))) g))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MulZeroClass.{u1} Œ±] {g : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± g) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toZero.{u1} Œ± _inst_1)))) (HMul.hMul.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHMul.{u1} (Filter.{u1} Œ±) (Filter.instMul.{u1} Œ± (MulZeroClass.toMul.{u1} Œ± _inst_1))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toZero.{u1} Œ± _inst_1)))) g))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.zero_mul_nonneg Filter.NeBot.zero_mul_nonneg‚Çì'. -/
theorem NeBot.zero_mul_nonneg (hg : g.ne_bot) : 0 ‚â§ 0 * g :=
  le_mul_iff.2 fun t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ =>
    let ‚ü®b, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ
    ‚ü®_, _, h‚ÇÅ, hb, MulZeroClass.zero_mul _‚ü©
#align filter.ne_bot.zero_mul_nonneg Filter.NeBot.zero_mul_nonneg

end MulZeroClass

section Group

variable [Group Œ±] [DivisionMonoid Œ≤] [MonoidHomClass F Œ± Œ≤] (m : F) {f g f‚ÇÅ g‚ÇÅ : Filter Œ±}
  {f‚ÇÇ g‚ÇÇ : Filter Œ≤}

/-! Note that `filter Œ±` is not a group because `f / f ‚â† 1` in general -/


/- warning: filter.one_le_div_iff -> Filter.one_le_div_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Group.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toHasDiv.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))) f g)) (Not (Disjoint.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) f g))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Group.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (InvOneClass.toOne.{u1} Œ± (DivInvOneMonoid.toInvOneClass.{u1} Œ± (DivisionMonoid.toDivInvOneMonoid.{u1} Œ± (Group.toDivisionMonoid.{u1} Œ± _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toDiv.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))) f g)) (Not (Disjoint.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) f g))
Case conversion may be inaccurate. Consider using '#align filter.one_le_div_iff Filter.one_le_div_iff‚Çì'. -/
@[simp, to_additive]
protected theorem one_le_div_iff : 1 ‚â§ f / g ‚Üî ¬¨Disjoint f g :=
  by
  refine' ‚ü®fun h hfg => _, _‚ü©
  ¬∑ obtain ‚ü®s, hs, t, ht, hst‚ü© := hfg.le_bot (mem_bot : ‚àÖ ‚àà ‚ä•)
    exact Set.one_mem_div_iff.1 (h <| div_mem_div hs ht) (disjoint_iff.2 hst.symm)
  ¬∑ rintro h s ‚ü®t‚ÇÅ, t‚ÇÇ, h‚ÇÅ, h‚ÇÇ, hs‚ü©
    exact hs (Set.one_mem_div_iff.2 fun ht => h <| disjoint_of_disjoint_of_mem ht h‚ÇÅ h‚ÇÇ)
#align filter.one_le_div_iff Filter.one_le_div_iff
#align filter.nonneg_sub_iff Filter.nonneg_sub_iff

/- warning: filter.not_one_le_div_iff -> Filter.not_one_le_div_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Group.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Not (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toHasDiv.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))) f g))) (Disjoint.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) f g)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Group.{u1} Œ±] {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, Iff (Not (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (InvOneClass.toOne.{u1} Œ± (DivInvOneMonoid.toInvOneClass.{u1} Œ± (DivisionMonoid.toDivInvOneMonoid.{u1} Œ± (Group.toDivisionMonoid.{u1} Œ± _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toDiv.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))) f g))) (Disjoint.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) f g)
Case conversion may be inaccurate. Consider using '#align filter.not_one_le_div_iff Filter.not_one_le_div_iff‚Çì'. -/
@[to_additive]
theorem not_one_le_div_iff : ¬¨1 ‚â§ f / g ‚Üî Disjoint f g :=
  Filter.one_le_div_iff.not_left
#align filter.not_one_le_div_iff Filter.not_one_le_div_iff
#align filter.not_nonneg_sub_iff Filter.not_nonneg_sub_iff

/- warning: filter.ne_bot.one_le_div -> Filter.NeBot.one_le_div is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Group.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (OfNat.mk.{u1} (Filter.{u1} Œ±) 1 (One.one.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (MulOneClass.toHasOne.{u1} Œ± (Monoid.toMulOneClass.{u1} Œ± (DivInvMonoid.toMonoid.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toHasDiv.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))) f f))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Group.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 1 (One.toOfNat1.{u1} (Filter.{u1} Œ±) (Filter.instOne.{u1} Œ± (InvOneClass.toOne.{u1} Œ± (DivInvOneMonoid.toInvOneClass.{u1} Œ± (DivisionMonoid.toDivInvOneMonoid.{u1} Œ± (Group.toDivisionMonoid.{u1} Œ± _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toDiv.{u1} Œ± (Group.toDivInvMonoid.{u1} Œ± _inst_1)))) f f))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.one_le_div Filter.NeBot.one_le_div‚Çì'. -/
@[to_additive]
theorem NeBot.one_le_div (h : f.ne_bot) : 1 ‚â§ f / f :=
  by
  rintro s ‚ü®t‚ÇÅ, t‚ÇÇ, h‚ÇÅ, h‚ÇÇ, hs‚ü©
  obtain ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := Set.not_disjoint_iff.1 (h.not_disjoint h‚ÇÅ h‚ÇÇ)
  rw [mem_one, ‚Üê div_self' a]
  exact hs (Set.div_mem_div ha‚ÇÅ ha‚ÇÇ)
#align filter.ne_bot.one_le_div Filter.NeBot.one_le_div
#align filter.ne_bot.nonneg_sub Filter.NeBot.nonneg_sub

#print Filter.isUnit_pure /-
@[to_additive]
theorem isUnit_pure (a : Œ±) : IsUnit (pure a : Filter Œ±) :=
  (Group.isUnit a).filter‚Çì
#align filter.is_unit_pure Filter.isUnit_pure
#align filter.is_add_unit_pure Filter.isAddUnit_pure
-/

#print Filter.isUnit_iff_singleton /-
@[simp]
theorem isUnit_iff_singleton : IsUnit f ‚Üî ‚àÉ a, f = pure a := by
  simp only [is_unit_iff, Group.isUnit, and_true_iff]
#align filter.is_unit_iff_singleton Filter.isUnit_iff_singleton
-/

include Œ≤

/- warning: filter.map_inv' -> Filter.map_inv' is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : Group.{u2} Œ±] [_inst_2 : DivisionMonoid.{u3} Œ≤] [_inst_3 : MonoidHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))] (m : F) {f : Filter.{u2} Œ±}, Eq.{succ u3} (Filter.{u3} Œ≤) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) (Inv.inv.{u2} (Filter.{u2} Œ±) (Filter.hasInv.{u2} Œ± (DivInvMonoid.toHasInv.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) f)) (Inv.inv.{u3} (Filter.{u3} Œ≤) (Filter.hasInv.{u3} Œ≤ (DivInvMonoid.toHasInv.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) f))
but is expected to have type
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : Group.{u2} Œ±] [_inst_2 : DivisionMonoid.{u3} Œ≤] [_inst_3 : MonoidHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))] (m : F) {f : Filter.{u2} Œ±}, Eq.{succ u3} (Filter.{u3} Œ≤) (Filter.map.{u2, u3} Œ± Œ≤ (FunLike.coe.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3)) m) (Inv.inv.{u2} (Filter.{u2} Œ±) (Filter.instInv.{u2} Œ± (InvOneClass.toInv.{u2} Œ± (DivInvOneMonoid.toInvOneClass.{u2} Œ± (DivisionMonoid.toDivInvOneMonoid.{u2} Œ± (Group.toDivisionMonoid.{u2} Œ± _inst_1))))) f)) (Inv.inv.{u3} (Filter.{u3} Œ≤) (Filter.instInv.{u3} Œ≤ (InvOneClass.toInv.{u3} Œ≤ (DivInvOneMonoid.toInvOneClass.{u3} Œ≤ (DivisionMonoid.toDivInvOneMonoid.{u3} Œ≤ _inst_2)))) (Filter.map.{u2, u3} Œ± Œ≤ (FunLike.coe.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3)) m) f))
Case conversion may be inaccurate. Consider using '#align filter.map_inv' Filter.map_inv'‚Çì'. -/
@[to_additive]
theorem map_inv' : f‚Åª¬π.map m = (f.map m)‚Åª¬π :=
  Semiconj.filter_map (map_inv m) f
#align filter.map_inv' Filter.map_inv'
#align filter.map_neg' Filter.map_neg'

/- warning: filter.tendsto.inv_inv -> Filter.Tendsto.inv_inv is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : Group.{u2} Œ±] [_inst_2 : DivisionMonoid.{u3} Œ≤] [_inst_3 : MonoidHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))] (m : F) {f‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u3} Œ≤}, (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) f‚ÇÅ f‚ÇÇ) -> (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) (Inv.inv.{u2} (Filter.{u2} Œ±) (Filter.hasInv.{u2} Œ± (DivInvMonoid.toHasInv.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) f‚ÇÅ) (Inv.inv.{u3} (Filter.{u3} Œ≤) (Filter.hasInv.{u3} Œ≤ (DivInvMonoid.toHasInv.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) f‚ÇÇ))
but is expected to have type
  forall {F : Type.{u1}} {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} [_inst_1 : Group.{u3} Œ±] [_inst_2 : DivisionMonoid.{u2} Œ≤] [_inst_3 : MonoidHomClass.{u1, u3, u2} F Œ± Œ≤ (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1))) (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))] (m : F) {f‚ÇÅ : Filter.{u3} Œ±} {f‚ÇÇ : Filter.{u2} Œ≤}, (Filter.Tendsto.{u3, u2} Œ± Œ≤ (FunLike.coe.{succ u1, succ u3, succ u2} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u3, u2} F Œ± Œ≤ (MulOneClass.toMul.{u3} Œ± (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1)))) (MulOneClass.toMul.{u2} Œ≤ (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u3, u2} F Œ± Œ≤ (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1))) (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2))) _inst_3)) m) f‚ÇÅ f‚ÇÇ) -> (Filter.Tendsto.{u3, u2} Œ± Œ≤ (FunLike.coe.{succ u1, succ u3, succ u2} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u3, u2} F Œ± Œ≤ (MulOneClass.toMul.{u3} Œ± (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1)))) (MulOneClass.toMul.{u2} Œ≤ (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u3, u2} F Œ± Œ≤ (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1))) (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2))) _inst_3)) m) (Inv.inv.{u3} (Filter.{u3} Œ±) (Filter.instInv.{u3} Œ± (InvOneClass.toInv.{u3} Œ± (DivInvOneMonoid.toInvOneClass.{u3} Œ± (DivisionMonoid.toDivInvOneMonoid.{u3} Œ± (Group.toDivisionMonoid.{u3} Œ± _inst_1))))) f‚ÇÅ) (Inv.inv.{u2} (Filter.{u2} Œ≤) (Filter.instInv.{u2} Œ≤ (InvOneClass.toInv.{u2} Œ≤ (DivInvOneMonoid.toInvOneClass.{u2} Œ≤ (DivisionMonoid.toDivInvOneMonoid.{u2} Œ≤ _inst_2)))) f‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.inv_inv Filter.Tendsto.inv_inv‚Çì'. -/
@[to_additive]
theorem Tendsto.inv_inv : Tendsto m f‚ÇÅ f‚ÇÇ ‚Üí Tendsto m f‚ÇÅ‚Åª¬π f‚ÇÇ‚Åª¬π := fun hf =>
  (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf
#align filter.tendsto.inv_inv Filter.Tendsto.inv_inv
#align filter.tendsto.neg_neg Filter.Tendsto.neg_neg

/- warning: filter.map_div -> Filter.map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : Group.{u2} Œ±] [_inst_2 : DivisionMonoid.{u3} Œ≤] [_inst_3 : MonoidHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))] (m : F) {f : Filter.{u2} Œ±} {g : Filter.{u2} Œ±}, Eq.{succ u3} (Filter.{u3} Œ≤) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) (HDiv.hDiv.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHDiv.{u2} (Filter.{u2} Œ±) (Filter.instDiv.{u2} Œ± (DivInvMonoid.toHasDiv.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) f g)) (HDiv.hDiv.{u3, u3, u3} (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (instHDiv.{u3} (Filter.{u3} Œ≤) (Filter.instDiv.{u3} Œ≤ (DivInvMonoid.toHasDiv.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) f) (Filter.map.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) g))
but is expected to have type
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : Group.{u2} Œ±] [_inst_2 : DivisionMonoid.{u3} Œ≤] [_inst_3 : MonoidHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))] (m : F) {f : Filter.{u2} Œ±} {g : Filter.{u2} Œ±}, Eq.{succ u3} (Filter.{u3} Œ≤) (Filter.map.{u2, u3} Œ± Œ≤ (FunLike.coe.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3)) m) (HDiv.hDiv.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHDiv.{u2} (Filter.{u2} Œ±) (Filter.instDiv.{u2} Œ± (DivInvMonoid.toDiv.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) f g)) (HDiv.hDiv.{u3, u3, u3} (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (instHDiv.{u3} (Filter.{u3} Œ≤) (Filter.instDiv.{u3} Œ≤ (DivInvMonoid.toDiv.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (Filter.map.{u2, u3} Œ± Œ≤ (FunLike.coe.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3)) m) f) (Filter.map.{u2, u3} Œ± Œ≤ (FunLike.coe.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3)) m) g))
Case conversion may be inaccurate. Consider using '#align filter.map_div Filter.map_div‚Çì'. -/
@[to_additive]
protected theorem map_div : (f / g).map m = f.map m / g.map m :=
  map_map‚ÇÇ_distrib <| map_div m
#align filter.map_div Filter.map_div
#align filter.map_sub Filter.map_sub

/- warning: filter.tendsto.div_div -> Filter.Tendsto.div_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : Group.{u2} Œ±] [_inst_2 : DivisionMonoid.{u3} Œ≤] [_inst_3 : MonoidHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))] (m : F) {f‚ÇÅ : Filter.{u2} Œ±} {g‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u3} Œ≤} {g‚ÇÇ : Filter.{u3} Œ≤}, (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) f‚ÇÅ f‚ÇÇ) -> (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) g‚ÇÅ g‚ÇÇ) -> (Filter.Tendsto.{u2, u3} Œ± Œ≤ (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => Œ± -> Œ≤) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F Œ± (fun (_x : Œ±) => Œ≤) (MulHomClass.toFunLike.{u1, u2, u3} F Œ± Œ≤ (MulOneClass.toHasMul.{u2} Œ± (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) (MulOneClass.toHasMul.{u3} Œ≤ (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F Œ± Œ≤ (Monoid.toMulOneClass.{u2} Œ± (DivInvMonoid.toMonoid.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1))) (Monoid.toMulOneClass.{u3} Œ≤ (DivInvMonoid.toMonoid.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2))) _inst_3))) m) (HDiv.hDiv.{u2, u2, u2} (Filter.{u2} Œ±) (Filter.{u2} Œ±) (Filter.{u2} Œ±) (instHDiv.{u2} (Filter.{u2} Œ±) (Filter.instDiv.{u2} Œ± (DivInvMonoid.toHasDiv.{u2} Œ± (Group.toDivInvMonoid.{u2} Œ± _inst_1)))) f‚ÇÅ g‚ÇÅ) (HDiv.hDiv.{u3, u3, u3} (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (Filter.{u3} Œ≤) (instHDiv.{u3} (Filter.{u3} Œ≤) (Filter.instDiv.{u3} Œ≤ (DivInvMonoid.toHasDiv.{u3} Œ≤ (DivisionMonoid.toDivInvMonoid.{u3} Œ≤ _inst_2)))) f‚ÇÇ g‚ÇÇ))
but is expected to have type
  forall {F : Type.{u1}} {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} [_inst_1 : Group.{u3} Œ±] [_inst_2 : DivisionMonoid.{u2} Œ≤] [_inst_3 : MonoidHomClass.{u1, u3, u2} F Œ± Œ≤ (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1))) (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))] (m : F) {f‚ÇÅ : Filter.{u3} Œ±} {g‚ÇÅ : Filter.{u3} Œ±} {f‚ÇÇ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (Filter.Tendsto.{u3, u2} Œ± Œ≤ (FunLike.coe.{succ u1, succ u3, succ u2} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u3, u2} F Œ± Œ≤ (MulOneClass.toMul.{u3} Œ± (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1)))) (MulOneClass.toMul.{u2} Œ≤ (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u3, u2} F Œ± Œ≤ (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1))) (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2))) _inst_3)) m) f‚ÇÅ f‚ÇÇ) -> (Filter.Tendsto.{u3, u2} Œ± Œ≤ (FunLike.coe.{succ u1, succ u3, succ u2} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u3, u2} F Œ± Œ≤ (MulOneClass.toMul.{u3} Œ± (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1)))) (MulOneClass.toMul.{u2} Œ≤ (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u3, u2} F Œ± Œ≤ (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1))) (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2))) _inst_3)) m) g‚ÇÅ g‚ÇÇ) -> (Filter.Tendsto.{u3, u2} Œ± Œ≤ (FunLike.coe.{succ u1, succ u3, succ u2} F Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Œ±) => Œ≤) _x) (MulHomClass.toFunLike.{u1, u3, u2} F Œ± Œ≤ (MulOneClass.toMul.{u3} Œ± (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1)))) (MulOneClass.toMul.{u2} Œ≤ (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u3, u2} F Œ± Œ≤ (Monoid.toMulOneClass.{u3} Œ± (DivInvMonoid.toMonoid.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1))) (Monoid.toMulOneClass.{u2} Œ≤ (DivInvMonoid.toMonoid.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2))) _inst_3)) m) (HDiv.hDiv.{u3, u3, u3} (Filter.{u3} Œ±) (Filter.{u3} Œ±) (Filter.{u3} Œ±) (instHDiv.{u3} (Filter.{u3} Œ±) (Filter.instDiv.{u3} Œ± (DivInvMonoid.toDiv.{u3} Œ± (Group.toDivInvMonoid.{u3} Œ± _inst_1)))) f‚ÇÅ g‚ÇÅ) (HDiv.hDiv.{u2, u2, u2} (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHDiv.{u2} (Filter.{u2} Œ≤) (Filter.instDiv.{u2} Œ≤ (DivInvMonoid.toDiv.{u2} Œ≤ (DivisionMonoid.toDivInvMonoid.{u2} Œ≤ _inst_2)))) f‚ÇÇ g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.div_div Filter.Tendsto.div_div‚Çì'. -/
@[to_additive]
theorem Tendsto.div_div : Tendsto m f‚ÇÅ f‚ÇÇ ‚Üí Tendsto m g‚ÇÅ g‚ÇÇ ‚Üí Tendsto m (f‚ÇÅ / g‚ÇÅ) (f‚ÇÇ / g‚ÇÇ) :=
  fun hf hg => (Filter.map_div m).trans_le <| Filter.div_le_div hf hg
#align filter.tendsto.div_div Filter.Tendsto.div_div
#align filter.tendsto.sub_sub Filter.Tendsto.sub_sub

end Group

open Pointwise

section GroupWithZero

variable [GroupWithZero Œ±] {f g : Filter Œ±}

/- warning: filter.ne_bot.div_zero_nonneg -> Filter.NeBot.div_zero_nonneg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : GroupWithZero.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± (MulZeroOneClass.toMulZeroClass.{u1} Œ± (MonoidWithZero.toMulZeroOneClass.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toHasDiv.{u1} Œ± (GroupWithZero.toDivInvMonoid.{u1} Œ± _inst_1)))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± (MulZeroOneClass.toMulZeroClass.{u1} Œ± (MonoidWithZero.toMulZeroOneClass.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1))))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : GroupWithZero.{u1} Œ±] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MonoidWithZero.toZero.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (GroupWithZero.toDiv.{u1} Œ± _inst_1))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MonoidWithZero.toZero.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.div_zero_nonneg Filter.NeBot.div_zero_nonneg‚Çì'. -/
theorem NeBot.div_zero_nonneg (hf : f.ne_bot) : 0 ‚â§ f / 0 :=
  Filter.le_div_iff.2 fun t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ =>
    let ‚ü®a, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ
    ‚ü®_, _, ha, h‚ÇÇ, div_zero _‚ü©
#align filter.ne_bot.div_zero_nonneg Filter.NeBot.div_zero_nonneg

/- warning: filter.ne_bot.zero_div_nonneg -> Filter.NeBot.zero_div_nonneg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : GroupWithZero.{u1} Œ±] {g : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± g) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± (MulZeroOneClass.toMulZeroClass.{u1} Œ± (MonoidWithZero.toMulZeroOneClass.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (DivInvMonoid.toHasDiv.{u1} Œ± (GroupWithZero.toDivInvMonoid.{u1} Œ± _inst_1)))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MulZeroClass.toHasZero.{u1} Œ± (MulZeroOneClass.toMulZeroClass.{u1} Œ± (MonoidWithZero.toMulZeroOneClass.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1)))))))) g))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : GroupWithZero.{u1} Œ±] {g : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± g) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MonoidWithZero.toZero.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1))))) (HDiv.hDiv.{u1, u1, u1} (Filter.{u1} Œ±) (Filter.{u1} Œ±) (Filter.{u1} Œ±) (instHDiv.{u1} (Filter.{u1} Œ±) (Filter.instDiv.{u1} Œ± (GroupWithZero.toDiv.{u1} Œ± _inst_1))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± (MonoidWithZero.toZero.{u1} Œ± (GroupWithZero.toMonoidWithZero.{u1} Œ± _inst_1))))) g))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.zero_div_nonneg Filter.NeBot.zero_div_nonneg‚Çì'. -/
theorem NeBot.zero_div_nonneg (hg : g.ne_bot) : 0 ‚â§ 0 / g :=
  Filter.le_div_iff.2 fun t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ =>
    let ‚ü®b, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ
    ‚ü®_, _, h‚ÇÅ, hb, zero_div _‚ü©
#align filter.ne_bot.zero_div_nonneg Filter.NeBot.zero_div_nonneg

end GroupWithZero

/-! ### Scalar addition/multiplication of filters -/


section Smul

variable [SMul Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : Filter Œ±} {g g‚ÇÅ g‚ÇÇ h : Filter Œ≤} {s : Set Œ±} {t : Set Œ≤} {a : Œ±}
  {b : Œ≤}

#print Filter.instSMul /-
/-- The filter `f ‚Ä¢ g` is generated by `{s ‚Ä¢ t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive Filter.instVAdd
      "The filter `f +·µ• g` is generated by `{s +·µ• t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def instSMul : SMul (Filter Œ±) (Filter Œ≤) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (‚Ä¢) f g`, but the hypothesis unfolds to `t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ s` rather than all the
  way to `set.image2 (‚Ä¢) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ ‚Ä¢ ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ s } }‚ü©
#align filter.has_smul Filter.instSMul
#align filter.has_vadd Filter.instVAdd
-/

scoped[Pointwise] attribute [instance] Filter.instSMul Filter.instVAdd

#print Filter.map‚ÇÇ_smul /-
@[simp, to_additive]
theorem map‚ÇÇ_smul : map‚ÇÇ (¬∑ ‚Ä¢ ¬∑) f g = f ‚Ä¢ g :=
  rfl
#align filter.map‚ÇÇ_smul Filter.map‚ÇÇ_smul
#align filter.map‚ÇÇ_vadd Filter.map‚ÇÇ_vadd
-/

#print Filter.mem_smul /-
@[to_additive]
theorem mem_smul : t ‚àà f ‚Ä¢ g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t :=
  Iff.rfl
#align filter.mem_smul Filter.mem_smul
#align filter.mem_vadd Filter.mem_vadd
-/

/- warning: filter.smul_mem_smul -> Filter.smul_mem_smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g : Filter.{u2} Œ≤} {s : Set.{u1} Œ±} {t : Set.{u2} Œ≤}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t g) -> (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (SMul.smul.{u1, u2} (Set.{u1} Œ±) (Set.{u2} Œ≤) (Set.smul.{u1, u2} Œ± Œ≤ _inst_1) s t) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f g))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : SMul.{u2, u1} Œ± Œ≤] {f : Filter.{u2} Œ±} {g : Filter.{u1} Œ≤} {s : Set.{u2} Œ±} {t : Set.{u1} Œ≤}, (Membership.mem.{u2, u2} (Set.{u2} Œ±) (Filter.{u2} Œ±) (instMembershipSetFilter.{u2} Œ±) s f) -> (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) t g) -> (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) (HSMul.hSMul.{u2, u1, u1} (Set.{u2} Œ±) (Set.{u1} Œ≤) (Set.{u1} Œ≤) (instHSMul.{u2, u1} (Set.{u2} Œ±) (Set.{u1} Œ≤) (Set.smul.{u2, u1} Œ± Œ≤ _inst_1)) s t) (HSMul.hSMul.{u2, u1, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHSMul.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instSMul.{u2, u1} Œ± Œ≤ _inst_1)) f g))
Case conversion may be inaccurate. Consider using '#align filter.smul_mem_smul Filter.smul_mem_smul‚Çì'. -/
@[to_additive]
theorem smul_mem_smul : s ‚àà f ‚Üí t ‚àà g ‚Üí s ‚Ä¢ t ‚àà f ‚Ä¢ g :=
  image2_mem_map‚ÇÇ
#align filter.smul_mem_smul Filter.smul_mem_smul
#align filter.vadd_mem_vadd Filter.vadd_mem_vadd

/- warning: filter.bot_smul -> Filter.bot_smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {g : Filter.{u2} Œ≤}, Eq.{succ u2} (Filter.{u2} Œ≤) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) g) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {g : Filter.{u2} Œ≤}, Eq.{succ u2} (Filter.{u2} Œ≤) (HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) g) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))
Case conversion may be inaccurate. Consider using '#align filter.bot_smul Filter.bot_smul‚Çì'. -/
@[simp, to_additive]
theorem bot_smul : (‚ä• : Filter Œ±) ‚Ä¢ g = ‚ä• :=
  map‚ÇÇ_bot_left
#align filter.bot_smul Filter.bot_smul
#align filter.bot_vadd Filter.bot_vadd

/- warning: filter.smul_bot -> Filter.smul_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±}, Eq.{succ u2} (Filter.{u2} Œ≤) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±}, Eq.{succ u2} (Filter.{u2} Œ≤) (HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) f (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))
Case conversion may be inaccurate. Consider using '#align filter.smul_bot Filter.smul_bot‚Çì'. -/
@[simp, to_additive]
theorem smul_bot : f ‚Ä¢ (‚ä• : Filter Œ≤) = ‚ä• :=
  map‚ÇÇ_bot_right
#align filter.smul_bot Filter.smul_bot
#align filter.vadd_bot Filter.vadd_bot

/- warning: filter.smul_eq_bot_iff -> Filter.smul_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g : Filter.{u2} Œ≤}, Iff (Eq.{succ u2} (Filter.{u2} Œ≤) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f g) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))) (Or (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Eq.{succ u2} (Filter.{u2} Œ≤) g (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g : Filter.{u2} Œ≤}, Iff (Eq.{succ u2} (Filter.{u2} Œ≤) (HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) f g) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))) (Or (Eq.{succ u1} (Filter.{u1} Œ±) f (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Eq.{succ u2} (Filter.{u2} Œ≤) g (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))))
Case conversion may be inaccurate. Consider using '#align filter.smul_eq_bot_iff Filter.smul_eq_bot_iff‚Çì'. -/
@[simp, to_additive]
theorem smul_eq_bot_iff : f ‚Ä¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff
#align filter.smul_eq_bot_iff Filter.smul_eq_bot_iff
#align filter.vadd_eq_bot_iff Filter.vadd_eq_bot_iff

#print Filter.smul_neBot_iff /-
@[simp, to_additive]
theorem smul_neBot_iff : (f ‚Ä¢ g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot :=
  map‚ÇÇ_neBot_iff
#align filter.smul_ne_bot_iff Filter.smul_neBot_iff
#align filter.vadd_ne_bot_iff Filter.vadd_neBot_iff
-/

/- warning: filter.ne_bot.smul -> Filter.NeBot.smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g : Filter.{u2} Œ≤}, (Filter.NeBot.{u1} Œ± f) -> (Filter.NeBot.{u2} Œ≤ g) -> (Filter.NeBot.{u2} Œ≤ (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f g))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : SMul.{u2, u1} Œ± Œ≤] {f : Filter.{u2} Œ±} {g : Filter.{u1} Œ≤}, (Filter.NeBot.{u2} Œ± f) -> (Filter.NeBot.{u1} Œ≤ g) -> (Filter.NeBot.{u1} Œ≤ (HSMul.hSMul.{u2, u1, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHSMul.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instSMul.{u2, u1} Œ± Œ≤ _inst_1)) f g))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.smul Filter.NeBot.smul‚Çì'. -/
@[to_additive]
theorem NeBot.smul : NeBot f ‚Üí NeBot g ‚Üí NeBot (f ‚Ä¢ g) :=
  NeBot.map‚ÇÇ
#align filter.ne_bot.smul Filter.NeBot.smul
#align filter.ne_bot.vadd Filter.NeBot.vadd

#print Filter.NeBot.of_smul_left /-
@[to_additive]
theorem NeBot.of_smul_left : (f ‚Ä¢ g).ne_bot ‚Üí f.ne_bot :=
  NeBot.of_map‚ÇÇ_left
#align filter.ne_bot.of_smul_left Filter.NeBot.of_smul_left
#align filter.ne_bot.of_vadd_left Filter.NeBot.of_vadd_left
-/

#print Filter.NeBot.of_smul_right /-
@[to_additive]
theorem NeBot.of_smul_right : (f ‚Ä¢ g).ne_bot ‚Üí g.ne_bot :=
  NeBot.of_map‚ÇÇ_right
#align filter.ne_bot.of_smul_right Filter.NeBot.of_smul_right
#align filter.ne_bot.of_vadd_right Filter.NeBot.of_vadd_right
-/

#print Filter.pure_smul /-
@[simp, to_additive]
theorem pure_smul : (pure a : Filter Œ±) ‚Ä¢ g = g.map ((¬∑ ‚Ä¢ ¬∑) a) :=
  map‚ÇÇ_pure_left
#align filter.pure_smul Filter.pure_smul
#align filter.pure_vadd Filter.pure_vadd
-/

#print Filter.smul_pure /-
@[simp, to_additive]
theorem smul_pure : f ‚Ä¢ pure b = f.map (¬∑ ‚Ä¢ b) :=
  map‚ÇÇ_pure_right
#align filter.smul_pure Filter.smul_pure
#align filter.vadd_pure Filter.vadd_pure
-/

#print Filter.pure_smul_pure /-
@[simp, to_additive]
theorem pure_smul_pure : (pure a : Filter Œ±) ‚Ä¢ (pure b : Filter Œ≤) = pure (a ‚Ä¢ b) :=
  map‚ÇÇ_pure
#align filter.pure_smul_pure Filter.pure_smul_pure
#align filter.pure_vadd_pure Filter.pure_vadd_pure
-/

/- warning: filter.smul_le_smul -> Filter.smul_le_smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u1} Œ±} {f‚ÇÇ : Filter.{u1} Œ±} {g‚ÇÅ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÅ g‚ÇÅ) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÇ g‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : SMul.{u2, u1} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u2} Œ±} {g‚ÇÅ : Filter.{u1} Œ≤} {g‚ÇÇ : Filter.{u1} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ±) (Preorder.toLE.{u2} (Filter.{u2} Œ±) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ±) (Filter.instPartialOrderFilter.{u2} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ≤) (Preorder.toLE.{u1} (Filter.{u1} Œ≤) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ≤) (Filter.instPartialOrderFilter.{u1} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ≤) (Preorder.toLE.{u1} (Filter.{u1} Œ≤) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ≤) (Filter.instPartialOrderFilter.{u1} Œ≤))) (HSMul.hSMul.{u2, u1, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHSMul.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instSMul.{u2, u1} Œ± Œ≤ _inst_1)) f‚ÇÅ g‚ÇÅ) (HSMul.hSMul.{u2, u1, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHSMul.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instSMul.{u2, u1} Œ± Œ≤ _inst_1)) f‚ÇÇ g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.smul_le_smul Filter.smul_le_smul‚Çì'. -/
@[to_additive]
theorem smul_le_smul : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g‚ÇÅ ‚â§ f‚ÇÇ ‚Ä¢ g‚ÇÇ :=
  map‚ÇÇ_mono
#align filter.smul_le_smul Filter.smul_le_smul
#align filter.vadd_le_vadd Filter.vadd_le_vadd

/- warning: filter.smul_le_smul_left -> Filter.smul_le_smul_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g‚ÇÅ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f g‚ÇÅ) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f g‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g‚ÇÅ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) (HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) f g‚ÇÅ) (HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) f g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.smul_le_smul_left Filter.smul_le_smul_left‚Çì'. -/
@[to_additive]
theorem smul_le_smul_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f ‚Ä¢ g‚ÇÅ ‚â§ f ‚Ä¢ g‚ÇÇ :=
  map‚ÇÇ_mono_left
#align filter.smul_le_smul_left Filter.smul_le_smul_left
#align filter.vadd_le_vadd_left Filter.vadd_le_vadd_left

/- warning: filter.smul_le_smul_right -> Filter.smul_le_smul_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u1} Œ±} {f‚ÇÇ : Filter.{u1} Œ±} {g : Filter.{u2} Œ≤}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÅ g) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÇ g))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : SMul.{u2, u1} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ±} {f‚ÇÇ : Filter.{u2} Œ±} {g : Filter.{u1} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ±) (Preorder.toLE.{u2} (Filter.{u2} Œ±) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ±) (Filter.instPartialOrderFilter.{u2} Œ±))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ≤) (Preorder.toLE.{u1} (Filter.{u1} Œ≤) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ≤) (Filter.instPartialOrderFilter.{u1} Œ≤))) (HSMul.hSMul.{u2, u1, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHSMul.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instSMul.{u2, u1} Œ± Œ≤ _inst_1)) f‚ÇÅ g) (HSMul.hSMul.{u2, u1, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHSMul.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instSMul.{u2, u1} Œ± Œ≤ _inst_1)) f‚ÇÇ g))
Case conversion may be inaccurate. Consider using '#align filter.smul_le_smul_right Filter.smul_le_smul_right‚Çì'. -/
@[to_additive]
theorem smul_le_smul_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g ‚â§ f‚ÇÇ ‚Ä¢ g :=
  map‚ÇÇ_mono_right
#align filter.smul_le_smul_right Filter.smul_le_smul_right
#align filter.vadd_le_vadd_right Filter.vadd_le_vadd_right

/- warning: filter.le_smul_iff -> Filter.le_smul_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g : Filter.{u2} Œ≤} {h : Filter.{u2} Œ≤}, Iff (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) h (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1) f g)) (forall {{s : Set.{u1} Œ±}}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (forall {{t : Set.{u2} Œ≤}}, (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t g) -> (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (SMul.smul.{u1, u2} (Set.{u1} Œ±) (Set.{u2} Œ≤) (Set.smul.{u1, u2} Œ± Œ≤ _inst_1) s t) h)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u1} Œ±} {g : Filter.{u2} Œ≤} {h : Filter.{u2} Œ≤}, Iff (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) h (HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) f g)) (forall {{s : Set.{u1} Œ±}}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s f) -> (forall {{t : Set.{u2} Œ≤}}, (Membership.mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (instMembershipSetFilter.{u2} Œ≤) t g) -> (Membership.mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (instMembershipSetFilter.{u2} Œ≤) (HSMul.hSMul.{u1, u2, u2} (Set.{u1} Œ±) (Set.{u2} Œ≤) (Set.{u2} Œ≤) (instHSMul.{u1, u2} (Set.{u1} Œ±) (Set.{u2} Œ≤) (Set.smul.{u1, u2} Œ± Œ≤ _inst_1)) s t) h)))
Case conversion may be inaccurate. Consider using '#align filter.le_smul_iff Filter.le_smul_iff‚Çì'. -/
@[simp, to_additive]
theorem le_smul_iff : h ‚â§ f ‚Ä¢ g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s ‚Ä¢ t ‚àà h :=
  le_map‚ÇÇ_iff
#align filter.le_smul_iff Filter.le_smul_iff
#align filter.le_vadd_iff Filter.le_vadd_iff

/- warning: filter.covariant_smul -> Filter.covariant_smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤], CovariantClass.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤], CovariantClass.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.8279 : Filter.{u1} Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.8281 : Filter.{u2} Œ≤) => HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ _inst_1)) x._@.Mathlib.Order.Filter.Pointwise._hyg.8279 x._@.Mathlib.Order.Filter.Pointwise._hyg.8281) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.8294 : Filter.{u2} Œ≤) (x._@.Mathlib.Order.Filter.Pointwise._hyg.8296 : Filter.{u2} Œ≤) => LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) x._@.Mathlib.Order.Filter.Pointwise._hyg.8294 x._@.Mathlib.Order.Filter.Pointwise._hyg.8296)
Case conversion may be inaccurate. Consider using '#align filter.covariant_smul Filter.covariant_smul‚Çì'. -/
@[to_additive]
instance covariant_smul : CovariantClass (Filter Œ±) (Filter Œ≤) (¬∑ ‚Ä¢ ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun f g h => map‚ÇÇ_mono_left‚ü©
#align filter.covariant_smul Filter.covariant_smul
#align filter.covariant_vadd Filter.covariant_vadd

end Smul

/-! ### Scalar subtraction of filters -/


section Vsub

variable [VSub Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : Filter Œ≤} {h : Filter Œ±} {s t : Set Œ≤} {a b : Œ≤}

include Œ±

#print Filter.instVSub /-
/-- The filter `f -·µ• g` is generated by `{s -·µ• t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
protected def instVSub : VSub (Filter Œ±) (Filter Œ≤) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (-·µ•) f g`, but the hypothesis unfolds to `t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s` rather than all
  the way to `set.image2 (-·µ•) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ -·µ• ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s } }‚ü©
#align filter.has_vsub Filter.instVSub
-/

scoped[Pointwise] attribute [instance] Filter.instVSub

/- warning: filter.map‚ÇÇ_vsub -> Filter.map‚ÇÇ_vsub is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤}, Eq.{succ u1} (Filter.{u1} Œ±) (Filter.map‚ÇÇ.{u2, u2, u1} Œ≤ Œ≤ Œ± (VSub.vsub.{u1, u2} Œ± Œ≤ _inst_1) f g) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤}, Eq.{succ u2} (Filter.{u2} Œ±) (Filter.map‚ÇÇ.{u1, u1, u2} Œ≤ Œ≤ Œ± (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.8531 : Œ≤) (x._@.Mathlib.Order.Filter.Pointwise._hyg.8533 : Œ≤) => VSub.vsub.{u2, u1} Œ± Œ≤ _inst_1 x._@.Mathlib.Order.Filter.Pointwise._hyg.8531 x._@.Mathlib.Order.Filter.Pointwise._hyg.8533) f g) (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f g)
Case conversion may be inaccurate. Consider using '#align filter.map‚ÇÇ_vsub Filter.map‚ÇÇ_vsub‚Çì'. -/
@[simp]
theorem map‚ÇÇ_vsub : map‚ÇÇ (¬∑ -·µ• ¬∑) f g = f -·µ• g :=
  rfl
#align filter.map‚ÇÇ_vsub Filter.map‚ÇÇ_vsub

/- warning: filter.mem_vsub -> Filter.mem_vsub is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g)) (Exists.{succ u2} (Set.{u2} Œ≤) (fun (t‚ÇÅ : Set.{u2} Œ≤) => Exists.{succ u2} (Set.{u2} Œ≤) (fun (t‚ÇÇ : Set.{u2} Œ≤) => And (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t‚ÇÅ f) (And (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t‚ÇÇ g) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (VSub.vsub.{u1, u2} (Set.{u1} Œ±) (Set.{u2} Œ≤) (Set.vsub.{u1, u2} Œ± Œ≤ _inst_1) t‚ÇÅ t‚ÇÇ) s)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤} {s : Set.{u2} Œ±}, Iff (Membership.mem.{u2, u2} (Set.{u2} Œ±) (Filter.{u2} Œ±) (instMembershipSetFilter.{u2} Œ±) s (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f g)) (Exists.{succ u1} (Set.{u1} Œ≤) (fun (t‚ÇÅ : Set.{u1} Œ≤) => Exists.{succ u1} (Set.{u1} Œ≤) (fun (t‚ÇÇ : Set.{u1} Œ≤) => And (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) t‚ÇÅ f) (And (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) t‚ÇÇ g) (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (VSub.vsub.{u2, u1} (Set.{u2} Œ±) (Set.{u1} Œ≤) (Set.vsub.{u2, u1} Œ± Œ≤ _inst_1) t‚ÇÅ t‚ÇÇ) s)))))
Case conversion may be inaccurate. Consider using '#align filter.mem_vsub Filter.mem_vsub‚Çì'. -/
theorem mem_vsub {s : Set Œ±} : s ‚àà f -·µ• g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s :=
  Iff.rfl
#align filter.mem_vsub Filter.mem_vsub

#print Filter.vsub_mem_vsub /-
theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=
  image2_mem_map‚ÇÇ
#align filter.vsub_mem_vsub Filter.vsub_mem_vsub
-/

/- warning: filter.bot_vsub -> Filter.bot_vsub is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {g : Filter.{u2} Œ≤}, Eq.{succ u1} (Filter.{u1} Œ±) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤))) g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {g : Filter.{u1} Œ≤}, Eq.{succ u2} (Filter.{u2} Œ±) (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) (Bot.bot.{u1} (Filter.{u1} Œ≤) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ≤) (Filter.instCompleteLatticeFilter.{u1} Œ≤))) g) (Bot.bot.{u2} (Filter.{u2} Œ±) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.bot_vsub Filter.bot_vsub‚Çì'. -/
@[simp]
theorem bot_vsub : (‚ä• : Filter Œ≤) -·µ• g = ‚ä• :=
  map‚ÇÇ_bot_left
#align filter.bot_vsub Filter.bot_vsub

/- warning: filter.vsub_bot -> Filter.vsub_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤}, Eq.{succ u1} (Filter.{u1} Œ±) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤}, Eq.{succ u2} (Filter.{u2} Œ±) (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f (Bot.bot.{u1} (Filter.{u1} Œ≤) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ≤) (Filter.instCompleteLatticeFilter.{u1} Œ≤)))) (Bot.bot.{u2} (Filter.{u2} Œ±) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±)))
Case conversion may be inaccurate. Consider using '#align filter.vsub_bot Filter.vsub_bot‚Çì'. -/
@[simp]
theorem vsub_bot : f -·µ• (‚ä• : Filter Œ≤) = ‚ä• :=
  map‚ÇÇ_bot_right
#align filter.vsub_bot Filter.vsub_bot

/- warning: filter.vsub_eq_bot_iff -> Filter.vsub_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Or (Eq.{succ u2} (Filter.{u2} Œ≤) f (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))) (Eq.{succ u2} (Filter.{u2} Œ≤) g (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤}, Iff (Eq.{succ u2} (Filter.{u2} Œ±) (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f g) (Bot.bot.{u2} (Filter.{u2} Œ±) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±)))) (Or (Eq.{succ u1} (Filter.{u1} Œ≤) f (Bot.bot.{u1} (Filter.{u1} Œ≤) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ≤) (Filter.instCompleteLatticeFilter.{u1} Œ≤)))) (Eq.{succ u1} (Filter.{u1} Œ≤) g (Bot.bot.{u1} (Filter.{u1} Œ≤) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ≤) (Filter.instCompleteLatticeFilter.{u1} Œ≤)))))
Case conversion may be inaccurate. Consider using '#align filter.vsub_eq_bot_iff Filter.vsub_eq_bot_iff‚Çì'. -/
@[simp]
theorem vsub_eq_bot_iff : f -·µ• g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff
#align filter.vsub_eq_bot_iff Filter.vsub_eq_bot_iff

/- warning: filter.vsub_ne_bot_iff -> Filter.vsub_neBot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤}, Iff (Filter.NeBot.{u1} Œ± (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g)) (And (Filter.NeBot.{u2} Œ≤ f) (Filter.NeBot.{u2} Œ≤ g))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤}, Iff (Filter.NeBot.{u2} Œ± (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f g)) (And (Filter.NeBot.{u1} Œ≤ f) (Filter.NeBot.{u1} Œ≤ g))
Case conversion may be inaccurate. Consider using '#align filter.vsub_ne_bot_iff Filter.vsub_neBot_iff‚Çì'. -/
@[simp]
theorem vsub_neBot_iff : (f -·µ• g : Filter Œ±).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot :=
  map‚ÇÇ_neBot_iff
#align filter.vsub_ne_bot_iff Filter.vsub_neBot_iff

#print Filter.NeBot.vsub /-
theorem NeBot.vsub : NeBot f ‚Üí NeBot g ‚Üí NeBot (f -·µ• g) :=
  NeBot.map‚ÇÇ
#align filter.ne_bot.vsub Filter.NeBot.vsub
-/

/- warning: filter.ne_bot.of_vsub_left -> Filter.NeBot.of_vsub_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤}, (Filter.NeBot.{u1} Œ± (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g)) -> (Filter.NeBot.{u2} Œ≤ f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤}, (Filter.NeBot.{u2} Œ± (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f g)) -> (Filter.NeBot.{u1} Œ≤ f)
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.of_vsub_left Filter.NeBot.of_vsub_left‚Çì'. -/
theorem NeBot.of_vsub_left : (f -·µ• g : Filter Œ±).ne_bot ‚Üí f.ne_bot :=
  NeBot.of_map‚ÇÇ_left
#align filter.ne_bot.of_vsub_left Filter.NeBot.of_vsub_left

/- warning: filter.ne_bot.of_vsub_right -> Filter.NeBot.of_vsub_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤}, (Filter.NeBot.{u1} Œ± (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g)) -> (Filter.NeBot.{u2} Œ≤ g)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤}, (Filter.NeBot.{u2} Œ± (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f g)) -> (Filter.NeBot.{u1} Œ≤ g)
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.of_vsub_right Filter.NeBot.of_vsub_right‚Çì'. -/
theorem NeBot.of_vsub_right : (f -·µ• g : Filter Œ±).ne_bot ‚Üí g.ne_bot :=
  NeBot.of_map‚ÇÇ_right
#align filter.ne_bot.of_vsub_right Filter.NeBot.of_vsub_right

/- warning: filter.pure_vsub -> Filter.pure_vsub is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {g : Filter.{u2} Œ≤} {a : Œ≤}, Eq.{succ u1} (Filter.{u1} Œ±) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) (Pure.pure.{u2, u2} Filter.{u2} Filter.hasPure.{u2} Œ≤ a) g) (Filter.map.{u2, u1} Œ≤ Œ± (VSub.vsub.{u1, u2} Œ± Œ≤ _inst_1 a) g)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {g : Filter.{u1} Œ≤} {a : Œ≤}, Eq.{succ u2} (Filter.{u2} Œ±) (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ≤ a) g) (Filter.map.{u1, u2} Œ≤ Œ± ((fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.9097 : Œ≤) (x._@.Mathlib.Order.Filter.Pointwise._hyg.9099 : Œ≤) => VSub.vsub.{u2, u1} Œ± Œ≤ _inst_1 x._@.Mathlib.Order.Filter.Pointwise._hyg.9097 x._@.Mathlib.Order.Filter.Pointwise._hyg.9099) a) g)
Case conversion may be inaccurate. Consider using '#align filter.pure_vsub Filter.pure_vsub‚Çì'. -/
@[simp]
theorem pure_vsub : (pure a : Filter Œ≤) -·µ• g = g.map ((¬∑ -·µ• ¬∑) a) :=
  map‚ÇÇ_pure_left
#align filter.pure_vsub Filter.pure_vsub

/- warning: filter.vsub_pure -> Filter.vsub_pure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {b : Œ≤}, Eq.{succ u1} (Filter.{u1} Œ±) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f (Pure.pure.{u2, u2} Filter.{u2} Filter.hasPure.{u2} Œ≤ b)) (Filter.map.{u2, u1} Œ≤ Œ± (fun (_x : Œ≤) => VSub.vsub.{u1, u2} Œ± Œ≤ _inst_1 _x b) f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {b : Œ≤}, Eq.{succ u2} (Filter.{u2} Œ±) (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ≤ b)) (Filter.map.{u1, u2} Œ≤ Œ± (fun (_x : Œ≤) => VSub.vsub.{u2, u1} Œ± Œ≤ _inst_1 _x b) f)
Case conversion may be inaccurate. Consider using '#align filter.vsub_pure Filter.vsub_pure‚Çì'. -/
@[simp]
theorem vsub_pure : f -·µ• pure b = f.map (¬∑ -·µ• b) :=
  map‚ÇÇ_pure_right
#align filter.vsub_pure Filter.vsub_pure

/- warning: filter.pure_vsub_pure -> Filter.pure_vsub_pure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {a : Œ≤} {b : Œ≤}, Eq.{succ u1} (Filter.{u1} Œ±) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) (Pure.pure.{u2, u2} Filter.{u2} Filter.hasPure.{u2} Œ≤ a) (Pure.pure.{u2, u2} Filter.{u2} Filter.hasPure.{u2} Œ≤ b)) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Œ± (VSub.vsub.{u1, u2} Œ± Œ≤ _inst_1 a b))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {a : Œ≤} {b : Œ≤}, Eq.{succ u2} (Filter.{u2} Œ±) (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ≤ a) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Œ≤ b)) (Pure.pure.{u2, u2} Filter.{u2} Filter.instPureFilter.{u2} Œ± (VSub.vsub.{u2, u1} Œ± Œ≤ _inst_1 a b))
Case conversion may be inaccurate. Consider using '#align filter.pure_vsub_pure Filter.pure_vsub_pure‚Çì'. -/
@[simp]
theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=
  map‚ÇÇ_pure
#align filter.pure_vsub_pure Filter.pure_vsub_pure

/- warning: filter.vsub_le_vsub -> Filter.vsub_le_vsub is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ≤} {f‚ÇÇ : Filter.{u2} Œ≤} {g‚ÇÅ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÅ g‚ÇÅ) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÇ g‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ≤} {f‚ÇÇ : Filter.{u2} Œ≤} {g‚ÇÅ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÅ g‚ÇÅ) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÇ g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.vsub_le_vsub Filter.vsub_le_vsub‚Çì'. -/
theorem vsub_le_vsub : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ -·µ• g‚ÇÅ ‚â§ f‚ÇÇ -·µ• g‚ÇÇ :=
  map‚ÇÇ_mono
#align filter.vsub_le_vsub Filter.vsub_le_vsub

/- warning: filter.vsub_le_vsub_left -> Filter.vsub_le_vsub_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g‚ÇÅ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g‚ÇÅ) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g‚ÇÅ : Filter.{u2} Œ≤} {g‚ÇÇ : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) g‚ÇÅ g‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g‚ÇÅ) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.vsub_le_vsub_left Filter.vsub_le_vsub_left‚Çì'. -/
theorem vsub_le_vsub_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f -·µ• g‚ÇÅ ‚â§ f -·µ• g‚ÇÇ :=
  map‚ÇÇ_mono_left
#align filter.vsub_le_vsub_left Filter.vsub_le_vsub_left

/- warning: filter.vsub_le_vsub_right -> Filter.vsub_le_vsub_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ≤} {f‚ÇÇ : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÅ g) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÇ g))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ≤} {f‚ÇÇ : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÅ g) (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f‚ÇÇ g))
Case conversion may be inaccurate. Consider using '#align filter.vsub_le_vsub_right Filter.vsub_le_vsub_right‚Çì'. -/
theorem vsub_le_vsub_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ -·µ• g ‚â§ f‚ÇÇ -·µ• g :=
  map‚ÇÇ_mono_right
#align filter.vsub_le_vsub_right Filter.vsub_le_vsub_right

/- warning: filter.le_vsub_iff -> Filter.le_vsub_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : VSub.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {g : Filter.{u2} Œ≤} {h : Filter.{u1} Œ±}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toHasLe.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) h (VSub.vsub.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instVSub.{u1, u2} Œ± Œ≤ _inst_1) f g)) (forall {{s : Set.{u2} Œ≤}}, (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) s f) -> (forall {{t : Set.{u2} Œ≤}}, (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t g) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (VSub.vsub.{u1, u2} (Set.{u1} Œ±) (Set.{u2} Œ≤) (Set.vsub.{u1, u2} Œ± Œ≤ _inst_1) s t) h)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : VSub.{u2, u1} Œ± Œ≤] {f : Filter.{u1} Œ≤} {g : Filter.{u1} Œ≤} {h : Filter.{u2} Œ±}, Iff (LE.le.{u2} (Filter.{u2} Œ±) (Preorder.toLE.{u2} (Filter.{u2} Œ±) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ±) (Filter.instPartialOrderFilter.{u2} Œ±))) h (VSub.vsub.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instVSub.{u2, u1} Œ± Œ≤ _inst_1) f g)) (forall {{s : Set.{u1} Œ≤}}, (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) s f) -> (forall {{t : Set.{u1} Œ≤}}, (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) t g) -> (Membership.mem.{u2, u2} (Set.{u2} Œ±) (Filter.{u2} Œ±) (instMembershipSetFilter.{u2} Œ±) (VSub.vsub.{u2, u1} (Set.{u2} Œ±) (Set.{u1} Œ≤) (Set.vsub.{u2, u1} Œ± Œ≤ _inst_1) s t) h)))
Case conversion may be inaccurate. Consider using '#align filter.le_vsub_iff Filter.le_vsub_iff‚Çì'. -/
@[simp]
theorem le_vsub_iff : h ‚â§ f -·µ• g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s -·µ• t ‚àà h :=
  le_map‚ÇÇ_iff
#align filter.le_vsub_iff Filter.le_vsub_iff

end Vsub

/-! ### Translation/scaling of filters -/


section Smul

variable [SMul Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : Filter Œ≤} {s : Set Œ≤} {a : Œ±}

#print Filter.instSMulFilter /-
/-- `a ‚Ä¢ f` is the map of `f` under `a ‚Ä¢` in locale `pointwise`. -/
@[to_additive Filter.instVAddFilter
      "`a +·µ• f` is the map of `f` under `a +·µ•` in locale `pointwise`."]
protected def instSMulFilter : SMul Œ± (Filter Œ≤) :=
  ‚ü®fun a => map ((¬∑ ‚Ä¢ ¬∑) a)‚ü©
#align filter.has_smul_filter Filter.instSMulFilter
#align filter.has_vadd_filter Filter.instVAddFilter
-/

scoped[Pointwise] attribute [instance] Filter.instSMulFilter Filter.instVAddFilter

#print Filter.map_smul /-
@[simp, to_additive]
theorem map_smul : map (fun b => a ‚Ä¢ b) f = a ‚Ä¢ f :=
  rfl
#align filter.map_smul Filter.map_smul
#align filter.map_vadd Filter.map_vadd
-/

#print Filter.mem_smul_filter /-
@[to_additive]
theorem mem_smul_filter : s ‚àà a ‚Ä¢ f ‚Üî (¬∑ ‚Ä¢ ¬∑) a ‚Åª¬π' s ‚àà f :=
  Iff.rfl
#align filter.mem_smul_filter Filter.mem_smul_filter
#align filter.mem_vadd_filter Filter.mem_vadd_filter
-/

#print Filter.smul_set_mem_smul_filter /-
@[to_additive]
theorem smul_set_mem_smul_filter : s ‚àà f ‚Üí a ‚Ä¢ s ‚àà a ‚Ä¢ f :=
  image_mem_map
#align filter.smul_set_mem_smul_filter Filter.smul_set_mem_smul_filter
#align filter.vadd_set_mem_vadd_filter Filter.vadd_set_mem_vadd_filter
-/

/- warning: filter.smul_filter_bot -> Filter.smul_filter_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {a : Œ±}, Eq.{succ u2} (Filter.{u2} Œ≤) (SMul.smul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1) a (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {a : Œ±}, Eq.{succ u2} (Filter.{u2} Œ≤) (HSMul.hSMul.{u1, u2, u2} Œ± (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1)) a (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))
Case conversion may be inaccurate. Consider using '#align filter.smul_filter_bot Filter.smul_filter_bot‚Çì'. -/
@[simp, to_additive]
theorem smul_filter_bot : a ‚Ä¢ (‚ä• : Filter Œ≤) = ‚ä• :=
  map_bot
#align filter.smul_filter_bot Filter.smul_filter_bot
#align filter.vadd_filter_bot Filter.vadd_filter_bot

/- warning: filter.smul_filter_eq_bot_iff -> Filter.smul_filter_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {a : Œ±}, Iff (Eq.{succ u2} (Filter.{u2} Œ≤) (SMul.smul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1) a f) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤)))) (Eq.{succ u2} (Filter.{u2} Œ≤) f (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toHasBot.{u2} (Filter.{u2} Œ≤) (Filter.completeLattice.{u2} Œ≤))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f : Filter.{u2} Œ≤} {a : Œ±}, Iff (Eq.{succ u2} (Filter.{u2} Œ≤) (HSMul.hSMul.{u1, u2, u2} Œ± (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1)) a f) (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤)))) (Eq.{succ u2} (Filter.{u2} Œ≤) f (Bot.bot.{u2} (Filter.{u2} Œ≤) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ≤) (Filter.instCompleteLatticeFilter.{u2} Œ≤))))
Case conversion may be inaccurate. Consider using '#align filter.smul_filter_eq_bot_iff Filter.smul_filter_eq_bot_iff‚Çì'. -/
@[simp, to_additive]
theorem smul_filter_eq_bot_iff : a ‚Ä¢ f = ‚ä• ‚Üî f = ‚ä• :=
  map_eq_bot_iff
#align filter.smul_filter_eq_bot_iff Filter.smul_filter_eq_bot_iff
#align filter.vadd_filter_eq_bot_iff Filter.vadd_filter_eq_bot_iff

#print Filter.smul_filter_neBot_iff /-
@[simp, to_additive]
theorem smul_filter_neBot_iff : (a ‚Ä¢ f).ne_bot ‚Üî f.ne_bot :=
  map_neBot_iff _
#align filter.smul_filter_ne_bot_iff Filter.smul_filter_neBot_iff
#align filter.vadd_filter_ne_bot_iff Filter.vadd_filter_neBot_iff
-/

#print Filter.NeBot.smul_filter /-
@[to_additive]
theorem NeBot.smul_filter : f.ne_bot ‚Üí (a ‚Ä¢ f).ne_bot := fun h => h.map _
#align filter.ne_bot.smul_filter Filter.NeBot.smul_filter
#align filter.ne_bot.vadd_filter Filter.NeBot.vadd_filter
-/

#print Filter.NeBot.of_smul_filter /-
@[to_additive]
theorem NeBot.of_smul_filter : (a ‚Ä¢ f).ne_bot ‚Üí f.ne_bot :=
  NeBot.of_map
#align filter.ne_bot.of_smul_filter Filter.NeBot.of_smul_filter
#align filter.ne_bot.of_vadd_filter Filter.NeBot.of_vadd_filter
-/

/- warning: filter.smul_filter_le_smul_filter -> Filter.smul_filter_le_smul_filter is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ≤} {f‚ÇÇ : Filter.{u2} Œ≤} {a : Œ±}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (SMul.smul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1) a f‚ÇÅ) (SMul.smul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1) a f‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤] {f‚ÇÅ : Filter.{u2} Œ≤} {f‚ÇÇ : Filter.{u2} Œ≤} {a : Œ±}, (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) f‚ÇÅ f‚ÇÇ) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) (HSMul.hSMul.{u1, u2, u2} Œ± (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1)) a f‚ÇÅ) (HSMul.hSMul.{u1, u2, u2} Œ± (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1)) a f‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align filter.smul_filter_le_smul_filter Filter.smul_filter_le_smul_filter‚Çì'. -/
@[to_additive]
theorem smul_filter_le_smul_filter (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : a ‚Ä¢ f‚ÇÅ ‚â§ a ‚Ä¢ f‚ÇÇ :=
  map_mono hf
#align filter.smul_filter_le_smul_filter Filter.smul_filter_le_smul_filter
#align filter.vadd_filter_le_vadd_filter Filter.vadd_filter_le_vadd_filter

/- warning: filter.covariant_smul_filter -> Filter.covariant_smul_filter is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤], CovariantClass.{u1, u2} Œ± (Filter.{u2} Œ≤) (SMul.smul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1)) (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : SMul.{u1, u2} Œ± Œ≤], CovariantClass.{u1, u2} Œ± (Filter.{u2} Œ≤) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.9944 : Œ±) (x._@.Mathlib.Order.Filter.Pointwise._hyg.9946 : Filter.{u2} Œ≤) => HSMul.hSMul.{u1, u2, u2} Œ± (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ _inst_1)) x._@.Mathlib.Order.Filter.Pointwise._hyg.9944 x._@.Mathlib.Order.Filter.Pointwise._hyg.9946) (fun (x._@.Mathlib.Order.Filter.Pointwise._hyg.9959 : Filter.{u2} Œ≤) (x._@.Mathlib.Order.Filter.Pointwise._hyg.9961 : Filter.{u2} Œ≤) => LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) x._@.Mathlib.Order.Filter.Pointwise._hyg.9959 x._@.Mathlib.Order.Filter.Pointwise._hyg.9961)
Case conversion may be inaccurate. Consider using '#align filter.covariant_smul_filter Filter.covariant_smul_filter‚Çì'. -/
@[to_additive]
instance covariant_smul_filter : CovariantClass Œ± (Filter Œ≤) (¬∑ ‚Ä¢ ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun f => map_mono‚ü©
#align filter.covariant_smul_filter Filter.covariant_smul_filter
#align filter.covariant_vadd_filter Filter.covariant_vadd_filter

end Smul

open Pointwise

#print Filter.smulCommClass_filter /-
@[to_additive]
instance smulCommClass_filter [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass Œ± Œ≤ (Filter Œ≥) :=
  ‚ü®fun _ _ _ => map_comm (funext <| smul_comm _ _) _‚ü©
#align filter.smul_comm_class_filter Filter.smulCommClass_filter
#align filter.vadd_comm_class_filter Filter.vaddCommClass_filter
-/

#print Filter.smulCommClass_filter' /-
@[to_additive]
instance smulCommClass_filter' [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass Œ± (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun a f g => map_map‚ÇÇ_distrib_right <| smul_comm a‚ü©
#align filter.smul_comm_class_filter' Filter.smulCommClass_filter'
#align filter.vadd_comm_class_filter' Filter.vaddCommClass_filter'
-/

#print Filter.smulCommClass_filter'' /-
@[to_additive]
instance smulCommClass_filter'' [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass (Filter Œ±) Œ≤ (Filter Œ≥) :=
  haveI := SMulCommClass.symm Œ± Œ≤ Œ≥
  SMulCommClass.symm _ _ _
#align filter.smul_comm_class_filter'' Filter.smulCommClass_filter''
#align filter.vadd_comm_class_filter'' Filter.vaddCommClass_filter''
-/

#print Filter.smulCommClass /-
@[to_additive]
instance smulCommClass [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass (Filter Œ±) (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun f g h => map‚ÇÇ_left_comm smul_comm‚ü©
#align filter.smul_comm_class Filter.smulCommClass
#align filter.vadd_comm_class Filter.vaddCommClass
-/

#print Filter.isScalarTower /-
@[to_additive]
instance isScalarTower [SMul Œ± Œ≤] [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [IsScalarTower Œ± Œ≤ Œ≥] :
    IsScalarTower Œ± Œ≤ (Filter Œ≥) :=
  ‚ü®fun a b f => by simp only [‚Üê map_smul, map_map, smul_assoc]‚ü©
#align filter.is_scalar_tower Filter.isScalarTower
#align filter.vadd_assoc_class Filter.vaddAssocClass
-/

#print Filter.isScalarTower' /-
@[to_additive]
instance isScalarTower' [SMul Œ± Œ≤] [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [IsScalarTower Œ± Œ≤ Œ≥] :
    IsScalarTower Œ± (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun a f g => by
    refine' (map_map‚ÇÇ_distrib_left fun _ _ => _).symm
    exact (smul_assoc a _ _).symm‚ü©
#align filter.is_scalar_tower' Filter.isScalarTower'
#align filter.vadd_assoc_class' Filter.vaddAssocClass'
-/

#print Filter.isScalarTower'' /-
@[to_additive]
instance isScalarTower'' [SMul Œ± Œ≤] [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [IsScalarTower Œ± Œ≤ Œ≥] :
    IsScalarTower (Filter Œ±) (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun f g h => map‚ÇÇ_assoc smul_assoc‚ü©
#align filter.is_scalar_tower'' Filter.isScalarTower''
#align filter.vadd_assoc_class'' Filter.vaddAssocClass''
-/

#print Filter.isCentralScalar /-
@[to_additive]
instance isCentralScalar [SMul Œ± Œ≤] [SMul Œ±·µê·µí·µñ Œ≤] [IsCentralScalar Œ± Œ≤] :
    IsCentralScalar Œ± (Filter Œ≤) :=
  ‚ü®fun a f => (congr_arg fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _‚ü©
#align filter.is_central_scalar Filter.isCentralScalar
#align filter.is_central_vadd Filter.isCentralVAdd
-/

#print Filter.mulAction /-
/-- A multiplicative action of a monoid `Œ±` on a type `Œ≤` gives a multiplicative action of
`filter Œ±` on `filter Œ≤`. -/
@[to_additive
      "An additive action of an additive monoid `Œ±` on a type `Œ≤` gives an additive action\nof `filter Œ±` on `filter Œ≤`"]
protected def mulAction [Monoid Œ±] [MulAction Œ± Œ≤] : MulAction (Filter Œ±) (Filter Œ≤)
    where
  one_smul f := map‚ÇÇ_pure_left.trans <| by simp_rw [one_smul, map_id']
  mul_smul f g h := map‚ÇÇ_assoc mul_smul
#align filter.mul_action Filter.mulAction
#align filter.add_action Filter.addAction
-/

#print Filter.mulActionFilter /-
/-- A multiplicative action of a monoid on a type `Œ≤` gives a multiplicative action on `filter Œ≤`.
-/
@[to_additive
      "An additive action of an additive monoid on a type `Œ≤` gives an additive action on\n`filter Œ≤`."]
protected def mulActionFilter [Monoid Œ±] [MulAction Œ± Œ≤] : MulAction Œ± (Filter Œ≤)
    where
  mul_smul a b f := by simp only [‚Üê map_smul, map_map, Function.comp, ‚Üê mul_smul]
  one_smul f := by simp only [‚Üê map_smul, one_smul, map_id']
#align filter.mul_action_filter Filter.mulActionFilter
#align filter.add_action_filter Filter.addActionFilter
-/

scoped[Pointwise]
  attribute [instance]
    Filter.mulAction Filter.addAction Filter.mulActionFilter Filter.addActionFilter

#print Filter.distribMulActionFilter /-
/-- A distributive multiplicative action of a monoid on an additive monoid `Œ≤` gives a distributive
multiplicative action on `filter Œ≤`. -/
protected def distribMulActionFilter [Monoid Œ±] [AddMonoid Œ≤] [DistribMulAction Œ± Œ≤] :
    DistribMulAction Œ± (Filter Œ≤)
    where
  smul_add _ _ _ := map_map‚ÇÇ_distrib <| smul_add _
  smul_zero _ := (map_pure _ _).trans <| by rw [smul_zero, pure_zero]
#align filter.distrib_mul_action_filter Filter.distribMulActionFilter
-/

#print Filter.mulDistribMulActionFilter /-
/-- A multiplicative action of a monoid on a monoid `Œ≤` gives a multiplicative action on `set Œ≤`. -/
protected def mulDistribMulActionFilter [Monoid Œ±] [Monoid Œ≤] [MulDistribMulAction Œ± Œ≤] :
    MulDistribMulAction Œ± (Set Œ≤)
    where
  smul_mul _ _ _ := image_image2_distrib <| smul_mul' _
  smul_one _ := image_singleton.trans <| by rw [smul_one, singleton_one]
#align filter.mul_distrib_mul_action_filter Filter.mulDistribMulActionFilter
-/

scoped[Pointwise]
  attribute [instance] Filter.distribMulActionFilter Filter.mulDistribMulActionFilter

section SMulWithZero

variable [Zero Œ±] [Zero Œ≤] [SMulWithZero Œ± Œ≤] {f : Filter Œ±} {g : Filter Œ≤}

/-!
Note that we have neither `smul_with_zero Œ± (filter Œ≤)` nor `smul_with_zero (filter Œ±) (filter Œ≤)`
because `0 * ‚ä• ‚â† 0`.
-/


/- warning: filter.ne_bot.smul_zero_nonneg -> Filter.NeBot.smul_zero_nonneg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : Zero.{u1} Œ±] [_inst_2 : Zero.{u2} Œ≤] [_inst_3 : SMulWithZero.{u1, u2} Œ± Œ≤ _inst_1 _inst_2] {f : Filter.{u1} Œ±}, (Filter.NeBot.{u1} Œ± f) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (OfNat.ofNat.{u2} (Filter.{u2} Œ≤) 0 (OfNat.mk.{u2} (Filter.{u2} Œ≤) 0 (Zero.zero.{u2} (Filter.{u2} Œ≤) (Filter.instZero.{u2} Œ≤ _inst_2)))) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ (SMulZeroClass.toHasSmul.{u1, u2} Œ± Œ≤ _inst_2 (SMulWithZero.toSmulZeroClass.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 _inst_3))) f (OfNat.ofNat.{u2} (Filter.{u2} Œ≤) 0 (OfNat.mk.{u2} (Filter.{u2} Œ≤) 0 (Zero.zero.{u2} (Filter.{u2} Œ≤) (Filter.instZero.{u2} Œ≤ _inst_2))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : Zero.{u2} Œ±] [_inst_2 : Zero.{u1} Œ≤] [_inst_3 : SMulWithZero.{u2, u1} Œ± Œ≤ _inst_1 _inst_2] {f : Filter.{u2} Œ±}, (Filter.NeBot.{u2} Œ± f) -> (LE.le.{u1} (Filter.{u1} Œ≤) (Preorder.toLE.{u1} (Filter.{u1} Œ≤) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ≤) (Filter.instPartialOrderFilter.{u1} Œ≤))) (OfNat.ofNat.{u1} (Filter.{u1} Œ≤) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ≤) (Filter.instZero.{u1} Œ≤ _inst_2))) (HSMul.hSMul.{u2, u1, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.{u1} Œ≤) (instHSMul.{u2, u1} (Filter.{u2} Œ±) (Filter.{u1} Œ≤) (Filter.instSMul.{u2, u1} Œ± Œ≤ (SMulZeroClass.toSMul.{u2, u1} Œ± Œ≤ _inst_2 (SMulWithZero.toSMulZeroClass.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 _inst_3)))) f (OfNat.ofNat.{u1} (Filter.{u1} Œ≤) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ≤) (Filter.instZero.{u1} Œ≤ _inst_2)))))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.smul_zero_nonneg Filter.NeBot.smul_zero_nonneg‚Çì'. -/
theorem NeBot.smul_zero_nonneg (hf : f.ne_bot) : 0 ‚â§ f ‚Ä¢ (0 : Filter Œ≤) :=
  le_smul_iff.2 fun t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ =>
    let ‚ü®a, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ
    ‚ü®_, _, ha, h‚ÇÇ, smul_zero _‚ü©
#align filter.ne_bot.smul_zero_nonneg Filter.NeBot.smul_zero_nonneg

/- warning: filter.ne_bot.zero_smul_nonneg -> Filter.NeBot.zero_smul_nonneg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : Zero.{u1} Œ±] [_inst_2 : Zero.{u2} Œ≤] [_inst_3 : SMulWithZero.{u1, u2} Œ± Œ≤ _inst_1 _inst_2] {g : Filter.{u2} Œ≤}, (Filter.NeBot.{u2} Œ≤ g) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (OfNat.ofNat.{u2} (Filter.{u2} Œ≤) 0 (OfNat.mk.{u2} (Filter.{u2} Œ≤) 0 (Zero.zero.{u2} (Filter.{u2} Œ≤) (Filter.instZero.{u2} Œ≤ _inst_2)))) (SMul.smul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ (SMulZeroClass.toHasSmul.{u1, u2} Œ± Œ≤ _inst_2 (SMulWithZero.toSmulZeroClass.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 _inst_3))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (OfNat.mk.{u1} (Filter.{u1} Œ±) 0 (Zero.zero.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± _inst_1)))) g))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : Zero.{u1} Œ±] [_inst_2 : Zero.{u2} Œ≤] [_inst_3 : SMulWithZero.{u1, u2} Œ± Œ≤ _inst_1 _inst_2] {g : Filter.{u2} Œ≤}, (Filter.NeBot.{u2} Œ≤ g) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) (OfNat.ofNat.{u2} (Filter.{u2} Œ≤) 0 (Zero.toOfNat0.{u2} (Filter.{u2} Œ≤) (Filter.instZero.{u2} Œ≤ _inst_2))) (HSMul.hSMul.{u1, u2, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} (Filter.{u1} Œ±) (Filter.{u2} Œ≤) (Filter.instSMul.{u1, u2} Œ± Œ≤ (SMulZeroClass.toSMul.{u1, u2} Œ± Œ≤ _inst_2 (SMulWithZero.toSMulZeroClass.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 _inst_3)))) (OfNat.ofNat.{u1} (Filter.{u1} Œ±) 0 (Zero.toOfNat0.{u1} (Filter.{u1} Œ±) (Filter.instZero.{u1} Œ± _inst_1))) g))
Case conversion may be inaccurate. Consider using '#align filter.ne_bot.zero_smul_nonneg Filter.NeBot.zero_smul_nonneg‚Çì'. -/
theorem NeBot.zero_smul_nonneg (hg : g.ne_bot) : 0 ‚â§ (0 : Filter Œ±) ‚Ä¢ g :=
  le_smul_iff.2 fun t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ =>
    let ‚ü®b, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ
    ‚ü®_, _, h‚ÇÅ, hb, zero_smul _ _‚ü©
#align filter.ne_bot.zero_smul_nonneg Filter.NeBot.zero_smul_nonneg

/- warning: filter.zero_smul_filter_nonpos -> Filter.zero_smul_filter_nonpos is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : Zero.{u1} Œ±] [_inst_2 : Zero.{u2} Œ≤] [_inst_3 : SMulWithZero.{u1, u2} Œ± Œ≤ _inst_1 _inst_2] {g : Filter.{u2} Œ≤}, LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toHasLe.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (SMul.smul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ (SMulZeroClass.toHasSmul.{u1, u2} Œ± Œ≤ _inst_2 (SMulWithZero.toSmulZeroClass.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 _inst_3))) (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± _inst_1))) g) (OfNat.ofNat.{u2} (Filter.{u2} Œ≤) 0 (OfNat.mk.{u2} (Filter.{u2} Œ≤) 0 (Zero.zero.{u2} (Filter.{u2} Œ≤) (Filter.instZero.{u2} Œ≤ _inst_2))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : Zero.{u1} Œ±] [_inst_2 : Zero.{u2} Œ≤] [_inst_3 : SMulWithZero.{u1, u2} Œ± Œ≤ _inst_1 _inst_2] {g : Filter.{u2} Œ≤}, LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) (HSMul.hSMul.{u1, u2, u2} Œ± (Filter.{u2} Œ≤) (Filter.{u2} Œ≤) (instHSMul.{u1, u2} Œ± (Filter.{u2} Œ≤) (Filter.instSMulFilter.{u1, u2} Œ± Œ≤ (SMulZeroClass.toSMul.{u1, u2} Œ± Œ≤ _inst_2 (SMulWithZero.toSMulZeroClass.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 _inst_3)))) (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± _inst_1)) g) (OfNat.ofNat.{u2} (Filter.{u2} Œ≤) 0 (Zero.toOfNat0.{u2} (Filter.{u2} Œ≤) (Filter.instZero.{u2} Œ≤ _inst_2)))
Case conversion may be inaccurate. Consider using '#align filter.zero_smul_filter_nonpos Filter.zero_smul_filter_nonpos‚Çì'. -/
theorem zero_smul_filter_nonpos : (0 : Œ±) ‚Ä¢ g ‚â§ 0 :=
  by
  refine' fun s hs => mem_smul_filter.2 _
  convert univ_mem
  refine' eq_univ_iff_forall.2 fun a => _
  rwa [mem_preimage, zero_smul]
#align filter.zero_smul_filter_nonpos Filter.zero_smul_filter_nonpos

#print Filter.zero_smul_filter /-
theorem zero_smul_filter (hg : g.ne_bot) : (0 : Œ±) ‚Ä¢ g = 0 :=
  zero_smul_filter_nonpos.antisymm <|
    le_map_iff.2 fun s hs =>
      by
      simp_rw [Set.image_eta, zero_smul, (hg.nonempty_of_mem hs).image_const]
      exact zero_mem_zero
#align filter.zero_smul_filter Filter.zero_smul_filter
-/

end SMulWithZero

end Filter

