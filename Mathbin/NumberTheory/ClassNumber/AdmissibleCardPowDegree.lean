/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen

! This file was ported from Lean 3 source module number_theory.class_number.admissible_card_pow_degree
! leanprover-community/mathlib commit 4280f5f32e16755ec7985ce11e189b6cd6ff6735
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.NumberTheory.ClassNumber.AdmissibleAbsoluteValue
import Mathbin.Analysis.SpecialFunctions.Pow.Real
import Mathbin.RingTheory.Ideal.LocalRing
import Mathbin.Data.Polynomial.Degree.CardPowDegree

/-!
# Admissible absolute values on polynomials

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines an admissible absolute value `polynomial.card_pow_degree_is_admissible` which we
use to show the class number of the ring of integers of a function field is finite.

## Main results

* `polynomial.card_pow_degree_is_admissible` shows `card_pow_degree`,
  mapping `p : polynomial ùîΩ_q` to `q ^ degree p`, is admissible
-/


namespace Polynomial

open Polynomial

open AbsoluteValue Real

variable {Fq : Type _} [Fintype Fq]

/- warning: polynomial.exists_eq_polynomial -> Polynomial.exists_eq_polynomial is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Semiring.{u1} Fq] {d : Nat} {m : Nat}, (LE.le.{0} Nat Nat.hasLe (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) d) m) -> (forall (b : Polynomial.{u1} Fq _inst_2), (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} Fq _inst_2 b) d) -> (forall (A : (Fin (Nat.succ m)) -> (Polynomial.{u1} Fq _inst_2)), (forall (i : Fin (Nat.succ m)), LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} Fq _inst_2 (A i)) (Polynomial.degree.{u1} Fq _inst_2 b)) -> (Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÄ : Fin (Nat.succ m)) => Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÅ : Fin (Nat.succ m)) => And (Ne.{1} (Fin (Nat.succ m)) i‚ÇÄ i‚ÇÅ) (Eq.{succ u1} (Polynomial.{u1} Fq _inst_2) (A i‚ÇÅ) (A i‚ÇÄ)))))))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Semiring.{u1} Fq] {d : Nat} {m : Nat}, (LE.le.{0} Nat instLENat (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) d) m) -> (forall (b : Polynomial.{u1} Fq _inst_2), (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} Fq _inst_2 b) d) -> (forall (A : (Fin (Nat.succ m)) -> (Polynomial.{u1} Fq _inst_2)), (forall (i : Fin (Nat.succ m)), LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} Fq _inst_2 (A i)) (Polynomial.degree.{u1} Fq _inst_2 b)) -> (Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÄ : Fin (Nat.succ m)) => Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÅ : Fin (Nat.succ m)) => And (Ne.{1} (Fin (Nat.succ m)) i‚ÇÄ i‚ÇÅ) (Eq.{succ u1} (Polynomial.{u1} Fq _inst_2) (A i‚ÇÅ) (A i‚ÇÄ)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_eq_polynomial Polynomial.exists_eq_polynomial‚Çì'. -/
/-- If `A` is a family of enough low-degree polynomials over a finite semiring, there is a
pair of equal elements in `A`. -/
theorem exists_eq_polynomial [Semiring Fq] {d : ‚Ñï} {m : ‚Ñï} (hm : Fintype.card Fq ^ d ‚â§ m)
    (b : Fq[X]) (hb : natDegree b ‚â§ d) (A : Fin m.succ ‚Üí Fq[X])
    (hA : ‚àÄ i, degree (A i) < degree b) : ‚àÉ i‚ÇÄ i‚ÇÅ, i‚ÇÄ ‚â† i‚ÇÅ ‚àß A i‚ÇÅ = A i‚ÇÄ :=
  by
  -- Since there are > q^d elements of A, and only q^d choices for the highest `d` coefficients,
  -- there must be two elements of A with the same coefficients at
  -- `0`, ... `degree b - 1` ‚â§ `d - 1`.
  -- In other words, the following map is not injective:
  set f : Fin m.succ ‚Üí Fin d ‚Üí Fq := fun i j => (A i).Coeff j
  have : Fintype.card (Fin d ‚Üí Fq) < Fintype.card (Fin m.succ) := by
    simpa using lt_of_le_of_lt hm (Nat.lt_succ_self m)
  -- Therefore, the differences have all coefficients higher than `deg b - d` equal.
  obtain ‚ü®i‚ÇÄ, i‚ÇÅ, i_ne, i_eq‚ü© := Fintype.exists_ne_map_eq_of_card_lt f this
  use i‚ÇÄ, i‚ÇÅ, i_ne
  ext j
  -- The coefficients higher than `deg b` are the same because they are equal to 0.
  by_cases hbj : degree b ‚â§ j
  ¬∑
    rw [coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj),
      coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj)]
  -- So we only need to look for the coefficients between `0` and `deg b`.
  rw [not_le] at hbj
  apply congr_fun i_eq.symm ‚ü®j, _‚ü©
  exact lt_of_lt_of_le (coe_lt_degree.mp hbj) hb
#align polynomial.exists_eq_polynomial Polynomial.exists_eq_polynomial

/- warning: polynomial.exists_approx_polynomial_aux -> Polynomial.exists_approx_polynomial_aux is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Ring.{u1} Fq] {d : Nat} {m : Nat}, (LE.le.{0} Nat Nat.hasLe (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) d) m) -> (forall (b : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (A : (Fin (Nat.succ m)) -> (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2))), (forall (i : Fin (Nat.succ m)), LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) (A i)) (Polynomial.degree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) b)) -> (Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÄ : Fin (Nat.succ m)) => Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÅ : Fin (Nat.succ m)) => And (Ne.{1} (Fin (Nat.succ m)) i‚ÇÄ i‚ÇÅ) (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (Polynomial.sub.{u1} Fq _inst_2)) (A i‚ÇÅ) (A i‚ÇÄ))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (WithBot.{0} Nat) (HasLiftT.mk.{1, 1} Nat (WithBot.{0} Nat) (CoeTC‚Çì.coe.{1, 1} Nat (WithBot.{0} Nat) (WithBot.hasCoeT.{0} Nat))) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Polynomial.natDegree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) b) d)))))))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Ring.{u1} Fq] {d : Nat} {m : Nat}, (LE.le.{0} Nat instLENat (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) d) m) -> (forall (b : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (A : (Fin (Nat.succ m)) -> (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2))), (forall (i : Fin (Nat.succ m)), LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) (A i)) (Polynomial.degree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) b)) -> (Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÄ : Fin (Nat.succ m)) => Exists.{1} (Fin (Nat.succ m)) (fun (i‚ÇÅ : Fin (Nat.succ m)) => And (Ne.{1} (Fin (Nat.succ m)) i‚ÇÄ i‚ÇÅ) (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2)) (Polynomial.sub.{u1} Fq _inst_2)) (A i‚ÇÅ) (A i‚ÇÄ))) (Nat.cast.{0} (WithBot.{0} Nat) (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Polynomial.natDegree.{u1} Fq (Ring.toSemiring.{u1} Fq _inst_2) b) d)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_approx_polynomial_aux Polynomial.exists_approx_polynomial_aux‚Çì'. -/
/-- If `A` is a family of enough low-degree polynomials over a finite ring,
there is a pair of elements in `A` (with different indices but not necessarily
distinct), such that their difference has small degree. -/
theorem exists_approx_polynomial_aux [Ring Fq] {d : ‚Ñï} {m : ‚Ñï} (hm : Fintype.card Fq ^ d ‚â§ m)
    (b : Fq[X]) (A : Fin m.succ ‚Üí Fq[X]) (hA : ‚àÄ i, degree (A i) < degree b) :
    ‚àÉ i‚ÇÄ i‚ÇÅ, i‚ÇÄ ‚â† i‚ÇÅ ‚àß degree (A i‚ÇÅ - A i‚ÇÄ) < ‚Üë(natDegree b - d) :=
  by
  have hb : b ‚â† 0 := by
    rintro rfl
    specialize hA 0
    rw [degree_zero] at hA
    exact not_lt_of_le bot_le hA
  -- Since there are > q^d elements of A, and only q^d choices for the highest `d` coefficients,
  -- there must be two elements of A with the same coefficients at
  -- `degree b - 1`, ... `degree b - d`.
  -- In other words, the following map is not injective:
  set f : Fin m.succ ‚Üí Fin d ‚Üí Fq := fun i j => (A i).Coeff (nat_degree b - j.succ)
  have : Fintype.card (Fin d ‚Üí Fq) < Fintype.card (Fin m.succ) := by
    simpa using lt_of_le_of_lt hm (Nat.lt_succ_self m)
  -- Therefore, the differences have all coefficients higher than `deg b - d` equal.
  obtain ‚ü®i‚ÇÄ, i‚ÇÅ, i_ne, i_eq‚ü© := Fintype.exists_ne_map_eq_of_card_lt f this
  use i‚ÇÄ, i‚ÇÅ, i_ne
  refine' (degree_lt_iff_coeff_zero _ _).mpr fun j hj => _
  -- The coefficients higher than `deg b` are the same because they are equal to 0.
  by_cases hbj : degree b ‚â§ j
  ¬∑ refine' coeff_eq_zero_of_degree_lt (lt_of_lt_of_le _ hbj)
    exact lt_of_le_of_lt (degree_sub_le _ _) (max_lt (hA _) (hA _))
  -- So we only need to look for the coefficients between `deg b - d` and `deg b`.
  rw [coeff_sub, sub_eq_zero]
  rw [not_le, degree_eq_nat_degree hb, WithBot.coe_lt_coe] at hbj
  have hj : nat_degree b - j.succ < d :=
    by
    by_cases hd : nat_degree b < d
    ¬∑ exact lt_of_le_of_lt tsub_le_self hd
    ¬∑ rw [not_lt] at hd
      have := lt_of_le_of_lt hj (Nat.lt_succ_self j)
      rwa [tsub_lt_iff_tsub_lt hd hbj] at this
  have : j = b.nat_degree - (nat_degree b - j.succ).succ := by
    rw [‚Üê Nat.succ_sub hbj, Nat.succ_sub_succ, tsub_tsub_cancel_of_le hbj.le]
  convert congr_fun i_eq.symm ‚ü®nat_degree b - j.succ, hj‚ü©
#align polynomial.exists_approx_polynomial_aux Polynomial.exists_approx_polynomial_aux

variable [Field Fq]

/- warning: polynomial.exists_approx_polynomial -> Polynomial.exists_approx_polynomial is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] {b : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) b (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) 0 (Zero.zero.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.zero.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))))))) -> (forall {Œµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Œµ) -> (forall (A : (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) -> (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2))))), Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) (fun (i‚ÇÄ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) => Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) (fun (i‚ÇÅ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) => And (Ne.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) i‚ÇÄ i‚ÇÅ) (LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTC‚Çì.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.hasMod.{u1} Fq _inst_2)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.hasMod.{u1} Fq _inst_2)) (A i‚ÇÄ) b)))) (SMul.smul.{0, 0} Int Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.addGroup)) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) b) Œµ))))))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] {b : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) b (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2))))))) -> (forall {Œµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Œµ) -> (forall (A : (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) -> (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2))))), Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) (fun (i‚ÇÄ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) => Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) (fun (i‚ÇÅ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) => And (Ne.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) i‚ÇÄ i‚ÇÅ) (LT.lt.{0} Real Real.instLTReal (Int.cast.{0} Real Real.intCast (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.instModPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_2)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.instModPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_2)) (A i‚ÇÄ) b)))) (HSMul.hSMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) b) Real Real (instHSMul.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) b) Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.instAddGroupReal))) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) b) Œµ))))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_approx_polynomial Polynomial.exists_approx_polynomial‚Çì'. -/
/-- If `A` is a family of enough low-degree polynomials over a finite field,
there is a pair of elements in `A` (with different indices but not necessarily
distinct), such that the difference of their remainders is close together. -/
theorem exists_approx_polynomial {b : Fq[X]} (hb : b ‚â† 0) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ)
    (A : Fin (Fintype.card Fq ^ ‚åà-log Œµ / log (Fintype.card Fq)‚åâ‚Çä).succ ‚Üí Fq[X]) :
    ‚àÉ i‚ÇÄ i‚ÇÅ, i‚ÇÄ ‚â† i‚ÇÅ ‚àß (cardPowDegree (A i‚ÇÅ % b - A i‚ÇÄ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ :=
  by
  have hbŒµ : 0 < card_pow_degree b ‚Ä¢ Œµ :=
    by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hŒµ
  have one_lt_q : 1 < Fintype.card Fq := Fintype.one_lt_card
  have one_lt_q' : (1 : ‚Ñù) < Fintype.card Fq := by assumption_mod_cast
  have q_pos : 0 < Fintype.card Fq := by linarith
  have q_pos' : (0 : ‚Ñù) < Fintype.card Fq := by assumption_mod_cast
  -- If `b` is already small enough, then the remainders are equal and we are done.
  by_cases le_b : b.nat_degree ‚â§ ‚åà-log Œµ / log (Fintype.card Fq)‚åâ‚Çä
  ¬∑ obtain ‚ü®i‚ÇÄ, i‚ÇÅ, i_ne, mod_eq‚ü© :=
      exists_eq_polynomial le_rfl b le_b (fun i => A i % b) fun i => EuclideanDomain.mod_lt (A i) hb
    refine' ‚ü®i‚ÇÄ, i‚ÇÅ, i_ne, _‚ü©
    simp only at mod_eq
    rwa [mod_eq, sub_self, map_zero, Int.cast_zero]
  -- Otherwise, it suffices to choose two elements whose difference is of small enough degree.
  rw [not_le] at le_b
  obtain ‚ü®i‚ÇÄ, i‚ÇÅ, i_ne, deg_lt‚ü© :=
    exists_approx_polynomial_aux le_rfl b (fun i => A i % b) fun i =>
      EuclideanDomain.mod_lt (A i) hb
  simp only at deg_lt
  use i‚ÇÄ, i‚ÇÅ, i_ne
  -- Again, if the remainders are equal we are done.
  by_cases h : A i‚ÇÅ % b = A i‚ÇÄ % b
  ¬∑ rwa [h, sub_self, map_zero, Int.cast_zero]
  have h' : A i‚ÇÅ % b - A i‚ÇÄ % b ‚â† 0 := mt sub_eq_zero.mp h
  -- If the remainders are not equal, we'll show their difference is of small degree.
  -- In particular, we'll show the degree is less than the following:
  suffices (nat_degree (A i‚ÇÅ % b - A i‚ÇÄ % b) : ‚Ñù) < b.nat_degree + log Œµ / log (Fintype.card Fq) by
    rwa [‚Üê Real.log_lt_log_iff (int.cast_pos.mpr (card_pow_degree.pos h')) hbŒµ,
      card_pow_degree_nonzero _ h', card_pow_degree_nonzero _ hb, Algebra.smul_def, eq_intCast,
      Int.cast_pow, Int.cast_ofNat, Int.cast_pow, Int.cast_ofNat,
      log_mul (pow_ne_zero _ q_pos'.ne') hŒµ.ne', ‚Üê rpow_nat_cast, ‚Üê rpow_nat_cast, log_rpow q_pos',
      log_rpow q_pos', ‚Üê lt_div_iff (log_pos one_lt_q'), add_div,
      mul_div_cancel _ (log_pos one_lt_q').ne']
  -- And that result follows from manipulating the result from `exists_approx_polynomial_aux`
  -- to turn the `-‚åà-stuff‚åâ‚Çä` into `+ stuff`.
  refine' lt_of_lt_of_le (nat.cast_lt.mpr (with_bot.coe_lt_coe.mp _)) _
  swap
  ¬∑ convert deg_lt
    rw [degree_eq_nat_degree h']
  rw [‚Üê sub_neg_eq_add, neg_div]
  refine' le_trans _ (sub_le_sub_left (Nat.le_ceil _) (b.nat_degree : ‚Ñù))
  rw [‚Üê neg_div]
  exact le_of_eq (Nat.cast_sub le_b.le)
#align polynomial.exists_approx_polynomial Polynomial.exists_approx_polynomial

/- warning: polynomial.card_pow_degree_anti_archimedean -> Polynomial.cardPowDegree_anti_archimedean is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] {x : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))} {y : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))} {z : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))} {a : Int}, (LT.lt.{0} Int Int.hasLt (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) x y)) a) -> (LT.lt.{0} Int Int.hasLt (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) y z)) a) -> (LT.lt.{0} Int Int.hasLt (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) x z)) a)
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] {x : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))} {y : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))} {z : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))} {a : Int}, (LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) x y)) Int.instLTInt (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) x y)) a) -> (LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) y z)) Int.instLTInt (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) y z)) a) -> (LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) x z)) Int.instLTInt (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) x z)) a)
Case conversion may be inaccurate. Consider using '#align polynomial.card_pow_degree_anti_archimedean Polynomial.cardPowDegree_anti_archimedean‚Çì'. -/
/-- If `x` is close to `y` and `y` is close to `z`, then `x` and `z` are at least as close. -/
theorem cardPowDegree_anti_archimedean {x y z : Fq[X]} {a : ‚Ñ§} (hxy : cardPowDegree (x - y) < a)
    (hyz : cardPowDegree (y - z) < a) : cardPowDegree (x - z) < a :=
  by
  have ha : 0 < a := lt_of_le_of_lt (AbsoluteValue.nonneg _ _) hxy
  by_cases hxy' : x = y
  ¬∑ rwa [hxy']
  by_cases hyz' : y = z
  ¬∑ rwa [‚Üê hyz']
  by_cases hxz' : x = z
  ¬∑ rwa [hxz', sub_self, map_zero]
  rw [‚Üê Ne.def, ‚Üê sub_ne_zero] at hxy' hyz' hxz'
  refine' lt_of_le_of_lt _ (max_lt hxy hyz)
  rw [card_pow_degree_nonzero _ hxz', card_pow_degree_nonzero _ hxy',
    card_pow_degree_nonzero _ hyz']
  have : (1 : ‚Ñ§) ‚â§ Fintype.card Fq := by exact_mod_cast (@Fintype.one_lt_card Fq _ _).le
  simp only [Int.cast_pow, Int.cast_ofNat, le_max_iff]
  refine' Or.imp (pow_le_pow this) (pow_le_pow this) _
  rw [nat_degree_le_iff_degree_le, nat_degree_le_iff_degree_le, ‚Üê le_max_iff, ‚Üê
    degree_eq_nat_degree hxy', ‚Üê degree_eq_nat_degree hyz']
  convert degree_add_le (x - y) (y - z) using 2
  exact (sub_add_sub_cancel _ _ _).symm
#align polynomial.card_pow_degree_anti_archimedean Polynomial.cardPowDegree_anti_archimedean

/- warning: polynomial.exists_partition_polynomial_aux -> Polynomial.exists_partition_polynomial_aux is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] (n : Nat) {Œµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Œµ) -> (forall {b : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) b (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) 0 (Zero.zero.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.zero.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))))))) -> (forall (A : (Fin n) -> (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2))))), Exists.{1} ((Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) (fun (t : (Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) => forall (i‚ÇÄ : Fin n) (i‚ÇÅ : Fin n), Iff (Eq.{1} (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1))))))) (t i‚ÇÄ) (t i‚ÇÅ)) (LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTC‚Çì.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.hasMod.{u1} Fq _inst_2)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.hasMod.{u1} Fq _inst_2)) (A i‚ÇÄ) b)))) (SMul.smul.{0, 0} Int Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.addGroup)) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) b) Œµ)))))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] (n : Nat) {Œµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Œµ) -> (forall {b : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) b (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2))))))) -> (forall (A : (Fin n) -> (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2))))), Exists.{1} ((Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) (fun (t : (Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) => forall (i‚ÇÄ : Fin n) (i‚ÇÅ : Fin n), Iff (Eq.{1} (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1))))))) (t i‚ÇÄ) (t i‚ÇÅ)) (LT.lt.{0} Real Real.instLTReal (Int.cast.{0} Real Real.intCast (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.instModPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_2)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.instModPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_2)) (A i‚ÇÄ) b)))) (HSMul.hSMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) b) Real Real (instHSMul.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) b) Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.instAddGroupReal))) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) b) Œµ)))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_partition_polynomial_aux Polynomial.exists_partition_polynomial_aux‚Çì'. -/
/-- A slightly stronger version of `exists_partition` on which we perform induction on `n`:
for all `Œµ > 0`, we can partition the remainders of any family of polynomials `A`
into equivalence classes, where the equivalence(!) relation is "closer than `Œµ`". -/
theorem exists_partition_polynomial_aux (n : ‚Ñï) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : Fq[X]} (hb : b ‚â† 0)
    (A : Fin n ‚Üí Fq[X]) :
    ‚àÉ t : Fin n ‚Üí Fin (Fintype.card Fq ^ ‚åà-log Œµ / log (Fintype.card Fq)‚åâ‚Çä),
      ‚àÄ i‚ÇÄ i‚ÇÅ : Fin n,
        t i‚ÇÄ = t i‚ÇÅ ‚Üî (cardPowDegree (A i‚ÇÅ % b - A i‚ÇÄ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ :=
  by
  have hbŒµ : 0 < card_pow_degree b ‚Ä¢ Œµ :=
    by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hŒµ
  -- We go by induction on the size `A`.
  induction' n with n ih
  ¬∑ refine' ‚ü®finZeroElim, finZeroElim‚ü©
  -- Show `anti_archimedean` also holds for real distances.
  have anti_archim' :
    ‚àÄ {i j k} {Œµ : ‚Ñù},
      (card_pow_degree (A i % b - A j % b) : ‚Ñù) < Œµ ‚Üí
        (card_pow_degree (A j % b - A k % b) : ‚Ñù) < Œµ ‚Üí
          (card_pow_degree (A i % b - A k % b) : ‚Ñù) < Œµ :=
    by
    intro i j k Œµ
    simp_rw [‚Üê Int.lt_ceil]
    exact card_pow_degree_anti_archimedean
  obtain ‚ü®t', ht'‚ü© := ih (Fin.tail A)
  -- We got rid of `A 0`, so determine the index `j` of the partition we'll re-add it to.
  rsuffices ‚ü®j, hj‚ü© :
    ‚àÉ j, ‚àÄ i, t' i = j ‚Üî (card_pow_degree (A 0 % b - A i.succ % b) : ‚Ñù) < card_pow_degree b ‚Ä¢ Œµ
  ¬∑ refine' ‚ü®Fin.cons j t', fun i‚ÇÄ i‚ÇÅ => _‚ü©
    refine' Fin.cases _ (fun i‚ÇÄ => _) i‚ÇÄ <;> refine' Fin.cases _ (fun i‚ÇÅ => _) i‚ÇÅ
    ¬∑ simpa using hbŒµ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i‚ÇÅ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i‚ÇÄ
    ¬∑ rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' i‚ÇÄ i‚ÇÅ
  -- `exists_approx_polynomial` guarantees that we can insert `A 0` into some partition `j`,
  -- but not that `j` is uniquely defined (which is needed to keep the induction going).
  obtain ‚ü®j, hj‚ü© :
    ‚àÉ j,
      ‚àÄ i : Fin n,
        t' i = j ‚Üí (card_pow_degree (A 0 % b - A i.succ % b) : ‚Ñù) < card_pow_degree b ‚Ä¢ Œµ :=
    by
    by_contra this
    push_neg  at this
    obtain ‚ü®j‚ÇÄ, j‚ÇÅ, j_ne, approx‚ü© :=
      exists_approx_polynomial hb hŒµ
        (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (this j))))
    revert j_ne approx
    refine' Fin.cases _ (fun j‚ÇÄ => _) j‚ÇÄ <;>
      refine' Fin.cases (fun j_ne approx => _) (fun j‚ÇÅ j_ne approx => _) j‚ÇÅ
    ¬∑ exact absurd rfl j_ne
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (this j‚ÇÅ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (this j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne.def, Fin.succ_inj] at j_ne
      have : j‚ÇÄ = j‚ÇÅ :=
        (Classical.choose_spec (this j‚ÇÄ)).1.symm.trans
          (((ht' (Classical.choose (this j‚ÇÄ)) (Classical.choose (this j‚ÇÅ))).mpr approx).trans
            (Classical.choose_spec (this j‚ÇÅ)).1)
      contradiction
  -- However, if one of those partitions `j` is inhabited by some `i`, then this `j` works.
  by_cases exists_nonempty_j :
    ‚àÉ j,
      (‚àÉ i, t' i = j) ‚àß
        ‚àÄ i, t' i = j ‚Üí (card_pow_degree (A 0 % b - A i.succ % b) : ‚Ñù) < card_pow_degree b ‚Ä¢ Œµ
  ¬∑ obtain ‚ü®j, ‚ü®i, hi‚ü©, hj‚ü© := exists_nonempty_j
    refine' ‚ü®j, fun i' => ‚ü®hj i', fun hi' => trans ((ht' _ _).mpr _) hi‚ü©‚ü©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  -- And otherwise, we can just take any `j`, since those are empty.
  refine' ‚ü®j, fun i => ‚ü®hj i, fun hi => _‚ü©‚ü©
  have := exists_nonempty_j ‚ü®t' i, ‚ü®i, rfl‚ü©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')‚ü©
  contradiction
#align polynomial.exists_partition_polynomial_aux Polynomial.exists_partition_polynomial_aux

/- warning: polynomial.exists_partition_polynomial -> Polynomial.exists_partition_polynomial is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] (n : Nat) {Œµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Œµ) -> (forall {b : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) b (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) 0 (Zero.zero.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.zero.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))))))) -> (forall (A : (Fin n) -> (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2))))), Exists.{1} ((Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) (fun (t : (Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1)))))))) => forall (i‚ÇÄ : Fin n) (i‚ÇÅ : Fin n), (Eq.{1} (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.linearOrderedRing Real.floorRing) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Real.log Œµ)) (Real.log ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Fintype.card.{u1} Fq _inst_1))))))) (t i‚ÇÄ) (t i‚ÇÅ)) -> (LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTC‚Çì.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.hasMod.{u1} Fq _inst_2)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.hasMod.{u1} Fq _inst_2)) (A i‚ÇÄ) b)))) (SMul.smul.{0, 0} Int Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.addGroup)) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) b) Œµ)))))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq] (n : Nat) {Œµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Œµ) -> (forall {b : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) b (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2))))))) -> (forall (A : (Fin n) -> (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2))))), Exists.{1} ((Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) (fun (t : (Fin n) -> (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1)))))))) => forall (i‚ÇÄ : Fin n) (i‚ÇÅ : Fin n), (Eq.{1} (Fin (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u1} Fq _inst_1) (Nat.ceil.{0} Real Real.orderedSemiring (FloorRing.toFloorSemiring.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Real.log Œµ)) (Real.log (Nat.cast.{0} Real Real.natCast (Fintype.card.{u1} Fq _inst_1))))))) (t i‚ÇÄ) (t i‚ÇÅ)) -> (LT.lt.{0} Real Real.instLTReal (Int.cast.{0} Real Real.intCast (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHSub.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.sub.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.instModPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_2)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (instHMod.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.instModPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_2)) (A i‚ÇÄ) b)))) (HSMul.hSMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) b) Real Real (instHSMul.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) b) Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.instAddGroupReal))) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1) b) Œµ)))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_partition_polynomial Polynomial.exists_partition_polynomial‚Çì'. -/
/-- For all `Œµ > 0`, we can partition the remainders of any family of polynomials `A`
into classes, where all remainders in a class are close together. -/
theorem exists_partition_polynomial (n : ‚Ñï) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : Fq[X]} (hb : b ‚â† 0)
    (A : Fin n ‚Üí Fq[X]) :
    ‚àÉ t : Fin n ‚Üí Fin (Fintype.card Fq ^ ‚åà-log Œµ / log (Fintype.card Fq)‚åâ‚Çä),
      ‚àÄ i‚ÇÄ i‚ÇÅ : Fin n,
        t i‚ÇÄ = t i‚ÇÅ ‚Üí (cardPowDegree (A i‚ÇÅ % b - A i‚ÇÄ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ :=
  by
  obtain ‚ü®t, ht‚ü© := exists_partition_polynomial_aux n hŒµ hb A
  exact ‚ü®t, fun i‚ÇÄ i‚ÇÅ hi => (ht i‚ÇÄ i‚ÇÅ).mp hi‚ü©
#align polynomial.exists_partition_polynomial Polynomial.exists_partition_polynomial

/- warning: polynomial.card_pow_degree_is_admissible -> Polynomial.cardPowDegreeIsAdmissible is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq], AbsoluteValue.IsAdmissible.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_2)))) (Polynomial.euclideanDomain.{u1} Fq _inst_2) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1)
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Fintype.{u1} Fq] [_inst_2 : Field.{u1} Fq], AbsoluteValue.IsAdmissible.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_2)))) (Polynomial.instEuclideanDomainPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_2) (Polynomial.cardPowDegree.{u1} Fq _inst_2 _inst_1)
Case conversion may be inaccurate. Consider using '#align polynomial.card_pow_degree_is_admissible Polynomial.cardPowDegreeIsAdmissible‚Çì'. -/
/-- `Œª p, fintype.card Fq ^ degree p` is an admissible absolute value.
We set `q ^ degree 0 = 0`. -/
noncomputable def cardPowDegreeIsAdmissible :
    IsAdmissible (cardPowDegree : AbsoluteValue Fq[X] ‚Ñ§) :=
  {
    @cardPowDegree_isEuclidean Fq _
      _ with
    card := fun Œµ => Fintype.card Fq ^ ‚åà-log Œµ / log (Fintype.card Fq)‚åâ‚Çä
    exists_partition' := fun n Œµ hŒµ b hb => exists_partition_polynomial n hŒµ hb }
#align polynomial.card_pow_degree_is_admissible Polynomial.cardPowDegreeIsAdmissible

end Polynomial

