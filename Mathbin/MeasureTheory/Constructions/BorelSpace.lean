import Mathbin.MeasureTheory.Function.AeMeasurableSequence 
import Mathbin.Analysis.Complex.Basic 
import Mathbin.Analysis.NormedSpace.FiniteDimension 
import Mathbin.Topology.GDelta 
import Mathbin.MeasureTheory.Group.Arithmetic 
import Mathbin.Topology.Semicontinuous 
import Mathbin.Topology.Instances.Ereal 
import Mathbin.Topology.ContinuousFunction.Basic

/-!
# Borel (measurable) space

## Main definitions

* `borel Î±` : the least `Ïƒ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `â€¹measurable_space Î±â€º = borel Î±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Î± â‰¤ â€¹measurable_space Î±â€º`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `â„`, `â„â‰¥0`, `â„â‰¥0âˆ`.

## Main statements

* `is_open.measurable_set`, `is_closed.measurable_set`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Î± â†’ Î²` and `g : Î± â†’ Î³` are measurable and `op : Î² Ã— Î³ â†’ Î´`
  is continuous, then `Î» x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `â„â‰¥0âˆ`.
-/


noncomputable theory

open Classical Set Filter MeasureTheory

open_locale Classical BigOperators TopologicalSpace Nnreal Ennreal Interval

universe u v w x y

variable{Î± Î² Î³ Î³â‚‚ Î´ : Type _}{Î¹ : Sort y}{s t u : Set Î±}

open MeasurableSpace TopologicalSpace

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Î± : Type u) [TopologicalSpace Î±] : MeasurableSpace Î± :=
  generate_from { s : Set Î± | IsOpen s }

theorem borel_eq_top_of_discrete [TopologicalSpace Î±] [DiscreteTopology Î±] : borel Î± = âŠ¤ :=
  top_le_iff.1$ fun s hs => generate_measurable.basic s (is_open_discrete s)

theorem borel_eq_top_of_encodable [TopologicalSpace Î±] [T1Space Î±] [Encodable Î±] : borel Î± = âŠ¤ :=
  by 
    refine' top_le_iff.1$ fun s hs => bUnion_of_singleton s â–¸ _ 
    apply MeasurableSet.bUnion s.countable_encodable 
    intro x hx 
    apply MeasurableSet.of_compl 
    apply generate_measurable.basic 
    exact is_closed_singleton.is_open_compl

theorem borel_eq_generate_from_of_subbasis {s : Set (Set Î±)} [t : TopologicalSpace Î±] [second_countable_topology Î±]
  (hs : t = generate_from s) : borel Î± = generate_from s :=
  le_antisymmâ‚“
    (generate_from_le$
      fun u hu : t.is_open u =>
        by 
          rw [hs] at hu 
          induction hu 
          case generate_open.basic u hu => 
            exact generate_measurable.basic u hu 
          case generate_open.univ => 
            exact @MeasurableSet.univ Î± (generate_from s)
          case generate_open.inter sâ‚ sâ‚‚ _ _ hsâ‚ hsâ‚‚ => 
            exact @MeasurableSet.inter Î± (generate_from s) _ _ hsâ‚ hsâ‚‚ 
          case generate_open.sUnion f hf ih => 
            rcases
              is_open_sUnion_countable f
                (by 
                  rwa [hs]) with
              âŸ¨v, hv, vf, vuâŸ©
            rw [â†vu]
            exact @MeasurableSet.sUnion Î± (generate_from s) _ hv fun x xv => ih _ (vf xv))
    (generate_from_le$
      fun u hu =>
        generate_measurable.basic _$
          show t.is_open u by 
            rw [hs] <;> exact generate_open.basic _ hu)

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generate_from [TopologicalSpace Î±] [second_countable_topology Î±]
  {s : Set (Set Î±)} (hs : is_topological_basis s) : borel Î± = generate_from s :=
  borel_eq_generate_from_of_subbasis hs.eq_generate_from

theorem is_pi_system_is_open [TopologicalSpace Î±] : IsPiSystem (IsOpen : Set Î± â†’ Prop) :=
  fun s t hs ht hst => IsOpen.inter hs ht

theorem borel_eq_generate_from_is_closed [TopologicalSpace Î±] : borel Î± = generate_from { s | IsClosed s } :=
  le_antisymmâ‚“
    (generate_from_le$
      fun t ht =>
        @MeasurableSet.of_compl Î± _ (generate_from { s | IsClosed s })
          (generate_measurable.basic _$ is_closed_compl_iff.2 ht))
    (generate_from_le$
      fun t ht => @MeasurableSet.of_compl Î± _ (borel Î±) (generate_measurable.basic _$ is_open_compl_iff.2 ht))

section OrderTopology

variable(Î±)

variable[TopologicalSpace Î±][second_countable_topology Î±][LinearOrderâ‚“ Î±][OrderTopology Î±]

theorem borel_eq_generate_from_Iio : borel Î± = generate_from (range Iio) :=
  by 
    refine' le_antisymmâ‚“ _ (generate_from_le _)
    Â·
      rw [borel_eq_generate_from_of_subbasis (@OrderTopology.topology_eq_generate_intervals Î± _ _ _)]
      letI this : MeasurableSpace Î± := MeasurableSpace.generateFrom (range Iio)
      have H : âˆ€ a : Î±, MeasurableSet (Iio a) := fun a => generate_measurable.basic _ âŸ¨_, rflâŸ©
      refine' generate_from_le _ 
      rintro _ âŸ¨a, rfl | rflâŸ© <;> [skip, apply H]
      byCases' h : âˆƒ a', âˆ€ b, a < b â†” a' â‰¤ b
      Â·
        rcases h with âŸ¨a', ha'âŸ©
        rw [(_ : Ioi a = Â«expr á¶œÂ» (Iio a'))]
        Â·
          exact (H _).Compl 
        simp [Set.ext_iff, ha']
      Â·
        rcases is_open_Union_countable (fun a' : { a' : Î± // a < a' } => { b | a'.1 < b }) fun a' => is_open_lt' _ with
          âŸ¨v, âŸ¨hvâŸ©, vuâŸ©
        simp [Set.ext_iff] at vu 
        have  : Ioi a = â‹ƒx : v, Â«expr á¶œÂ» (Iio x.1.1)
        Â·
          simp [Set.ext_iff]
          refine' fun x => âŸ¨fun ax => _, fun âŸ¨a', âŸ¨h, avâŸ©, axâŸ© => lt_of_lt_of_leâ‚“ h axâŸ©
          rcases(vu x).2 _ with âŸ¨a', hâ‚, hâ‚‚âŸ©
          Â·
            exact âŸ¨a', hâ‚, le_of_ltâ‚“ hâ‚‚âŸ©
          refine' not_imp_comm.1 (fun h => _) h 
          exact âŸ¨x, fun b => âŸ¨fun ab => le_of_not_ltâ‚“ fun h' => h âŸ¨b, ab, h'âŸ©, lt_of_lt_of_leâ‚“ axâŸ©âŸ©
        rw [this]
        resetI 
        apply MeasurableSet.Union 
        exact fun _ => (H _).Compl
    Â·
      rw [forall_range_iff]
      intro a 
      exact generate_measurable.basic _ is_open_Iio

theorem borel_eq_generate_from_Ioi : borel Î± = generate_from (range Ioi) :=
  @borel_eq_generate_from_Iio (OrderDual Î±) _
    (by 
      infer_instance :
    second_countable_topology Î±)
    _ _

end OrderTopology

theorem borel_comap {f : Î± â†’ Î²} {t : TopologicalSpace Î²} : @borel Î± (t.induced f) = (@borel Î² t).comap f :=
  comap_generate_from.symm

theorem Continuous.borel_measurable [TopologicalSpace Î±] [TopologicalSpace Î²] {f : Î± â†’ Î²} (hf : Continuous f) :
  @Measurable Î± Î² (borel Î±) (borel Î²) f :=
  Measurable.of_le_map$ generate_from_le$ fun s hs => generate_measurable.basic (f â»Â¹' s) (hs.preimage hf)

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace(Î± : Type _)[TopologicalSpace Î±][h : MeasurableSpace Î±] : Prop where 
  borel_le : borel Î± â‰¤ h

/-- A space with `measurable_space` and `topological_space` structures such that
the `Ïƒ`-algebra of measurable sets is exactly the `Ïƒ`-algebra generated by open sets. -/
class BorelSpace(Î± : Type _)[TopologicalSpace Î±][MeasurableSpace Î±] : Prop where 
  measurable_eq : â€¹MeasurableSpace Î±â€º = borel Î±

/-- In a `borel_space` all open sets are measurable. -/
instance (priority := 100)BorelSpace.opens_measurable {Î± : Type _} [TopologicalSpace Î±] [MeasurableSpace Î±]
  [BorelSpace Î±] : OpensMeasurableSpace Î± :=
  âŸ¨ge_of_eq$ BorelSpace.measurable_eqâŸ©

instance Subtype.borel_space {Î± : Type _} [TopologicalSpace Î±] [MeasurableSpace Î±] [hÎ± : BorelSpace Î±] (s : Set Î±) :
  BorelSpace s :=
  âŸ¨by 
      rw [hÎ±.1, Subtype.measurableSpace, â†borel_comap]
      rflâŸ©

instance Subtype.opens_measurable_space {Î± : Type _} [TopologicalSpace Î±] [MeasurableSpace Î±]
  [h : OpensMeasurableSpace Î±] (s : Set Î±) : OpensMeasurableSpace s :=
  âŸ¨by 
      rw [borel_comap]
      exact comap_mono h.1âŸ©

theorem _root_.measurable_set.induction_on_open [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±]
  {C : Set Î± â†’ Prop} (h_open : âˆ€ U, IsOpen U â†’ C U) (h_compl : âˆ€ t, MeasurableSet t â†’ C t â†’ C (Â«expr á¶œÂ» t))
  (h_union : âˆ€ f : â„• â†’ Set Î±, Pairwise (Disjoint on f) â†’ (âˆ€ i, MeasurableSet (f i)) â†’ (âˆ€ i, C (f i)) â†’ C (â‹ƒi, f i)) :
  âˆ€ â¦ƒtâ¦„, MeasurableSet t â†’ C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq is_pi_system_is_open (h_open _ is_open_empty) h_open
    h_compl h_union

section 

variable[TopologicalSpace
      Î±][MeasurableSpace
      Î±][OpensMeasurableSpace
      Î±][TopologicalSpace
      Î²][MeasurableSpace
      Î²][OpensMeasurableSpace
      Î²][TopologicalSpace
      Î³][MeasurableSpace Î³][BorelSpace Î³][TopologicalSpace Î³â‚‚][MeasurableSpace Î³â‚‚][BorelSpace Î³â‚‚][MeasurableSpace Î´]

theorem IsOpen.measurable_set (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _$ generate_measurable.basic _ h

@[measurability]
theorem measurable_set_interior : MeasurableSet (Interior s) :=
  is_open_interior.MeasurableSet

theorem IsGÎ´.measurable_set (h : IsGÎ´ s) : MeasurableSet s :=
  by 
    rcases h with âŸ¨S, hSo, hSc, rflâŸ©
    exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).MeasurableSet

theorem measurable_set_of_continuous_at {Î²} [EmetricSpace Î²] (f : Î± â†’ Î²) : MeasurableSet { x | ContinuousAt f x } :=
  (is_GÎ´_set_of_continuous_at f).MeasurableSet

theorem IsClosed.measurable_set (h : IsClosed s) : MeasurableSet s :=
  h.is_open_compl.measurable_set.of_compl

theorem IsCompact.measurable_set [T2Space Î±] (h : IsCompact s) : MeasurableSet s :=
  h.is_closed.measurable_set

@[measurability]
theorem measurable_set_closure : MeasurableSet (Closure s) :=
  is_closed_closure.MeasurableSet

theorem measurable_of_is_open {f : Î´ â†’ Î³} (hf : âˆ€ s, IsOpen s â†’ MeasurableSet (f â»Â¹' s)) : Measurable f :=
  by 
    rw [â€¹BorelSpace Î³â€º.measurable_eq]
    exact measurable_generate_from hf

theorem measurable_of_is_closed {f : Î´ â†’ Î³} (hf : âˆ€ s, IsClosed s â†’ MeasurableSet (f â»Â¹' s)) : Measurable f :=
  by 
    apply measurable_of_is_open 
    intro s hs 
    rw [â†MeasurableSet.compl_iff, â†preimage_compl]
    apply hf 
    rw [is_closed_compl_iff]
    exact hs

theorem measurable_of_is_closed' {f : Î´ â†’ Î³} (hf : âˆ€ s, IsClosed s â†’ s.nonempty â†’ s â‰  univ â†’ MeasurableSet (f â»Â¹' s)) :
  Measurable f :=
  by 
    apply measurable_of_is_closed 
    intro s hs 
    cases' eq_empty_or_nonempty s with h1 h1
    Â·
      simp [h1]
    byCases' h2 : s = univ
    Â·
      simp [h2]
    exact hf s hs h1 h2

instance nhds_is_measurably_generated (a : Î±) : (ğ“ a).IsMeasurablyGenerated :=
  by 
    rw [nhds, infi_subtype']
    refine' @Filter.infi_is_measurably_generated _ _ _ _ fun i => _ 
    exact i.2.2.MeasurableSet.principal_is_measurably_generated

/-- If `s` is a measurable set, then `ğ“[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.
-/
theorem MeasurableSet.nhds_within_is_measurably_generated {s : Set Î±} (hs : MeasurableSet s) (a : Î±) :
  (ğ“[s] a).IsMeasurablyGenerated :=
  by 
    haveI  := hs.principal_is_measurably_generated <;> exact Filter.inf_is_measurably_generated _ _

instance (priority := 100)OpensMeasurableSpace.to_measurable_singleton_class [T1Space Î±] : MeasurableSingletonClass Î± :=
  âŸ¨fun x => is_closed_singleton.MeasurableSetâŸ©

instance Pi.opens_measurable_space_encodable {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [Encodable Î¹]
  [t' : âˆ€ i, TopologicalSpace (Ï€ i)] [âˆ€ i, MeasurableSpace (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)]
  [âˆ€ i, OpensMeasurableSpace (Ï€ i)] : OpensMeasurableSpace (âˆ€ i, Ï€ i) :=
  by 
    constructor 
    have  :
      Pi.topologicalSpace =
        generate_from
          { t |
            âˆƒ (s : âˆ€ a, Set (Ï€ a))(i : Finset Î¹), (âˆ€ a _ : a âˆˆ i, s a âˆˆ countable_basis (Ï€ a)) âˆ§ t = pi (Â«exprâ†‘ Â» i) s }
    Â·
      rw [funext fun a => @eq_generate_from_countable_basis (Ï€ a) _ _, pi_generate_from_eq]
    rw [borel_eq_generate_from_of_subbasis this]
    apply generate_from_le 
    rintro _ âŸ¨s, i, hi, rflâŸ©
    refine' MeasurableSet.pi i.countable_to_set fun a ha => IsOpen.measurable_set _ 
    rw [eq_generate_from_countable_basis (Ï€ a)]
    exact generate_open.basic _ (hi a ha)

instance Pi.opens_measurable_space_fintype {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [Fintype Î¹] [t' : âˆ€ i, TopologicalSpace (Ï€ i)]
  [âˆ€ i, MeasurableSpace (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)] [âˆ€ i, OpensMeasurableSpace (Ï€ i)] :
  OpensMeasurableSpace (âˆ€ i, Ï€ i) :=
  by 
    letI this := Fintype.encodable Î¹ 
    infer_instance

instance Prod.opens_measurable_space [second_countable_topology Î±] [second_countable_topology Î²] :
  OpensMeasurableSpace (Î± Ã— Î²) :=
  by 
    constructor 
    rw [((is_basis_countable_basis Î±).Prod (is_basis_countable_basis Î²)).borel_eq_generate_from]
    apply generate_from_le 
    rintro _ âŸ¨u, v, hu, hv, rflâŸ©
    exact (is_open_of_mem_countable_basis hu).MeasurableSet.Prod (is_open_of_mem_countable_basis hv).MeasurableSet

variable{Î±' : Type _}[TopologicalSpace Î±'][MeasurableSpace Î±']

theorem measure_interior_of_null_bdry {Î¼ : Measureâ‚“ Î±'} {s : Set Î±'} (h_nullbdry : Î¼ (Frontier s) = 0) :
  Î¼ (Interior s) = Î¼ s :=
  measure_eq_measure_smaller_of_between_null_diff interior_subset subset_closure h_nullbdry

theorem measure_closure_of_null_bdry {Î¼ : Measureâ‚“ Î±'} {s : Set Î±'} (h_nullbdry : Î¼ (Frontier s) = 0) :
  Î¼ (Closure s) = Î¼ s :=
  (measure_eq_measure_larger_of_between_null_diff interior_subset subset_closure h_nullbdry).symm

section Preorderâ‚“

variable[Preorderâ‚“ Î±][OrderClosedTopology Î±]{a b x : Î±}

@[simp, measurability]
theorem measurable_set_Ici : MeasurableSet (Ici a) :=
  is_closed_Ici.MeasurableSet

@[simp, measurability]
theorem measurable_set_Iic : MeasurableSet (Iic a) :=
  is_closed_Iic.MeasurableSet

@[simp, measurability]
theorem measurable_set_Icc : MeasurableSet (Icc a b) :=
  is_closed_Icc.MeasurableSet

instance nhds_within_Ici_is_measurably_generated : (ğ“[Ici b] a).IsMeasurablyGenerated :=
  measurable_set_Ici.nhds_within_is_measurably_generated _

instance nhds_within_Iic_is_measurably_generated : (ğ“[Iic b] a).IsMeasurablyGenerated :=
  measurable_set_Iic.nhds_within_is_measurably_generated _

instance nhds_within_Icc_is_measurably_generated : is_measurably_generated (ğ“[Icc a b] x) :=
  by 
    rw [â†Ici_inter_Iic, nhds_within_inter]
    infer_instance

instance at_top_is_measurably_generated : (Filter.atTop : Filter Î±).IsMeasurablyGenerated :=
  @Filter.infi_is_measurably_generated _ _ _ _$
    fun a => (measurable_set_Ici : MeasurableSet (Ici a)).principal_is_measurably_generated

instance at_bot_is_measurably_generated : (Filter.atBot : Filter Î±).IsMeasurablyGenerated :=
  @Filter.infi_is_measurably_generated _ _ _ _$
    fun a => (measurable_set_Iic : MeasurableSet (Iic a)).principal_is_measurably_generated

theorem bsupr_measure_Iic {Î¼ : Measureâ‚“ Î±} {s : Set Î±} (hsc : countable s) (hst : âˆ€ x : Î±, âˆƒ (y : _)(_ : y âˆˆ s), x â‰¤ y)
  (hdir : DirectedOn (Â· â‰¤ Â·) s) : (â¨†(x : _)(_ : x âˆˆ s), Î¼ (Iic x)) = Î¼ univ :=
  by 
    rw [â†measure_bUnion_eq_supr hsc]
    Â·
      congr 
      exact bUnion_eq_univ_iff.2 hst
    Â·
      exact fun _ _ => measurable_set_Iic
    Â·
      exact directed_on_iff_directed.2 (hdir.directed_coe.mono_comp _$ fun x y => Iic_subset_Iic.2)

end Preorderâ‚“

section PartialOrderâ‚“

variable[PartialOrderâ‚“ Î±][OrderClosedTopology Î±][second_countable_topology Î±]{a b : Î±}

@[measurability]
theorem measurable_set_le' : MeasurableSet { p : Î± Ã— Î± | p.1 â‰¤ p.2 } :=
  OrderClosedTopology.is_closed_le'.MeasurableSet

@[measurability]
theorem measurable_set_le {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) : MeasurableSet { a | f a â‰¤ g a } :=
  hf.prod_mk hg measurable_set_le'

end PartialOrderâ‚“

section LinearOrderâ‚“

variable[LinearOrderâ‚“ Î±][OrderClosedTopology Î±]{a b x : Î±}

@[simp, measurability]
theorem measurable_set_Iio : MeasurableSet (Iio a) :=
  is_open_Iio.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioi : MeasurableSet (Ioi a) :=
  is_open_Ioi.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioo : MeasurableSet (Ioo a b) :=
  is_open_Ioo.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioc : MeasurableSet (Ioc a b) :=
  measurable_set_Ioi.inter measurable_set_Iic

@[simp, measurability]
theorem measurable_set_Ico : MeasurableSet (Ico a b) :=
  measurable_set_Ici.inter measurable_set_Iio

instance nhds_within_Ioi_is_measurably_generated : (ğ“[Ioi b] a).IsMeasurablyGenerated :=
  measurable_set_Ioi.nhds_within_is_measurably_generated _

instance nhds_within_Iio_is_measurably_generated : (ğ“[Iio b] a).IsMeasurablyGenerated :=
  measurable_set_Iio.nhds_within_is_measurably_generated _

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:545:47: unsupported (impossible)
instance nhds_within_interval_is_measurably_generated : is_measurably_generated Â«exprğ“[ ] Â»(Â«expr[ , ]Â»(a, b), x) :=
nhds_within_Icc_is_measurably_generated

@[measurability]
theorem measurable_set_lt' [second_countable_topology Î±] : MeasurableSet { p : Î± Ã— Î± | p.1 < p.2 } :=
  (is_open_lt continuous_fst continuous_snd).MeasurableSet

@[measurability]
theorem measurable_set_lt [second_countable_topology Î±] {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
  MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurable_set_lt'

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:340:40: in by_contra: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
theorem set.ord_connected.measurable_set (h : ord_connected s) : measurable_set s :=
begin
  let [ident u] [] [":=", expr Â«exprâ‹ƒ , Â»((x Â«expr âˆˆ Â» s) (y Â«expr âˆˆ Â» s), Ioo x y)],
  have [ident huopen] [":", expr is_open u] [":=", expr is_open_bUnion (Î» x hx, is_open_bUnion (Î» y hy, is_open_Ioo))],
  have [ident humeas] [":", expr measurable_set u] [":=", expr huopen.measurable_set],
  have [ident hfinite] [":", expr Â«expr \ Â»(s, u).finite] [],
  { refine [expr set.finite_of_forall_between_eq_endpoints Â«expr \ Â»(s, u) (Î» x hx y hy z hz hxy hyz, _)],
    by_contra [ident h],
    push_neg ["at", ident h],
    exact [expr hy.2 (mem_bUnion_iff.mpr âŸ¨x, hx.1, mem_bUnion_iff.mpr âŸ¨z, hz.1, lt_of_le_of_ne hxy h.1, lt_of_le_of_ne hyz h.2âŸ©âŸ©)] },
  have [] [":", expr Â«expr âŠ† Â»(u, s)] [":=", expr bUnion_subset (Î»
    x hx, bUnion_subset (Î» y hy, Ioo_subset_Icc_self.trans (h.out hx hy)))],
  rw ["<-", expr union_diff_cancel this] [],
  exact [expr humeas.union hfinite.measurable_set]
end

theorem IsPreconnected.measurable_set (h : IsPreconnected s) : MeasurableSet s :=
  h.ord_connected.measurable_set

theorem generate_from_Ico_mem_le_borel {Î± : Type _} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±]
  (s t : Set Î±) :
  MeasurableSpace.generateFrom { S | âˆƒ (l : _)(_ : l âˆˆ s)(u : _)(_ : u âˆˆ t)(h : l < u), Ico l u = S } â‰¤ borel Î± :=
  by 
    apply generate_from_le 
    letI this : MeasurableSpace Î± := borel Î± 
    haveI  : BorelSpace Î± := âŸ¨rflâŸ©
    rintro _ âŸ¨a, -, b, -, -, rflâŸ©
    exact measurable_set_Ico

theorem Dense.borel_eq_generate_from_Ico_mem_aux {Î± : Type _} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±]
  [second_countable_topology Î±] {s : Set Î±} (hd : Dense s) (hbot : âˆ€ x, IsBot x â†’ x âˆˆ s)
  (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ y âˆˆ s) :
  borel Î± = generate_from { S : Set Î± | âˆƒ (l : _)(_ : l âˆˆ s)(u : _)(_ : u âˆˆ s)(h : l < u), Ico l u = S } :=
  by 
    set S : Set (Set Î±) := { S | âˆƒ (l : _)(_ : l âˆˆ s)(u : _)(_ : u âˆˆ s)(h : l < u), Ico l u = S }
    refine' le_antisymmâ‚“ _ (generate_from_Ico_mem_le_borel _ _)
    letI this : MeasurableSpace Î± := generate_from S 
    rw [borel_eq_generate_from_Iio]
    refine' generate_from_le (forall_range_iff.2$ fun a => _)
    rcases hd.exists_countable_dense_subset_bot_top with âŸ¨t, hts, hc, htd, htb, httâŸ©
    byCases' ha : âˆ€ b _ : b < a, (Ioo b a).Nonempty
    Â·
      convertTo MeasurableSet (â‹ƒ(l : _)(_ : l âˆˆ t)(u : _)(_ : u âˆˆ t)(hlu : l < u)(hu : u â‰¤ a), Ico l u)
      Â·
        ext y 
        simp only [mem_Union, mem_Iio, mem_Ico]
        split 
        Â·
          intro hy 
          rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with âŸ¨l, hlt, hlyâŸ©
          rcases htd.exists_mem_open is_open_Ioo (ha y hy) with âŸ¨u, hut, hyu, huaâŸ©
          exact âŸ¨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyuâŸ©
        Â·
          rintro âŸ¨l, -, u, -, -, hua, -, hyuâŸ©
          exact hyu.trans_le hua
      Â·
        refine' MeasurableSet.bUnion hc fun a ha => MeasurableSet.bUnion hc$ fun b hb => _ 
        refine' MeasurableSet.Union_Prop fun hab => MeasurableSet.Union_Prop$ fun hb' => _ 
        exact generate_measurable.basic _ âŸ¨a, hts ha, b, hts hb, hab, mem_singleton _âŸ©
    Â·
      simp only [not_forall, not_nonempty_iff_eq_empty] at ha 
      replace ha : a âˆˆ s := hIoo ha.some a ha.some_spec.fst ha.some_spec.snd 
      convertTo MeasurableSet (â‹ƒ(l : _)(_ : l âˆˆ t)(hl : l < a), Ico l a)
      Â·
        symm 
        simp only [â†Ici_inter_Iio, â†Union_inter, inter_eq_right_iff_subset, subset_def, mem_Union, mem_Ici, mem_Iio]
        intro x hx 
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with âŸ¨z, hzt, hzxâŸ©
        exact âŸ¨z, hzt, hzx.trans_lt hx, hzxâŸ©
      Â·
        refine' MeasurableSet.bUnion hc fun x hx => MeasurableSet.Union_Prop$ fun hlt => _ 
        exact generate_measurable.basic _ âŸ¨x, hts hx, a, ha, hlt, mem_singleton _âŸ©

theorem Dense.borel_eq_generate_from_Ico_mem {Î± : Type _} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±]
  [second_countable_topology Î±] [DenselyOrdered Î±] [NoBotOrder Î±] {s : Set Î±} (hd : Dense s) :
  borel Î± = generate_from { S : Set Î± | âˆƒ (l : _)(_ : l âˆˆ s)(u : _)(_ : u âˆˆ s)(h : l < u), Ico l u = S } :=
  hd.borel_eq_generate_from_Ico_mem_aux
      (by 
        simp )$
    fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ico (Î± : Type _) [TopologicalSpace Î±] [second_countable_topology Î±] [LinearOrderâ‚“ Î±]
  [OrderTopology Î±] : borel Î± = generate_from { S : Set Î± | âˆƒ (l u : _)(h : l < u), Ico l u = S } :=
  by 
    simpa only [exists_prop, mem_univ, true_andâ‚“] using
      (@dense_univ Î± _).borel_eq_generate_from_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:340:40: in exacts: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
theorem dense.borel_eq_generate_from_Ioc_mem_aux
{Î± : Type*}
[topological_space Î±]
[linear_order Î±]
[order_topology Î±]
[second_countable_topology Î±]
{s : set Î±}
(hd : dense s)
(hbot : âˆ€ x, is_top x â†’ Â«expr âˆˆ Â»(x, s))
(hIoo : âˆ€
 x
 y : Î±, Â«expr < Â»(x, y) â†’ Â«expr = Â»(Ioo x y, Â«exprâˆ…Â»()) â†’ Â«expr âˆˆ Â»(x, s)) : Â«expr = Â»(borel Î±, generate_from {S : set Î± | Â«exprâˆƒ , Â»((l Â«expr âˆˆ Â» s)
  (u Â«expr âˆˆ Â» s)
  (h : Â«expr < Â»(l, u)), Â«expr = Â»(Ioc l u, S))}) :=
begin
  convert [] [expr hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot (Î» x y hlt he, hIoo y x hlt _)] [],
  { ext [] [ident s] [],
    split; rintro ["âŸ¨", ident l, ",", ident hl, ",", ident u, ",", ident hu, ",", ident hlt, ",", ident rfl, "âŸ©"],
    exacts ["[", expr âŸ¨u, hu, l, hl, hlt, dual_IcoâŸ©, ",", expr âŸ¨u, hu, l, hl, hlt, dual_IocâŸ©, "]"] },
  { erw [expr dual_Ioo] [],
    exact [expr he] }
end

theorem Dense.borel_eq_generate_from_Ioc_mem {Î± : Type _} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±]
  [second_countable_topology Î±] [DenselyOrdered Î±] [NoTopOrder Î±] {s : Set Î±} (hd : Dense s) :
  borel Î± = generate_from { S : Set Î± | âˆƒ (l : _)(_ : l âˆˆ s)(u : _)(_ : u âˆˆ s)(h : l < u), Ioc l u = S } :=
  hd.borel_eq_generate_from_Ioc_mem_aux
      (by 
        simp )$
    fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ioc (Î± : Type _) [TopologicalSpace Î±] [second_countable_topology Î±] [LinearOrderâ‚“ Î±]
  [OrderTopology Î±] : borel Î± = generate_from { S : Set Î± | âˆƒ (l u : _)(h : l < u), Ioc l u = S } :=
  by 
    simpa only [exists_prop, mem_univ, true_andâ‚“] using
      (@dense_univ Î± _).borel_eq_generate_from_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Î±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `Î¼` and
`Î½`. -/
theorem ext_of_Ico_finite {Î± : Type _} [TopologicalSpace Î±] {m : MeasurableSpace Î±} [second_countable_topology Î±]
  [LinearOrderâ‚“ Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measureâ‚“ Î±) [is_finite_measure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ)
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=
  by 
    refine'
      ext_of_generate_finite _ (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Î±))
        (is_pi_system_Ico (id : Î± â†’ Î±) id) _ hÎ¼Î½
    Â·
      rintro - âŸ¨a, b, hlt, rflâŸ©
      exact h hlt

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Î±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Î¼` and
`Î½`. -/
theorem ext_of_Ioc_finite {Î± : Type _} [TopologicalSpace Î±] {m : MeasurableSpace Î±} [second_countable_topology Î±]
  [LinearOrderâ‚“ Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measureâ‚“ Î±) [is_finite_measure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ)
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=
  by 
    refine' @ext_of_Ico_finite (OrderDual Î±) _ _ _ _ _ â€¹_â€º Î¼ Î½ _ hÎ¼Î½ fun a b hab => _ 
    erw [dual_Ico]
    exact h hab

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico' {Î± : Type _} [TopologicalSpace Î±] {m : MeasurableSpace Î±} [second_countable_topology Î±]
  [LinearOrderâ‚“ Î±] [OrderTopology Î±] [BorelSpace Î±] [NoTopOrder Î±] (Î¼ Î½ : Measureâ‚“ Î±)
  (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) â‰  âˆ) (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=
  by 
    rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, hsb, hstâŸ©
    have  : countable (â‹ƒ(l : _)(_ : l âˆˆ s)(u : _)(_ : u âˆˆ s)(h : l < u), {Ico l u} : Set (Set Î±))
    exact hsc.bUnion fun l hl => hsc.bUnion fun u hu => countable_Union_Prop$ fun _ => countable_singleton _ 
    simp only [â†set_of_eq_eq_singleton, â†set_of_exists] at this 
    refine'
      measure.ext_of_generate_from_of_cover_subset (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Î±))
        (is_pi_system_Ico id id) _ this _ _ _
    Â·
      rintro _ âŸ¨l, -, u, -, h, rflâŸ©
      exact âŸ¨l, u, h, rflâŸ©
    Â·
      refine' sUnion_eq_univ_iff.2 fun x => _ 
      rcases hsd.exists_le' hsb x with âŸ¨l, hls, hlxâŸ©
      rcases hsd.exists_gt x with âŸ¨u, hus, hxuâŸ©
      exact âŸ¨_, âŸ¨l, hls, u, hus, hlx.trans_lt hxu, rflâŸ©, hlx, hxuâŸ©
    Â·
      rintro _ âŸ¨l, -, u, -, hlt, rflâŸ©
      exact hÎ¼ hlt
    Â·
      rintro _ âŸ¨l, u, hlt, rflâŸ©
      exact h hlt

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:340:40: in exacts: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc'
{Î± : Type*}
[topological_space Î±]
{m : measurable_space Î±}
[second_countable_topology Î±]
[linear_order Î±]
[order_topology Î±]
[borel_space Î±]
[no_bot_order Î±]
(Î¼ Î½ : measure Î±)
(hÎ¼ : âˆ€ {{a b}}, Â«expr < Â»(a, b) â†’ Â«expr â‰  Â»(Î¼ (Ioc a b), Â«exprâˆÂ»()))
(h : âˆ€ {{a b}}, Â«expr < Â»(a, b) â†’ Â«expr = Â»(Î¼ (Ioc a b), Î½ (Ioc a b))) : Â«expr = Â»(Î¼, Î½) :=
begin
  refine [expr @ext_of_Ico' (order_dual Î±) _ _ _ _ _ Â«exprâ€¹ â€ºÂ»(_) _ Î¼ Î½ _ _]; intros [ident a, ident b, ident hab]; erw [expr dual_Ico] [],
  exacts ["[", expr hÎ¼ hab, ",", expr h hab, "]"]
end

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico {Î± : Type _} [TopologicalSpace Î±] {m : MeasurableSpace Î±} [second_countable_topology Î±]
  [ConditionallyCompleteLinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] [NoTopOrder Î±] (Î¼ Î½ : Measureâ‚“ Î±)
  [is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=
  Î¼.ext_of_Ico' Î½ (fun a b hab => measure_Ico_lt_top.Ne) h

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc {Î± : Type _} [TopologicalSpace Î±] {m : MeasurableSpace Î±} [second_countable_topology Î±]
  [ConditionallyCompleteLinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] [NoBotOrder Î±] (Î¼ Î½ : Measureâ‚“ Î±)
  [is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=
  Î¼.ext_of_Ioc' Î½ (fun a b hab => measure_Ioc_lt_top.Ne) h

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {Î± : Type _} [TopologicalSpace Î±] {m : MeasurableSpace Î±} [second_countable_topology Î±]
  [LinearOrderâ‚“ Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measureâ‚“ Î±) [is_finite_measure Î¼]
  (h : âˆ€ a, Î¼ (Iic a) = Î½ (Iic a)) : Î¼ = Î½ :=
  by 
    refine' ext_of_Ioc_finite Î¼ Î½ _ fun a b hlt => _
    Â·
      rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, -, hstâŸ©
      have  : DirectedOn (Â· â‰¤ Â·) s 
      exact directed_on_iff_directed.2 (directed_of_sup$ fun _ _ => id)
      simp only [â†bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, h]
    rw [â†Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic measurable_set_Iic,
      measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic measurable_set_Iic, h a, h b]
    Â·
      rw [â†h a]
      exact (measure_lt_top Î¼ _).Ne
    Â·
      exact (measure_lt_top Î¼ _).Ne

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {Î± : Type _} [TopologicalSpace Î±] {m : MeasurableSpace Î±} [second_countable_topology Î±]
  [LinearOrderâ‚“ Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measureâ‚“ Î±) [is_finite_measure Î¼]
  (h : âˆ€ a, Î¼ (Ici a) = Î½ (Ici a)) : Î¼ = Î½ :=
  @ext_of_Iic (OrderDual Î±) _ _ _ _ _ â€¹_â€º _ _ _ h

end MeasureTheory.Measure

end LinearOrderâ‚“

section LinearOrderâ‚“

variable[LinearOrderâ‚“ Î±][OrderClosedTopology Î±]

@[measurability]
theorem measurable_set_interval {a b : Î±} : MeasurableSet (interval a b) :=
  measurable_set_Icc

variable[second_countable_topology Î±]

@[measurability]
theorem Measurable.max {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => max (f a) (g a) :=
  by 
    simpa only [max_def] using hf.piecewise (measurable_set_le hg hf) hg

@[measurability]
theorem AeMeasurable.max {f g : Î´ â†’ Î±} {Î¼ : Measureâ‚“ Î´} (hf : AeMeasurable f Î¼) (hg : AeMeasurable g Î¼) :
  AeMeasurable (fun a => max (f a) (g a)) Î¼ :=
  âŸ¨fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    eventually_eq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©

@[measurability]
theorem Measurable.min {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => min (f a) (g a) :=
  by 
    simpa only [min_def] using hf.piecewise (measurable_set_le hf hg) hg

@[measurability]
theorem AeMeasurable.min {f g : Î´ â†’ Î±} {Î¼ : Measureâ‚“ Î´} (hf : AeMeasurable f Î¼) (hg : AeMeasurable g Î¼) :
  AeMeasurable (fun a => min (f a) (g a)) Î¼ :=
  âŸ¨fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    eventually_eq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©

end LinearOrderâ‚“

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
theorem Continuous.measurable {f : Î± â†’ Î³} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eqâ‚“$ BorelSpace.measurable_eq)

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is ae-measurable. -/
theorem Continuous.ae_measurable {f : Î± â†’ Î³} (h : Continuous f) (Î¼ : Measureâ‚“ Î±) : AeMeasurable f Î¼ :=
  h.measurable.ae_measurable

theorem ClosedEmbedding.measurable {f : Î± â†’ Î³} (hf : ClosedEmbedding f) : Measurable f :=
  hf.continuous.measurable

@[toAdditive]
instance (priority := 100)HasContinuousMul.has_measurable_mul [Mul Î³] [HasContinuousMul Î³] : HasMeasurableMul Î³ :=
  { measurable_const_mul := fun c => (continuous_const.mul continuous_id).Measurable,
    measurable_mul_const := fun c => (continuous_id.mul continuous_const).Measurable }

instance (priority := 100)HasContinuousSub.has_measurable_sub [Sub Î³] [HasContinuousSub Î³] : HasMeasurableSub Î³ :=
  { measurable_const_sub := fun c => (continuous_const.sub continuous_id).Measurable,
    measurable_sub_const := fun c => (continuous_id.sub continuous_const).Measurable }

@[toAdditive]
instance (priority := 100)TopologicalGroup.has_measurable_inv [Groupâ‚“ Î³] [TopologicalGroup Î³] : HasMeasurableInv Î³ :=
  âŸ¨continuous_inv.MeasurableâŸ©

instance (priority := 100)HasContinuousSmul.has_measurable_smul {M Î±} [TopologicalSpace M] [TopologicalSpace Î±]
  [MeasurableSpace M] [MeasurableSpace Î±] [OpensMeasurableSpace M] [BorelSpace Î±] [HasScalar M Î±]
  [HasContinuousSmul M Î±] : HasMeasurableSmul M Î± :=
  âŸ¨fun c => (continuous_const.smul continuous_id).Measurable, fun y => (continuous_id.smul continuous_const).MeasurableâŸ©

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : Î± â‰ƒâ‚œ Î³) : Measurable h :=
  h.continuous.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : Î³ â‰ƒâ‚œ Î³â‚‚) : Î³ â‰ƒáµ Î³â‚‚ :=
  { measurable_to_fun := h.measurable, measurable_inv_fun := h.symm.measurable, toEquiv := h.to_equiv }

@[simp]
theorem Homeomorph.to_measurable_equiv_coe (h : Î³ â‰ƒâ‚œ Î³â‚‚) : (h.to_measurable_equiv : Î³ â†’ Î³â‚‚) = h :=
  rfl

@[simp]
theorem Homeomorph.to_measurable_equiv_symm_coe (h : Î³ â‰ƒâ‚œ Î³â‚‚) : (h.to_measurable_equiv.symm : Î³â‚‚ â†’ Î³) = h.symm :=
  rfl

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(Î±, Î³)) : Measurable f :=
  f.continuous.measurable

theorem measurable_of_continuous_on_compl_singleton [T1Space Î±] {f : Î± â†’ Î³} (a : Î±)
  (hf : ContinuousOn f (Â«expr á¶œÂ» {a})) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a (continuous_on_iff_continuous_restrict.1 hf).Measurable

theorem Continuous.measurable2 [second_countable_topology Î±] [second_countable_topology Î²] {f : Î´ â†’ Î±} {g : Î´ â†’ Î²}
  {c : Î± â†’ Î² â†’ Î³} (h : Continuous fun p : Î± Ã— Î² => c p.1 p.2) (hf : Measurable f) (hg : Measurable g) :
  Measurable fun a => c (f a) (g a) :=
  h.measurable.comp (hf.prod_mk hg)

theorem Continuous.ae_measurable2 [second_countable_topology Î±] [second_countable_topology Î²] {f : Î´ â†’ Î±} {g : Î´ â†’ Î²}
  {c : Î± â†’ Î² â†’ Î³} {Î¼ : Measureâ‚“ Î´} (h : Continuous fun p : Î± Ã— Î² => c p.1 p.2) (hf : AeMeasurable f Î¼)
  (hg : AeMeasurable g Î¼) : AeMeasurable (fun a => c (f a) (g a)) Î¼ :=
  h.measurable.comp_ae_measurable (hf.prod_mk hg)

instance (priority := 100)HasContinuousInvâ‚€.has_measurable_inv [GroupWithZeroâ‚“ Î³] [T1Space Î³] [HasContinuousInvâ‚€ Î³] :
  HasMeasurableInv Î³ :=
  âŸ¨measurable_of_continuous_on_compl_singleton 0 continuous_on_invâ‚€âŸ©

@[toAdditive]
instance (priority := 100)HasContinuousMul.has_measurable_mulâ‚‚ [second_countable_topology Î³] [Mul Î³]
  [HasContinuousMul Î³] : HasMeasurableMulâ‚‚ Î³ :=
  âŸ¨continuous_mul.MeasurableâŸ©

instance (priority := 100)HasContinuousSub.has_measurable_subâ‚‚ [second_countable_topology Î³] [Sub Î³]
  [HasContinuousSub Î³] : HasMeasurableSubâ‚‚ Î³ :=
  âŸ¨continuous_sub.MeasurableâŸ©

instance (priority := 100)HasContinuousSmul.has_measurable_smulâ‚‚ {M Î±} [TopologicalSpace M]
  [second_countable_topology M] [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Î±]
  [second_countable_topology Î±] [MeasurableSpace Î±] [BorelSpace Î±] [HasScalar M Î±] [HasContinuousSmul M Î±] :
  HasMeasurableSmulâ‚‚ M Î± :=
  âŸ¨continuous_smul.MeasurableâŸ©

end 

section BorelSpace

variable[TopologicalSpace
      Î±][MeasurableSpace
      Î±][BorelSpace
      Î±][TopologicalSpace
      Î²][MeasurableSpace Î²][BorelSpace Î²][TopologicalSpace Î³][MeasurableSpace Î³][BorelSpace Î³][MeasurableSpace Î´]

theorem pi_le_borel_pi {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [âˆ€ i, TopologicalSpace (Ï€ i)] [âˆ€ i, MeasurableSpace (Ï€ i)]
  [âˆ€ i, BorelSpace (Ï€ i)] : MeasurableSpace.pi â‰¤ borel (âˆ€ i, Ï€ i) :=
  by 
    have  : â€¹âˆ€ i, MeasurableSpace (Ï€ i)â€º = fun i => borel (Ï€ i) := funext fun i => BorelSpace.measurable_eq 
    rw [this]
    exact supr_le fun i => comap_le_iff_le_map.2$ (continuous_apply i).borel_measurable

theorem prod_le_borel_prod : Prod.measurableSpace â‰¤ borel (Î± Ã— Î²) :=
  by 
    rw [â€¹BorelSpace Î±â€º.measurable_eq, â€¹BorelSpace Î²â€º.measurable_eq]
    refine' sup_le _ _
    Â·
      exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
    Â·
      exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable

instance Pi.borel_space_fintype_encodable {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [Encodable Î¹] [t' : âˆ€ i, TopologicalSpace (Ï€ i)]
  [âˆ€ i, MeasurableSpace (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)] [âˆ€ i, BorelSpace (Ï€ i)] : BorelSpace (âˆ€ i, Ï€ i) :=
  âŸ¨le_antisymmâ‚“ pi_le_borel_pi OpensMeasurableSpace.borel_leâŸ©

instance Pi.borel_space_fintype {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [Fintype Î¹] [t' : âˆ€ i, TopologicalSpace (Ï€ i)]
  [âˆ€ i, MeasurableSpace (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)] [âˆ€ i, BorelSpace (Ï€ i)] : BorelSpace (âˆ€ i, Ï€ i) :=
  âŸ¨le_antisymmâ‚“ pi_le_borel_pi OpensMeasurableSpace.borel_leâŸ©

instance Prod.borel_space [second_countable_topology Î±] [second_countable_topology Î²] : BorelSpace (Î± Ã— Î²) :=
  âŸ¨le_antisymmâ‚“ prod_le_borel_prod OpensMeasurableSpace.borel_leâŸ©

protected theorem Embedding.measurable_embedding {f : Î± â†’ Î²} (hâ‚ : Embedding f) (hâ‚‚ : MeasurableSet (range f)) :
  MeasurableEmbedding f :=
  show MeasurableEmbedding (coeâ‚“ âˆ˜ (Homeomorph.ofEmbedding f hâ‚).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe hâ‚‚).comp (MeasurableEquiv.measurable_embedding _)

protected theorem ClosedEmbedding.measurable_embedding {f : Î± â†’ Î²} (h : ClosedEmbedding f) : MeasurableEmbedding f :=
  h.to_embedding.measurable_embedding h.closed_range.measurable_set

protected theorem OpenEmbedding.measurable_embedding {f : Î± â†’ Î²} (h : OpenEmbedding f) : MeasurableEmbedding f :=
  h.to_embedding.measurable_embedding h.open_range.measurable_set

section LinearOrderâ‚“

variable[LinearOrderâ‚“ Î±][OrderTopology Î±][second_countable_topology Î±]

theorem measurable_of_Iio {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Iio x)) : Measurable f :=
  by 
    convert measurable_generate_from _ 
    exact borel_space.measurable_eq.trans (borel_eq_generate_from_Iio _)
    rintro _ âŸ¨x, rflâŸ©
    exact hf x

theorem UpperSemicontinuous.measurable [TopologicalSpace Î´] [OpensMeasurableSpace Î´] {f : Î´ â†’ Î±}
  (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurable_of_Ioi {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Ioi x)) : Measurable f :=
  by 
    convert measurable_generate_from _ 
    exact borel_space.measurable_eq.trans (borel_eq_generate_from_Ioi _)
    rintro _ âŸ¨x, rflâŸ©
    exact hf x

theorem LowerSemicontinuous.measurable [TopologicalSpace Î´] [OpensMeasurableSpace Î´] {f : Î´ â†’ Î±}
  (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurable_of_Iic {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Iic x)) : Measurable f :=
  by 
    apply measurable_of_Ioi 
    simpRw [â†compl_Iic, preimage_compl, MeasurableSet.compl_iff]
    assumption

theorem measurable_of_Ici {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Ici x)) : Measurable f :=
  by 
    apply measurable_of_Iio 
    simpRw [â†compl_Ici, preimage_compl, MeasurableSet.compl_iff]
    assumption

theorem Measurable.is_lub {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))
  (hg : âˆ€ b, IsLub { a | âˆƒ i, f i b = a } (g b)) : Measurable g :=
  by 
    change âˆ€ b, IsLub (range$ fun i => f i b) (g b) at hg 
    rw [â€¹BorelSpace Î±â€º.measurable_eq, borel_eq_generate_from_Ioi Î±]
    apply measurable_generate_from 
    rintro _ âŸ¨a, rflâŸ©
    simpRw [Set.Preimage, mem_Ioi, lt_is_lub_iff (hg _), exists_range_iff, set_of_exists]
    exact MeasurableSet.Union fun i => hf i (is_open_lt' _).MeasurableSet

private theorem ae_measurable.is_lub_of_nonempty {Î¹} (hÎ¹ : Nonempty Î¹) {Î¼ : Measureâ‚“ Î´} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
  {g : Î´ â†’ Î±} (hf : âˆ€ i, AeMeasurable (f i) Î¼) (hg : âˆ€áµb âˆ‚Î¼, IsLub { a | âˆƒ i, f i b = a } (g b)) : AeMeasurable g Î¼ :=
  by 
    let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := fun x f' => IsLub { a | âˆƒ i, f' i = a } (g x)
    let g_seq := fun x => ite (x âˆˆ AeSeqSet hf p) (g x) (âŸ¨g xâŸ© : Nonempty Î±).some 
    have hg_seq : âˆ€ b, IsLub { a | âˆƒ i, aeSeq hf p i b = a } (g_seq b)
    Â·
      intro b 
      haveI hÎ± : Nonempty Î± := Nonempty.map g âŸ¨bâŸ©
      simp only [aeSeq, g_seq]
      splitIfs
      Â·
        have h_set_eq : { a : Î± | âˆƒ i : Î¹, (hf i).mk (f i) b = a } = { a : Î± | âˆƒ i : Î¹, f i b = a }
        Â·
          ext x 
          simpRw [Set.mem_set_of_eq, aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h]
        rw [h_set_eq]
        exact aeSeq.fun_prop_of_mem_ae_seq_set hf h
      Â·
        have h_singleton : { a : Î± | âˆƒ i : Î¹, hÎ±.some = a } = {hÎ±.some}
        Â·
          ext1 x 
          exact âŸ¨fun hx => hx.some_spec.symm, fun hx => âŸ¨hÎ¹.some, hx.symmâŸ©âŸ©
        rw [h_singleton]
        exact is_lub_singleton 
    refine' âŸ¨g_seq, Measurable.is_lub (aeSeq.measurable hf p) hg_seq, _âŸ©
    exact
      (ite_ae_eq_of_measure_compl_zero g (fun x => (âŸ¨g xâŸ© : Nonempty Î±).some) (AeSeqSet hf p)
          (aeSeq.measure_compl_ae_seq_set_eq_zero hf hg)).symm

theorem AeMeasurable.is_lub {Î¹} {Î¼ : Measureâ‚“ Î´} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
  (hf : âˆ€ i, AeMeasurable (f i) Î¼) (hg : âˆ€áµb âˆ‚Î¼, IsLub { a | âˆƒ i, f i b = a } (g b)) : AeMeasurable g Î¼ :=
  by 
    byCases' hÎ¼ : Î¼ = 0
    Â·
      rw [hÎ¼]
      exact ae_measurable_zero_measure 
    haveI  : Î¼.ae.ne_bot
    Â·
      simpa [ne_bot_iff]
    byCases' hÎ¹ : Nonempty Î¹
    Â·
      exact ae_measurable.is_lub_of_nonempty hÎ¹ hf hg 
    suffices  : âˆƒ x, g =áµ[Î¼] fun y => g x
    Â·
      Â·
        exact âŸ¨fun y => g this.some, measurable_const, this.some_specâŸ©
    have h_empty : âˆ€ x, { a : Î± | âˆƒ i : Î¹, f i x = a } = âˆ…
    Â·
      intro x 
      ext1 y 
      rw [Set.mem_set_of_eq, Set.mem_empty_eq, iff_falseâ‚“]
      exact fun hi => hÎ¹ (nonempty_of_exists hi)
    simpRw [h_empty]  at hg 
    exact âŸ¨hg.exists.some, hg.mono fun y hy => IsLub.unique hy hg.exists.some_specâŸ©

theorem Measurable.is_glb {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))
  (hg : âˆ€ b, IsGlb { a | âˆƒ i, f i b = a } (g b)) : Measurable g :=
  by 
    change âˆ€ b, IsGlb (range$ fun i => f i b) (g b) at hg 
    rw [â€¹BorelSpace Î±â€º.measurable_eq, borel_eq_generate_from_Iio Î±]
    apply measurable_generate_from 
    rintro _ âŸ¨a, rflâŸ©
    simpRw [Set.Preimage, mem_Iio, is_glb_lt_iff (hg _), exists_range_iff, set_of_exists]
    exact MeasurableSet.Union fun i => hf i (is_open_gt' _).MeasurableSet

private theorem ae_measurable.is_glb_of_nonempty {Î¹} (hÎ¹ : Nonempty Î¹) {Î¼ : Measureâ‚“ Î´} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
  {g : Î´ â†’ Î±} (hf : âˆ€ i, AeMeasurable (f i) Î¼) (hg : âˆ€áµb âˆ‚Î¼, IsGlb { a | âˆƒ i, f i b = a } (g b)) : AeMeasurable g Î¼ :=
  by 
    let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := fun x f' => IsGlb { a | âˆƒ i, f' i = a } (g x)
    let g_seq := fun x => ite (x âˆˆ AeSeqSet hf p) (g x) (âŸ¨g xâŸ© : Nonempty Î±).some 
    have hg_seq : âˆ€ b, IsGlb { a | âˆƒ i, aeSeq hf p i b = a } (g_seq b)
    Â·
      intro b 
      haveI hÎ± : Nonempty Î± := Nonempty.map g âŸ¨bâŸ©
      simp only [aeSeq, g_seq]
      splitIfs
      Â·
        have h_set_eq : { a : Î± | âˆƒ i : Î¹, (hf i).mk (f i) b = a } = { a : Î± | âˆƒ i : Î¹, f i b = a }
        Â·
          ext x 
          simpRw [Set.mem_set_of_eq, aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h]
        rw [h_set_eq]
        exact aeSeq.fun_prop_of_mem_ae_seq_set hf h
      Â·
        have h_singleton : { a : Î± | âˆƒ i : Î¹, hÎ±.some = a } = {hÎ±.some}
        Â·
          ext1 x 
          exact âŸ¨fun hx => hx.some_spec.symm, fun hx => âŸ¨hÎ¹.some, hx.symmâŸ©âŸ©
        rw [h_singleton]
        exact is_glb_singleton 
    refine' âŸ¨g_seq, Measurable.is_glb (aeSeq.measurable hf p) hg_seq, _âŸ©
    exact
      (ite_ae_eq_of_measure_compl_zero g (fun x => (âŸ¨g xâŸ© : Nonempty Î±).some) (AeSeqSet hf p)
          (aeSeq.measure_compl_ae_seq_set_eq_zero hf hg)).symm

theorem AeMeasurable.is_glb {Î¹} {Î¼ : Measureâ‚“ Î´} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
  (hf : âˆ€ i, AeMeasurable (f i) Î¼) (hg : âˆ€áµb âˆ‚Î¼, IsGlb { a | âˆƒ i, f i b = a } (g b)) : AeMeasurable g Î¼ :=
  by 
    byCases' hÎ¼ : Î¼ = 0
    Â·
      rw [hÎ¼]
      exact ae_measurable_zero_measure 
    haveI  : Î¼.ae.ne_bot
    Â·
      simpa [ne_bot_iff]
    byCases' hÎ¹ : Nonempty Î¹
    Â·
      exact ae_measurable.is_glb_of_nonempty hÎ¹ hf hg 
    suffices  : âˆƒ x, g =áµ[Î¼] fun y => g x
    Â·
      Â·
        exact âŸ¨fun y => g this.some, measurable_const, this.some_specâŸ©
    have h_empty : âˆ€ x, { a : Î± | âˆƒ i : Î¹, f i x = a } = âˆ…
    Â·
      intro x 
      ext1 y 
      rw [Set.mem_set_of_eq, Set.mem_empty_eq, iff_falseâ‚“]
      exact fun hi => hÎ¹ (nonempty_of_exists hi)
    simpRw [h_empty]  at hg 
    exact âŸ¨hg.exists.some, hg.mono fun y hy => IsGlb.unique hy hg.exists.some_specâŸ©

protected theorem Monotone.measurable [LinearOrderâ‚“ Î²] [OrderClosedTopology Î²] {f : Î² â†’ Î±} (hf : Monotone f) :
  Measurable f :=
  suffices h : âˆ€ x, ord_connected (f â»Â¹' Ioi x) from measurable_of_Ioi fun x => (h x).MeasurableSet 
  fun x => ord_connected_def.mpr fun a ha b hb c hc => lt_of_lt_of_leâ‚“ ha (hf hc.1)

theorem ae_measurable_restrict_of_monotone_on [LinearOrderâ‚“ Î²] [OrderClosedTopology Î²] {Î¼ : Measureâ‚“ Î²} {s : Set Î²}
  (hs : MeasurableSet s) {f : Î² â†’ Î±} (hf : MonotoneOn f s) : AeMeasurable f (Î¼.restrict s) :=
  have this : Monotone (f âˆ˜ coeâ‚“ : s â†’ Î±) := fun âŸ¨x, hxâŸ© âŸ¨y, hyâŸ© hxy : x â‰¤ y => hf hx hy hxy 
  ae_measurable_restrict_of_measurable_subtype hs this.measurable

protected theorem Antitone.measurable [LinearOrderâ‚“ Î²] [OrderClosedTopology Î²] {f : Î² â†’ Î±} (hf : Antitone f) :
  Measurable f :=
  @Monotone.measurable (OrderDual Î±) Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ hf

theorem ae_measurable_restrict_of_antitone_on [LinearOrderâ‚“ Î²] [OrderClosedTopology Î²] {Î¼ : Measureâ‚“ Î²} {s : Set Î²}
  (hs : MeasurableSet s) {f : Î² â†’ Î±} (hf : AntitoneOn f s) : AeMeasurable f (Î¼.restrict s) :=
  @ae_measurable_restrict_of_monotone_on (OrderDual Î±) Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ _ hs _ hf

end LinearOrderâ‚“

@[measurability]
theorem Measurable.supr_Prop {Î±} [MeasurableSpace Î±] [CompleteLattice Î±] (p : Prop) {f : Î´ â†’ Î±} (hf : Measurable f) :
  Measurable fun b => â¨†h : p, f b :=
  Classical.by_cases
    (fun h : p =>
      by 
        convert hf 
        funext 
        exact supr_pos h)
    fun h : Â¬p =>
      by 
        convert measurable_const 
        funext 
        exact supr_neg h

@[measurability]
theorem Measurable.infi_Prop {Î±} [MeasurableSpace Î±] [CompleteLattice Î±] (p : Prop) {f : Î´ â†’ Î±} (hf : Measurable f) :
  Measurable fun b => â¨…h : p, f b :=
  Classical.by_cases
    (fun h : p =>
      by 
        convert hf 
        funext 
        exact infi_pos h)
    fun h : Â¬p =>
      by 
        convert measurable_const 
        funext 
        exact infi_neg h

section CompleteLinearOrder

variable[CompleteLinearOrder Î±][OrderTopology Î±][second_countable_topology Î±]

@[measurability]
theorem measurable_supr {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
  Measurable fun b => â¨†i, f i b :=
  Measurable.is_lub hf$ fun b => is_lub_supr

@[measurability]
theorem ae_measurable_supr {Î¹} {Î¼ : Measureâ‚“ Î´} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, AeMeasurable (f i) Î¼) :
  AeMeasurable (fun b => â¨†i, f i b) Î¼ :=
  AeMeasurable.is_lub hf$ ae_of_all Î¼ fun b => is_lub_supr

@[measurability]
theorem measurable_infi {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
  Measurable fun b => â¨…i, f i b :=
  Measurable.is_glb hf$ fun b => is_glb_infi

@[measurability]
theorem ae_measurable_infi {Î¹} {Î¼ : Measureâ‚“ Î´} [Encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, AeMeasurable (f i) Î¼) :
  AeMeasurable (fun b => â¨…i, f i b) Î¼ :=
  AeMeasurable.is_glb hf$ ae_of_all Î¼ fun b => is_glb_infi

theorem measurable_bsupr {Î¹} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s) (hf : âˆ€ i, Measurable (f i)) :
  Measurable fun b => â¨†(i : _)(_ : i âˆˆ s), f i b :=
  by 
    haveI  : Encodable s := hs.to_encodable 
    simp only [supr_subtype']
    exact measurable_supr fun i => hf i

theorem ae_measurable_bsupr {Î¹} {Î¼ : Measureâ‚“ Î´} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, AeMeasurable (f i) Î¼) : AeMeasurable (fun b => â¨†(i : _)(_ : i âˆˆ s), f i b) Î¼ :=
  by 
    haveI  : Encodable s := hs.to_encodable 
    simp only [supr_subtype']
    exact ae_measurable_supr fun i => hf i

theorem measurable_binfi {Î¹} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s) (hf : âˆ€ i, Measurable (f i)) :
  Measurable fun b => â¨…(i : _)(_ : i âˆˆ s), f i b :=
  by 
    haveI  : Encodable s := hs.to_encodable 
    simp only [infi_subtype']
    exact measurable_infi fun i => hf i

theorem ae_measurable_binfi {Î¹} {Î¼ : Measureâ‚“ Î´} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, AeMeasurable (f i) Î¼) : AeMeasurable (fun b => â¨…(i : _)(_ : i âˆˆ s), f i b) Î¼ :=
  by 
    haveI  : Encodable s := hs.to_encodable 
    simp only [infi_subtype']
    exact ae_measurable_infi fun i => hf i

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `â„•`.
-/
theorem measurable_liminf' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hf : âˆ€ i, Measurable (f i)) {p : Î¹' â†’ Prop}
  {s : Î¹' â†’ Set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ i, (s i).Countable) :
  Measurable fun x => liminf u fun i => f i x :=
  by 
    simpRw [hu.to_has_basis.liminf_eq_supr_infi]
    refine' measurable_bsupr _ hu.countable _ 
    exact fun i => measurable_binfi _ (hs i) hf

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `â„•`.
-/
theorem measurable_limsup' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hf : âˆ€ i, Measurable (f i)) {p : Î¹' â†’ Prop}
  {s : Î¹' â†’ Set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ i, (s i).Countable) :
  Measurable fun x => limsup u fun i => f i x :=
  by 
    simpRw [hu.to_has_basis.limsup_eq_infi_supr]
    refine' measurable_binfi _ hu.countable _ 
    exact fun i => measurable_bsupr _ (hs i) hf

/-- `liminf` over `â„•` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurable_liminf {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
  Measurable fun x => liminf at_top fun i => f i x :=
  measurable_liminf' hf at_top_countable_basis fun i => countable_encodable _

/-- `limsup` over `â„•` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurable_limsup {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
  Measurable fun x => limsup at_top fun i => f i x :=
  measurable_limsup' hf at_top_countable_basis fun i => countable_encodable _

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable[ConditionallyCompleteLinearOrder Î±][OrderTopology Î±][second_countable_topology Î±]

theorem measurable_cSup {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : Set Î¹} (hs : s.countable) (hf : âˆ€ i, Measurable (f i))
  (bdd : âˆ€ x, BddAbove ((fun i => f i x) '' s)) : Measurable fun x => Sup ((fun i => f i x) '' s) :=
  by 
    cases' eq_empty_or_nonempty s with h2s h2s
    Â·
      simp [h2s, measurable_const]
    Â·
      apply measurable_of_Iic 
      intro y 
      simpRw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]
      exact MeasurableSet.bInter hs fun i hi => measurable_set_le (hf i) measurable_const

end ConditionallyCompleteLinearOrder

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def Homemorph.toMeasurableEquiv (h : Î± â‰ƒâ‚œ Î²) : Î± â‰ƒáµ Î² :=
  { toEquiv := h.to_equiv, measurable_to_fun := h.continuous_to_fun.measurable,
    measurable_inv_fun := h.continuous_inv_fun.measurable }

end BorelSpace

instance Empty.borel_space : BorelSpace Empty :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©

instance Unit.borel_space : BorelSpace Unit :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©

instance Bool.borel_space : BorelSpace Bool :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©

instance Nat.borel_space : BorelSpace â„• :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©

instance Int.borel_space : BorelSpace â„¤ :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©

instance Rat.borel_space : BorelSpace â„š :=
  âŸ¨borel_eq_top_of_encodable.symmâŸ©

instance Real.measurableSpace : MeasurableSpace â„ :=
  borel â„

instance Real.borel_space : BorelSpace â„ :=
  âŸ¨rflâŸ©

instance Nnreal.measurableSpace : MeasurableSpace â„â‰¥0  :=
  Subtype.measurableSpace

instance Nnreal.borel_space : BorelSpace â„â‰¥0  :=
  Subtype.borel_space _

instance Ennreal.measurableSpace : MeasurableSpace â„â‰¥0âˆ :=
  borel â„â‰¥0âˆ

instance Ennreal.borel_space : BorelSpace â„â‰¥0âˆ :=
  âŸ¨rflâŸ©

instance Ereal.measurableSpace : MeasurableSpace Ereal :=
  borel Ereal

instance Ereal.borel_space : BorelSpace Ereal :=
  âŸ¨rflâŸ©

instance Complex.measurableSpace : MeasurableSpace â„‚ :=
  borel â„‚

instance Complex.borel_space : BorelSpace â„‚ :=
  âŸ¨rflâŸ©

/-- One can cut out `â„â‰¥0âˆ` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : â„¤` and `{âˆ}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace Î±] (Î¼ : Measureâ‚“ Î±) {f : Î± â†’ â„â‰¥0âˆ}
  (hf : Measurable f) {s : Set Î±} (hs : MeasurableSet s) {t :  â„â‰¥0 } (ht : 1 < t) :
  Î¼ s = (Î¼ (s âˆ© f â»Â¹' {0})+Î¼ (s âˆ© f â»Â¹' {âˆ}))+âˆ‘'n : â„¤, Î¼ (s âˆ© f â»Â¹' Ico (t^n) (t^n+1)) :=
  by 
    have A : Î¼ s = Î¼ (s âˆ© f â»Â¹' {0})+Î¼ (s âˆ© f â»Â¹' Ioi 0)
    Â·
      rw [â†measure_union]
      Â·
        congr 1 
        ext x 
        have  : 0 = f x âˆ¨ 0 < f x := eq_or_lt_of_le bot_le 
        rw [eq_comm] at this 
        simp only [â†and_or_distrib_left, this, mem_singleton_iff, mem_inter_eq, and_trueâ‚“, mem_union_eq, mem_Ioi,
          mem_preimage]
      Â·
        apply disjoint_left.2 fun x hx h'x => _ 
        have  : 0 < f x := h'x.2 
        exact lt_irreflâ‚“ 0 (this.trans_le hx.2.le)
      Â·
        exact hs.inter (hf (measurable_set_singleton _))
      Â·
        exact hs.inter (hf measurable_set_Ioi)
    have B : Î¼ (s âˆ© f â»Â¹' Ioi 0) = Î¼ (s âˆ© f â»Â¹' {âˆ})+Î¼ (s âˆ© f â»Â¹' Ioo 0 âˆ)
    Â·
      rw [â†measure_union]
      Â·
        rw [â†inter_union_distrib_left]
        congr 
        ext x 
        simp only [mem_singleton_iff, mem_union_eq, mem_Ioo, mem_Ioi, mem_preimage]
        have H : f x = âˆ âˆ¨ f x < âˆ := eq_or_lt_of_le le_top 
        cases H
        Â·
          simp only [H, eq_self_iff_true, or_falseâ‚“, WithTop.zero_lt_top, not_top_lt, and_falseâ‚“]
        Â·
          simp only [H, H.ne, and_trueâ‚“, false_orâ‚“]
      Â·
        apply disjoint_left.2 fun x hx h'x => _ 
        have  : f x < âˆ := h'x.2.2 
        exact lt_irreflâ‚“ _ (this.trans_le (le_of_eqâ‚“ hx.2.symm))
      Â·
        exact hs.inter (hf (measurable_set_singleton _))
      Â·
        exact hs.inter (hf measurable_set_Ioo)
    have C : Î¼ (s âˆ© f â»Â¹' Ioo 0 âˆ) = âˆ‘'n : â„¤, Î¼ (s âˆ© f â»Â¹' Ico (t^n) (t^n+1))
    Â·
      rw [â†measure_Union, Ennreal.Ioo_zero_top_eq_Union_Ico_zpow (Ennreal.one_lt_coe_iff.2 ht) Ennreal.coe_ne_top,
        preimage_Union, inter_Union]
      Â·
        intro i j 
        simp only [Function.onFun]
        wlog (discharger := tactic.skip) h : i â‰¤ j := le_totalâ‚“ i j using i j, j i
        Â·
          intro hij 
          replace hij : (i+1) â‰¤ j := lt_of_le_of_neâ‚“ h hij 
          apply disjoint_left.2 fun x hx h'x => lt_irreflâ‚“ (f x) _ 
          calc f x < (t^i+1) := hx.2.2_ â‰¤ (t^j) := Ennreal.zpow_le_of_le (Ennreal.one_le_coe_iff.2 ht.le) hij _ â‰¤ f x :=
            h'x.2.1
        Â·
          intro hij 
          rw [Disjoint.comm]
          exact this hij.symm
      Â·
        intro n 
        exact hs.inter (hf measurable_set_Ico)
    rw [A, B, C, add_assocâ‚“]

section MetricSpace

variable[MetricSpace Î±][MeasurableSpace Î±][OpensMeasurableSpace Î±]

variable[MeasurableSpace Î²]{x : Î±}{Îµ : â„}

open Metric

@[measurability]
theorem measurable_set_ball : MeasurableSet (Metric.Ball x Îµ) :=
  Metric.is_open_ball.MeasurableSet

@[measurability]
theorem measurable_set_closed_ball : MeasurableSet (Metric.ClosedBall x Îµ) :=
  Metric.is_closed_ball.MeasurableSet

@[measurability]
theorem measurable_inf_dist {s : Set Î±} : Measurable fun x => inf_dist x s :=
  (continuous_inf_dist_pt s).Measurable

@[measurability]
theorem Measurable.inf_dist {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} : Measurable fun x => inf_dist (f x) s :=
  measurable_inf_dist.comp hf

@[measurability]
theorem measurable_inf_nndist {s : Set Î±} : Measurable fun x => inf_nndist x s :=
  (continuous_inf_nndist_pt s).Measurable

@[measurability]
theorem Measurable.inf_nndist {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} : Measurable fun x => inf_nndist (f x) s :=
  measurable_inf_nndist.comp hf

variable[second_countable_topology Î±]

@[measurability]
theorem measurable_dist : Measurable fun p : Î± Ã— Î± => dist p.1 p.2 :=
  continuous_dist.Measurable

@[measurability]
theorem Measurable.dist {f g : Î² â†’ Î±} (hf : Measurable f) (hg : Measurable g) : Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist Î± _).measurable2 hf hg

@[measurability]
theorem measurable_nndist : Measurable fun p : Î± Ã— Î± => nndist p.1 p.2 :=
  continuous_nndist.Measurable

@[measurability]
theorem Measurable.nndist {f g : Î² â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
  Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist Î± _).measurable2 hf hg

end MetricSpace

section EmetricSpace

variable[EmetricSpace Î±][MeasurableSpace Î±][OpensMeasurableSpace Î±]

variable[MeasurableSpace Î²]{x : Î±}{Îµ : â„â‰¥0âˆ}

open Emetric

@[measurability]
theorem measurable_set_eball : MeasurableSet (Emetric.Ball x Îµ) :=
  Emetric.is_open_ball.MeasurableSet

@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).Measurable

@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).Measurable

@[measurability]
theorem measurable_inf_edist {s : Set Î±} : Measurable fun x => inf_edist x s :=
  continuous_inf_edist.Measurable

@[measurability]
theorem Measurable.inf_edist {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} : Measurable fun x => inf_edist (f x) s :=
  measurable_inf_edist.comp hf

variable[second_countable_topology Î±]

@[measurability]
theorem measurable_edist : Measurable fun p : Î± Ã— Î± => edist p.1 p.2 :=
  continuous_edist.Measurable

@[measurability]
theorem Measurable.edist {f g : Î² â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
  Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist Î± _).measurable2 hf hg

@[measurability]
theorem AeMeasurable.edist {f g : Î² â†’ Î±} {Î¼ : Measureâ‚“ Î²} (hf : AeMeasurable f Î¼) (hg : AeMeasurable g Î¼) :
  AeMeasurable (fun a => edist (f a) (g a)) Î¼ :=
  (@continuous_edist Î± _).ae_measurable2 hf hg

end EmetricSpace

namespace Real

open MeasurableSpace MeasureTheory

theorem borel_eq_generate_from_Ioo_rat : borel â„ = generate_from (â‹ƒ(a b : â„š)(h : a < b), {Ioo a b}) :=
  is_topological_basis_Ioo_rat.borel_eq_generate_from

theorem is_pi_system_Ioo_rat : @IsPiSystem â„ (â‹ƒ(a b : â„š)(h : a < b), {Ioo a b}) :=
  by 
    convert is_pi_system_Ioo (coeâ‚“ : â„š â†’ â„) (coeâ‚“ : â„š â†’ â„)
    ext x 
    simp [eq_comm]

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Î¼` on `â„`. -/
def finite_spanning_sets_in_Ioo_rat (Î¼ : Measureâ‚“ â„) [is_locally_finite_measure Î¼] :
  Î¼.finite_spanning_sets_in (â‹ƒ(a b : â„š)(h : a < b), {Ioo a b}) :=
  { Set := fun n => Ioo (-n+1) (n+1),
    set_mem :=
      fun n =>
        by 
          simp only [mem_Union, mem_singleton_iff]
          refine'
            âŸ¨-n+1, n+1, _,
              by 
                normCastâŸ©
          exact (neg_nonpos.2 (@Nat.cast_nonneg â„š _ (n+1))).trans_lt n.cast_add_one_pos,
    Finite := fun n => measure_Ioo_lt_top,
    spanning :=
      Union_eq_univ_iff.2$
        fun x =>
          âŸ¨âŒŠ|x|âŒ‹â‚Š, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
            (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)âŸ© }

theorem measure_ext_Ioo_rat {Î¼ Î½ : Measureâ‚“ â„} [is_locally_finite_measure Î¼]
  (h : âˆ€ a b : â„š, Î¼ (Ioo a b) = Î½ (Ioo a b)) : Î¼ = Î½ :=
  (finite_spanning_sets_in_Ioo_rat Î¼).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat$
    by 
      simp only [mem_Union, mem_singleton_iff]
      rintro _ âŸ¨a, b, -, rflâŸ©
      apply h

theorem borel_eq_generate_from_Iio_rat : borel â„ = generate_from (â‹ƒa : â„š, {Iio a}) :=
  by 
    let g : MeasurableSpace â„ := generate_from (â‹ƒa : â„š, {Iio a})
    apply le_antisymmâ‚“ _ (MeasurableSpace.generate_from_le fun t => _)
    Â·
      rw [borel_eq_generate_from_Ioo_rat]
      refine' generate_from_le fun t => _ 
      simp only [mem_Union, mem_singleton_iff]
      rintro âŸ¨a, b, h, rflâŸ©
      rw [(Set.ext fun x => _ : Ioo (a : â„) b = (â‹ƒ(c : _)(_ : c > a), Â«expr á¶œÂ» (Iio c)) âˆ© Iio b)]
      Â·
        have hg : âˆ€ q : â„š, g.measurable_set' (Iio q) :=
          fun q =>
            generate_measurable.basic (Iio q)
              (by 
                simp 
                exact âŸ¨_, rflâŸ©)
        refine' @MeasurableSet.inter _ g _ _ _ (hg _)
        refine' @MeasurableSet.bUnion _ _ g _ _ (countable_encodable _) fun c h => _ 
        exact @MeasurableSet.compl _ _ g (hg _)
      Â·
        suffices  : x < Â«exprâ†‘ Â» b â†’ (Â«exprâ†‘ Â» a < x â†” âˆƒ i : â„š, a < i âˆ§ Â«exprâ†‘ Â» i â‰¤ x)
        Â·
          simpa 
        refine' fun _ => âŸ¨fun h => _, fun âŸ¨i, hai, hixâŸ© => (Rat.cast_lt.2 hai).trans_le hixâŸ©
        rcases exists_rat_btwn h with âŸ¨c, ac, cxâŸ©
        exact âŸ¨c, Rat.cast_lt.1 ac, cx.leâŸ©
    Â·
      simp only [mem_Union, mem_singleton_iff]
      rintro âŸ¨r, rflâŸ©
      exact measurable_set_Iio

end Real

variable[MeasurableSpace Î±]

@[measurability]
theorem measurable_real_to_nnreal : Measurable Real.toNnreal :=
  Nnreal.continuous_of_real.Measurable

@[measurability]
theorem Measurable.real_to_nnreal {f : Î± â†’ â„} (hf : Measurable f) : Measurable fun x => Real.toNnreal (f x) :=
  measurable_real_to_nnreal.comp hf

@[measurability]
theorem AeMeasurable.real_to_nnreal {f : Î± â†’ â„} {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => Real.toNnreal (f x)) Î¼ :=
  measurable_real_to_nnreal.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_nnreal_real : Measurable (coeâ‚“ :  â„â‰¥0  â†’ â„) :=
  Nnreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coe_nnreal_real {f : Î± â†’  â„â‰¥0 } (hf : Measurable f) : Measurable fun x => (f x : â„) :=
  measurable_coe_nnreal_real.comp hf

@[measurability]
theorem AeMeasurable.coe_nnreal_real {f : Î± â†’  â„â‰¥0 } {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => (f x : â„)) Î¼ :=
  measurable_coe_nnreal_real.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable (coeâ‚“ :  â„â‰¥0  â†’ â„â‰¥0âˆ) :=
  Ennreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Î± â†’  â„â‰¥0 } (hf : Measurable f) : Measurable fun x => (f x : â„â‰¥0âˆ) :=
  Ennreal.continuous_coe.Measurable.comp hf

@[measurability]
theorem AeMeasurable.coe_nnreal_ennreal {f : Î± â†’  â„â‰¥0 } {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => (f x : â„â‰¥0âˆ)) Î¼ :=
  Ennreal.continuous_coe.Measurable.comp_ae_measurable hf

@[measurability]
theorem Measurable.ennreal_of_real {f : Î± â†’ â„} (hf : Measurable f) : Measurable fun x => Ennreal.ofReal (f x) :=
  Ennreal.continuous_of_real.Measurable.comp hf

/-- The set of finite `â„â‰¥0âˆ` numbers is `measurable_equiv` to `â„â‰¥0`. -/
def MeasurableEquiv.ennrealEquivNnreal : { r : â„â‰¥0âˆ | r â‰  âˆ } â‰ƒáµ  â„â‰¥0  :=
  Ennreal.neTopHomeomorphNnreal.toMeasurableEquiv

namespace Ennreal

theorem measurable_of_measurable_nnreal {f : â„â‰¥0âˆ â†’ Î±} (h : Measurable fun p :  â„â‰¥0  => f p) : Measurable f :=
  measurable_of_measurable_on_compl_singleton âˆ (MeasurableEquiv.ennrealEquivNnreal.symm.measurable_comp_iff.1 h)

/-- `â„â‰¥0âˆ` is `measurable_equiv` to `â„â‰¥0 âŠ• unit`. -/
def ennreal_equiv_sum : â„â‰¥0âˆ â‰ƒáµ Sum â„â‰¥0  Unit :=
  { Equiv.optionEquivSumPunit â„â‰¥0  with measurable_to_fun := measurable_of_measurable_nnreal measurable_inl,
    measurable_inv_fun := measurable_sum measurable_coe_nnreal_ennreal (@measurable_const â„â‰¥0âˆ Unit _ _ âˆ) }

open function(uncurry)

theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Î²] [MeasurableSpace Î³] {f : â„â‰¥0âˆ Ã— Î² â†’ Î³}
  (Hâ‚ : Measurable fun p :  â„â‰¥0  Ã— Î² => f (p.1, p.2)) (Hâ‚‚ : Measurable fun x => f (âˆ, x)) : Measurable f :=
  let e : â„â‰¥0âˆ Ã— Î² â‰ƒáµ Sum ( â„â‰¥0  Ã— Î²) (Unit Ã— Î²) :=
    (ennreal_equiv_sum.prodCongr (MeasurableEquiv.refl Î²)).trans (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1$ measurable_sum Hâ‚ (Hâ‚‚.comp measurable_id.snd)

theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Î²] {f : â„â‰¥0âˆ Ã— â„â‰¥0âˆ â†’ Î²}
  (hâ‚ : Measurable fun p :  â„â‰¥0  Ã—  â„â‰¥0  => f (p.1, p.2)) (hâ‚‚ : Measurable fun r :  â„â‰¥0  => f (âˆ, r))
  (hâ‚ƒ : Measurable fun r :  â„â‰¥0  => f (r, âˆ)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1$ measurable_of_measurable_nnreal_prod (hâ‚.comp measurable_swap) hâ‚ƒ)
    (measurable_of_measurable_nnreal hâ‚‚)

@[measurability]
theorem measurable_of_real : Measurable Ennreal.ofReal :=
  Ennreal.continuous_of_real.Measurable

@[measurability]
theorem measurable_to_real : Measurable Ennreal.toReal :=
  Ennreal.measurable_of_measurable_nnreal measurable_coe_nnreal_real

@[measurability]
theorem measurable_to_nnreal : Measurable Ennreal.toNnreal :=
  Ennreal.measurable_of_measurable_nnreal measurable_id

instance  : HasMeasurableMulâ‚‚ â„â‰¥0âˆ :=
  by 
    refine' âŸ¨measurable_of_measurable_nnreal_nnreal _ _ _âŸ©
    Â·
      simp only [â†Ennreal.coe_mul, measurable_mul.coe_nnreal_ennreal]
    Â·
      simp only [Ennreal.top_mul, Ennreal.coe_eq_zero]
      exact measurable_const.piecewise (measurable_set_singleton _) measurable_const
    Â·
      simp only [Ennreal.mul_top, Ennreal.coe_eq_zero]
      exact measurable_const.piecewise (measurable_set_singleton _) measurable_const

instance  : HasMeasurableSubâ‚‚ â„â‰¥0âˆ :=
  âŸ¨by 
      apply measurable_of_measurable_nnreal_nnreal <;>
        simp [â†WithTop.coe_sub, continuous_sub.measurable.coe_nnreal_ennreal]âŸ©

instance  : HasMeasurableInv â„â‰¥0âˆ :=
  âŸ¨Ennreal.continuous_inv.MeasurableâŸ©

end Ennreal

@[measurability]
theorem Measurable.ennreal_to_nnreal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) : Measurable fun x => (f x).toNnreal :=
  Ennreal.measurable_to_nnreal.comp hf

@[measurability]
theorem AeMeasurable.ennreal_to_nnreal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => (f x).toNnreal) Î¼ :=
  Ennreal.measurable_to_nnreal.comp_ae_measurable hf

theorem measurable_coe_nnreal_ennreal_iff {f : Î± â†’  â„â‰¥0 } : (Measurable fun x => (f x : â„â‰¥0âˆ)) â†” Measurable f :=
  âŸ¨fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennrealâŸ©

@[measurability]
theorem Measurable.ennreal_to_real {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) : Measurable fun x => Ennreal.toReal (f x) :=
  Ennreal.measurable_to_real.comp hf

@[measurability]
theorem AeMeasurable.ennreal_to_real {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => Ennreal.toReal (f x)) Î¼ :=
  Ennreal.measurable_to_real.comp_ae_measurable hf

/-- note: `â„â‰¥0âˆ` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, Measurable (f i)) :
  Measurable fun x => âˆ‘'i, f i x :=
  by 
    simpRw [Ennreal.tsum_eq_supr_sum]
    apply measurable_supr 
    exact fun s => s.measurable_sum fun i _ => h i

@[measurability]
theorem Measurable.ennreal_tsum' {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, Measurable (f i)) :
  Measurable (âˆ‘'i, f i) :=
  by 
    convert Measurable.ennreal_tsum h 
    ext1 x 
    exact tsum_apply (Pi.summable.2 fun _ => Ennreal.summable)

@[measurability]
theorem Measurable.nnreal_tsum {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î± â†’  â„â‰¥0 } (h : âˆ€ i, Measurable (f i)) :
  Measurable fun x => âˆ‘'i, f i x :=
  by 
    simpRw [Nnreal.tsum_eq_to_nnreal_tsum]
    exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_to_nnreal

@[measurability]
theorem AeMeasurable.ennreal_tsum {Î¹} [Encodable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {Î¼ : Measureâ‚“ Î±}
  (h : âˆ€ i, AeMeasurable (f i) Î¼) : AeMeasurable (fun x => âˆ‘'i, f i x) Î¼ :=
  by 
    simpRw [Ennreal.tsum_eq_supr_sum]
    apply ae_measurable_supr 
    exact fun s => Finset.ae_measurable_sum s fun i _ => h i

@[measurability]
theorem measurable_coe_real_ereal : Measurable (coeâ‚“ : â„ â†’ Ereal) :=
  continuous_coe_real_ereal.Measurable

@[measurability]
theorem Measurable.coe_real_ereal {f : Î± â†’ â„} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurable_coe_real_ereal.comp hf

@[measurability]
theorem AeMeasurable.coe_real_ereal {f : Î± â†’ â„} {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => (f x : Ereal)) Î¼ :=
  measurable_coe_real_ereal.comp_ae_measurable hf

/-- The set of finite `ereal` numbers is `measurable_equiv` to `â„`. -/
def MeasurableEquiv.erealEquivReal : ({âŠ¥, âŠ¤} : Set Ereal).Compl â‰ƒáµ â„ :=
  Ereal.neBotTopHomeomorphReal.toMeasurableEquiv

theorem Ereal.measurable_of_measurable_real {f : Ereal â†’ Î±} (h : Measurable fun p : â„ => f p) : Measurable f :=
  measurable_of_measurable_on_compl_finite {âŠ¥, âŠ¤}
    (by 
      simp )
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)

@[measurability]
theorem measurable_ereal_to_real : Measurable Ereal.toReal :=
  Ereal.measurable_of_measurable_real
    (by 
      simpa using measurable_id)

@[measurability]
theorem Measurable.ereal_to_real {f : Î± â†’ Ereal} (hf : Measurable f) : Measurable fun x => (f x).toReal :=
  measurable_ereal_to_real.comp hf

@[measurability]
theorem AeMeasurable.ereal_to_real {f : Î± â†’ Ereal} {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => (f x).toReal) Î¼ :=
  measurable_ereal_to_real.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable (coeâ‚“ : â„â‰¥0âˆ â†’ Ereal) :=
  continuous_coe_ennreal_ereal.Measurable

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurable_coe_ennreal_ereal.comp hf

@[measurability]
theorem AeMeasurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measureâ‚“ Î±} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun x => (f x : Ereal)) Î¼ :=
  measurable_coe_ennreal_ereal.comp_ae_measurable hf

section NormedGroup

variable[NormedGroup Î±][OpensMeasurableSpace Î±][MeasurableSpace Î²]

@[measurability]
theorem measurable_norm : Measurable (norm : Î± â†’ â„) :=
  continuous_norm.Measurable

@[measurability]
theorem Measurable.norm {f : Î² â†’ Î±} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf

@[measurability]
theorem AeMeasurable.norm {f : Î² â†’ Î±} {Î¼ : Measureâ‚“ Î²} (hf : AeMeasurable f Î¼) : AeMeasurable (fun a => norm (f a)) Î¼ :=
  measurable_norm.comp_ae_measurable hf

@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : Î± â†’  â„â‰¥0 ) :=
  continuous_nnnorm.Measurable

@[measurability]
theorem Measurable.nnnorm {f : Î² â†’ Î±} (hf : Measurable f) : Measurable fun a => nnnorm (f a) :=
  measurable_nnnorm.comp hf

@[measurability]
theorem AeMeasurable.nnnorm {f : Î² â†’ Î±} {Î¼ : Measureâ‚“ Î²} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun a => nnnorm (f a)) Î¼ :=
  measurable_nnnorm.comp_ae_measurable hf

@[measurability]
theorem measurable_ennnorm : Measurable fun x : Î± => (nnnorm x : â„â‰¥0âˆ) :=
  measurable_nnnorm.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennnorm {f : Î² â†’ Î±} (hf : Measurable f) : Measurable fun a => (nnnorm (f a) : â„â‰¥0âˆ) :=
  hf.nnnorm.coe_nnreal_ennreal

@[measurability]
theorem AeMeasurable.ennnorm {f : Î² â†’ Î±} {Î¼ : Measureâ‚“ Î²} (hf : AeMeasurable f Î¼) :
  AeMeasurable (fun a => (nnnorm (f a) : â„â‰¥0âˆ)) Î¼ :=
  measurable_ennnorm.comp_ae_measurable hf

end NormedGroup

section Limits

variable[MeasurableSpace Î²][MetricSpace Î²][BorelSpace Î²]

open Metric

/-- A limit (over a general filter) of measurable `â„â‰¥0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal' {Î¹} {f : Î¹ â†’ Î± â†’  â„â‰¥0 } {g : Î± â†’  â„â‰¥0 } (u : Filter Î¹) [ne_bot u]
  [is_countably_generated u] (hf : âˆ€ i, Measurable (f i)) (lim : tendsto f u (ğ“ g)) : Measurable g :=
  by 
    rcases u.exists_seq_tendsto with âŸ¨x, hxâŸ©
    rw [tendsto_pi] at lim 
    rw [â†measurable_coe_nnreal_ennreal_iff]
    have  : âˆ€ y, (liminf at_top fun n => (f (x n) y : â„â‰¥0âˆ)) = (g y : â„â‰¥0âˆ) :=
      fun y => ((ennreal.continuous_coe.tendsto (g y)).comp$ (limâ‚“ y).comp hx).liminf_eq 
    simp only [â†this]
    show Measurable fun y => liminf at_top fun n => (f (x n) y : â„â‰¥0âˆ)
    exact measurable_liminf fun n => (hf (x n)).coe_nnreal_ennreal

/-- A sequential limit of measurable `â„â‰¥0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal {f : â„• â†’ Î± â†’  â„â‰¥0 } {g : Î± â†’  â„â‰¥0 } (hf : âˆ€ i, Measurable (f i))
  (lim : tendsto f at_top (ğ“ g)) : Measurable g :=
  measurable_of_tendsto_nnreal' at_top hf limâ‚“

/-- A limit (over a general filter) of measurable functions valued in a metric space is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antitone_basis`, but we
don't need that case yet. -/
theorem measurable_of_tendsto_metric' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [ne_bot u]
  [is_countably_generated u] (hf : âˆ€ i, Measurable (f i)) (lim : tendsto f u (ğ“ g)) : Measurable g :=
  by 
    apply measurable_of_is_closed' 
    intro s h1s h2s h3s 
    have  : Measurable fun x => inf_nndist (g x) s
    Â·
      suffices  : tendsto (fun i x => inf_nndist (f i x) s) u (ğ“ fun x => inf_nndist (g x) s)
      exact measurable_of_tendsto_nnreal' u (fun i => (hf i).infNndist) this 
      rw [tendsto_pi] at limâŠ¢
      intro x 
      exact ((continuous_inf_nndist_pt s).Tendsto (g x)).comp (limâ‚“ x)
    have h4s : g â»Â¹' s = (fun x => inf_nndist (g x) s) â»Â¹' {0}
    Â·
      ext x 
      simp [h1s, â†h1s.mem_iff_inf_dist_zero h2s, â†Nnreal.coe_eq_zero]
    rw [h4s]
    exact this (measurable_set_singleton 0)

/-- A sequential limit of measurable functions valued in a metric space is measurable. -/
theorem measurable_of_tendsto_metric {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ i, Measurable (f i))
  (lim : tendsto f at_top (ğ“ g)) : Measurable g :=
  measurable_of_tendsto_metric' at_top hf limâ‚“

theorem ae_measurable_of_tendsto_metric_ae {Î¼ : Measureâ‚“ Î±} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ n, AeMeasurable (f n) Î¼)
  (h_ae_tendsto : âˆ€áµx âˆ‚Î¼, tendsto (fun n => f n x) at_top (ğ“ (g x))) : AeMeasurable g Î¼ :=
  by 
    let p : Î± â†’ (â„• â†’ Î²) â†’ Prop := fun x f' => filter.at_top.tendsto (fun n => f' n) (ğ“ (g x))
    let hp : âˆ€áµx âˆ‚Î¼, p x fun n => f n x 
    exact h_ae_tendsto 
    let ae_seq_lim := fun x => ite (x âˆˆ AeSeqSet hf p) (g x) (âŸ¨f 0 xâŸ© : Nonempty Î²).some 
    refine'
      âŸ¨ae_seq_lim, _,
        (ite_ae_eq_of_measure_compl_zero g (fun x => (âŸ¨f 0 xâŸ© : Nonempty Î²).some) (AeSeqSet hf p)
            (aeSeq.measure_compl_ae_seq_set_eq_zero hf hp)).symmâŸ©
    refine' measurable_of_tendsto_metric (@aeSeq.measurable Î± Î² _ _ _ f Î¼ hf p) _ 
    refine' tendsto_pi.mpr fun x => _ 
    simpRw [aeSeq, ae_seq_lim]
    splitIfs with hx
    Â·
      simpRw [aeSeq.mk_eq_fun_of_mem_ae_seq_set hf hx]
      exact @aeSeq.fun_prop_of_mem_ae_seq_set Î± Î² _ _ _ _ _ _ hf x hx
    Â·
      exact tendsto_const_nhds

theorem measurable_of_tendsto_metric_ae {Î¼ : Measureâ‚“ Î±} [Î¼.is_complete] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (hf : âˆ€ n, Measurable (f n)) (h_ae_tendsto : âˆ€áµx âˆ‚Î¼, Filter.atTop.Tendsto (fun n => f n x) (ğ“ (g x))) :
  Measurable g :=
  ae_measurable_iff_measurable.mp (ae_measurable_of_tendsto_metric_ae (fun i => (hf i).AeMeasurable) h_ae_tendsto)

theorem measurable_limit_of_tendsto_metric_ae {Î¼ : Measureâ‚“ Î±} {f : â„• â†’ Î± â†’ Î²} (hf : âˆ€ n, AeMeasurable (f n) Î¼)
  (h_ae_tendsto : âˆ€áµx âˆ‚Î¼, âˆƒ l : Î², Filter.atTop.Tendsto (fun n => f n x) (ğ“ l)) :
  âˆƒ (f_lim : Î± â†’ Î²)(hf_lim_meas : Measurable f_lim), âˆ€áµx âˆ‚Î¼, Filter.atTop.Tendsto (fun n => f n x) (ğ“ (f_lim x)) :=
  by 
    let p : Î± â†’ (â„• â†’ Î²) â†’ Prop := fun x f' => âˆƒ l : Î², filter.at_top.tendsto (fun n => f' n) (ğ“ l)
    have hp_mem : âˆ€ x, x âˆˆ AeSeqSet hf p â†’ p x fun n => f n x 
    exact fun x hx => aeSeq.fun_prop_of_mem_ae_seq_set hf hx 
    have hÎ¼_compl : Î¼ (Â«expr á¶œÂ» (AeSeqSet hf p)) = 0 
    exact aeSeq.measure_compl_ae_seq_set_eq_zero hf h_ae_tendsto 
    let f_lim : Î± â†’ Î² :=
      fun x => dite (x âˆˆ AeSeqSet hf p) (fun h => (hp_mem x h).some) fun h => (âŸ¨f 0 xâŸ© : Nonempty Î²).some 
    have hf_lim_conv : âˆ€ x, x âˆˆ AeSeqSet hf p â†’ filter.at_top.tendsto (fun n => f n x) (ğ“ (f_lim x))
    Â·
      intro x hx_conv 
      simp only [f_lim, hx_conv, dif_pos]
      exact (hp_mem x hx_conv).some_spec 
    have hf_lim : âˆ€ x, filter.at_top.tendsto (fun n => aeSeq hf p n x) (ğ“ (f_lim x))
    Â·
      intro x 
      simp only [f_lim, aeSeq]
      splitIfs
      Â·
        rw [funext fun n => aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h n]
        exact (hp_mem x h).some_spec
      Â·
        exact tendsto_const_nhds 
    have h_ae_tendsto_f_lim : âˆ€áµx âˆ‚Î¼, filter.at_top.tendsto (fun n => f n x) (ğ“ (f_lim x))
    Â·
      refine' le_antisymmâ‚“ (le_of_eqâ‚“ (measure_mono_null _ hÎ¼_compl)) (zero_le _)
      exact set.compl_subset_compl.mpr fun x hx => hf_lim_conv x hx 
    have h_f_lim_meas : Measurable f_lim 
    exact measurable_of_tendsto_metric (aeSeq.measurable hf p) (tendsto_pi.mpr fun x => hf_lim x)
    exact âŸ¨f_lim, h_f_lim_meas, h_ae_tendsto_f_limâŸ©

end Limits

namespace ContinuousLinearMap

variable{ğ•œ : Type _}[NormedField ğ•œ]

variable{E : Type _}[NormedGroup E][NormedSpace ğ•œ E][MeasurableSpace E]

variable[OpensMeasurableSpace E]

variable{F : Type _}[NormedGroup F][NormedSpace ğ•œ F][MeasurableSpace F][BorelSpace F]

@[measurability]
protected theorem Measurable (L : E â†’L[ğ•œ] F) : Measurable L :=
  L.continuous.measurable

theorem measurable_comp (L : E â†’L[ğ•œ] F) {Ï† : Î± â†’ E} (Ï†_meas : Measurable Ï†) : Measurable fun a : Î± => L (Ï† a) :=
  L.measurable.comp Ï†_meas

end ContinuousLinearMap

namespace ContinuousLinearMap

variable{ğ•œ : Type _}[NondiscreteNormedField ğ•œ]

variable{E : Type _}[NormedGroup E][NormedSpace ğ•œ E]{F : Type _}[NormedGroup F][NormedSpace ğ•œ F]

instance  : MeasurableSpace (E â†’L[ğ•œ] F) :=
  borel _

instance  : BorelSpace (E â†’L[ğ•œ] F) :=
  âŸ¨rflâŸ©

@[measurability]
theorem measurable_apply [MeasurableSpace F] [BorelSpace F] (x : E) : Measurable fun f : E â†’L[ğ•œ] F => f x :=
  (apply ğ•œ F x).Continuous.Measurable

@[measurability]
theorem measurable_apply' [MeasurableSpace E] [OpensMeasurableSpace E] [MeasurableSpace F] [BorelSpace F] :
  Measurable fun x : E f : E â†’L[ğ•œ] F => f x :=
  measurable_pi_lambda _$ fun f => f.measurable

@[measurability]
theorem measurable_coe [MeasurableSpace F] [BorelSpace F] : Measurable fun f : E â†’L[ğ•œ] F x : E => f x :=
  measurable_pi_lambda _ measurable_apply

end ContinuousLinearMap

section ContinuousLinearMapNondiscreteNormedField

variable{ğ•œ : Type _}[NondiscreteNormedField ğ•œ]

variable{E : Type _}[NormedGroup E][NormedSpace ğ•œ E][MeasurableSpace E][BorelSpace E]

variable{F : Type _}[NormedGroup F][NormedSpace ğ•œ F]

@[measurability]
theorem Measurable.apply_continuous_linear_map {Ï† : Î± â†’ F â†’L[ğ•œ] E} (hÏ† : Measurable Ï†) (v : F) :
  Measurable fun a => Ï† a v :=
  (ContinuousLinearMap.apply ğ•œ E v).Measurable.comp hÏ†

@[measurability]
theorem AeMeasurable.apply_continuous_linear_map {Ï† : Î± â†’ F â†’L[ğ•œ] E} {Î¼ : Measureâ‚“ Î±} (hÏ† : AeMeasurable Ï† Î¼) (v : F) :
  AeMeasurable (fun a => Ï† a v) Î¼ :=
  (ContinuousLinearMap.apply ğ•œ E v).Measurable.comp_ae_measurable hÏ†

end ContinuousLinearMapNondiscreteNormedField

section NormedSpace

variable{ğ•œ : Type _}[NondiscreteNormedField ğ•œ][CompleteSpace ğ•œ][MeasurableSpace ğ•œ]

variable[BorelSpace ğ•œ]

variable{E : Type _}[NormedGroup E][NormedSpace ğ•œ E][MeasurableSpace E][BorelSpace E]

theorem measurable_smul_const {f : Î± â†’ ğ•œ} {c : E} (hc : c â‰  0) : (Measurable fun x => f x â€¢ c) â†” Measurable f :=
  (closed_embedding_smul_left hc).MeasurableEmbedding.measurable_comp_iff

theorem ae_measurable_smul_const {f : Î± â†’ ğ•œ} {Î¼ : Measureâ‚“ Î±} {c : E} (hc : c â‰  0) :
  AeMeasurable (fun x => f x â€¢ c) Î¼ â†” AeMeasurable f Î¼ :=
  (closed_embedding_smul_left hc).MeasurableEmbedding.ae_measurable_comp_iff

end NormedSpace

