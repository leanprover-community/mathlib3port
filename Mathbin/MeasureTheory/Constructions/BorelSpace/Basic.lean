/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov

! This file was ported from Lean 3 source module measure_theory.constructions.borel_space.basic
! leanprover-community/mathlib commit 4280f5f32e16755ec7985ce11e189b6cd6ff6735
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Normed.Group.Basic
import Mathbin.MeasureTheory.Function.AeMeasurableSequence
import Mathbin.MeasureTheory.Group.Arithmetic
import Mathbin.MeasureTheory.Lattice
import Mathbin.MeasureTheory.Measure.OpenPos
import Mathbin.Topology.Algebra.Order.LiminfLimsup
import Mathbin.Topology.ContinuousFunction.Basic
import Mathbin.Topology.Instances.Ereal
import Mathbin.Topology.MetricSpace.HausdorffDistance
import Mathbin.Topology.GDelta
import Mathbin.Topology.Order.Lattice
import Mathbin.Topology.Semicontinuous

/-!
# Borel (measurable) space

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `‚Äπmeasurable_space Œ±‚Ä∫ = borel Œ±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚Äπmeasurable_space Œ±‚Ä∫`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`.

## Main statements

* `is_open.measurable_set`, `is_closed.measurable_set`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `Œª x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `‚Ñù‚â•0‚àû`.
-/


noncomputable section

open Classical Set Filter MeasureTheory

open Classical BigOperators Topology NNReal ENNReal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ≥‚ÇÇ Œ¥ : Type _} {Œπ : Sort y} {s t u : Set Œ±}

open MeasurableSpace TopologicalSpace

#print borel /-
/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Œ± : Type u) [TopologicalSpace Œ±] : MeasurableSpace Œ± :=
  generateFrom { s : Set Œ± | IsOpen s }
#align borel borel
-/

/- warning: borel_eq_top_of_discrete -> borel_eq_top_of_discrete is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : DiscreteTopology.{u1} Œ± _inst_1], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_1) (Top.top.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toHasTop.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : DiscreteTopology.{u1} Œ± _inst_1], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_1) (Top.top.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toTop.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align borel_eq_top_of_discrete borel_eq_top_of_discrete‚Çì'. -/
theorem borel_eq_top_of_discrete [TopologicalSpace Œ±] [DiscreteTopology Œ±] : borel Œ± = ‚ä§ :=
  top_le_iff.1 fun s hs => GenerateMeasurable.basic s (isOpen_discrete s)
#align borel_eq_top_of_discrete borel_eq_top_of_discrete

/- warning: borel_eq_top_of_countable -> borel_eq_top_of_countable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : T1Space.{u1} Œ± _inst_1] [_inst_3 : Countable.{succ u1} Œ±], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_1) (Top.top.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toHasTop.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : T1Space.{u1} Œ± _inst_1] [_inst_3 : Countable.{succ u1} Œ±], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_1) (Top.top.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toTop.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align borel_eq_top_of_countable borel_eq_top_of_countable‚Çì'. -/
theorem borel_eq_top_of_countable [TopologicalSpace Œ±] [T1Space Œ±] [Countable Œ±] : borel Œ± = ‚ä§ :=
  by
  refine' top_le_iff.1 fun s hs => bUnion_of_singleton s ‚ñ∏ _
  apply MeasurableSet.biUnion s.to_countable
  intro x hx
  apply MeasurableSet.of_compl
  apply generate_measurable.basic
  exact is_closed_singleton.is_open_compl
#align borel_eq_top_of_countable borel_eq_top_of_countable

#print borel_eq_generateFrom_of_subbasis /-
theorem borel_eq_generateFrom_of_subbasis {s : Set (Set Œ±)} [t : TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] (hs : t = generateFrom s) : borel Œ± = generateFrom s :=
  le_antisymm
    (generateFrom_le fun u (hu : t.IsOpen u) =>
      by
      rw [hs] at hu
      induction hu
      case basic u hu => exact generate_measurable.basic u hu
      case univ => exact @MeasurableSet.univ Œ± (generate_from s)
      case inter s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ => exact @MeasurableSet.inter Œ± (generate_from s) _ _ hs‚ÇÅ hs‚ÇÇ
      case
        sUnion f hf ih =>
        rcases is_open_sUnion_countable f (by rwa [hs]) with ‚ü®v, hv, vf, vu‚ü©
        rw [‚Üê vu]
        exact @MeasurableSet.sUnion Œ± (generate_from s) _ hv fun x xv => ih _ (vf xv))
    (generateFrom_le fun u hu =>
      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs] <;> exact generate_open.basic _ hu)
#align borel_eq_generate_from_of_subbasis borel_eq_generateFrom_of_subbasis
-/

#print TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom /-
theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) :
    borel Œ± = generateFrom s :=
  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom
#align topological_space.is_topological_basis.borel_eq_generate_from TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom
-/

#print isPiSystem_isOpen /-
theorem isPiSystem_isOpen [TopologicalSpace Œ±] : IsPiSystem (IsOpen : Set Œ± ‚Üí Prop) :=
  fun s hs t ht hst => IsOpen.inter hs ht
#align is_pi_system_is_open isPiSystem_isOpen
-/

#print borel_eq_generateFrom_isClosed /-
theorem borel_eq_generateFrom_isClosed [TopologicalSpace Œ±] :
    borel Œ± = generateFrom { s | IsClosed s } :=
  le_antisymm
    (generateFrom_le fun t ht =>
      @MeasurableSet.of_compl Œ± _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))
    (generateFrom_le fun t ht =>
      @MeasurableSet.of_compl Œ± _ (borel Œ±) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))
#align borel_eq_generate_from_is_closed borel_eq_generateFrom_isClosed
-/

section OrderTopology

variable (Œ±)

variable [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±]

#print borel_eq_generateFrom_Iio /-
theorem borel_eq_generateFrom_Iio : borel Œ± = generateFrom (range Iio) :=
  by
  refine' le_antisymm _ (generate_from_le _)
  ¬∑ rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals Œ± _ _ _)]
    letI : MeasurableSpace Œ± := MeasurableSpace.generateFrom (range Iio)
    have H : ‚àÄ a : Œ±, MeasurableSet (Iio a) := fun a => generate_measurable.basic _ ‚ü®_, rfl‚ü©
    refine' generate_from_le _
    rintro _ ‚ü®a, rfl | rfl‚ü© <;> [skip;apply H]
    by_cases h : ‚àÉ a', ‚àÄ b, a < b ‚Üî a' ‚â§ b
    ¬∑ rcases h with ‚ü®a', ha'‚ü©
      rw [(_ : Ioi a = Iio a'·∂ú)]
      ¬∑ exact (H _).compl
      simp [Set.ext_iff, ha']
    ¬∑ rcases is_open_Union_countable (fun a' : { a' : Œ± // a < a' } => { b | a'.1 < b }) fun a' =>
          isOpen_lt' _ with ‚ü®v, ‚ü®hv‚ü©, vu‚ü©
      simp [Set.ext_iff] at vu
      have : Ioi a = ‚ãÉ x : v, Iio x.1.1·∂ú :=
        by
        simp [Set.ext_iff]
        refine' fun x => ‚ü®fun ax => _, fun ‚ü®a', ‚ü®h, av‚ü©, ax‚ü© => lt_of_lt_of_le h ax‚ü©
        rcases(vu x).2 _ with ‚ü®a', h‚ÇÅ, h‚ÇÇ‚ü©
        ¬∑ exact ‚ü®a', h‚ÇÅ, le_of_lt h‚ÇÇ‚ü©
        refine' not_imp_comm.1 (fun h => _) h
        exact ‚ü®x, fun b => ‚ü®fun ab => le_of_not_lt fun h' => h ‚ü®b, ab, h'‚ü©, lt_of_lt_of_le ax‚ü©‚ü©
      rw [this]
      skip
      apply MeasurableSet.iUnion
      exact fun _ => (H _).compl
  ¬∑ rw [forall_range_iff]
    intro a
    exact generate_measurable.basic _ isOpen_Iio
#align borel_eq_generate_from_Iio borel_eq_generateFrom_Iio
-/

#print borel_eq_generateFrom_Ioi /-
theorem borel_eq_generateFrom_Ioi : borel Œ± = generateFrom (range Ioi) :=
  @borel_eq_generateFrom_Iio Œ±·µí·µà _ (by infer_instance : SecondCountableTopology Œ±) _ _
#align borel_eq_generate_from_Ioi borel_eq_generateFrom_Ioi
-/

#print borel_eq_generateFrom_Iic /-
theorem borel_eq_generateFrom_Iic : borel Œ± = MeasurableSpace.generateFrom (range Iic) :=
  by
  rw [borel_eq_generateFrom_Ioi]
  refine' le_antisymm _ _
  ¬∑ refine' MeasurableSpace.generateFrom_le fun t ht => _
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Iic]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl
  ¬∑ refine' MeasurableSpace.generateFrom_le fun t ht => _
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Ioi]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl
#align borel_eq_generate_from_Iic borel_eq_generateFrom_Iic
-/

#print borel_eq_generateFrom_Ici /-
theorem borel_eq_generateFrom_Ici : borel Œ± = MeasurableSpace.generateFrom (range Ici) :=
  @borel_eq_generateFrom_Iic Œ±·µí·µà _ _ _ _
#align borel_eq_generate_from_Ici borel_eq_generateFrom_Ici
-/

end OrderTopology

#print borel_comap /-
theorem borel_comap {f : Œ± ‚Üí Œ≤} {t : TopologicalSpace Œ≤} :
    @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=
  comap_generateFrom.symm
#align borel_comap borel_comap
-/

/- warning: continuous.borel_measurable -> Continuous.borel_measurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Measurable.{u1, u2} Œ± Œ≤ (borel.{u1} Œ± _inst_1) (borel.{u2} Œ≤ _inst_2) f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Measurable.{u2, u1} Œ± Œ≤ (borel.{u2} Œ± _inst_1) (borel.{u1} Œ≤ _inst_2) f)
Case conversion may be inaccurate. Consider using '#align continuous.borel_measurable Continuous.borel_measurable‚Çì'. -/
theorem Continuous.borel_measurable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Continuous f) : @Measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=
  Measurable.of_le_map <|
    generateFrom_le fun s hs => GenerateMeasurable.basic (f ‚Åª¬π' s) (hs.Preimage hf)
#align continuous.borel_measurable Continuous.borel_measurable

#print OpensMeasurableSpace /-
/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (Œ± : Type _) [TopologicalSpace Œ±] [h : MeasurableSpace Œ±] : Prop where
  borel_le : borel Œ± ‚â§ h
#align opens_measurable_space OpensMeasurableSpace
-/

#print BorelSpace /-
/-- A space with `measurable_space` and `topological_space` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class BorelSpace (Œ± : Type _) [TopologicalSpace Œ±] [MeasurableSpace Œ±] : Prop where
  measurable_eq : ‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±
#align borel_space BorelSpace
-/

namespace Tactic

/-- Add instances `borel Œ± : measurable_space Œ±` and `‚ü®rfl‚ü© : borel_space Œ±`. -/
unsafe def add_borel_instance (Œ± : expr) : tactic Unit := do
  let n1 ‚Üê get_unused_name "_inst"
  to_expr ``(borel $(Œ±)) >>= pose n1
  reset_instance_cache
  let n2 ‚Üê get_unused_name "_inst"
  let v ‚Üê to_expr ``((BorelSpace.mk rfl : BorelSpace $(Œ±)))
  note n2 none v
  reset_instance_cache
#align tactic.add_borel_instance tactic.add_borel_instance

-- failed to format: unknown constant 'term.pseudo.antiquot'
/--
      Given a type `Œ±`, an assumption `i : measurable_space Œ±`, and an instance `[borel_space Œ±]`,
      replace `i` with `borel Œ±`. -/
    unsafe
  def
    borel_to_refl
    ( Œ± i : expr ) : tactic Unit
    :=
      do
        let n ‚Üê get_unused_name "h"
          to_expr ` `( $ ( i ) = borel $ ( Œ± ) ) >>= assert n
          applyc `borel_space.measurable_eq
          unfreezing ( tactic.subst i )
          let n1 ‚Üê get_unused_name "_inst"
          to_expr ` `( borel $ ( Œ± ) ) >>= pose n1
          reset_instance_cache
#align tactic.borel_to_refl tactic.borel_to_refl

/-- Given a type `Œ±`, if there is an assumption `[i : measurable_space Œ±]`, then try to prove
`[borel_space Œ±]` and replace `i` with `borel Œ±`. Otherwise, add instances
`borel Œ± : measurable_space Œ±` and `‚ü®rfl‚ü© : borel_space Œ±`. -/
unsafe def borelize (Œ± : expr) : tactic Unit := do
  let i ‚Üê optional (to_expr ``(MeasurableSpace $(Œ±)) >>= find_assumption)
  i (add_borel_instance Œ±) (borel_to_refl Œ±)
#align tactic.borelize tactic.borelize

namespace Interactive

/- ./././Mathport/Syntax/Translate/Tactic/Mathlib/Core.lean:38:34: unsupported: setup_tactic_parser -/
/-- The behaviour of `borelize Œ±` depends on the existing assumptions on `Œ±`.

- if `Œ±` is a topological space with instances `[measurable_space Œ±] [borel_space Œ±]`, then
  `borelize Œ±` replaces the former instance by `borel Œ±`;
- otherwise, `borelize Œ±` adds instances `borel Œ± : measurable_space Œ±` and `‚ü®rfl‚ü© : borel_space Œ±`.

Finally, `borelize [Œ±, Œ≤, Œ≥]` runs `borelize Œ±, borelize Œ≤, borelize Œ≥`.
-/
unsafe def borelize (ts : parse pexpr_list_or_texpr) : tactic Unit :=
  mapM' (fun t => to_expr t >>= tactic.borelize) ts
#align tactic.interactive.borelize tactic.interactive.borelize

add_tactic_doc
  { Name := "borelize"
    category := DocCategory.tactic
    declNames := [`tactic.interactive.borelize]
    tags := ["type class"] }

end Interactive

end Tactic

#print OrderDual.opensMeasurableSpace /-
instance (priority := 100) OrderDual.opensMeasurableSpace {Œ± : Type _} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : OpensMeasurableSpace Œ±] : OpensMeasurableSpace Œ±·µí·µà
    where borel_le := h.borel_le
#align order_dual.opens_measurable_space OrderDual.opensMeasurableSpace
-/

#print OrderDual.borelSpace /-
instance (priority := 100) OrderDual.borelSpace {Œ± : Type _} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : BorelSpace Œ±] : BorelSpace Œ±·µí·µà where measurable_eq := h.measurable_eq
#align order_dual.borel_space OrderDual.borelSpace
-/

#print BorelSpace.opensMeasurable /-
/-- In a `borel_space` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opensMeasurable {Œ± : Type _} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] : OpensMeasurableSpace Œ± :=
  ‚ü®ge_of_eq <| BorelSpace.measurable_eq‚ü©
#align borel_space.opens_measurable BorelSpace.opensMeasurable
-/

#print Subtype.borelSpace /-
instance Subtype.borelSpace {Œ± : Type _} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [hŒ± : BorelSpace Œ±] (s : Set Œ±) : BorelSpace s :=
  ‚ü®by
    rw [hŒ±.1, Subtype.instMeasurableSpace, ‚Üê borel_comap]
    rfl‚ü©
#align subtype.borel_space Subtype.borelSpace
-/

#print Subtype.opensMeasurableSpace /-
instance Subtype.opensMeasurableSpace {Œ± : Type _} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : OpensMeasurableSpace Œ±] (s : Set Œ±) : OpensMeasurableSpace s :=
  ‚ü®by
    rw [borel_comap]
    exact comap_mono h.1‚ü©
#align subtype.opens_measurable_space Subtype.opensMeasurableSpace
-/

#print BorelSpace.countablyGenerated /-
instance (priority := 100) BorelSpace.countablyGenerated {Œ± : Type _} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] [SecondCountableTopology Œ±] : CountablyGenerated Œ± :=
  by
  obtain ‚ü®b, bct, -, hb‚ü© := exists_countable_basis Œ±
  refine' ‚ü®‚ü®b, bct, _‚ü©‚ü©
  borelize Œ±
  exact hb.borel_eq_generate_from
#align borel_space.countably_generated BorelSpace.countablyGenerated
-/

/- warning: measurable_set.induction_on_open -> MeasurableSet.induction_on_open is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] {C : (Set.{u1} Œ±) -> Prop}, (forall (U : Set.{u1} Œ±), (IsOpen.{u1} Œ± _inst_1 U) -> (C U)) -> (forall (t : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_2 t) -> (C t) -> (C (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) t))) -> (forall (f : Nat -> (Set.{u1} Œ±)), (Pairwise.{0} Nat (Function.onFun.{1, succ u1, 1} Nat (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) f)) -> (forall (i : Nat), MeasurableSet.{u1} Œ± _inst_2 (f i)) -> (forall (i : Nat), C (f i)) -> (C (Set.iUnion.{u1, 1} Œ± Nat (fun (i : Nat) => f i)))) -> (forall {{t : Set.{u1} Œ±}}, (MeasurableSet.{u1} Œ± _inst_2 t) -> (C t))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] {C : (Set.{u1} Œ±) -> Prop}, (forall (U : Set.{u1} Œ±), (IsOpen.{u1} Œ± _inst_1 U) -> (C U)) -> (forall (t : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_2 t) -> (C t) -> (C (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) t))) -> (forall (f : Nat -> (Set.{u1} Œ±)), (Pairwise.{0} Nat (Function.onFun.{1, succ u1, 1} Nat (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) f)) -> (forall (i : Nat), MeasurableSet.{u1} Œ± _inst_2 (f i)) -> (forall (i : Nat), C (f i)) -> (C (Set.iUnion.{u1, 1} Œ± Nat (fun (i : Nat) => f i)))) -> (forall {{t : Set.{u1} Œ±}}, (MeasurableSet.{u1} Œ± _inst_2 t) -> (C t))
Case conversion may be inaccurate. Consider using '#align measurable_set.induction_on_open MeasurableSet.induction_on_open‚Çì'. -/
theorem MeasurableSet.induction_on_open [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±]
    {C : Set Œ± ‚Üí Prop} (h_open : ‚àÄ U, IsOpen U ‚Üí C U)
    (h_compl : ‚àÄ t, MeasurableSet t ‚Üí C t ‚Üí C (t·∂ú))
    (h_union :
      ‚àÄ f : ‚Ñï ‚Üí Set Œ±,
        Pairwise (Disjoint on f) ‚Üí (‚àÄ i, MeasurableSet (f i)) ‚Üí (‚àÄ i, C (f i)) ‚Üí C (‚ãÉ i, f i)) :
    ‚àÄ ‚¶Ét‚¶Ñ, MeasurableSet t ‚Üí C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen
    (h_open _ isOpen_empty) h_open h_compl h_union
#align measurable_set.induction_on_open MeasurableSet.induction_on_open

section

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [OpensMeasurableSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥]
  [BorelSpace Œ≥] [TopologicalSpace Œ≥‚ÇÇ] [MeasurableSpace Œ≥‚ÇÇ] [BorelSpace Œ≥‚ÇÇ] [MeasurableSpace Œ¥]

#print IsOpen.measurableSet /-
theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h
#align is_open.measurable_set IsOpen.measurableSet
-/

#print measurableSet_interior /-
@[measurability]
theorem measurableSet_interior : MeasurableSet (interior s) :=
  isOpen_interior.MeasurableSet
#align measurable_set_interior measurableSet_interior
-/

#print IsGŒ¥.measurableSet /-
theorem IsGŒ¥.measurableSet (h : IsGŒ¥ s) : MeasurableSet s :=
  by
  rcases h with ‚ü®S, hSo, hSc, rfl‚ü©
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).MeasurableSet
#align is_GŒ¥.measurable_set IsGŒ¥.measurableSet
-/

#print measurableSet_of_continuousAt /-
theorem measurableSet_of_continuousAt {Œ≤} [EMetricSpace Œ≤] (f : Œ± ‚Üí Œ≤) :
    MeasurableSet { x | ContinuousAt f x } :=
  (isGŒ¥_setOf_continuousAt f).MeasurableSet
#align measurable_set_of_continuous_at measurableSet_of_continuousAt
-/

#print IsClosed.measurableSet /-
theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=
  h.isOpen_compl.MeasurableSet.ofCompl
#align is_closed.measurable_set IsClosed.measurableSet
-/

#print IsCompact.measurableSet /-
theorem IsCompact.measurableSet [T2Space Œ±] (h : IsCompact s) : MeasurableSet s :=
  h.IsClosed.MeasurableSet
#align is_compact.measurable_set IsCompact.measurableSet
-/

#print measurableSet_closure /-
@[measurability]
theorem measurableSet_closure : MeasurableSet (closure s) :=
  isClosed_closure.MeasurableSet
#align measurable_set_closure measurableSet_closure
-/

/- warning: measurable_of_is_open -> measurable_of_isOpen is a dubious translation:
lean 3 declaration is
  forall {Œ≥ : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u2} Œ¥] {f : Œ¥ -> Œ≥}, (forall (s : Set.{u1} Œ≥), (IsOpen.{u1} Œ≥ _inst_7 s) -> (MeasurableSet.{u2} Œ¥ _inst_13 (Set.preimage.{u2, u1} Œ¥ Œ≥ f s))) -> (Measurable.{u2, u1} Œ¥ Œ≥ _inst_13 _inst_8 f)
but is expected to have type
  forall {Œ≥ : Type.{u2}} {Œ¥ : Type.{u1}} [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u1} Œ¥] {f : Œ¥ -> Œ≥}, (forall (s : Set.{u2} Œ≥), (IsOpen.{u2} Œ≥ _inst_7 s) -> (MeasurableSet.{u1} Œ¥ _inst_13 (Set.preimage.{u1, u2} Œ¥ Œ≥ f s))) -> (Measurable.{u1, u2} Œ¥ Œ≥ _inst_13 _inst_8 f)
Case conversion may be inaccurate. Consider using '#align measurable_of_is_open measurable_of_isOpen‚Çì'. -/
theorem measurable_of_isOpen {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsOpen s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  rw [‚ÄπBorelSpace Œ≥‚Ä∫.measurable_eq]
  exact measurable_generateFrom hf
#align measurable_of_is_open measurable_of_isOpen

/- warning: measurable_of_is_closed -> measurable_of_isClosed is a dubious translation:
lean 3 declaration is
  forall {Œ≥ : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u2} Œ¥] {f : Œ¥ -> Œ≥}, (forall (s : Set.{u1} Œ≥), (IsClosed.{u1} Œ≥ _inst_7 s) -> (MeasurableSet.{u2} Œ¥ _inst_13 (Set.preimage.{u2, u1} Œ¥ Œ≥ f s))) -> (Measurable.{u2, u1} Œ¥ Œ≥ _inst_13 _inst_8 f)
but is expected to have type
  forall {Œ≥ : Type.{u2}} {Œ¥ : Type.{u1}} [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u1} Œ¥] {f : Œ¥ -> Œ≥}, (forall (s : Set.{u2} Œ≥), (IsClosed.{u2} Œ≥ _inst_7 s) -> (MeasurableSet.{u1} Œ¥ _inst_13 (Set.preimage.{u1, u2} Œ¥ Œ≥ f s))) -> (Measurable.{u1, u2} Œ¥ Œ≥ _inst_13 _inst_8 f)
Case conversion may be inaccurate. Consider using '#align measurable_of_is_closed measurable_of_isClosed‚Çì'. -/
theorem measurable_of_isClosed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsClosed s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  apply measurable_of_isOpen; intro s hs
  rw [‚Üê MeasurableSet.compl_iff, ‚Üê preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs
#align measurable_of_is_closed measurable_of_isClosed

/- warning: measurable_of_is_closed' -> measurable_of_is_closed' is a dubious translation:
lean 3 declaration is
  forall {Œ≥ : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u2} Œ¥] {f : Œ¥ -> Œ≥}, (forall (s : Set.{u1} Œ≥), (IsClosed.{u1} Œ≥ _inst_7 s) -> (Set.Nonempty.{u1} Œ≥ s) -> (Ne.{succ u1} (Set.{u1} Œ≥) s (Set.univ.{u1} Œ≥)) -> (MeasurableSet.{u2} Œ¥ _inst_13 (Set.preimage.{u2, u1} Œ¥ Œ≥ f s))) -> (Measurable.{u2, u1} Œ¥ Œ≥ _inst_13 _inst_8 f)
but is expected to have type
  forall {Œ≥ : Type.{u2}} {Œ¥ : Type.{u1}} [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u1} Œ¥] {f : Œ¥ -> Œ≥}, (forall (s : Set.{u2} Œ≥), (IsClosed.{u2} Œ≥ _inst_7 s) -> (Set.Nonempty.{u2} Œ≥ s) -> (Ne.{succ u2} (Set.{u2} Œ≥) s (Set.univ.{u2} Œ≥)) -> (MeasurableSet.{u1} Œ¥ _inst_13 (Set.preimage.{u1, u2} Œ¥ Œ≥ f s))) -> (Measurable.{u1, u2} Œ¥ Œ≥ _inst_13 _inst_8 f)
Case conversion may be inaccurate. Consider using '#align measurable_of_is_closed' measurable_of_is_closed'‚Çì'. -/
theorem measurable_of_is_closed' {f : Œ¥ ‚Üí Œ≥}
    (hf : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí s ‚â† univ ‚Üí MeasurableSet (f ‚Åª¬π' s)) : Measurable f :=
  by
  apply measurable_of_isClosed; intro s hs
  cases' eq_empty_or_nonempty s with h1 h1; ¬∑ simp [h1]
  by_cases h2 : s = univ; ¬∑ simp [h2]
  exact hf s hs h1 h2
#align measurable_of_is_closed' measurable_of_is_closed'

#print nhds_isMeasurablyGenerated /-
instance nhds_isMeasurablyGenerated (a : Œ±) : (ùìù a).IsMeasurablyGenerated :=
  by
  rw [nhds, iInf_subtype']
  refine' @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun i => _
  exact i.2.2.MeasurableSet.principal_isMeasurablyGenerated
#align nhds_is_measurably_generated nhds_isMeasurablyGenerated
-/

#print MeasurableSet.nhdsWithin_isMeasurablyGenerated /-
/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.
-/
theorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set Œ±} (hs : MeasurableSet s) (a : Œ±) :
    (ùìù[s] a).IsMeasurablyGenerated :=
  haveI := hs.principal_is_measurably_generated
  Filter.inf_isMeasurablyGenerated _ _
#align measurable_set.nhds_within_is_measurably_generated MeasurableSet.nhdsWithin_isMeasurablyGenerated
-/

#print OpensMeasurableSpace.toMeasurableSingletonClass /-
-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space Œ±] :
    MeasurableSingletonClass Œ± :=
  ‚ü®fun x => isClosed_singleton.MeasurableSet‚ü©
#align opens_measurable_space.to_measurable_singleton_class OpensMeasurableSpace.toMeasurableSingletonClass
-/

#print Pi.opensMeasurableSpace /-
instance Pi.opensMeasurableSpace {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [Countable Œπ]
    [t' : ‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, MeasurableSpace (œÄ i)]
    [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, OpensMeasurableSpace (œÄ i)] :
    OpensMeasurableSpace (‚àÄ i, œÄ i) := by
  constructor
  have :
    Pi.topologicalSpace =
      generate_from
        { t |
          ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ),
            (‚àÄ a ‚àà i, s a ‚àà countable_basis (œÄ a)) ‚àß t = pi (‚Üëi) s } :=
    by rw [funext fun a => @eq_generate_from_countable_basis (œÄ a) _ _, pi_generateFrom_eq]
  rw [borel_eq_generateFrom_of_subbasis this]
  apply generate_from_le
  rintro _ ‚ü®s, i, hi, rfl‚ü©
  refine' MeasurableSet.pi i.countable_to_set fun a ha => IsOpen.measurableSet _
  rw [eq_generate_from_countable_basis (œÄ a)]
  exact generate_open.basic _ (hi a ha)
#align pi.opens_measurable_space Pi.opensMeasurableSpace
-/

/- warning: prod.opens_measurable_space -> Prod.opensMeasurableSpace is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : OpensMeasurableSpace.{u2} Œ≤ _inst_4 _inst_5] [_inst_14 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] [_inst_15 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_4], OpensMeasurableSpace.{max u1 u2} (Prod.{u1, u2} Œ± Œ≤) (Prod.topologicalSpace.{u1, u2} Œ± Œ≤ _inst_1 _inst_4) (Prod.instMeasurableSpace.{u1, u2} Œ± Œ≤ _inst_2 _inst_5)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : OpensMeasurableSpace.{u2} Œ≤ _inst_4 _inst_5] [_inst_14 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] [_inst_15 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_4], OpensMeasurableSpace.{max u2 u1} (Prod.{u1, u2} Œ± Œ≤) (instTopologicalSpaceProd.{u1, u2} Œ± Œ≤ _inst_1 _inst_4) (Prod.instMeasurableSpace.{u1, u2} Œ± Œ≤ _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align prod.opens_measurable_space Prod.opensMeasurableSpace‚Çì'. -/
instance Prod.opensMeasurableSpace [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] :
    OpensMeasurableSpace (Œ± √ó Œ≤) := by
  constructor
  rw [((is_basis_countable_basis Œ±).Prod (is_basis_countable_basis Œ≤)).borel_eq_generateFrom]
  apply generate_from_le
  rintro _ ‚ü®u, v, hu, hv, rfl‚ü©
  exact
    (is_open_of_mem_countable_basis hu).MeasurableSet.Prod
      (is_open_of_mem_countable_basis hv).MeasurableSet
#align prod.opens_measurable_space Prod.opensMeasurableSpace

variable {Œ±' : Type _} [TopologicalSpace Œ±'] [MeasurableSpace Œ±']

/- warning: interior_ae_eq_of_null_frontier -> interior_ae_eq_of_null_frontier is a dubious translation:
lean 3 declaration is
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ±' Prop (MeasureTheory.Measure.ae.{u1} Œ±' _inst_15 Œº) (interior.{u1} Œ±' _inst_14 s) s)
but is expected to have type
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ±' Prop (MeasureTheory.Measure.ae.{u1} Œ±' _inst_15 Œº) (interior.{u1} Œ±' _inst_14 s) s)
Case conversion may be inaccurate. Consider using '#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier‚Çì'. -/
theorem interior_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    interior s =·µê[Œº] s :=
  interior_subset.EventuallyLE.antisymm <| subset_closure.EventuallyLE.trans (ae_le_set.2 h)
#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier

/- warning: measure_interior_of_null_frontier -> measure_interior_of_null_frontier is a dubious translation:
lean 3 declaration is
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº (interior.{u1} Œ±' _inst_14 s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº s))
but is expected to have type
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) (interior.{u1} Œ±' _inst_14 s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_interior_of_null_frontier measure_interior_of_null_frontier‚Çì'. -/
theorem measure_interior_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (interior s) = Œº s :=
  measure_congr (interior_ae_eq_of_null_frontier h)
#align measure_interior_of_null_frontier measure_interior_of_null_frontier

/- warning: null_measurable_set_of_null_frontier -> nullMeasurableSet_of_null_frontier is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] {s : Set.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº (frontier.{u1} Œ± _inst_1 s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± _inst_2 s Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] {s : Set.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) (frontier.{u1} Œ± _inst_1 s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± _inst_2 s Œº)
Case conversion may be inaccurate. Consider using '#align null_measurable_set_of_null_frontier nullMeasurableSet_of_null_frontier‚Çì'. -/
theorem nullMeasurableSet_of_null_frontier {s : Set Œ±} {Œº : Measure Œ±} (h : Œº (frontier s) = 0) :
    NullMeasurableSet s Œº :=
  ‚ü®interior s, isOpen_interior.MeasurableSet, (interior_ae_eq_of_null_frontier h).symm‚ü©
#align null_measurable_set_of_null_frontier nullMeasurableSet_of_null_frontier

/- warning: closure_ae_eq_of_null_frontier -> closure_ae_eq_of_null_frontier is a dubious translation:
lean 3 declaration is
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ±' Prop (MeasureTheory.Measure.ae.{u1} Œ±' _inst_15 Œº) (closure.{u1} Œ±' _inst_14 s) s)
but is expected to have type
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ±' Prop (MeasureTheory.Measure.ae.{u1} Œ±' _inst_15 Œº) (closure.{u1} Œ±' _inst_14 s) s)
Case conversion may be inaccurate. Consider using '#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier‚Çì'. -/
theorem closure_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    closure s =·µê[Œº] s :=
  ((ae_le_set.2 h).trans interior_subset.EventuallyLE).antisymm <| subset_closure.EventuallyLE
#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier

/- warning: measure_closure_of_null_frontier -> measure_closure_of_null_frontier is a dubious translation:
lean 3 declaration is
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº (closure.{u1} Œ±' _inst_14 s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ±' _inst_15) (fun (_x : MeasureTheory.Measure.{u1} Œ±' _inst_15) => (Set.{u1} Œ±') -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ±' _inst_15) Œº s))
but is expected to have type
  forall {Œ±' : Type.{u1}} [_inst_14 : TopologicalSpace.{u1} Œ±'] [_inst_15 : MeasurableSpace.{u1} Œ±'] {Œº : MeasureTheory.Measure.{u1} Œ±' _inst_15} {s : Set.{u1} Œ±'}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) (frontier.{u1} Œ±' _inst_14 s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) (closure.{u1} Œ±' _inst_14 s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ±' (MeasureTheory.Measure.toOuterMeasure.{u1} Œ±' _inst_15 Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_closure_of_null_frontier measure_closure_of_null_frontier‚Çì'. -/
theorem measure_closure_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (closure s) = Œº s :=
  measure_congr (closure_ae_eq_of_null_frontier h)
#align measure_closure_of_null_frontier measure_closure_of_null_frontier

section Preorder

variable [Preorder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

#print measurableSet_Ici /-
@[simp, measurability]
theorem measurableSet_Ici : MeasurableSet (Ici a) :=
  isClosed_Ici.MeasurableSet
#align measurable_set_Ici measurableSet_Ici
-/

#print measurableSet_Iic /-
@[simp, measurability]
theorem measurableSet_Iic : MeasurableSet (Iic a) :=
  isClosed_Iic.MeasurableSet
#align measurable_set_Iic measurableSet_Iic
-/

#print measurableSet_Icc /-
@[simp, measurability]
theorem measurableSet_Icc : MeasurableSet (Icc a b) :=
  isClosed_Icc.MeasurableSet
#align measurable_set_Icc measurableSet_Icc
-/

#print nhdsWithin_Ici_isMeasurablyGenerated /-
instance nhdsWithin_Ici_isMeasurablyGenerated : (ùìù[Ici b] a).IsMeasurablyGenerated :=
  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Ici_is_measurably_generated nhdsWithin_Ici_isMeasurablyGenerated
-/

#print nhdsWithin_Iic_isMeasurablyGenerated /-
instance nhdsWithin_Iic_isMeasurablyGenerated : (ùìù[Iic b] a).IsMeasurablyGenerated :=
  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Iic_is_measurably_generated nhdsWithin_Iic_isMeasurablyGenerated
-/

#print nhdsWithin_Icc_isMeasurablyGenerated /-
instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[Icc a b] x) :=
  by
  rw [‚Üê Ici_inter_Iic, nhdsWithin_inter]
  infer_instance
#align nhds_within_Icc_is_measurably_generated nhdsWithin_Icc_isMeasurablyGenerated
-/

#print atTop_isMeasurablyGenerated /-
instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated
#align at_top_is_measurably_generated atTop_isMeasurablyGenerated
-/

#print atBot_isMeasurablyGenerated /-
instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated
#align at_bot_is_measurably_generated atBot_isMeasurablyGenerated
-/

end Preorder

section PartialOrder

variable [PartialOrder Œ±] [OrderClosedTopology Œ±] [SecondCountableTopology Œ±] {a b : Œ±}

/- warning: measurable_set_le' -> measurableSet_le' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_16 : PartialOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± _inst_16)] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1], MeasurableSet.{u1} (Prod.{u1, u1} Œ± Œ±) (Prod.instMeasurableSpace.{u1, u1} Œ± Œ± _inst_2 _inst_2) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_16)) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_16 : PartialOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± _inst_16)] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1], MeasurableSet.{u1} (Prod.{u1, u1} Œ± Œ±) (Prod.instMeasurableSpace.{u1, u1} Œ± Œ± _inst_2 _inst_2) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_16)) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
Case conversion may be inaccurate. Consider using '#align measurable_set_le' measurableSet_le'‚Çì'. -/
@[measurability]
theorem measurableSet_le' : MeasurableSet { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } :=
  OrderClosedTopology.isClosed_le'.MeasurableSet
#align measurable_set_le' measurableSet_le'

/- warning: measurable_set_le -> measurableSet_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : PartialOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± _inst_16)] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 g) -> (MeasurableSet.{u2} Œ¥ _inst_13 (setOf.{u2} Œ¥ (fun (a : Œ¥) => LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_16)) (f a) (g a))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : PartialOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± _inst_16)] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 g) -> (MeasurableSet.{u2} Œ¥ _inst_13 (setOf.{u2} Œ¥ (fun (a : Œ¥) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_16)) (f a) (g a))))
Case conversion may be inaccurate. Consider using '#align measurable_set_le measurableSet_le‚Çì'. -/
@[measurability]
theorem measurableSet_le {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    MeasurableSet { a | f a ‚â§ g a } :=
  hf.prod_mk hg measurableSet_le'
#align measurable_set_le measurableSet_le

end PartialOrder

section LinearOrder

variable [LinearOrder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

-- we open this locale only here to avoid issues with list being treated as intervals above
open Interval

#print measurableSet_Iio /-
@[simp, measurability]
theorem measurableSet_Iio : MeasurableSet (Iio a) :=
  isOpen_Iio.MeasurableSet
#align measurable_set_Iio measurableSet_Iio
-/

#print measurableSet_Ioi /-
@[simp, measurability]
theorem measurableSet_Ioi : MeasurableSet (Ioi a) :=
  isOpen_Ioi.MeasurableSet
#align measurable_set_Ioi measurableSet_Ioi
-/

#print measurableSet_Ioo /-
@[simp, measurability]
theorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=
  isOpen_Ioo.MeasurableSet
#align measurable_set_Ioo measurableSet_Ioo
-/

#print measurableSet_Ioc /-
@[simp, measurability]
theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=
  measurableSet_Ioi.inter measurableSet_Iic
#align measurable_set_Ioc measurableSet_Ioc
-/

#print measurableSet_Ico /-
@[simp, measurability]
theorem measurableSet_Ico : MeasurableSet (Ico a b) :=
  measurableSet_Ici.inter measurableSet_Iio
#align measurable_set_Ico measurableSet_Ico
-/

#print nhdsWithin_Ioi_isMeasurablyGenerated /-
instance nhdsWithin_Ioi_isMeasurablyGenerated : (ùìù[Ioi b] a).IsMeasurablyGenerated :=
  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Ioi_is_measurably_generated nhdsWithin_Ioi_isMeasurablyGenerated
-/

#print nhdsWithin_Iio_isMeasurablyGenerated /-
instance nhdsWithin_Iio_isMeasurablyGenerated : (ùìù[Iio b] a).IsMeasurablyGenerated :=
  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Iio_is_measurably_generated nhdsWithin_Iio_isMeasurablyGenerated
-/

#print nhdsWithin_uIcc_isMeasurablyGenerated /-
instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[[a, b]] x) :=
  nhdsWithin_Icc_isMeasurablyGenerated
#align nhds_within_uIcc_is_measurably_generated nhdsWithin_uIcc_isMeasurablyGenerated
-/

/- warning: measurable_set_lt' -> measurableSet_lt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1], MeasurableSet.{u1} (Prod.{u1, u1} Œ± Œ±) (Prod.instMeasurableSpace.{u1, u1} Œ± Œ± _inst_2 _inst_2) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_16)))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1], MeasurableSet.{u1} (Prod.{u1, u1} Œ± Œ±) (Prod.instMeasurableSpace.{u1, u1} Œ± Œ± _inst_2 _inst_2) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_16)))))) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
Case conversion may be inaccurate. Consider using '#align measurable_set_lt' measurableSet_lt'‚Çì'. -/
@[measurability]
theorem measurableSet_lt' [SecondCountableTopology Œ±] : MeasurableSet { p : Œ± √ó Œ± | p.1 < p.2 } :=
  (isOpen_lt continuous_fst continuous_snd).MeasurableSet
#align measurable_set_lt' measurableSet_lt'

/- warning: measurable_set_lt -> measurableSet_lt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 g) -> (MeasurableSet.{u2} Œ¥ _inst_13 (setOf.{u2} Œ¥ (fun (a : Œ¥) => LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))) (f a) (g a))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ¥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u1} Œ¥] [_inst_16 : LinearOrder.{u2} Œ±] [_inst_17 : OrderClosedTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_16)))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u2} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u1, u2} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u1, u2} Œ¥ Œ± _inst_13 _inst_2 g) -> (MeasurableSet.{u1} Œ¥ _inst_13 (setOf.{u1} Œ¥ (fun (a : Œ¥) => LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_16)))))) (f a) (g a))))
Case conversion may be inaccurate. Consider using '#align measurable_set_lt measurableSet_lt‚Çì'. -/
@[measurability]
theorem measurableSet_lt [SecondCountableTopology Œ±] {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f)
    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurableSet_lt'
#align measurable_set_lt measurableSet_lt

/- warning: null_measurable_set_lt -> nullMeasurableSet_lt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_13} {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 g Œº) -> (MeasureTheory.NullMeasurableSet.{u2} Œ¥ _inst_13 (setOf.{u2} Œ¥ (fun (a : Œ¥) => LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))) (f a) (g a))) Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ¥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u1} Œ¥] [_inst_16 : LinearOrder.{u2} Œ±] [_inst_17 : OrderClosedTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_16)))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u2} Œ± _inst_1] {Œº : MeasureTheory.Measure.{u1} Œ¥ _inst_13} {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (AEMeasurable.{u1, u2} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u1, u2} Œ¥ Œ± _inst_2 _inst_13 g Œº) -> (MeasureTheory.NullMeasurableSet.{u1} Œ¥ _inst_13 (setOf.{u1} Œ¥ (fun (a : Œ¥) => LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_16)))))) (f a) (g a))) Œº)
Case conversion may be inaccurate. Consider using '#align null_measurable_set_lt nullMeasurableSet_lt‚Çì'. -/
theorem nullMeasurableSet_lt [SecondCountableTopology Œ±] {Œº : Measure Œ¥} {f g : Œ¥ ‚Üí Œ±}
    (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) : NullMeasurableSet { a | f a < g a } Œº :=
  (hf.prod_mk hg).NullMeasurable measurableSet_lt'
#align null_measurable_set_lt nullMeasurableSet_lt

#print Set.OrdConnected.measurableSet /-
theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s :=
  by
  let u := ‚ãÉ (x ‚àà s) (y ‚àà s), Ioo x y
  have huopen : IsOpen u := isOpen_biUnion fun x hx => isOpen_biUnion fun y hy => isOpen_Ioo
  have humeas : MeasurableSet u := huopen.measurable_set
  have hfinite : (s \ u).Finite := s.finite_diff_Union_Ioo
  have : u ‚äÜ s :=
    Union‚ÇÇ_subset fun x hx => Union‚ÇÇ_subset fun y hy => Ioo_subset_Icc_self.trans (h.out hx hy)
  rw [‚Üê union_diff_cancel this]
  exact humeas.union hfinite.measurable_set
#align set.ord_connected.measurable_set Set.OrdConnected.measurableSet
-/

#print IsPreconnected.measurableSet /-
theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=
  h.OrdConnected.MeasurableSet
#align is_preconnected.measurable_set IsPreconnected.measurableSet
-/

/- warning: generate_from_Ico_mem_le_borel -> generateFrom_Ico_mem_le_borel is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderClosedTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))] (s : Set.{u1} Œ±) (t : Set.{u1} Œ±), LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) => Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u t) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u t) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) (fun (h : LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) => Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))) l u) S)))))))) (borel.{u1} Œ± _inst_18)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderClosedTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))] (s : Set.{u1} Œ±) (t : Set.{u1} Œ±), LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l s) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u t) (And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) l u) (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))) l u) S)))))))) (borel.{u1} Œ± _inst_18)
Case conversion may be inaccurate. Consider using '#align generate_from_Ico_mem_le_borel generateFrom_Ico_mem_le_borel‚Çì'. -/
theorem generateFrom_Ico_mem_le_borel {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderClosedTopology Œ±] (s t : Set Œ±) :
    MeasurableSpace.generateFrom { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà t, ‚àÉ h : l < u, Ico l u = S } ‚â§ borel Œ± :=
  by
  apply generate_from_le
  borelize Œ±
  rintro _ ‚ü®a, -, b, -, -, rfl‚ü©
  exact measurableSet_Ico
#align generate_from_Ico_mem_le_borel generateFrom_Ico_mem_le_borel

/- warning: dense.borel_eq_generate_from_Ico_mem_aux -> Dense.borel_eq_generateFrom_Ico_mem_aux is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (forall (x : Œ±), (IsBot.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) x) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) -> (forall (x : Œ±) (y : Œ±), (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) x y) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))) x y) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±))) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s)) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) => Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) (fun (h : LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) => Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))) l u) S)))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (forall (x : Œ±), (IsBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) x) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) -> (forall (x : Œ±) (y : Œ±), (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) x y) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))) x y) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±))) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s)) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l s) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u s) (And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) l u) (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))) l u) S)))))))))
Case conversion may be inaccurate. Consider using '#align dense.borel_eq_generate_from_Ico_mem_aux Dense.borel_eq_generateFrom_Ico_mem_aux‚Çì'. -/
theorem Dense.borel_eq_generateFrom_Ico_mem_aux {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsBot x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí y ‚àà s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S } :=
  by
  set S : Set (Set Œ±) := { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S }
  refine' le_antisymm _ (generateFrom_Ico_mem_le_borel _ _)
  letI : MeasurableSpace Œ± := generate_from S
  rw [borel_eq_generateFrom_Iio]
  refine' generate_from_le (forall_range_iff.2 fun a => _)
  rcases hd.exists_countable_dense_subset_bot_top with ‚ü®t, hts, hc, htd, htb, htt‚ü©
  by_cases ha : ‚àÄ b < a, (Ioo b a).Nonempty
  ¬∑ convert_to MeasurableSet (‚ãÉ (l ‚àà t) (u ‚àà t) (hlu : l < u) (hu : u ‚â§ a), Ico l u)
    ¬∑ ext y
      simp only [mem_Union, mem_Iio, mem_Ico]
      constructor
      ¬∑ intro hy
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ‚ü®l, hlt, hly‚ü©
        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with ‚ü®u, hut, hyu, hua‚ü©
        exact ‚ü®l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu‚ü©
      ¬∑ rintro ‚ü®l, -, u, -, -, hua, -, hyu‚ü©
        exact hyu.trans_le hua
    ¬∑ refine' MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => _
      refine' MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun hb' => _
      exact generate_measurable.basic _ ‚ü®a, hts ha, b, hts hb, hab, mem_singleton _‚ü©
  ¬∑ simp only [not_forall, not_nonempty_iff_eq_empty] at ha
    replace ha : a ‚àà s := hIoo ha.some a ha.some_spec.fst ha.some_spec.snd
    convert_to MeasurableSet (‚ãÉ (l ‚àà t) (hl : l < a), Ico l a)
    ¬∑ symm
      simp only [‚Üê Ici_inter_Iio, ‚Üê Union_inter, inter_eq_right_iff_subset, subset_def, mem_Union,
        mem_Ici, mem_Iio]
      intro x hx
      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ‚ü®z, hzt, hzx‚ü©
      exact ‚ü®z, hzt, hzx.trans_lt hx, hzx‚ü©
    ¬∑ refine' MeasurableSet.biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => _
      exact generate_measurable.basic _ ‚ü®x, hts hx, a, ha, hlt, mem_singleton _‚ü©
#align dense.borel_eq_generate_from_Ico_mem_aux Dense.borel_eq_generateFrom_Ico_mem_aux

/- warning: dense.borel_eq_generate_from_Ico_mem -> Dense.borel_eq_generateFrom_Ico_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_22 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))))] [_inst_23 : NoMinOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) => Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) (fun (h : LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) => Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))) l u) S)))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_22 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))))] [_inst_23 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l s) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u s) (And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) l u) (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))) l u) S)))))))))
Case conversion may be inaccurate. Consider using '#align dense.borel_eq_generate_from_Ico_mem Dense.borel_eq_generateFrom_Ico_mem‚Çì'. -/
theorem Dense.borel_eq_generateFrom_Ico_mem {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMinOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S } :=
  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun x y hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim
#align dense.borel_eq_generate_from_Ico_mem Dense.borel_eq_generateFrom_Ico_mem

/- warning: borel_eq_generate_from_Ico -> borel_eq_generateFrom_Ico is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) l u) (fun (h : LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) l u) => Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) l u) S))))))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{succ u1} Œ± (fun (u : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) l u) (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) l u) S))))))
Case conversion may be inaccurate. Consider using '#align borel_eq_generate_from_Ico borel_eq_generateFrom_Ico‚Çì'. -/
theorem borel_eq_generateFrom_Ico (Œ± : Type _) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ (l u : _)(h : l < u), Ico l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _
#align borel_eq_generate_from_Ico borel_eq_generateFrom_Ico

/- warning: dense.borel_eq_generate_from_Ioc_mem_aux -> Dense.borel_eq_generateFrom_Ioc_mem_aux is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (forall (x : Œ±), (IsTop.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) x) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) -> (forall (x : Œ±) (y : Œ±), (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) x y) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))) x y) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±))) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) => Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) (fun (h : LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) => Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))) l u) S)))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (forall (x : Œ±), (IsTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) x) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) -> (forall (x : Œ±) (y : Œ±), (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) x y) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))) x y) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±))) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l s) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u s) (And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) l u) (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))) l u) S)))))))))
Case conversion may be inaccurate. Consider using '#align dense.borel_eq_generate_from_Ioc_mem_aux Dense.borel_eq_generateFrom_Ioc_mem_aux‚Çì'. -/
theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsTop x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí x ‚àà s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ioc l u = S } :=
  by
  convert hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
  ¬∑ ext s
    constructor <;> rintro ‚ü®l, hl, u, hu, hlt, rfl‚ü©
    exacts[‚ü®u, hu, l, hl, hlt, dual_Ico‚ü©, ‚ü®u, hu, l, hl, hlt, dual_Ioc‚ü©]
  ¬∑ erw [dual_Ioo]
    exact he
#align dense.borel_eq_generate_from_Ioc_mem_aux Dense.borel_eq_generateFrom_Ioc_mem_aux

/- warning: dense.borel_eq_generate_from_Ioc_mem -> Dense.borel_eq_generateFrom_Ioc_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_22 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))))] [_inst_23 : NoMaxOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l s) => Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u s) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) (fun (h : LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19))))) l u) => Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_19)))) l u) S)))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : LinearOrder.{u1} Œ±] [_inst_20 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))] [_inst_21 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_22 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))))] [_inst_23 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_18 s) -> (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l s) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u s) (And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19)))))) l u) (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_19))))) l u) S)))))))))
Case conversion may be inaccurate. Consider using '#align dense.borel_eq_generate_from_Ioc_mem Dense.borel_eq_generateFrom_Ioc_mem‚Çì'. -/
theorem Dense.borel_eq_generateFrom_Ioc_mem {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMaxOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ioc l u = S } :=
  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun x y hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim
#align dense.borel_eq_generate_from_Ioc_mem Dense.borel_eq_generateFrom_Ioc_mem

/- warning: borel_eq_generate_from_Ioc -> borel_eq_generateFrom_Ioc is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) l u) (fun (h : LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) l u) => Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) l u) S))))))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_18 : TopologicalSpace.{u1} Œ±] [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))], Eq.{succ u1} (MeasurableSpace.{u1} Œ±) (borel.{u1} Œ± _inst_18) (MeasurableSpace.generateFrom.{u1} Œ± (setOf.{u1} (Set.{u1} Œ±) (fun (S : Set.{u1} Œ±) => Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{succ u1} Œ± (fun (u : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) l u) (Eq.{succ u1} (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) l u) S))))))
Case conversion may be inaccurate. Consider using '#align borel_eq_generate_from_Ioc borel_eq_generateFrom_Ioc‚Çì'. -/
theorem borel_eq_generateFrom_Ioc (Œ± : Type _) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ (l u : _)(h : l < u), Ioc l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _
#align borel_eq_generate_from_Ioc borel_eq_generateFrom_Ioc

namespace MeasureTheory.Measure

/- warning: measure_theory.measure.ext_of_Ico_finite -> MeasureTheory.Measure.ext_of_Ico_finite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_23 : MeasureTheory.FiniteMeasure.{u1} Œ± m Œº], (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.univ.{u1} Œ±))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) a b) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_23 : MeasureTheory.FiniteMeasure.{u1} Œ± m Œº], (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.univ.{u1} Œ±)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.univ.{u1} Œ±))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_Ico_finite MeasureTheory.Measure.ext_of_Ico_finite‚Çì'. -/
/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ico_finite {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [FiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) :
    Œº = ŒΩ :=
  by
  refine'
    ext_of_generate_finite _ (borel_space.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±))
      (isPiSystem_Ico (id : Œ± ‚Üí Œ±) id) _ hŒºŒΩ
  ¬∑ rintro - ‚ü®a, b, hlt, rfl‚ü©
    exact h hlt
#align measure_theory.measure.ext_of_Ico_finite MeasureTheory.Measure.ext_of_Ico_finite

/- warning: measure_theory.measure.ext_of_Ioc_finite -> MeasureTheory.Measure.ext_of_Ioc_finite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_23 : MeasureTheory.FiniteMeasure.{u1} Œ± m Œº], (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.univ.{u1} Œ±))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) a b) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_23 : MeasureTheory.FiniteMeasure.{u1} Œ± m Œº], (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.univ.{u1} Œ±)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.univ.{u1} Œ±))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_Ioc_finite MeasureTheory.Measure.ext_of_Ioc_finite‚Çì'. -/
/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ioc_finite {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [FiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) :
    Œº = ŒΩ := by
  refine' @ext_of_Ico_finite Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ Œº ŒΩ _ hŒºŒΩ fun a b hab => _
  erw [dual_Ico]
  exact h hab
#align measure_theory.measure.ext_of_Ioc_finite MeasureTheory.Measure.ext_of_Ioc_finite

/- warning: measure_theory.measure.ext_of_Ico' -> MeasureTheory.Measure.ext_of_Ico' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMaxOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m), (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) a b) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) a b) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m), (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) a b) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_Ico' MeasureTheory.Measure.ext_of_Ico'‚Çì'. -/
/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico' {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMaxOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=
  by
  rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, hsb, hst‚ü©
  have : (‚ãÉ (l ‚àà s) (u ‚àà s) (h : l < u), {Ico l u} : Set (Set Œ±)).Countable :=
    hsc.bUnion fun l hl => hsc.bUnion fun u hu => countable_Union fun _ => countable_singleton _
  simp only [‚Üê set_of_eq_eq_singleton, ‚Üê set_of_exists] at this
  refine'
    measure.ext_of_generate_from_of_cover_subset
      (borel_space.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±)) (isPiSystem_Ico id id) _ this
      _ _ _
  ¬∑ rintro _ ‚ü®l, -, u, -, h, rfl‚ü©
    exact ‚ü®l, u, h, rfl‚ü©
  ¬∑ refine' sUnion_eq_univ_iff.2 fun x => _
    rcases hsd.exists_le' hsb x with ‚ü®l, hls, hlx‚ü©
    rcases hsd.exists_gt x with ‚ü®u, hus, hxu‚ü©
    exact ‚ü®_, ‚ü®l, hls, u, hus, hlx.trans_lt hxu, rfl‚ü©, hlx, hxu‚ü©
  ¬∑ rintro _ ‚ü®l, -, u, -, hlt, rfl‚ü©
    exact hŒº hlt
  ¬∑ rintro _ ‚ü®l, u, hlt, rfl‚ü©
    exact h hlt
#align measure_theory.measure.ext_of_Ico' MeasureTheory.Measure.ext_of_Ico'

/- warning: measure_theory.measure.ext_of_Ioc' -> MeasureTheory.Measure.ext_of_Ioc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMinOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m), (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) a b) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20))))) a b) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_20)))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : LinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m), (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) a b) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) -> (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_Ioc' MeasureTheory.Measure.ext_of_Ioc'‚Çì'. -/
/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMinOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=
  by
  refine' @ext_of_Ico' Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ Œº ŒΩ _ _ <;> intro a b hab <;> erw [dual_Ico]
  exacts[hŒº hab, h hab]
#align measure_theory.measure.ext_of_Ioc' MeasureTheory.Measure.ext_of_Ioc'

/- warning: measure_theory.measure.ext_of_Ico -> MeasureTheory.Measure.ext_of_Ico is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMaxOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_24 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_18 Œº], (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_24 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_18 Œº], (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_Ico MeasureTheory.Measure.ext_of_Ico‚Çì'. -/
/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : Measure Œ±) [LocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ico' ŒΩ (fun a b hab => measure_Ico_lt_top.Ne) h
#align measure_theory.measure.ext_of_Ico MeasureTheory.Measure.ext_of_Ico

/- warning: measure_theory.measure.ext_of_Ioc -> MeasureTheory.Measure.ext_of_Ioc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMinOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_24 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_18 Œº], (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) ŒΩ (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_18 : TopologicalSpace.{u1} Œ±] {m : MeasurableSpace.{u1} Œ±} [_inst_19 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_18] [_inst_20 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_21 : OrderTopology.{u1} Œ± _inst_18 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))] [_inst_22 : BorelSpace.{u1} Œ± _inst_18 m] [_inst_23 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))))] (Œº : MeasureTheory.Measure.{u1} Œ± m) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m) [_inst_24 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_18 Œº], (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20)))))) a b) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m ŒΩ) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_20))))) a b)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_Ioc MeasureTheory.Measure.ext_of_Ioc‚Çì'. -/
/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMinOrder Œ±] (Œº ŒΩ : Measure Œ±) [LocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ioc' ŒΩ (fun a b hab => measure_Ioc_lt_top.Ne) h
#align measure_theory.measure.ext_of_Ioc MeasureTheory.Measure.ext_of_Ioc

#print MeasureTheory.Measure.ext_of_Iic /-
/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [FiniteMeasure Œº] (h : ‚àÄ a, Œº (Iic a) = ŒΩ (Iic a)) : Œº = ŒΩ :=
  by
  refine' ext_of_Ioc_finite Œº ŒΩ _ fun a b hlt => _
  ¬∑ rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, -, hst‚ü©
    have : DirectedOn (¬∑ ‚â§ ¬∑) s := directedOn_iff_directed.2 (directed_of_sup fun _ _ => id)
    simp only [‚Üê bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, h]
  rw [‚Üê Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic,
    measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic, h a, h b]
  ¬∑ rw [‚Üê h a]
    exact (measure_lt_top Œº _).Ne
  ¬∑ exact (measure_lt_top Œº _).Ne
#align measure_theory.measure.ext_of_Iic MeasureTheory.Measure.ext_of_Iic
-/

#print MeasureTheory.Measure.ext_of_Ici /-
/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [FiniteMeasure Œº] (h : ‚àÄ a, Œº (Ici a) = ŒΩ (Ici a)) : Œº = ŒΩ :=
  @ext_of_Iic Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ h
#align measure_theory.measure.ext_of_Ici MeasureTheory.Measure.ext_of_Ici
-/

end MeasureTheory.Measure

end LinearOrder

section LinearOrder

variable [LinearOrder Œ±] [OrderClosedTopology Œ±] {a b : Œ±}

#print measurableSet_uIcc /-
@[measurability]
theorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=
  measurableSet_Icc
#align measurable_set_uIcc measurableSet_uIcc
-/

#print measurableSet_uIoc /-
@[measurability]
theorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=
  measurableSet_Ioc
#align measurable_set_uIoc measurableSet_uIoc
-/

variable [SecondCountableTopology Œ±]

/- warning: measurable.max -> Measurable.max is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 g) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 (fun (a : Œ¥) => LinearOrder.max.{u1} Œ± _inst_16 (f a) (g a)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_16)))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 g) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 (fun (a : Œ¥) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_16) (f a) (g a)))
Case conversion may be inaccurate. Consider using '#align measurable.max Measurable.max‚Çì'. -/
@[measurability]
theorem Measurable.max {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => max (f a) (g a) := by
  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg
#align measurable.max Measurable.max

/- warning: ae_measurable.max -> AEMeasurable.max is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_13}, (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 g Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 (fun (a : Œ¥) => LinearOrder.max.{u1} Œ± _inst_16 (f a) (g a)) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_16)))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_13}, (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 g Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 (fun (a : Œ¥) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_16) (f a) (g a)) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable.max AEMeasurable.max‚Çì'. -/
@[measurability]
theorem AEMeasurable.max {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => max (f a) (g a)) Œº :=
  ‚ü®fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©
#align ae_measurable.max AEMeasurable.max

/- warning: measurable.min -> Measurable.min is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 g) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 (fun (a : Œ¥) => LinearOrder.min.{u1} Œ± _inst_16 (f a) (g a)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_16)))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±}, (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 g) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_13 _inst_2 (fun (a : Œ¥) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_16) (f a) (g a)))
Case conversion may be inaccurate. Consider using '#align measurable.min Measurable.min‚Çì'. -/
@[measurability]
theorem Measurable.min {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => min (f a) (g a) := by
  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg
#align measurable.min Measurable.min

/- warning: ae_measurable.min -> AEMeasurable.min is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_16))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_13}, (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 g Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 (fun (a : Œ¥) => LinearOrder.min.{u1} Œ± _inst_16 (f a) (g a)) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : LinearOrder.{u1} Œ±] [_inst_17 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_16)))))] [_inst_18 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ±} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_13}, (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 g Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_13 (fun (a : Œ¥) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_16) (f a) (g a)) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable.min AEMeasurable.min‚Çì'. -/
@[measurability]
theorem AEMeasurable.min {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => min (f a) (g a)) Œº :=
  ‚ü®fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©
#align ae_measurable.min AEMeasurable.min

end LinearOrder

/- warning: continuous.measurable -> Continuous.measurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥}, (Continuous.{u1, u2} Œ± Œ≥ _inst_1 _inst_7 f) -> (Measurable.{u1, u2} Œ± Œ≥ _inst_2 _inst_8 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥}, (Continuous.{u2, u1} Œ± Œ≥ _inst_1 _inst_7 f) -> (Measurable.{u2, u1} Œ± Œ≥ _inst_2 _inst_8 f)
Case conversion may be inaccurate. Consider using '#align continuous.measurable Continuous.measurable‚Çì'. -/
/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
theorem Continuous.measurable {f : Œ± ‚Üí Œ≥} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)
#align continuous.measurable Continuous.measurable

/- warning: continuous.ae_measurable -> Continuous.aemeasurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥}, (Continuous.{u1, u2} Œ± Œ≥ _inst_1 _inst_7 f) -> (forall {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2}, AEMeasurable.{u1, u2} Œ± Œ≥ _inst_8 _inst_2 f Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥}, (Continuous.{u2, u1} Œ± Œ≥ _inst_1 _inst_7 f) -> (forall {Œº : MeasureTheory.Measure.{u2} Œ± _inst_2}, AEMeasurable.{u2, u1} Œ± Œ≥ _inst_8 _inst_2 f Œº)
Case conversion may be inaccurate. Consider using '#align continuous.ae_measurable Continuous.aemeasurable‚Çì'. -/
/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is ae-measurable. -/
theorem Continuous.aemeasurable {f : Œ± ‚Üí Œ≥} (h : Continuous f) {Œº : Measure Œ±} : AEMeasurable f Œº :=
  h.Measurable.AEMeasurable
#align continuous.ae_measurable Continuous.aemeasurable

/- warning: closed_embedding.measurable -> ClosedEmbedding.measurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥}, (ClosedEmbedding.{u1, u2} Œ± Œ≥ _inst_1 _inst_7 f) -> (Measurable.{u1, u2} Œ± Œ≥ _inst_2 _inst_8 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥}, (ClosedEmbedding.{u2, u1} Œ± Œ≥ _inst_1 _inst_7 f) -> (Measurable.{u2, u1} Œ± Œ≥ _inst_2 _inst_8 f)
Case conversion may be inaccurate. Consider using '#align closed_embedding.measurable ClosedEmbedding.measurable‚Çì'. -/
theorem ClosedEmbedding.measurable {f : Œ± ‚Üí Œ≥} (hf : ClosedEmbedding f) : Measurable f :=
  hf.Continuous.Measurable
#align closed_embedding.measurable ClosedEmbedding.measurable

/- warning: continuous.is_open_pos_measure_map -> Continuous.openPosMeasure_map is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_4 : TopologicalSpace.{u1} Œ≤] [_inst_5 : MeasurableSpace.{u1} Œ≤] [_inst_6 : OpensMeasurableSpace.{u1} Œ≤ _inst_4 _inst_5] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] {f : Œ≤ -> Œ≥}, (Continuous.{u1, u2} Œ≤ Œ≥ _inst_4 _inst_7 f) -> (Function.Surjective.{succ u1, succ u2} Œ≤ Œ≥ f) -> (forall {Œº : MeasureTheory.Measure.{u1} Œ≤ _inst_5} [_inst_16 : MeasureTheory.Measure.OpenPosMeasure.{u1} Œ≤ _inst_4 _inst_5 Œº], MeasureTheory.Measure.OpenPosMeasure.{u2} Œ≥ _inst_7 _inst_8 (MeasureTheory.Measure.map.{u1, u2} Œ≤ Œ≥ _inst_8 _inst_5 f Œº))
but is expected to have type
  forall {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : OpensMeasurableSpace.{u2} Œ≤ _inst_4 _inst_5] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] {f : Œ≤ -> Œ≥}, (Continuous.{u2, u1} Œ≤ Œ≥ _inst_4 _inst_7 f) -> (Function.Surjective.{succ u2, succ u1} Œ≤ Œ≥ f) -> (forall {Œº : MeasureTheory.Measure.{u2} Œ≤ _inst_5} [_inst_16 : MeasureTheory.Measure.OpenPosMeasure.{u2} Œ≤ _inst_4 _inst_5 Œº], MeasureTheory.Measure.OpenPosMeasure.{u1} Œ≥ _inst_7 _inst_8 (MeasureTheory.Measure.map.{u2, u1} Œ≤ Œ≥ _inst_8 _inst_5 f Œº))
Case conversion may be inaccurate. Consider using '#align continuous.is_open_pos_measure_map Continuous.openPosMeasure_map‚Çì'. -/
theorem Continuous.openPosMeasure_map {f : Œ≤ ‚Üí Œ≥} (hf : Continuous f)
    (hf_surj : Function.Surjective f) {Œº : Measure Œ≤} [Œº.OpenPosMeasure] :
    (Measure.map f Œº).OpenPosMeasure :=
  by
  refine' ‚ü®fun U hUo hUne => _‚ü©
  rw [measure.map_apply hf.measurable hUo.measurable_set]
  exact (hUo.preimage hf).measure_ne_zero Œº (hf_surj.nonempty_preimage.mpr hUne)
#align continuous.is_open_pos_measure_map Continuous.openPosMeasure_map

/- warning: continuous_on.measurable_piecewise -> ContinuousOn.measurable_piecewise is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥} {g : Œ± -> Œ≥} {s : Set.{u1} Œ±} [_inst_16 : forall (j : Œ±), Decidable (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) j s)], (ContinuousOn.{u1, u2} Œ± Œ≥ _inst_1 _inst_7 f s) -> (ContinuousOn.{u1, u2} Œ± Œ≥ _inst_1 _inst_7 g (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) -> (MeasurableSet.{u1} Œ± _inst_2 s) -> (Measurable.{u1, u2} Œ± Œ≥ _inst_2 _inst_8 (Set.piecewise.{u1, succ u2} Œ± (fun (·æ∞ : Œ±) => Œ≥) s f g (fun (j : Œ±) => _inst_16 j)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] {f : Œ± -> Œ≥} {g : Œ± -> Œ≥} {s : Set.{u2} Œ±} [_inst_16 : forall (j : Œ±), Decidable (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) j s)], (ContinuousOn.{u2, u1} Œ± Œ≥ _inst_1 _inst_7 f s) -> (ContinuousOn.{u2, u1} Œ± Œ≥ _inst_1 _inst_7 g (HasCompl.compl.{u2} (Set.{u2} Œ±) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} Œ±) (Set.instBooleanAlgebraSet.{u2} Œ±)) s)) -> (MeasurableSet.{u2} Œ± _inst_2 s) -> (Measurable.{u2, u1} Œ± Œ≥ _inst_2 _inst_8 (Set.piecewise.{u2, succ u1} Œ± (fun (·æ∞ : Œ±) => Œ≥) s f g (fun (j : Œ±) => _inst_16 j)))
Case conversion may be inaccurate. Consider using '#align continuous_on.measurable_piecewise ContinuousOn.measurable_piecewise‚Çì'. -/
/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurable_piecewise {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [‚àÄ j : Œ±, Decidable (j ‚àà s)]
    (hf : ContinuousOn f s) (hg : ContinuousOn g (s·∂ú)) (hs : MeasurableSet s) :
    Measurable (s.piecewise f g) :=
  by
  refine' measurable_of_isOpen fun t ht => _
  rw [piecewise_preimage, Set.ite]
  apply MeasurableSet.union
  ¬∑ rcases _root_.continuous_on_iff'.1 hf t ht with ‚ü®u, u_open, hu‚ü©
    rw [hu]
    exact u_open.measurable_set.inter hs
  ¬∑ rcases _root_.continuous_on_iff'.1 hg t ht with ‚ü®u, u_open, hu‚ü©
    rw [diff_eq_compl_inter, inter_comm, hu]
    exact u_open.measurable_set.inter hs.compl
#align continuous_on.measurable_piecewise ContinuousOn.measurable_piecewise

#print ContinuousMul.measurableMul /-
@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul [Mul Œ≥] [ContinuousMul Œ≥] : MeasurableMul Œ≥
    where
  measurable_const_mul c := (continuous_const.mul continuous_id).Measurable
  measurable_mul_const c := (continuous_id.mul continuous_const).Measurable
#align has_continuous_mul.has_measurable_mul ContinuousMul.measurableMul
#align has_continuous_add.has_measurable_add ContinuousAdd.measurableAdd
-/

#print ContinuousSub.measurableSub /-
instance (priority := 100) ContinuousSub.measurableSub [Sub Œ≥] [ContinuousSub Œ≥] : MeasurableSub Œ≥
    where
  measurable_const_sub c := (continuous_const.sub continuous_id).Measurable
  measurable_sub_const c := (continuous_id.sub continuous_const).Measurable
#align has_continuous_sub.has_measurable_sub ContinuousSub.measurableSub
-/

/- warning: topological_group.has_measurable_inv -> TopologicalGroup.measurableInv is a dubious translation:
lean 3 declaration is
  forall {Œ≥ : Type.{u1}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_16 : Group.{u1} Œ≥] [_inst_17 : TopologicalGroup.{u1} Œ≥ _inst_7 _inst_16], MeasurableInv.{u1} Œ≥ (DivInvMonoid.toHasInv.{u1} Œ≥ (Group.toDivInvMonoid.{u1} Œ≥ _inst_16)) _inst_8
but is expected to have type
  forall {Œ≥ : Type.{u1}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_16 : Group.{u1} Œ≥] [_inst_17 : TopologicalGroup.{u1} Œ≥ _inst_7 _inst_16], MeasurableInv.{u1} Œ≥ (InvOneClass.toInv.{u1} Œ≥ (DivInvOneMonoid.toInvOneClass.{u1} Œ≥ (DivisionMonoid.toDivInvOneMonoid.{u1} Œ≥ (Group.toDivisionMonoid.{u1} Œ≥ _inst_16)))) _inst_8
Case conversion may be inaccurate. Consider using '#align topological_group.has_measurable_inv TopologicalGroup.measurableInv‚Çì'. -/
@[to_additive]
instance (priority := 100) TopologicalGroup.measurableInv [Group Œ≥] [TopologicalGroup Œ≥] :
    MeasurableInv Œ≥ :=
  ‚ü®continuous_inv.Measurable‚ü©
#align topological_group.has_measurable_inv TopologicalGroup.measurableInv
#align topological_add_group.has_measurable_neg TopologicalAddGroup.measurableNeg

#print ContinuousSMul.measurableSMul /-
instance (priority := 100) ContinuousSMul.measurableSMul {M Œ±} [TopologicalSpace M]
    [TopologicalSpace Œ±] [MeasurableSpace M] [MeasurableSpace Œ±] [OpensMeasurableSpace M]
    [BorelSpace Œ±] [SMul M Œ±] [ContinuousSMul M Œ±] : MeasurableSMul M Œ± :=
  ‚ü®fun c => (continuous_const_smul _).Measurable, fun y =>
    (continuous_id.smul continuous_const).Measurable‚ü©
#align has_continuous_smul.has_measurable_smul ContinuousSMul.measurableSMul
-/

section Lattice

#print ContinuousSup.measurableSup /-
instance (priority := 100) ContinuousSup.measurableSup [Sup Œ≥] [ContinuousSup Œ≥] : MeasurableSup Œ≥
    where
  measurable_const_sup c := (continuous_const.sup continuous_id).Measurable
  measurable_sup_const c := (continuous_id.sup continuous_const).Measurable
#align has_continuous_sup.has_measurable_sup ContinuousSup.measurableSup
-/

#print ContinuousSup.measurableSup‚ÇÇ /-
instance (priority := 100) ContinuousSup.measurableSup‚ÇÇ [SecondCountableTopology Œ≥] [Sup Œ≥]
    [ContinuousSup Œ≥] : MeasurableSup‚ÇÇ Œ≥ :=
  ‚ü®continuous_sup.Measurable‚ü©
#align has_continuous_sup.has_measurable_sup‚ÇÇ ContinuousSup.measurableSup‚ÇÇ
-/

#print ContinuousInf.measurableInf /-
instance (priority := 100) ContinuousInf.measurableInf [Inf Œ≥] [ContinuousInf Œ≥] : MeasurableInf Œ≥
    where
  measurable_const_inf c := (continuous_const.inf continuous_id).Measurable
  measurable_inf_const c := (continuous_id.inf continuous_const).Measurable
#align has_continuous_inf.has_measurable_inf ContinuousInf.measurableInf
-/

#print ContinuousInf.measurableInf‚ÇÇ /-
instance (priority := 100) ContinuousInf.measurableInf‚ÇÇ [SecondCountableTopology Œ≥] [Inf Œ≥]
    [ContinuousInf Œ≥] : MeasurableInf‚ÇÇ Œ≥ :=
  ‚ü®continuous_inf.Measurable‚ü©
#align has_continuous_inf.has_measurable_inf‚ÇÇ ContinuousInf.measurableInf‚ÇÇ
-/

end Lattice

section Homeomorph

/- warning: homeomorph.measurable -> Homeomorph.measurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] (h : Homeomorph.{u1, u2} Œ± Œ≥ _inst_1 _inst_7), Measurable.{u1, u2} Œ± Œ≥ _inst_2 _inst_8 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Homeomorph.{u1, u2} Œ± Œ≥ _inst_1 _inst_7) (fun (_x : Homeomorph.{u1, u2} Œ± Œ≥ _inst_1 _inst_7) => Œ± -> Œ≥) (Homeomorph.hasCoeToFun.{u1, u2} Œ± Œ≥ _inst_1 _inst_7) h)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] (h : Homeomorph.{u2, u1} Œ± Œ≥ _inst_1 _inst_7), Measurable.{u2, u1} Œ± Œ≥ _inst_2 _inst_8 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ± Œ≥ _inst_1 _inst_7) Œ± (fun (_x : Œ±) => Œ≥) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ± Œ≥ _inst_1 _inst_7) Œ± Œ≥ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ± Œ≥ _inst_1 _inst_7) Œ± Œ≥ (Homeomorph.instEquivLikeHomeomorph.{u2, u1} Œ± Œ≥ _inst_1 _inst_7))) h)
Case conversion may be inaccurate. Consider using '#align homeomorph.measurable Homeomorph.measurable‚Çì'. -/
@[measurability]
protected theorem Homeomorph.measurable (h : Œ± ‚âÉ‚Çú Œ≥) : Measurable h :=
  h.Continuous.Measurable
#align homeomorph.measurable Homeomorph.measurable

#print Homeomorph.toMeasurableEquiv /-
/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ
    where
  measurable_to_fun := h.Measurable
  measurable_inv_fun := h.symm.Measurable
  toEquiv := h.toEquiv
#align homeomorph.to_measurable_equiv Homeomorph.toMeasurableEquiv
-/

/- warning: homeomorph.to_measurable_equiv_coe -> Homeomorph.toMeasurableEquiv_coe is a dubious translation:
lean 3 declaration is
  forall {Œ≥ : Type.{u1}} {Œ≥‚ÇÇ : Type.{u2}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_10 : TopologicalSpace.{u2} Œ≥‚ÇÇ] [_inst_11 : MeasurableSpace.{u2} Œ≥‚ÇÇ] [_inst_12 : BorelSpace.{u2} Œ≥‚ÇÇ _inst_10 _inst_11] (h : Homeomorph.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10), Eq.{max (succ u1) (succ u2)} ((fun (_x : MeasurableEquiv.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11) => Œ≥ -> Œ≥‚ÇÇ) (Homeomorph.toMeasurableEquiv.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 h)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11) (fun (_x : MeasurableEquiv.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11) => Œ≥ -> Œ≥‚ÇÇ) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11) (Homeomorph.toMeasurableEquiv.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 h)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Homeomorph.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10) (fun (_x : Homeomorph.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10) => Œ≥ -> Œ≥‚ÇÇ) (Homeomorph.hasCoeToFun.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10) h)
but is expected to have type
  forall {Œ≥ : Type.{u2}} {Œ≥‚ÇÇ : Type.{u1}} [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] [_inst_10 : TopologicalSpace.{u1} Œ≥‚ÇÇ] [_inst_11 : MeasurableSpace.{u1} Œ≥‚ÇÇ] [_inst_12 : BorelSpace.{u1} Œ≥‚ÇÇ _inst_10 _inst_11] (h : Homeomorph.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10), Eq.{max (succ u2) (succ u1)} (forall (a : Œ≥), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≥) => Œ≥‚ÇÇ) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11) Œ≥ (fun (_x : Œ≥) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≥) => Œ≥‚ÇÇ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11) Œ≥ Œ≥‚ÇÇ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11) Œ≥ Œ≥‚ÇÇ (MeasurableEquiv.instEquivLike.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11))) (Homeomorph.toMeasurableEquiv.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 h)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10) Œ≥ (fun (_x : Œ≥) => Œ≥‚ÇÇ) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10) Œ≥ Œ≥‚ÇÇ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10) Œ≥ Œ≥‚ÇÇ (Homeomorph.instEquivLikeHomeomorph.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10))) h)
Case conversion may be inaccurate. Consider using '#align homeomorph.to_measurable_equiv_coe Homeomorph.toMeasurableEquiv_coe‚Çì'. -/
@[simp]
theorem Homeomorph.toMeasurableEquiv_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.toMeasurableEquiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=
  rfl
#align homeomorph.to_measurable_equiv_coe Homeomorph.toMeasurableEquiv_coe

/- warning: homeomorph.to_measurable_equiv_symm_coe -> Homeomorph.toMeasurableEquiv_symm_coe is a dubious translation:
lean 3 declaration is
  forall {Œ≥ : Type.{u1}} {Œ≥‚ÇÇ : Type.{u2}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_10 : TopologicalSpace.{u2} Œ≥‚ÇÇ] [_inst_11 : MeasurableSpace.{u2} Œ≥‚ÇÇ] [_inst_12 : BorelSpace.{u2} Œ≥‚ÇÇ _inst_10 _inst_11] (h : Homeomorph.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10), Eq.{max (succ u2) (succ u1)} ((fun (_x : MeasurableEquiv.{u2, u1} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8) => Œ≥‚ÇÇ -> Œ≥) (MeasurableEquiv.symm.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11 (Homeomorph.toMeasurableEquiv.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 h))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MeasurableEquiv.{u2, u1} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8) (fun (_x : MeasurableEquiv.{u2, u1} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8) => Œ≥‚ÇÇ -> Œ≥) (MeasurableEquiv.hasCoeToFun.{u2, u1} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8) (MeasurableEquiv.symm.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11 (Homeomorph.toMeasurableEquiv.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 h))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Homeomorph.{u2, u1} Œ≥‚ÇÇ Œ≥ _inst_10 _inst_7) (fun (_x : Homeomorph.{u2, u1} Œ≥‚ÇÇ Œ≥ _inst_10 _inst_7) => Œ≥‚ÇÇ -> Œ≥) (Homeomorph.hasCoeToFun.{u2, u1} Œ≥‚ÇÇ Œ≥ _inst_10 _inst_7) (Homeomorph.symm.{u1, u2} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10 h))
but is expected to have type
  forall {Œ≥ : Type.{u2}} {Œ≥‚ÇÇ : Type.{u1}} [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] [_inst_10 : TopologicalSpace.{u1} Œ≥‚ÇÇ] [_inst_11 : MeasurableSpace.{u1} Œ≥‚ÇÇ] [_inst_12 : BorelSpace.{u1} Œ≥‚ÇÇ _inst_10 _inst_11] (h : Homeomorph.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10), Eq.{max (succ u2) (succ u1)} (forall (a : Œ≥‚ÇÇ), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≥‚ÇÇ) => Œ≥) a) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8) Œ≥‚ÇÇ (fun (_x : Œ≥‚ÇÇ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≥‚ÇÇ) => Œ≥) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8) Œ≥‚ÇÇ Œ≥ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8) Œ≥‚ÇÇ Œ≥ (MeasurableEquiv.instEquivLike.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_11 _inst_8))) (MeasurableEquiv.symm.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_8 _inst_11 (Homeomorph.toMeasurableEquiv.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 h))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Homeomorph.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_10 _inst_7) Œ≥‚ÇÇ (fun (_x : Œ≥‚ÇÇ) => Œ≥) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Homeomorph.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_10 _inst_7) Œ≥‚ÇÇ Œ≥ (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (Homeomorph.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_10 _inst_7) Œ≥‚ÇÇ Œ≥ (Homeomorph.instEquivLikeHomeomorph.{u1, u2} Œ≥‚ÇÇ Œ≥ _inst_10 _inst_7))) (Homeomorph.symm.{u2, u1} Œ≥ Œ≥‚ÇÇ _inst_7 _inst_10 h))
Case conversion may be inaccurate. Consider using '#align homeomorph.to_measurable_equiv_symm_coe Homeomorph.toMeasurableEquiv_symm_coe‚Çì'. -/
@[simp]
theorem Homeomorph.toMeasurableEquiv_symm_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) :
    (h.toMeasurableEquiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=
  rfl
#align homeomorph.to_measurable_equiv_symm_coe Homeomorph.toMeasurableEquiv_symm_coe

end Homeomorph

/- warning: continuous_map.measurable -> ContinuousMap.measurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] (f : ContinuousMap.{u1, u2} Œ± Œ≥ _inst_1 _inst_7), Measurable.{u1, u2} Œ± Œ≥ _inst_2 _inst_8 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Œ± Œ≥ _inst_1 _inst_7) (fun (_x : ContinuousMap.{u1, u2} Œ± Œ≥ _inst_1 _inst_7) => Œ± -> Œ≥) (ContinuousMap.hasCoeToFun.{u1, u2} Œ± Œ≥ _inst_1 _inst_7) f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] (f : ContinuousMap.{u2, u1} Œ± Œ≥ _inst_1 _inst_7), Measurable.{u2, u1} Œ± Œ≥ _inst_2 _inst_8 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Œ± Œ≥ _inst_1 _inst_7) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Œ±) => Œ≥) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Œ± Œ≥ _inst_1 _inst_7) Œ± Œ≥ _inst_1 _inst_7 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Œ± Œ≥ _inst_1 _inst_7)) f)
Case conversion may be inaccurate. Consider using '#align continuous_map.measurable ContinuousMap.measurable‚Çì'. -/
@[measurability]
theorem ContinuousMap.measurable (f : C(Œ±, Œ≥)) : Measurable f :=
  f.Continuous.Measurable
#align continuous_map.measurable ContinuousMap.measurable

/- warning: measurable_of_continuous_on_compl_singleton -> measurable_of_continuousOn_compl_singleton is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] [_inst_16 : T1Space.{u1} Œ± _inst_1] {f : Œ± -> Œ≥} (a : Œ±), (ContinuousOn.{u1, u2} Œ± Œ≥ _inst_1 _inst_7 f (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a))) -> (Measurable.{u1, u2} Œ± Œ≥ _inst_2 _inst_8 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : OpensMeasurableSpace.{u2} Œ± _inst_1 _inst_2] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_16 : T1Space.{u2} Œ± _inst_1] {f : Œ± -> Œ≥} (a : Œ±), (ContinuousOn.{u2, u1} Œ± Œ≥ _inst_1 _inst_7 f (HasCompl.compl.{u2} (Set.{u2} Œ±) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} Œ±) (Set.instBooleanAlgebraSet.{u2} Œ±)) (Singleton.singleton.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instSingletonSet.{u2} Œ±) a))) -> (Measurable.{u2, u1} Œ± Œ≥ _inst_2 _inst_8 f)
Case conversion may be inaccurate. Consider using '#align measurable_of_continuous_on_compl_singleton measurable_of_continuousOn_compl_singleton‚Çì'. -/
theorem measurable_of_continuousOn_compl_singleton [T1Space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±)
    (hf : ContinuousOn f ({a}·∂ú)) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a
    (continuousOn_iff_continuous_restrict.1 hf).Measurable
#align measurable_of_continuous_on_compl_singleton measurable_of_continuousOn_compl_singleton

/- warning: continuous.measurable2 -> Continuous.measurable2 is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} {Œ¥ : Type.{u4}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : OpensMeasurableSpace.{u2} Œ≤ _inst_4 _inst_5] [_inst_7 : TopologicalSpace.{u3} Œ≥] [_inst_8 : MeasurableSpace.{u3} Œ≥] [_inst_9 : BorelSpace.{u3} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u4} Œ¥] [_inst_16 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] [_inst_17 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_4] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ≤} {c : Œ± -> Œ≤ -> Œ≥}, (Continuous.{max u1 u2, u3} (Prod.{u1, u2} Œ± Œ≤) Œ≥ (Prod.topologicalSpace.{u1, u2} Œ± Œ≤ _inst_1 _inst_4) _inst_7 (fun (p : Prod.{u1, u2} Œ± Œ≤) => c (Prod.fst.{u1, u2} Œ± Œ≤ p) (Prod.snd.{u1, u2} Œ± Œ≤ p))) -> (Measurable.{u4, u1} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u4, u2} Œ¥ Œ≤ _inst_13 _inst_5 g) -> (Measurable.{u4, u3} Œ¥ Œ≥ _inst_13 _inst_8 (fun (a : Œ¥) => c (f a) (g a)))
but is expected to have type
  forall {Œ± : Type.{u4}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} {Œ¥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u4} Œ±] [_inst_2 : MeasurableSpace.{u4} Œ±] [_inst_3 : OpensMeasurableSpace.{u4} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u3} Œ≤] [_inst_5 : MeasurableSpace.{u3} Œ≤] [_inst_6 : OpensMeasurableSpace.{u3} Œ≤ _inst_4 _inst_5] [_inst_7 : TopologicalSpace.{u2} Œ≥] [_inst_8 : MeasurableSpace.{u2} Œ≥] [_inst_9 : BorelSpace.{u2} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u1} Œ¥] [_inst_16 : TopologicalSpace.SecondCountableTopology.{u4} Œ± _inst_1] [_inst_17 : TopologicalSpace.SecondCountableTopology.{u3} Œ≤ _inst_4] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ≤} {c : Œ± -> Œ≤ -> Œ≥}, (Continuous.{max u4 u3, u2} (Prod.{u4, u3} Œ± Œ≤) Œ≥ (instTopologicalSpaceProd.{u4, u3} Œ± Œ≤ _inst_1 _inst_4) _inst_7 (fun (p : Prod.{u4, u3} Œ± Œ≤) => c (Prod.fst.{u4, u3} Œ± Œ≤ p) (Prod.snd.{u4, u3} Œ± Œ≤ p))) -> (Measurable.{u1, u4} Œ¥ Œ± _inst_13 _inst_2 f) -> (Measurable.{u1, u3} Œ¥ Œ≤ _inst_13 _inst_5 g) -> (Measurable.{u1, u2} Œ¥ Œ≥ _inst_13 _inst_8 (fun (a : Œ¥) => c (f a) (g a)))
Case conversion may be inaccurate. Consider using '#align continuous.measurable2 Continuous.measurable2‚Çì'. -/
theorem Continuous.measurable2 [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] {f : Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : Measurable f)
    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=
  h.Measurable.comp (hf.prod_mk hg)
#align continuous.measurable2 Continuous.measurable2

/- warning: continuous.ae_measurable2 -> Continuous.aemeasurable2 is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} {Œ¥ : Type.{u4}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : OpensMeasurableSpace.{u2} Œ≤ _inst_4 _inst_5] [_inst_7 : TopologicalSpace.{u3} Œ≥] [_inst_8 : MeasurableSpace.{u3} Œ≥] [_inst_9 : BorelSpace.{u3} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u4} Œ¥] [_inst_16 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] [_inst_17 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_4] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ≤} {c : Œ± -> Œ≤ -> Œ≥} {Œº : MeasureTheory.Measure.{u4} Œ¥ _inst_13}, (Continuous.{max u1 u2, u3} (Prod.{u1, u2} Œ± Œ≤) Œ≥ (Prod.topologicalSpace.{u1, u2} Œ± Œ≤ _inst_1 _inst_4) _inst_7 (fun (p : Prod.{u1, u2} Œ± Œ≤) => c (Prod.fst.{u1, u2} Œ± Œ≤ p) (Prod.snd.{u1, u2} Œ± Œ≤ p))) -> (AEMeasurable.{u4, u1} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u4, u2} Œ¥ Œ≤ _inst_5 _inst_13 g Œº) -> (AEMeasurable.{u4, u3} Œ¥ Œ≥ _inst_8 _inst_13 (fun (a : Œ¥) => c (f a) (g a)) Œº)
but is expected to have type
  forall {Œ± : Type.{u4}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u4} Œ±] [_inst_2 : MeasurableSpace.{u4} Œ±] [_inst_3 : OpensMeasurableSpace.{u4} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u3} Œ≤] [_inst_5 : MeasurableSpace.{u3} Œ≤] [_inst_6 : OpensMeasurableSpace.{u3} Œ≤ _inst_4 _inst_5] [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_13 : MeasurableSpace.{u2} Œ¥] [_inst_16 : TopologicalSpace.SecondCountableTopology.{u4} Œ± _inst_1] [_inst_17 : TopologicalSpace.SecondCountableTopology.{u3} Œ≤ _inst_4] {f : Œ¥ -> Œ±} {g : Œ¥ -> Œ≤} {c : Œ± -> Œ≤ -> Œ≥} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_13}, (Continuous.{max u4 u3, u1} (Prod.{u4, u3} Œ± Œ≤) Œ≥ (instTopologicalSpaceProd.{u4, u3} Œ± Œ≤ _inst_1 _inst_4) _inst_7 (fun (p : Prod.{u4, u3} Œ± Œ≤) => c (Prod.fst.{u4, u3} Œ± Œ≤ p) (Prod.snd.{u4, u3} Œ± Œ≤ p))) -> (AEMeasurable.{u2, u4} Œ¥ Œ± _inst_2 _inst_13 f Œº) -> (AEMeasurable.{u2, u3} Œ¥ Œ≤ _inst_5 _inst_13 g Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ≥ _inst_8 _inst_13 (fun (a : Œ¥) => c (f a) (g a)) Œº)
Case conversion may be inaccurate. Consider using '#align continuous.ae_measurable2 Continuous.aemeasurable2‚Çì'. -/
theorem Continuous.aemeasurable2 [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] {f : Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : Measure Œ¥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2)
    (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) : AEMeasurable (fun a => c (f a) (g a)) Œº :=
  h.Measurable.comp_aemeasurable (hf.prod_mk hg)
#align continuous.ae_measurable2 Continuous.aemeasurable2

/- warning: has_continuous_inv‚ÇÄ.has_measurable_inv -> HasContinuousInv‚ÇÄ.measurableInv is a dubious translation:
lean 3 declaration is
  forall {Œ≥ : Type.{u1}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_16 : GroupWithZero.{u1} Œ≥] [_inst_17 : T1Space.{u1} Œ≥ _inst_7] [_inst_18 : HasContinuousInv‚ÇÄ.{u1} Œ≥ (MulZeroClass.toHasZero.{u1} Œ≥ (MulZeroOneClass.toMulZeroClass.{u1} Œ≥ (MonoidWithZero.toMulZeroOneClass.{u1} Œ≥ (GroupWithZero.toMonoidWithZero.{u1} Œ≥ _inst_16)))) (DivInvMonoid.toHasInv.{u1} Œ≥ (GroupWithZero.toDivInvMonoid.{u1} Œ≥ _inst_16)) _inst_7], MeasurableInv.{u1} Œ≥ (DivInvMonoid.toHasInv.{u1} Œ≥ (GroupWithZero.toDivInvMonoid.{u1} Œ≥ _inst_16)) _inst_8
but is expected to have type
  forall {Œ≥ : Type.{u1}} [_inst_7 : TopologicalSpace.{u1} Œ≥] [_inst_8 : MeasurableSpace.{u1} Œ≥] [_inst_9 : BorelSpace.{u1} Œ≥ _inst_7 _inst_8] [_inst_16 : GroupWithZero.{u1} Œ≥] [_inst_17 : T1Space.{u1} Œ≥ _inst_7] [_inst_18 : HasContinuousInv‚ÇÄ.{u1} Œ≥ (MonoidWithZero.toZero.{u1} Œ≥ (GroupWithZero.toMonoidWithZero.{u1} Œ≥ _inst_16)) (GroupWithZero.toInv.{u1} Œ≥ _inst_16) _inst_7], MeasurableInv.{u1} Œ≥ (GroupWithZero.toInv.{u1} Œ≥ _inst_16) _inst_8
Case conversion may be inaccurate. Consider using '#align has_continuous_inv‚ÇÄ.has_measurable_inv HasContinuousInv‚ÇÄ.measurableInv‚Çì'. -/
instance (priority := 100) HasContinuousInv‚ÇÄ.measurableInv [GroupWithZero Œ≥] [T1Space Œ≥]
    [HasContinuousInv‚ÇÄ Œ≥] : MeasurableInv Œ≥ :=
  ‚ü®measurable_of_continuousOn_compl_singleton 0 continuousOn_inv‚ÇÄ‚ü©
#align has_continuous_inv‚ÇÄ.has_measurable_inv HasContinuousInv‚ÇÄ.measurableInv

#print ContinuousMul.measurableMul‚ÇÇ /-
@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul‚ÇÇ [SecondCountableTopology Œ≥] [Mul Œ≥]
    [ContinuousMul Œ≥] : MeasurableMul‚ÇÇ Œ≥ :=
  ‚ü®continuous_mul.Measurable‚ü©
#align has_continuous_mul.has_measurable_mul‚ÇÇ ContinuousMul.measurableMul‚ÇÇ
#align has_continuous_add.has_measurable_mul‚ÇÇ ContinuousAdd.measurableMul‚ÇÇ
-/

#print ContinuousSub.measurableSub‚ÇÇ /-
instance (priority := 100) ContinuousSub.measurableSub‚ÇÇ [SecondCountableTopology Œ≥] [Sub Œ≥]
    [ContinuousSub Œ≥] : MeasurableSub‚ÇÇ Œ≥ :=
  ‚ü®continuous_sub.Measurable‚ü©
#align has_continuous_sub.has_measurable_sub‚ÇÇ ContinuousSub.measurableSub‚ÇÇ
-/

#print ContinuousSMul.measurableSMul‚ÇÇ /-
instance (priority := 100) ContinuousSMul.measurableSMul‚ÇÇ {M Œ±} [TopologicalSpace M]
    [SecondCountableTopology M] [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [SMul M Œ±] [ContinuousSMul M Œ±] :
    MeasurableSMul‚ÇÇ M Œ± :=
  ‚ü®continuous_smul.Measurable‚ü©
#align has_continuous_smul.has_measurable_smul‚ÇÇ ContinuousSMul.measurableSMul‚ÇÇ
-/

end

section BorelSpace

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [BorelSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥] [BorelSpace Œ≥]
  [MeasurableSpace Œ¥]

/- warning: pi_le_borel_pi -> pi_le_borel_pi is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÄ : Œπ -> Type.{u2}} [_inst_11 : forall (i : Œπ), TopologicalSpace.{u2} (œÄ i)] [_inst_12 : forall (i : Œπ), MeasurableSpace.{u2} (œÄ i)] [_inst_13 : forall (i : Œπ), BorelSpace.{u2} (œÄ i) (_inst_11 i) (_inst_12 i)], LE.le.{max u1 u2} (MeasurableSpace.{max u1 u2} (forall (a : Œπ), œÄ a)) (MeasurableSpace.hasLe.{max u1 u2} (forall (a : Œπ), œÄ a)) (MeasurableSpace.pi.{u1, u2} Œπ (fun (a : Œπ) => œÄ a) (fun (a : Œπ) => _inst_12 a)) (borel.{max u1 u2} (forall (i : Œπ), œÄ i) (Pi.topologicalSpace.{u1, u2} Œπ (fun (a : Œπ) => œÄ a) (fun (a : Œπ) => _inst_11 a)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÄ : Œπ -> Type.{u1}} [_inst_11 : forall (i : Œπ), TopologicalSpace.{u1} (œÄ i)] [_inst_12 : forall (i : Œπ), MeasurableSpace.{u1} (œÄ i)] [_inst_13 : forall (i : Œπ), BorelSpace.{u1} (œÄ i) (_inst_11 i) (_inst_12 i)], LE.le.{max u2 u1} (MeasurableSpace.{max u2 u1} (forall (a : Œπ), œÄ a)) (MeasurableSpace.instLEMeasurableSpace.{max u2 u1} (forall (a : Œπ), œÄ a)) (MeasurableSpace.pi.{u2, u1} Œπ (fun (a : Œπ) => œÄ a) (fun (a : Œπ) => _inst_12 a)) (borel.{max u2 u1} (forall (i : Œπ), œÄ i) (Pi.topologicalSpace.{u2, u1} Œπ (fun (a : Œπ) => œÄ a) (fun (a : Œπ) => _inst_11 a)))
Case conversion may be inaccurate. Consider using '#align pi_le_borel_pi pi_le_borel_pi‚Çì'. -/
theorem pi_le_borel_pi {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] : MeasurableSpace.pi ‚â§ borel (‚àÄ i, œÄ i) :=
  by
  have : ‚Äπ‚àÄ i, MeasurableSpace (œÄ i)‚Ä∫ = fun i => borel (œÄ i) :=
    funext fun i => BorelSpace.measurable_eq
  rw [this]
  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable
#align pi_le_borel_pi pi_le_borel_pi

/- warning: prod_le_borel_prod -> prod_le_borel_prod is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : BorelSpace.{u2} Œ≤ _inst_4 _inst_5], LE.le.{max u1 u2} (MeasurableSpace.{max u1 u2} (Prod.{u1, u2} Œ± Œ≤)) (MeasurableSpace.hasLe.{max u1 u2} (Prod.{u1, u2} Œ± Œ≤)) (Prod.instMeasurableSpace.{u1, u2} Œ± Œ≤ _inst_2 _inst_5) (borel.{max u1 u2} (Prod.{u1, u2} Œ± Œ≤) (Prod.topologicalSpace.{u1, u2} Œ± Œ≤ _inst_1 _inst_4))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : BorelSpace.{u2} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} Œ≤] [_inst_5 : MeasurableSpace.{u1} Œ≤] [_inst_6 : BorelSpace.{u1} Œ≤ _inst_4 _inst_5], LE.le.{max u2 u1} (MeasurableSpace.{max u1 u2} (Prod.{u2, u1} Œ± Œ≤)) (MeasurableSpace.instLEMeasurableSpace.{max u2 u1} (Prod.{u2, u1} Œ± Œ≤)) (Prod.instMeasurableSpace.{u2, u1} Œ± Œ≤ _inst_2 _inst_5) (borel.{max u1 u2} (Prod.{u2, u1} Œ± Œ≤) (instTopologicalSpaceProd.{u2, u1} Œ± Œ≤ _inst_1 _inst_4))
Case conversion may be inaccurate. Consider using '#align prod_le_borel_prod prod_le_borel_prod‚Çì'. -/
theorem prod_le_borel_prod : Prod.instMeasurableSpace ‚â§ borel (Œ± √ó Œ≤) :=
  by
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, ‚ÄπBorelSpace Œ≤‚Ä∫.measurable_eq]
  refine' sup_le _ _
  ¬∑ exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
  ¬∑ exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable
#align prod_le_borel_prod prod_le_borel_prod

#print Pi.borelSpace /-
instance Pi.borelSpace {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [Countable Œπ] [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] :
    BorelSpace (‚àÄ i, œÄ i) :=
  ‚ü®le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le‚ü©
#align pi.borel_space Pi.borelSpace
-/

/- warning: prod.borel_space -> Prod.borelSpace is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : BorelSpace.{u2} Œ≤ _inst_4 _inst_5] [_inst_11 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] [_inst_12 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_4], BorelSpace.{max u1 u2} (Prod.{u1, u2} Œ± Œ≤) (Prod.topologicalSpace.{u1, u2} Œ± Œ≤ _inst_1 _inst_4) (Prod.instMeasurableSpace.{u1, u2} Œ± Œ≤ _inst_2 _inst_5)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : BorelSpace.{u2} Œ≤ _inst_4 _inst_5] [_inst_11 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] [_inst_12 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_4], BorelSpace.{max u2 u1} (Prod.{u1, u2} Œ± Œ≤) (instTopologicalSpaceProd.{u1, u2} Œ± Œ≤ _inst_1 _inst_4) (Prod.instMeasurableSpace.{u1, u2} Œ± Œ≤ _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align prod.borel_space Prod.borelSpace‚Çì'. -/
instance Prod.borelSpace [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] :
    BorelSpace (Œ± √ó Œ≤) :=
  ‚ü®le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le‚ü©
#align prod.borel_space Prod.borelSpace

/- warning: embedding.measurable_embedding -> Embedding.measurableEmbedding is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : BorelSpace.{u2} Œ≤ _inst_4 _inst_5] {f : Œ± -> Œ≤}, (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_4 f) -> (MeasurableSet.{u2} Œ≤ _inst_5 (Set.range.{u2, succ u1} Œ≤ Œ± f)) -> (MeasurableEmbedding.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : BorelSpace.{u2} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} Œ≤] [_inst_5 : MeasurableSpace.{u1} Œ≤] [_inst_6 : BorelSpace.{u1} Œ≤ _inst_4 _inst_5] {f : Œ± -> Œ≤}, (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_4 f) -> (MeasurableSet.{u1} Œ≤ _inst_5 (Set.range.{u1, succ u2} Œ≤ Œ± f)) -> (MeasurableEmbedding.{u2, u1} Œ± Œ≤ _inst_2 _inst_5 f)
Case conversion may be inaccurate. Consider using '#align embedding.measurable_embedding Embedding.measurableEmbedding‚Çì'. -/
protected theorem Embedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : Embedding f)
    (h‚ÇÇ : MeasurableSet (range f)) : MeasurableEmbedding f :=
  show MeasurableEmbedding (coe ‚àò (Homeomorph.ofEmbedding f h‚ÇÅ).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe h‚ÇÇ).comp (MeasurableEquiv.measurableEmbedding _)
#align embedding.measurable_embedding Embedding.measurableEmbedding

/- warning: closed_embedding.measurable_embedding -> ClosedEmbedding.measurableEmbedding is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : BorelSpace.{u2} Œ≤ _inst_4 _inst_5] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_4 f) -> (MeasurableEmbedding.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : BorelSpace.{u2} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} Œ≤] [_inst_5 : MeasurableSpace.{u1} Œ≤] [_inst_6 : BorelSpace.{u1} Œ≤ _inst_4 _inst_5] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_4 f) -> (MeasurableEmbedding.{u2, u1} Œ± Œ≤ _inst_2 _inst_5 f)
Case conversion may be inaccurate. Consider using '#align closed_embedding.measurable_embedding ClosedEmbedding.measurableEmbedding‚Çì'. -/
protected theorem ClosedEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : ClosedEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.MeasurableEmbedding h.closed_range.MeasurableSet
#align closed_embedding.measurable_embedding ClosedEmbedding.measurableEmbedding

/- warning: open_embedding.measurable_embedding -> OpenEmbedding.measurableEmbedding is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} Œ≤] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : BorelSpace.{u2} Œ≤ _inst_4 _inst_5] {f : Œ± -> Œ≤}, (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_4 f) -> (MeasurableEmbedding.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ±] [_inst_3 : BorelSpace.{u2} Œ± _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} Œ≤] [_inst_5 : MeasurableSpace.{u1} Œ≤] [_inst_6 : BorelSpace.{u1} Œ≤ _inst_4 _inst_5] {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_4 f) -> (MeasurableEmbedding.{u2, u1} Œ± Œ≤ _inst_2 _inst_5 f)
Case conversion may be inaccurate. Consider using '#align open_embedding.measurable_embedding OpenEmbedding.measurableEmbedding‚Çì'. -/
protected theorem OpenEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : OpenEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.MeasurableEmbedding h.open_range.MeasurableSet
#align open_embedding.measurable_embedding OpenEmbedding.measurableEmbedding

section LinearOrder

variable [LinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

#print measurable_of_Iio /-
theorem measurable_of_Iio {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iio x)) : Measurable f :=
  by
  convert measurable_generateFrom _
  exact borel_space.measurable_eq.trans (borel_eq_generateFrom_Iio _)
  rintro _ ‚ü®x, rfl‚ü©; exact hf x
#align measurable_of_Iio measurable_of_Iio
-/

#print UpperSemicontinuous.measurable /-
theorem UpperSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.isOpen_preimage y).MeasurableSet
#align upper_semicontinuous.measurable UpperSemicontinuous.measurable
-/

#print measurable_of_Ioi /-
theorem measurable_of_Ioi {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ioi x)) : Measurable f :=
  by
  convert measurable_generateFrom _
  exact borel_space.measurable_eq.trans (borel_eq_generateFrom_Ioi _)
  rintro _ ‚ü®x, rfl‚ü©; exact hf x
#align measurable_of_Ioi measurable_of_Ioi
-/

#print LowerSemicontinuous.measurable /-
theorem LowerSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.isOpen_preimage y).MeasurableSet
#align lower_semicontinuous.measurable LowerSemicontinuous.measurable
-/

#print measurable_of_Iic /-
theorem measurable_of_Iic {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iic x)) : Measurable f :=
  by
  apply measurable_of_Ioi
  simp_rw [‚Üê compl_Iic, preimage_compl, MeasurableSet.compl_iff]
  assumption
#align measurable_of_Iic measurable_of_Iic
-/

#print measurable_of_Ici /-
theorem measurable_of_Ici {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ici x)) : Measurable f :=
  by
  apply measurable_of_Iio
  simp_rw [‚Üê compl_Ici, preimage_compl, MeasurableSet.compl_iff]
  assumption
#align measurable_of_Ici measurable_of_Ici
-/

#print Measurable.isLUB /-
theorem Measurable.isLUB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsLUB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g :=
  by
  change ‚àÄ b, IsLUB (range fun i => f i b) (g b) at hg
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, borel_eq_generateFrom_Ioi Œ±]
  apply measurable_generateFrom
  rintro _ ‚ü®a, rfl‚ü©
  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, set_of_exists]
  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).MeasurableSet
#align measurable.is_lub Measurable.isLUB
-/

private theorem ae_measurable.is_lub_of_nonempty {Œπ} (hŒπ : Nonempty Œπ) {Œº : Measure Œ¥} [Countable Œπ]
    {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, AEMeasurable (f i) Œº)
    (hg : ‚àÄ·µê b ‚àÇŒº, IsLUB { a | ‚àÉ i, f i b = a } (g b)) : AEMeasurable g Œº :=
  by
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsLUB { a | ‚àÉ i, f' i = a } (g x)
  let g_seq x := ite (x ‚àà aeSeqSet hf p) (g x) (‚ü®g x‚ü© : Nonempty Œ±).some
  have hg_seq : ‚àÄ b, IsLUB { a | ‚àÉ i, aeSeq hf p i b = a } (g_seq b) :=
    by
    intro b
    haveI hŒ± : Nonempty Œ± := Nonempty.map g ‚ü®b‚ü©
    simp only [aeSeq, g_seq]
    split_ifs
    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } = { a : Œ± | ‚àÉ i : Œπ, f i b = a } :=
        by
        ext x
        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h
    ¬∑ have h_singleton : { a : Œ± | ‚àÉ i : Œπ, hŒ±.some = a } = {hŒ±.some} :=
        by
        ext1 x
        exact ‚ü®fun hx => hx.some_spec.symm, fun hx => ‚ü®hŒπ.some, hx.symm‚ü©‚ü©
      rw [h_singleton]
      exact isLUB_singleton
  refine' ‚ü®g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, _‚ü©
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun x => (‚ü®g x‚ü© : Nonempty Œ±).some) (aeSeqSet hf p)
        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm
#align ae_measurable.is_lub_of_nonempty ae_measurable.is_lub_of_nonempty

#print AEMeasurable.isLUB /-
theorem AEMeasurable.isLUB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsLUB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº := by
  by_cases hŒº : Œº = 0
  ¬∑ rw [hŒº]
    exact aemeasurable_zero_measure
  have : Œº.ae.ne_bot := by simpa [ne_bot_iff]
  by_cases hŒπ : Nonempty Œπ
  ¬∑ exact ae_measurable.is_lub_of_nonempty hŒπ hf hg
  suffices ‚àÉ x, g =·µê[Œº] fun y => g x by
    exact ‚ü®fun y => g this.some, measurable_const, this.some_spec‚ü©
  have h_empty : ‚àÄ x, { a : Œ± | ‚àÉ i : Œπ, f i x = a } = ‚àÖ :=
    by
    intro x
    ext1 y
    rw [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]
    exact fun hi => hŒπ (nonempty_of_exists hi)
  simp_rw [h_empty] at hg
  exact ‚ü®hg.exists.some, hg.mono fun y hy => IsLUB.unique hy hg.exists.some_spec‚ü©
#align ae_measurable.is_lub AEMeasurable.isLUB
-/

#print Measurable.isGLB /-
theorem Measurable.isGLB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsGLB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g :=
  by
  change ‚àÄ b, IsGLB (range fun i => f i b) (g b) at hg
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, borel_eq_generateFrom_Iio Œ±]
  apply measurable_generateFrom
  rintro _ ‚ü®a, rfl‚ü©
  simp_rw [Set.preimage, mem_Iio, isGLB_lt_iff (hg _), exists_range_iff, set_of_exists]
  exact MeasurableSet.iUnion fun i => hf i (isOpen_gt' _).MeasurableSet
#align measurable.is_glb Measurable.isGLB
-/

#print AEMeasurable.isGLB /-
theorem AEMeasurable.isGLB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsGLB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº := by
  nontriviality Œ±
  haveI hŒ± : Nonempty Œ± := inferInstance
  cases' isEmpty_or_nonempty Œπ with hŒπ hŒπ
  ¬∑ simp only [IsEmpty.exists_iff, set_of_false, isGLB_empty_iff] at hg
    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (hb _).antisymm (ha _))
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsGLB { a | ‚àÉ i, f' i = a } (g x)
  let g_seq := (aeSeqSet hf p).piecewise g fun _ => hŒ±.some
  have hg_seq : ‚àÄ b, IsGLB { a | ‚àÉ i, aeSeq hf p i b = a } (g_seq b) :=
    by
    intro b
    simp only [aeSeq, g_seq, Set.piecewise]
    split_ifs
    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } = { a : Œ± | ‚àÉ i : Œπ, f i b = a } :=
        by
        ext x
        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h
    ¬∑ exact IsLeast.isGLB ‚ü®(@exists_const (hŒ±.some = hŒ±.some) Œπ _).2 rfl, fun x ‚ü®i, hi‚ü© => hi.le‚ü©
  refine' ‚ü®g_seq, Measurable.isGLB (aeSeq.measurable hf p) hg_seq, _‚ü©
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun x => hŒ±.some) (aeSeqSet hf p)
        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm
#align ae_measurable.is_glb AEMeasurable.isGLB
-/

#print Monotone.measurable /-
protected theorem Monotone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Monotone f) : Measurable f :=
  suffices h : ‚àÄ x, OrdConnected (f ‚Åª¬π' Ioi x) from measurable_of_Ioi fun x => (h x).MeasurableSet
  fun x => ordConnected_def.mpr fun a ha b hb c hc => lt_of_lt_of_le ha (hf hc.1)
#align monotone.measurable Monotone.measurable
-/

#print aemeasurable_restrict_of_monotoneOn /-
theorem aemeasurable_restrict_of_monotoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : MonotoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  have this : Monotone (f ‚àò coe : s ‚Üí Œ±) := fun ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© (hxy : x ‚â§ y) => hf hx hy hxy
  aemeasurable_restrict_of_measurable_subtype hs this.Measurable
#align ae_measurable_restrict_of_monotone_on aemeasurable_restrict_of_monotoneOn
-/

#print Antitone.measurable /-
protected theorem Antitone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Antitone f) : Measurable f :=
  @Monotone.measurable Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ hf
#align antitone.measurable Antitone.measurable
-/

#print aemeasurable_restrict_of_antitoneOn /-
theorem aemeasurable_restrict_of_antitoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : AntitoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  @aemeasurable_restrict_of_monotoneOn Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ _ hs _ hf
#align ae_measurable_restrict_of_antitone_on aemeasurable_restrict_of_antitoneOn
-/

/- warning: measurable_set_of_mem_nhds_within_Ioi_aux -> measurableSet_of_mem_nhdsWithin_Ioi_aux is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_11 : LinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {s : Set.{u1} Œ±}, (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_11)))) x)))) -> (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) -> (Exists.{succ u1} Œ± (fun (y : Œ±) => LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_11))))) x y))) -> (MeasurableSet.{u1} Œ± _inst_2 s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_11 : LinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {s : Set.{u1} Œ±}, (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_11))))) x)))) -> (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) -> (Exists.{succ u1} Œ± (fun (y : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_11)))))) x y))) -> (MeasurableSet.{u1} Œ± _inst_2 s)
Case conversion may be inaccurate. Consider using '#align measurable_set_of_mem_nhds_within_Ioi_aux measurableSet_of_mem_nhdsWithin_Ioi_aux‚Çì'. -/
theorem measurableSet_of_mem_nhdsWithin_Ioi_aux {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x)
    (h' : ‚àÄ x ‚àà s, ‚àÉ y, x < y) : MeasurableSet s :=
  by
  choose! M hM using h'
  suffices H : (s \ interior s).Countable
  ¬∑ have : s = interior s ‚à™ s \ interior s := by rw [union_diff_cancel interior_subset]
    rw [this]
    exact is_open_interior.measurable_set.union H.measurable_set
  have A : ‚àÄ x ‚àà s, ‚àÉ y ‚àà Ioi x, Ioo x y ‚äÜ s := fun x hx =>
    (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)
  choose! y hy h'y using A
  have B : Set.PairwiseDisjoint (s \ interior s) fun x => Ioo x (y x) :=
    by
    intro x hx x' hx' hxx'
    rcases lt_or_gt_of_ne hxx' with (h' | h')
    ¬∑ apply disjoint_left.2 fun z hz h'z => _
      have : x' ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x (y x), h'y _ hx.1, isOpen_Ioo, ‚ü®h', h'z.1.trans hz.2‚ü©‚ü©
      exact False.elim (hx'.2 this)
    ¬∑ apply disjoint_left.2 fun z hz h'z => _
      have : x ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, ‚ü®h', hz.1.trans h'z.2‚ü©‚ü©
      exact False.elim (hx.2 this)
  exact B.countable_of_Ioo fun x hx => hy x hx.1
#align measurable_set_of_mem_nhds_within_Ioi_aux measurableSet_of_mem_nhdsWithin_Ioi_aux

#print measurableSet_of_mem_nhdsWithin_Ioi /-
/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/
theorem measurableSet_of_mem_nhdsWithin_Ioi {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x) :
    MeasurableSet s := by
  by_cases H : ‚àÉ x ‚àà s, IsTop x
  ¬∑ rcases H with ‚ü®x‚ÇÄ, x‚ÇÄs, h‚ÇÄ‚ü©
    have : s = {x‚ÇÄ} ‚à™ s \ {x‚ÇÄ} := by rw [union_diff_cancel (singleton_subset_iff.2 x‚ÇÄs)]
    rw [this]
    refine' (measurable_set_singleton _).union _
    have A : ‚àÄ x ‚àà s \ {x‚ÇÄ}, x < x‚ÇÄ := fun x hx => lt_of_le_of_ne (h‚ÇÄ _) (by simpa using hx.2)
    refine' measurableSet_of_mem_nhdsWithin_Ioi_aux (fun x hx => _) fun x hx => ‚ü®x‚ÇÄ, A x hx‚ü©
    obtain ‚ü®u, hu, us‚ü© : ‚àÉ (u : Œ±)(H : u ‚àà Ioi x), Ioo x u ‚äÜ s :=
      (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)
    refine' (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).2 ‚ü®u, hu, fun y hy => ‚ü®us hy, _‚ü©‚ü©
    exact ne_of_lt (hy.2.trans_le (h‚ÇÄ _))
  ¬∑ apply measurableSet_of_mem_nhdsWithin_Ioi_aux h
    simp only [IsTop] at H
    push_neg  at H
    exact H
#align measurable_set_of_mem_nhds_within_Ioi measurableSet_of_mem_nhdsWithin_Ioi
-/

end LinearOrder

/- warning: measurable.supr_Prop -> Measurable.iSup_Prop is a dubious translation:
lean 3 declaration is
  forall {Œ¥ : Type.{u1}} [_inst_10 : MeasurableSpace.{u1} Œ¥] {Œ± : Type.{u2}} [_inst_11 : MeasurableSpace.{u2} Œ±] [_inst_12 : CompleteLattice.{u2} Œ±] (p : Prop) {f : Œ¥ -> Œ±}, (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 f) -> (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 (fun (b : Œ¥) => iSup.{u2, 0} Œ± (ConditionallyCompleteLattice.toHasSup.{u2} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ± _inst_12)) p (fun (h : p) => f b)))
but is expected to have type
  forall {Œ¥ : Type.{u1}} [_inst_10 : MeasurableSpace.{u1} Œ¥] {Œ± : Type.{u2}} [_inst_11 : MeasurableSpace.{u2} Œ±] [_inst_12 : CompleteLattice.{u2} Œ±] (p : Prop) {f : Œ¥ -> Œ±}, (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 f) -> (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 (fun (b : Œ¥) => iSup.{u2, 0} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ± _inst_12)) p (fun (h : p) => f b)))
Case conversion may be inaccurate. Consider using '#align measurable.supr_Prop Measurable.iSup_Prop‚Çì'. -/
@[measurability]
theorem Measurable.iSup_Prop {Œ±} [MeasurableSpace Œ±] [CompleteLattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±}
    (hf : Measurable f) : Measurable fun b => ‚®Ü h : p, f b :=
  by_cases (fun h : p => by convert hf; funext; exact iSup_pos h) fun h : ¬¨p => by
    convert measurable_const; funext; exact iSup_neg h
#align measurable.supr_Prop Measurable.iSup_Prop

/- warning: measurable.infi_Prop -> Measurable.iInf_Prop is a dubious translation:
lean 3 declaration is
  forall {Œ¥ : Type.{u1}} [_inst_10 : MeasurableSpace.{u1} Œ¥] {Œ± : Type.{u2}} [_inst_11 : MeasurableSpace.{u2} Œ±] [_inst_12 : CompleteLattice.{u2} Œ±] (p : Prop) {f : Œ¥ -> Œ±}, (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 f) -> (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 (fun (b : Œ¥) => iInf.{u2, 0} Œ± (ConditionallyCompleteLattice.toHasInf.{u2} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ± _inst_12)) p (fun (h : p) => f b)))
but is expected to have type
  forall {Œ¥ : Type.{u1}} [_inst_10 : MeasurableSpace.{u1} Œ¥] {Œ± : Type.{u2}} [_inst_11 : MeasurableSpace.{u2} Œ±] [_inst_12 : CompleteLattice.{u2} Œ±] (p : Prop) {f : Œ¥ -> Œ±}, (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 f) -> (Measurable.{u1, u2} Œ¥ Œ± _inst_10 _inst_11 (fun (b : Œ¥) => iInf.{u2, 0} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ± _inst_12)) p (fun (h : p) => f b)))
Case conversion may be inaccurate. Consider using '#align measurable.infi_Prop Measurable.iInf_Prop‚Çì'. -/
@[measurability]
theorem Measurable.iInf_Prop {Œ±} [MeasurableSpace Œ±] [CompleteLattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±}
    (hf : Measurable f) : Measurable fun b => ‚®Ö h : p, f b :=
  by_cases (fun h : p => by convert hf; funext; exact iInf_pos h) fun h : ¬¨p => by
    convert measurable_const; funext; exact iInf_neg h
#align measurable.infi_Prop Measurable.iInf_Prop

section CompleteLinearOrder

variable [CompleteLinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

/- warning: measurable_supr -> measurable_iSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => f i b)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => f i b)))
Case conversion may be inaccurate. Consider using '#align measurable_supr measurable_iSup‚Çì'. -/
@[measurability]
theorem measurable_iSup {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ü i, f i b :=
  Measurable.isLUB hf fun b => isLUB_iSup
#align measurable_supr measurable_iSup

/- warning: ae_measurable_supr -> aemeasurable_iSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => f i b)) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => f i b)) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable_supr aemeasurable_iSup‚Çì'. -/
@[measurability]
theorem aemeasurable_iSup {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i, f i b) Œº :=
  AEMeasurable.isLUB hf <| ae_of_all Œº fun b => isLUB_iSup
#align ae_measurable_supr aemeasurable_iSup

/- warning: measurable_infi -> measurable_iInf is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => f i b)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => f i b)))
Case conversion may be inaccurate. Consider using '#align measurable_infi measurable_iInf‚Çì'. -/
@[measurability]
theorem measurable_iInf {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ö i, f i b :=
  Measurable.isGLB hf fun b => isGLB_iInf
#align measurable_infi measurable_iInf

/- warning: ae_measurable_infi -> aemeasurable_iInf is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => f i b)) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Sort.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} [_inst_14 : Countable.{u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => f i b)) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable_infi aemeasurable_iInf‚Çì'. -/
@[measurability]
theorem aemeasurable_iInf {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i, f i b) Œº :=
  AEMeasurable.isGLB hf <| ae_of_all Œº fun b => isGLB_iInf
#align ae_measurable_infi aemeasurable_iInf

/- warning: measurable_bsupr -> measurable_biSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => iSup.{u1, 0} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) (Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) (fun (H : Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) => f i b))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => iSup.{u1, 0} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) (Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) (fun (H : Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) => f i b))))
Case conversion may be inaccurate. Consider using '#align measurable_bsupr measurable_biSup‚Çì'. -/
theorem measurable_biSup {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i, Measurable (f i)) : Measurable fun b => ‚®Ü i ‚àà s, f i b :=
  by
  haveI : Encodable s := hs.to_encodable
  simp only [iSup_subtype']
  exact measurable_iSup fun i => hf i
#align measurable_bsupr measurable_biSup

/- warning: ae_measurable_bsupr -> aemeasurable_biSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => iSup.{u1, 0} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) (Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) (fun (H : Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) => f i b))) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => iSup.{u1, 0} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) (Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) (fun (H : Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) => f i b))) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable_bsupr aemeasurable_biSup‚Çì'. -/
theorem aemeasurable_biSup {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i ‚àà s, f i b) Œº :=
  by
  haveI : Encodable s := hs.to_encodable
  simp only [iSup_subtype']
  exact aemeasurable_iSup fun i => hf i
#align ae_measurable_bsupr aemeasurable_biSup

/- warning: measurable_binfi -> measurable_biInf is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => iInf.{u1, 0} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) (Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) (fun (H : Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) => f i b))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (b : Œ¥) => iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => iInf.{u1, 0} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) (Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) (fun (H : Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) => f i b))))
Case conversion may be inaccurate. Consider using '#align measurable_binfi measurable_biInf‚Çì'. -/
theorem measurable_biInf {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i, Measurable (f i)) : Measurable fun b => ‚®Ö i ‚àà s, f i b :=
  by
  haveI : Encodable s := hs.to_encodable
  simp only [iInf_subtype']
  exact measurable_iInf fun i => hf i
#align measurable_binfi measurable_biInf

/- warning: ae_measurable_binfi -> aemeasurable_biInf is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) Œπ (fun (i : Œπ) => iInf.{u1, 0} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))) (Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) (fun (H : Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i s) => f i b))) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {Œº : MeasureTheory.Measure.{u2} Œ¥ _inst_10} (s : Set.{u3} Œπ) {f : Œπ -> Œ¥ -> Œ±}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (f i) Œº) -> (AEMeasurable.{u2, u1} Œ¥ Œ± _inst_2 _inst_10 (fun (b : Œ¥) => iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) Œπ (fun (i : Œπ) => iInf.{u1, 0} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11)))) (Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) (fun (H : Membership.mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.instMembershipSet.{u3} Œπ) i s) => f i b))) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable_binfi aemeasurable_biInf‚Çì'. -/
theorem aemeasurable_biInf {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i ‚àà s, f i b) Œº :=
  by
  haveI : Encodable s := hs.to_encodable
  simp only [iInf_subtype']
  exact aemeasurable_iInf fun i => hf i
#align ae_measurable_binfi aemeasurable_biInf

/- warning: measurable_liminf' -> measurable_liminf' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {Œπ' : Type.{u4}} {f : Œπ -> Œ¥ -> Œ±} {u : Filter.{u3} Œπ}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall {p : Œπ' -> Prop} {s : Œπ' -> (Set.{u3} Œπ)}, (Filter.HasCountableBasis.{u3, u4} Œπ Œπ' u p s) -> (forall (i : Œπ'), Set.Countable.{u3} Œπ (s i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => Filter.liminf.{u1, u3} Œ± Œπ (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11)) (fun (i : Œπ) => f i x) u)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u4}} {Œπ' : Type.{u3}} {f : Œπ -> Œ¥ -> Œ±} {u : Filter.{u4} Œπ}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall {p : Œπ' -> Prop} {s : Œπ' -> (Set.{u4} Œπ)}, (Filter.HasCountableBasis.{u4, u3} Œπ Œπ' u p s) -> (forall (i : Œπ'), Set.Countable.{u4} Œπ (s i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => Filter.liminf.{u1, u4} Œ± Œπ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11))) (fun (i : Œπ) => f i x) u)))
Case conversion may be inaccurate. Consider using '#align measurable_liminf' measurable_liminf'‚Çì'. -/
/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `‚Ñï`.
-/
theorem measurable_liminf' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hu : u.HasCountableBasis p s) (hs : ‚àÄ i, (s i).Countable) :
    Measurable fun x => liminf (fun i => f i x) u :=
  by
  simp_rw [hu.to_has_basis.liminf_eq_supr_infi]
  refine' measurable_biSup _ hu.countable _
  exact fun i => measurable_biInf _ (hs i) hf
#align measurable_liminf' measurable_liminf'

/- warning: measurable_limsup' -> measurable_limsup' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {Œπ' : Type.{u4}} {f : Œπ -> Œ¥ -> Œ±} {u : Filter.{u3} Œπ}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall {p : Œπ' -> Prop} {s : Œπ' -> (Set.{u3} Œπ)}, (Filter.HasCountableBasis.{u3, u4} Œπ Œπ' u p s) -> (forall (i : Œπ'), Set.Countable.{u3} Œπ (s i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => Filter.limsup.{u1, u3} Œ± Œπ (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11)) (fun (i : Œπ) => f i x) u)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : CompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OmegaCompletePartialOrder.toPartialOrder.{u1} Œ± (CompleteLattice.instOmegaCompletePartialOrder.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_11))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u4}} {Œπ' : Type.{u3}} {f : Œπ -> Œ¥ -> Œ±} {u : Filter.{u4} Œπ}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall {p : Œπ' -> Prop} {s : Œπ' -> (Set.{u4} Œπ)}, (Filter.HasCountableBasis.{u4, u3} Œπ Œπ' u p s) -> (forall (i : Œπ'), Set.Countable.{u4} Œπ (s i)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => Filter.limsup.{u1, u4} Œ± Œπ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_11))) (fun (i : Œπ) => f i x) u)))
Case conversion may be inaccurate. Consider using '#align measurable_limsup' measurable_limsup'‚Çì'. -/
/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `‚Ñï`.
-/
theorem measurable_limsup' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hu : u.HasCountableBasis p s) (hs : ‚àÄ i, (s i).Countable) :
    Measurable fun x => limsup (fun i => f i x) u :=
  by
  simp_rw [hu.to_has_basis.limsup_eq_infi_supr]
  refine' measurable_biInf _ hu.countable _
  exact fun i => measurable_biSup _ (hs i) hf
#align measurable_limsup' measurable_limsup'

#print measurable_liminf /-
/-- `liminf` over `‚Ñï` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurable_liminf {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => liminf (fun i => f i x) atTop :=
  measurable_liminf' hf atTop_countable_basis fun i => to_countable _
#align measurable_liminf measurable_liminf
-/

#print measurable_limsup /-
/-- `limsup` over `‚Ñï` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurable_limsup {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => limsup (fun i => f i x) atTop :=
  measurable_limsup' hf atTop_countable_basis fun i => to_countable _
#align measurable_limsup measurable_limsup
-/

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

/- warning: measurable_cSup -> measurable_cSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {f : Œπ -> Œ¥ -> Œ±} {s : Set.{u3} Œπ}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {f : Œπ -> Œ¥ -> Œ±} {s : Set.{u3} Œπ}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)))
Case conversion may be inaccurate. Consider using '#align measurable_cSup measurable_cSup‚Çì'. -/
theorem measurable_cSup {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i, Measurable (f i)) (bdd : ‚àÄ x, BddAbove ((fun i => f i x) '' s)) :
    Measurable fun x => sSup ((fun i => f i x) '' s) :=
  by
  cases' eq_empty_or_nonempty s with h2s h2s
  ¬∑ simp [h2s, measurable_const]
  ¬∑ apply measurable_of_Iic
    intro y
    simp_rw [preimage, mem_Iic, csSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]
    exact MeasurableSet.biInter hs fun i hi => measurableSet_le (hf i) measurable_const
#align measurable_cSup measurable_cSup

/- warning: measurable_cInf -> measurable_cInf is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {f : Œπ -> Œ¥ -> Œ±} {s : Set.{u3} Œπ}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} {f : Œπ -> Œ¥ -> Œ±} {s : Set.{u3} Œπ}, (Set.Countable.{u3} Œπ s) -> (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) (Set.image.{u3, u1} Œπ Œ± (fun (i : Œπ) => f i x) s)))
Case conversion may be inaccurate. Consider using '#align measurable_cInf measurable_cInf‚Çì'. -/
theorem measurable_cInf {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i, Measurable (f i)) (bdd : ‚àÄ x, BddBelow ((fun i => f i x) '' s)) :
    Measurable fun x => sInf ((fun i => f i x) '' s) :=
  @measurable_cSup Œ±·µí·µà _ _ _ _ _ _ _ _ _ _ _ hs hf bdd
#align measurable_cInf measurable_cInf

/- warning: measurable_csupr -> measurable_ciSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} [_inst_14 : Countable.{succ u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.range.{u1, succ u3} Œ± Œπ (fun (i : Œπ) => f i x))) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) Œπ (fun (i : Œπ) => f i x)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} [_inst_14 : Countable.{succ u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.range.{u1, succ u3} Œ± Œπ (fun (i : Œπ) => f i x))) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) Œπ (fun (i : Œπ) => f i x)))
Case conversion may be inaccurate. Consider using '#align measurable_csupr measurable_ciSup‚Çì'. -/
theorem measurable_ciSup {Œπ : Type _} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (bdd : ‚àÄ x, BddAbove (range fun i => f i x)) : Measurable fun x => ‚®Ü i, f i x :=
  by
  change Measurable fun x => Sup (range fun i : Œπ => f i x)
  simp_rw [‚Üê image_univ] at bdd‚ä¢
  refine' measurable_cSup countable_univ hf bdd
#align measurable_csupr measurable_ciSup

/- warning: measurable_cinfi -> measurable_ciInf is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} [_inst_14 : Countable.{succ u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.range.{u1, succ u3} Œ± Œπ (fun (i : Œπ) => f i x))) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) Œπ (fun (i : Œπ) => f i x)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : BorelSpace.{u1} Œ± _inst_1 _inst_2] [_inst_10 : MeasurableSpace.{u2} Œ¥] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_12 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)))))] [_inst_13 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {Œπ : Type.{u3}} [_inst_14 : Countable.{succ u3} Œπ] {f : Œπ -> Œ¥ -> Œ±}, (forall (i : Œπ), Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (f i)) -> (forall (x : Œ¥), BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11))))) (Set.range.{u1, succ u3} Œ± Œπ (fun (i : Œπ) => f i x))) -> (Measurable.{u2, u1} Œ¥ Œ± _inst_10 _inst_2 (fun (x : Œ¥) => iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_11)) Œπ (fun (i : Œπ) => f i x)))
Case conversion may be inaccurate. Consider using '#align measurable_cinfi measurable_ciInf‚Çì'. -/
theorem measurable_ciInf {Œπ : Type _} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (bdd : ‚àÄ x, BddBelow (range fun i => f i x)) : Measurable fun x => ‚®Ö i, f i x :=
  @measurable_ciSup Œ±·µí·µà _ _ _ _ _ _ _ _ _ _ _ hf bdd
#align measurable_cinfi measurable_ciInf

end ConditionallyCompleteLinearOrder

#print Homemorph.toMeasurableEquiv /-
/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def Homemorph.toMeasurableEquiv (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚âÉ·µê Œ≤
    where
  toEquiv := h.toEquiv
  measurable_to_fun := h.continuous_toFun.Measurable
  measurable_inv_fun := h.continuous_invFun.Measurable
#align homemorph.to_measurable_equiv Homemorph.toMeasurableEquiv
-/

/- warning: is_finite_measure_on_compacts.map -> IsFiniteMeasureOnCompacts.map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_11 : TopologicalSpace.{u1} Œ±] [_inst_12 : OpensMeasurableSpace.{u1} Œ± _inst_11 m0] {Œ≤ : Type.{u2}} [_inst_13 : MeasurableSpace.{u2} Œ≤] [_inst_14 : TopologicalSpace.{u2} Œ≤] [_inst_15 : BorelSpace.{u2} Œ≤ _inst_14 _inst_13] [_inst_16 : T2Space.{u2} Œ≤ _inst_14] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_17 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 _inst_11 Œº] (f : Homeomorph.{u1, u2} Œ± Œ≤ _inst_11 _inst_14), MeasureTheory.FiniteMeasureOnCompacts.{u2} Œ≤ _inst_13 _inst_14 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_13 m0 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Homeomorph.{u1, u2} Œ± Œ≤ _inst_11 _inst_14) (fun (_x : Homeomorph.{u1, u2} Œ± Œ≤ _inst_11 _inst_14) => Œ± -> Œ≤) (Homeomorph.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_11 _inst_14) f) Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_11 : TopologicalSpace.{u2} Œ±] [_inst_12 : OpensMeasurableSpace.{u2} Œ± _inst_11 m0] {Œ≤ : Type.{u1}} [_inst_13 : MeasurableSpace.{u1} Œ≤] [_inst_14 : TopologicalSpace.{u1} Œ≤] [_inst_15 : BorelSpace.{u1} Œ≤ _inst_14 _inst_13] [_inst_16 : T2Space.{u1} Œ≤ _inst_14] (Œº : MeasureTheory.Measure.{u2} Œ± m0) [_inst_17 : MeasureTheory.FiniteMeasureOnCompacts.{u2} Œ± m0 _inst_11 Œº] (f : Homeomorph.{u2, u1} Œ± Œ≤ _inst_11 _inst_14), MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ≤ _inst_13 _inst_14 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_13 m0 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ± Œ≤ _inst_11 _inst_14) Œ± (fun (_x : Œ±) => Œ≤) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ± Œ≤ _inst_11 _inst_14) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (Homeomorph.{u2, u1} Œ± Œ≤ _inst_11 _inst_14) Œ± Œ≤ (Homeomorph.instEquivLikeHomeomorph.{u2, u1} Œ± Œ≤ _inst_11 _inst_14))) f) Œº)
Case conversion may be inaccurate. Consider using '#align is_finite_measure_on_compacts.map IsFiniteMeasureOnCompacts.map‚Çì'. -/
protected theorem IsFiniteMeasureOnCompacts.map {Œ± : Type _} {m0 : MeasurableSpace Œ±}
    [TopologicalSpace Œ±] [OpensMeasurableSpace Œ±] {Œ≤ : Type _} [MeasurableSpace Œ≤]
    [TopologicalSpace Œ≤] [BorelSpace Œ≤] [T2Space Œ≤] (Œº : Measure Œ±) [FiniteMeasureOnCompacts Œº]
    (f : Œ± ‚âÉ‚Çú Œ≤) : FiniteMeasureOnCompacts (Measure.map f Œº) :=
  ‚ü®by
    intro K hK
    rw [measure.map_apply f.measurable hK.measurable_set]
    apply IsCompact.measure_lt_top
    rwa [f.is_compact_preimage]‚ü©
#align is_finite_measure_on_compacts.map IsFiniteMeasureOnCompacts.map

end BorelSpace

/- warning: empty.borel_space -> Empty.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} Empty Empty.topologicalSpace Empty.instMeasurableSpace
but is expected to have type
  BorelSpace.{0} Empty instTopologicalSpaceEmpty Empty.instMeasurableSpace
Case conversion may be inaccurate. Consider using '#align empty.borel_space Empty.borelSpace‚Çì'. -/
instance Empty.borelSpace : BorelSpace Empty :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align empty.borel_space Empty.borelSpace

/- warning: unit.borel_space -> Unit.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} Unit PUnit.topologicalSpace.{0} PUnit.instMeasurableSpace.{0}
but is expected to have type
  BorelSpace.{0} Unit instTopologicalSpacePUnit.{0} PUnit.instMeasurableSpace.{0}
Case conversion may be inaccurate. Consider using '#align unit.borel_space Unit.borelSpace‚Çì'. -/
instance Unit.borelSpace : BorelSpace Unit :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align unit.borel_space Unit.borelSpace

/- warning: bool.borel_space -> Bool.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} Bool Bool.topologicalSpace Bool.instMeasurableSpace
but is expected to have type
  BorelSpace.{0} Bool instTopologicalSpaceBool Bool.instMeasurableSpace
Case conversion may be inaccurate. Consider using '#align bool.borel_space Bool.borelSpace‚Çì'. -/
instance Bool.borelSpace : BorelSpace Bool :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align bool.borel_space Bool.borelSpace

/- warning: nat.borel_space -> Nat.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} Nat Nat.topologicalSpace Nat.instMeasurableSpace
but is expected to have type
  BorelSpace.{0} Nat instTopologicalSpaceNat Nat.instMeasurableSpace
Case conversion may be inaccurate. Consider using '#align nat.borel_space Nat.borelSpace‚Çì'. -/
instance Nat.borelSpace : BorelSpace ‚Ñï :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align nat.borel_space Nat.borelSpace

/- warning: int.borel_space -> Int.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} Int Int.topologicalSpace Int.instMeasurableSpace
but is expected to have type
  BorelSpace.{0} Int instTopologicalSpaceInt Int.instMeasurableSpace
Case conversion may be inaccurate. Consider using '#align int.borel_space Int.borelSpace‚Çì'. -/
instance Int.borelSpace : BorelSpace ‚Ñ§ :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align int.borel_space Int.borelSpace

#print Rat.borelSpace /-
instance Rat.borelSpace : BorelSpace ‚Ñö :=
  ‚ü®borel_eq_top_of_countable.symm‚ü©
#align rat.borel_space Rat.borelSpace
-/

#print Real.measurableSpace /-
/- Instances on `real` and `complex` are special cases of `is_R_or_C` but without these instances,
Lean fails to prove `borel_space (Œπ ‚Üí ‚Ñù)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace ‚Ñù :=
  borel ‚Ñù
#align real.measurable_space Real.measurableSpace
-/

#print Real.borelSpace /-
instance Real.borelSpace : BorelSpace ‚Ñù :=
  ‚ü®rfl‚ü©
#align real.borel_space Real.borelSpace
-/

#print NNReal.measurableSpace /-
instance NNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0 :=
  Subtype.instMeasurableSpace
#align nnreal.measurable_space NNReal.measurableSpace
-/

/- warning: nnreal.borel_space -> NNReal.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} NNReal NNReal.topologicalSpace NNReal.measurableSpace
but is expected to have type
  BorelSpace.{0} NNReal NNReal.instTopologicalSpaceNNReal NNReal.measurableSpace
Case conversion may be inaccurate. Consider using '#align nnreal.borel_space NNReal.borelSpace‚Çì'. -/
instance NNReal.borelSpace : BorelSpace ‚Ñù‚â•0 :=
  Subtype.borelSpace _
#align nnreal.borel_space NNReal.borelSpace

#print ENNReal.measurableSpace /-
instance ENNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0‚àû :=
  borel ‚Ñù‚â•0‚àû
#align ennreal.measurable_space ENNReal.measurableSpace
-/

/- warning: ennreal.borel_space -> ENNReal.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} ENNReal ENNReal.topologicalSpace ENNReal.measurableSpace
but is expected to have type
  BorelSpace.{0} ENNReal ENNReal.instTopologicalSpaceENNReal ENNReal.measurableSpace
Case conversion may be inaccurate. Consider using '#align ennreal.borel_space ENNReal.borelSpace‚Çì'. -/
instance ENNReal.borelSpace : BorelSpace ‚Ñù‚â•0‚àû :=
  ‚ü®rfl‚ü©
#align ennreal.borel_space ENNReal.borelSpace

#print EReal.measurableSpace /-
instance EReal.measurableSpace : MeasurableSpace EReal :=
  borel EReal
#align ereal.measurable_space EReal.measurableSpace
-/

/- warning: ereal.borel_space -> EReal.borelSpace is a dubious translation:
lean 3 declaration is
  BorelSpace.{0} EReal EReal.topologicalSpace EReal.measurableSpace
but is expected to have type
  BorelSpace.{0} EReal EReal.instTopologicalSpaceEReal EReal.measurableSpace
Case conversion may be inaccurate. Consider using '#align ereal.borel_space EReal.borelSpace‚Çì'. -/
instance EReal.borelSpace : BorelSpace EReal :=
  ‚ü®rfl‚ü©
#align ereal.borel_space EReal.borelSpace

/- warning: measure_eq_measure_preimage_add_measure_tsum_Ico_zpow -> measure_eq_measure_preimage_add_measure_tsum_Ico_zpow is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_1) {f : Œ± -> ENNReal}, (Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace f) -> (forall {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± _inst_1 s) -> (forall {t : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº s) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.preimage.{u1, 0} Œ± ENNReal f (Singleton.singleton.{0, 0} ENNReal (Set.{0} ENNReal) (Set.hasSingleton.{0} ENNReal) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.preimage.{u1, 0} Œ± ENNReal f (Singleton.singleton.{0, 0} ENNReal (Set.{0} ENNReal) (Set.hasSingleton.{0} ENNReal) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))))) (tsum.{0, 0} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Int (fun (n : Int) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.preimage.{u1, 0} Œ± ENNReal f (Set.Ico.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) (HPow.hPow.{0, 0, 0} ENNReal Int ENNReal (instHPow.{0, 0} ENNReal Int (DivInvMonoid.Pow.{0} ENNReal ENNReal.divInvMonoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) t) n) (HPow.hPow.{0, 0, 0} ENNReal Int ENNReal (instHPow.{0, 0} ENNReal Int (DivInvMonoid.Pow.{0} ENNReal ENNReal.divInvMonoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) t) (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) n (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))))))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_1) {f : Œ± -> ENNReal}, (Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace f) -> (forall {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± _inst_1 s) -> (forall {t : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_1 Œº) s) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_1 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.preimage.{u1, 0} Œ± ENNReal f (Singleton.singleton.{0, 0} ENNReal (Set.{0} ENNReal) (Set.instSingletonSet.{0} ENNReal) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_1 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.preimage.{u1, 0} Œ± ENNReal f (Singleton.singleton.{0, 0} ENNReal (Set.{0} ENNReal) (Set.instSingletonSet.{0} ENNReal) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))))) (tsum.{0, 0} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Int (fun (n : Int) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_1 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.preimage.{u1, 0} Œ± ENNReal f (Set.Ico.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (HPow.hPow.{0, 0, 0} ENNReal Int ENNReal (instHPow.{0, 0} ENNReal Int (DivInvMonoid.Pow.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (ENNReal.some t) n) (HPow.hPow.{0, 0, 0} ENNReal Int ENNReal (instHPow.{0, 0} ENNReal Int (DivInvMonoid.Pow.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (ENNReal.some t) (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) n (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))))))))))))
Case conversion may be inaccurate. Consider using '#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow‚Çì'. -/
/-- One can cut out `‚Ñù‚â•0‚àû` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ‚Ñ§` and `{‚àû}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace Œ±] (Œº : Measure Œ±)
    {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    Œº s =
      Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' {‚àû}) + ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico (t ^ n) (t ^ (n + 1))) :=
  by
  have A : Œº s = Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' Ioi 0) :=
    by
    rw [‚Üê measure_union]
    ¬∑ congr 1
      ext x
      have : 0 = f x ‚à® 0 < f x := eq_or_lt_of_le bot_le
      rw [eq_comm] at this
      simp only [‚Üê and_or_left, this, mem_singleton_iff, mem_inter_iff, and_true_iff, mem_union,
        mem_Ioi, mem_preimage]
    ¬∑ apply disjoint_left.2 fun x hx h'x => _
      have : 0 < f x := h'x.2
      exact lt_irrefl 0 (this.trans_le hx.2.le)
    ¬∑ exact hs.inter (hf measurableSet_Ioi)
  have B : Œº (s ‚à© f ‚Åª¬π' Ioi 0) = Œº (s ‚à© f ‚Åª¬π' {‚àû}) + Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) :=
    by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left]
      congr
      ext x
      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]
      have H : f x = ‚àû ‚à® f x < ‚àû := eq_or_lt_of_le le_top
      cases H
      ¬∑
        simp only [H, eq_self_iff_true, or_false_iff, WithTop.zero_lt_top, not_top_lt,
          and_false_iff]
      ¬∑ simp only [H, H.ne, and_true_iff, false_or_iff]
    ¬∑ apply disjoint_left.2 fun x hx h'x => _
      have : f x < ‚àû := h'x.2.2
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))
    ¬∑ exact hs.inter (hf measurableSet_Ioo)
  have C : Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) = ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico (t ^ n) (t ^ (n + 1))) :=
    by
    rw [‚Üê measure_Union,
      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,
      preimage_Union, inter_Union]
    ¬∑ intro i j
      simp only [Function.onFun]
      intro hij
      wlog h : i < j generalizing i j
      ¬∑ exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm
      apply disjoint_left.2 fun x hx h'x => lt_irrefl (f x) _
      calc
        f x < t ^ (i + 1) := hx.2.2
        _ ‚â§ t ^ j := (ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h)
        _ ‚â§ f x := h'x.2.1
        
    ¬∑ intro n
      exact hs.inter (hf measurableSet_Ico)
  rw [A, B, C, add_assoc]
#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow

section PseudoMetricSpace

variable [PseudoMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù}

open Metric

#print measurableSet_ball /-
@[measurability]
theorem measurableSet_ball : MeasurableSet (Metric.ball x Œµ) :=
  Metric.isOpen_ball.MeasurableSet
#align measurable_set_ball measurableSet_ball
-/

#print measurableSet_closedBall /-
@[measurability]
theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x Œµ) :=
  Metric.isClosed_ball.MeasurableSet
#align measurable_set_closed_ball measurableSet_closedBall
-/

#print measurable_infDist /-
@[measurability]
theorem measurable_infDist {s : Set Œ±} : Measurable fun x => infDist x s :=
  (continuous_infDist_pt s).Measurable
#align measurable_inf_dist measurable_infDist
-/

#print Measurable.infDist /-
@[measurability]
theorem Measurable.infDist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infDist (f x) s :=
  measurable_infDist.comp hf
#align measurable.inf_dist Measurable.infDist
-/

#print measurable_infNndist /-
@[measurability]
theorem measurable_infNndist {s : Set Œ±} : Measurable fun x => infNndist x s :=
  (continuous_infNndist_pt s).Measurable
#align measurable_inf_nndist measurable_infNndist
-/

#print Measurable.infNndist /-
@[measurability]
theorem Measurable.infNndist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infNndist (f x) s :=
  measurable_infNndist.comp hf
#align measurable.inf_nndist Measurable.infNndist
-/

section

variable [SecondCountableTopology Œ±]

#print measurable_dist /-
@[measurability]
theorem measurable_dist : Measurable fun p : Œ± √ó Œ± => dist p.1 p.2 :=
  continuous_dist.Measurable
#align measurable_dist measurable_dist
-/

#print Measurable.dist /-
@[measurability]
theorem Measurable.dist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist Œ± _).measurable2 hf hg
#align measurable.dist Measurable.dist
-/

#print measurable_nndist /-
@[measurability]
theorem measurable_nndist : Measurable fun p : Œ± √ó Œ± => nndist p.1 p.2 :=
  continuous_nndist.Measurable
#align measurable_nndist measurable_nndist
-/

#print Measurable.nndist /-
@[measurability]
theorem Measurable.nndist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist Œ± _).measurable2 hf hg
#align measurable.nndist Measurable.nndist
-/

end

/- warning: tendsto_measure_cthickening -> tendsto_measure_cthickening is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) _inst_2] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (Exists.{1} Real (fun (R : Real) => Exists.{0} (GT.gt.{0} Real Real.hasLt R (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (fun (H : GT.gt.{0} Real Real.hasLt R (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) => Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) R s)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))) -> (Filter.Tendsto.{0, 0} Real ENNReal (fun (r : Real) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) r s)) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (nhds.{0} ENNReal ENNReal.topologicalSpace (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº (closure.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) _inst_2] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (Exists.{1} Real (fun (R : Real) => And (GT.gt.{0} Real Real.instLTReal R (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) R s)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))) -> (Filter.Tendsto.{0, 0} Real ENNReal (fun (r : Real) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) r s)) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (nhds.{0} ENNReal ENNReal.instTopologicalSpaceENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) (closure.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) s))))
Case conversion may be inaccurate. Consider using '#align tendsto_measure_cthickening tendsto_measure_cthickening‚Çì'. -/
/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº (closure s))) :=
  by
  have A : tendsto (fun r => Œº (cthickening r s)) (ùìù[Ioi 0] 0) (ùìù (Œº (closure s))) :=
    by
    rw [closure_eq_Inter_cthickening]
    exact
      tendsto_measure_bInter_gt (fun r hr => is_closed_cthickening.measurable_set)
        (fun i j ipos ij => cthickening_mono ij _) hs
  have B : tendsto (fun r => Œº (cthickening r s)) (ùìù[Iic 0] 0) (ùìù (Œº (closure s))) :=
    by
    apply tendsto.congr' _ tendsto_const_nhds
    filter_upwards [self_mem_nhdsWithin]with _ hr
    rw [cthickening_of_nonpos hr]
  convert B.sup A
  exact (nhds_left_sup_nhds_right' 0).symm
#align tendsto_measure_cthickening tendsto_measure_cthickening

/- warning: tendsto_measure_cthickening_of_is_closed -> tendsto_measure_cthickening_of_isClosed is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) _inst_2] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (Exists.{1} Real (fun (R : Real) => Exists.{0} (GT.gt.{0} Real Real.hasLt R (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (fun (H : GT.gt.{0} Real Real.hasLt R (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) => Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) R s)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))) -> (IsClosed.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) s) -> (Filter.Tendsto.{0, 0} Real ENNReal (fun (r : Real) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) r s)) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (nhds.{0} ENNReal ENNReal.topologicalSpace (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) _inst_2] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (Exists.{1} Real (fun (R : Real) => And (GT.gt.{0} Real Real.instLTReal R (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) R s)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))) -> (IsClosed.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_1)) s) -> (Filter.Tendsto.{0, 0} Real ENNReal (fun (r : Real) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± _inst_1) r s)) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (nhds.{0} ENNReal ENNReal.instTopologicalSpaceENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) s)))
Case conversion may be inaccurate. Consider using '#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed‚Çì'. -/
/-- If a closed set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isClosed {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) (h's : IsClosed s) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº s)) :=
  by
  convert tendsto_measure_cthickening hs
  exact h's.closure_eq.symm
#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed

end PseudoMetricSpace

/- warning: tendsto_measure_cthickening_of_is_compact -> tendsto_measure_cthickening_of_isCompact is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MetricSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1))) _inst_2] [_inst_4 : ProperSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1)] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± _inst_2 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1))) Œº] {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1))) s) -> (Filter.Tendsto.{0, 0} Real ENNReal (fun (r : Real) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº (Metric.cthickening.{u1} Œ± (PseudoMetricSpace.toPseudoEMetricSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1)) r s)) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (nhds.{0} ENNReal ENNReal.topologicalSpace (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MetricSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] [_inst_3 : OpensMeasurableSpace.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1))) _inst_2] [_inst_4 : ProperSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1)] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± _inst_2 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1))) Œº] {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± (MetricSpace.toPseudoMetricSpace.{u1} Œ± _inst_1))) s) -> (Filter.Tendsto.{0, 0} Real ENNReal (fun (r : Real) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) (Metric.cthickening.{u1} Œ± (EMetricSpace.toPseudoEMetricSpace.{u1} Œ± (MetricSpace.toEMetricSpace.{u1} Œ± _inst_1)) r s)) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (nhds.{0} ENNReal ENNReal.instTopologicalSpaceENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) s)))
Case conversion may be inaccurate. Consider using '#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_isCompact‚Çì'. -/
/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isCompact [MetricSpace Œ±] [MeasurableSpace Œ±]
    [OpensMeasurableSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±} [FiniteMeasureOnCompacts Œº] {s : Set Œ±}
    (hs : IsCompact s) : Tendsto (fun r => Œº (Metric.cthickening r s)) (ùìù 0) (ùìù (Œº s)) :=
  tendsto_measure_cthickening_of_isClosed ‚ü®1, zero_lt_one, hs.Bounded.cthickening.measure_lt_top.Ne‚ü©
    hs.IsClosed
#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_isCompact

section PseudoEMetricSpace

variable [PseudoEMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù‚â•0‚àû}

open Emetric

#print measurableSet_eball /-
@[measurability]
theorem measurableSet_eball : MeasurableSet (EMetric.ball x Œµ) :=
  EMetric.isOpen_ball.MeasurableSet
#align measurable_set_eball measurableSet_eball
-/

#print measurable_edist_right /-
@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).Measurable
#align measurable_edist_right measurable_edist_right
-/

#print measurable_edist_left /-
@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).Measurable
#align measurable_edist_left measurable_edist_left
-/

#print measurable_infEdist /-
@[measurability]
theorem measurable_infEdist {s : Set Œ±} : Measurable fun x => infEdist x s :=
  continuous_infEdist.Measurable
#align measurable_inf_edist measurable_infEdist
-/

#print Measurable.infEdist /-
@[measurability]
theorem Measurable.infEdist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infEdist (f x) s :=
  measurable_infEdist.comp hf
#align measurable.inf_edist Measurable.infEdist
-/

variable [SecondCountableTopology Œ±]

#print measurable_edist /-
@[measurability]
theorem measurable_edist : Measurable fun p : Œ± √ó Œ± => edist p.1 p.2 :=
  continuous_edist.Measurable
#align measurable_edist measurable_edist
-/

#print Measurable.edist /-
@[measurability]
theorem Measurable.edist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist Œ± _).measurable2 hf hg
#align measurable.edist Measurable.edist
-/

#print AEMeasurable.edist /-
@[measurability]
theorem AEMeasurable.edist {f g : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => edist (f a) (g a)) Œº :=
  (@continuous_edist Œ± _).aemeasurable2 hf hg
#align ae_measurable.edist AEMeasurable.edist
-/

end PseudoEMetricSpace

namespace Real

open MeasurableSpace MeasureTheory

/- warning: real.borel_eq_generate_from_Ioo_rat -> Real.borel_eq_generateFrom_Ioo_rat is a dubious translation:
lean 3 declaration is
  Eq.{1} (MeasurableSpace.{0} Real) (borel.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (MeasurableSpace.generateFrom.{0} Real (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (b : Rat) => Set.iUnion.{0, 0} (Set.{0} Real) (LT.lt.{0} Rat Rat.hasLt a b) (fun (h : LT.lt.{0} Rat Rat.hasLt a b) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.hasSingleton.{0} (Set.{0} Real)) (Set.Ioo.{0} Real Real.preorder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) a) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) b)))))))
but is expected to have type
  Eq.{1} (MeasurableSpace.{0} Real) (borel.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (MeasurableSpace.generateFrom.{0} Real (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (b : Rat) => Set.iUnion.{0, 0} (Set.{0} Real) (LT.lt.{0} Rat Rat.instLTRat_1 a b) (fun (h : LT.lt.{0} Rat Rat.instLTRat_1 a b) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.instSingletonSet.{0} (Set.{0} Real)) (Set.Ioo.{0} Real Real.instPreorderReal (Rat.cast.{0} Real Real.ratCast a) (Rat.cast.{0} Real Real.ratCast b)))))))
Case conversion may be inaccurate. Consider using '#align real.borel_eq_generate_from_Ioo_rat Real.borel_eq_generateFrom_Ioo_rat‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (a b) -/
theorem borel_eq_generateFrom_Ioo_rat :
    borel ‚Ñù = generateFrom (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (h : a < b), {Ioo a b}) :=
  isTopologicalBasis_Ioo_rat.borel_eq_generateFrom
#align real.borel_eq_generate_from_Ioo_rat Real.borel_eq_generateFrom_Ioo_rat

/- warning: real.is_pi_system_Ioo_rat -> Real.isPiSystem_Ioo_rat is a dubious translation:
lean 3 declaration is
  IsPiSystem.{0} Real (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (b : Rat) => Set.iUnion.{0, 0} (Set.{0} Real) (LT.lt.{0} Rat Rat.hasLt a b) (fun (h : LT.lt.{0} Rat Rat.hasLt a b) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.hasSingleton.{0} (Set.{0} Real)) (Set.Ioo.{0} Real Real.preorder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) a) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) b))))))
but is expected to have type
  IsPiSystem.{0} Real (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (b : Rat) => Set.iUnion.{0, 0} (Set.{0} Real) (LT.lt.{0} Rat Rat.instLTRat_1 a b) (fun (h : LT.lt.{0} Rat Rat.instLTRat_1 a b) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.instSingletonSet.{0} (Set.{0} Real)) (Set.Ioo.{0} Real Real.instPreorderReal (Rat.cast.{0} Real Real.ratCast a) (Rat.cast.{0} Real Real.ratCast b))))))
Case conversion may be inaccurate. Consider using '#align real.is_pi_system_Ioo_rat Real.isPiSystem_Ioo_rat‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (a b) -/
theorem isPiSystem_Ioo_rat : @IsPiSystem ‚Ñù (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (h : a < b), {Ioo a b}) :=
  by
  convert isPiSystem_Ioo (coe : ‚Ñö ‚Üí ‚Ñù) (coe : ‚Ñö ‚Üí ‚Ñù)
  ext x
  simp [eq_comm]
#align real.is_pi_system_Ioo_rat Real.isPiSystem_Ioo_rat

/- warning: real.finite_spanning_sets_in_Ioo_rat -> Real.finiteSpanningSetsInIooRat is a dubious translation:
lean 3 declaration is
  forall (Œº : MeasureTheory.Measure.{0} Real Real.measurableSpace) [_inst_1 : MeasureTheory.LocallyFiniteMeasure.{0} Real Real.measurableSpace (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Œº], MeasureTheory.Measure.FiniteSpanningSetsIn.{0} Real Real.measurableSpace Œº (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (b : Rat) => Set.iUnion.{0, 0} (Set.{0} Real) (LT.lt.{0} Rat Rat.hasLt a b) (fun (h : LT.lt.{0} Rat Rat.hasLt a b) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.hasSingleton.{0} (Set.{0} Real)) (Set.Ioo.{0} Real Real.preorder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) a) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) b))))))
but is expected to have type
  forall (Œº : MeasureTheory.Measure.{0} Real Real.measurableSpace) [_inst_1 : MeasureTheory.LocallyFiniteMeasure.{0} Real Real.measurableSpace (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Œº], MeasureTheory.Measure.FiniteSpanningSetsIn.{0} Real Real.measurableSpace Œº (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (b : Rat) => Set.iUnion.{0, 0} (Set.{0} Real) (LT.lt.{0} Rat Rat.instLTRat_1 a b) (fun (h : LT.lt.{0} Rat Rat.instLTRat_1 a b) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.instSingletonSet.{0} (Set.{0} Real)) (Set.Ioo.{0} Real Real.instPreorderReal (Rat.cast.{0} Real Real.ratCast a) (Rat.cast.{0} Real Real.ratCast b))))))
Case conversion may be inaccurate. Consider using '#align real.finite_spanning_sets_in_Ioo_rat Real.finiteSpanningSetsInIooRat‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (a b) -/
/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Œº` on `‚Ñù`. -/
def finiteSpanningSetsInIooRat (Œº : Measure ‚Ñù) [LocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (h : a < b), {Ioo a b})
    where
  Set n := Ioo (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_Union, mem_singleton_iff]
    refine' ‚ü®-(n + 1 : ‚Ñï), n + 1, _, by simp‚ü©
    -- TODO: norm_cast fails here?
    exact (neg_nonpos.2 (@Nat.cast_nonneg ‚Ñö _ (n + 1))).trans_lt n.cast_add_one_pos
  Finite n := measure_Ioo_lt_top
  spanning :=
    iUnion_eq_univ_iff.2 fun x =>
      ‚ü®‚åä|x|‚åã‚Çä, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)‚ü©
#align real.finite_spanning_sets_in_Ioo_rat Real.finiteSpanningSetsInIooRat

/- warning: real.measure_ext_Ioo_rat -> Real.measure_ext_Ioo_rat is a dubious translation:
lean 3 declaration is
  forall {Œº : MeasureTheory.Measure.{0} Real Real.measurableSpace} {ŒΩ : MeasureTheory.Measure.{0} Real Real.measurableSpace} [_inst_1 : MeasureTheory.LocallyFiniteMeasure.{0} Real Real.measurableSpace (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Œº], (forall (a : Rat) (b : Rat), Eq.{1} ENNReal (coeFn.{1, 1} (MeasureTheory.Measure.{0} Real Real.measurableSpace) (fun (_x : MeasureTheory.Measure.{0} Real Real.measurableSpace) => (Set.{0} Real) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{0} Real Real.measurableSpace) Œº (Set.Ioo.{0} Real Real.preorder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) a) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) b))) (coeFn.{1, 1} (MeasureTheory.Measure.{0} Real Real.measurableSpace) (fun (_x : MeasureTheory.Measure.{0} Real Real.measurableSpace) => (Set.{0} Real) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{0} Real Real.measurableSpace) ŒΩ (Set.Ioo.{0} Real Real.preorder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) a) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) b)))) -> (Eq.{1} (MeasureTheory.Measure.{0} Real Real.measurableSpace) Œº ŒΩ)
but is expected to have type
  forall {Œº : MeasureTheory.Measure.{0} Real Real.measurableSpace} {ŒΩ : MeasureTheory.Measure.{0} Real Real.measurableSpace} [_inst_1 : MeasureTheory.LocallyFiniteMeasure.{0} Real Real.measurableSpace (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Œº], (forall (a : Rat) (b : Rat), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{0} Real (MeasureTheory.Measure.toOuterMeasure.{0} Real Real.measurableSpace Œº) (Set.Ioo.{0} Real Real.instPreorderReal (Rat.cast.{0} Real Real.ratCast a) (Rat.cast.{0} Real Real.ratCast b))) (MeasureTheory.OuterMeasure.measureOf.{0} Real (MeasureTheory.Measure.toOuterMeasure.{0} Real Real.measurableSpace ŒΩ) (Set.Ioo.{0} Real Real.instPreorderReal (Rat.cast.{0} Real Real.ratCast a) (Rat.cast.{0} Real Real.ratCast b)))) -> (Eq.{1} (MeasureTheory.Measure.{0} Real Real.measurableSpace) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align real.measure_ext_Ioo_rat Real.measure_ext_Ioo_rat‚Çì'. -/
theorem measure_ext_Ioo_rat {Œº ŒΩ : Measure ‚Ñù} [LocallyFiniteMeasure Œº]
    (h : ‚àÄ a b : ‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) : Œº = ŒΩ :=
  (finiteSpanningSetsInIooRat Œº).ext borel_eq_generateFrom_Ioo_rat isPiSystem_Ioo_rat <|
    by
    simp only [mem_Union, mem_singleton_iff]
    rintro _ ‚ü®a, b, -, rfl‚ü©
    apply h
#align real.measure_ext_Ioo_rat Real.measure_ext_Ioo_rat

/- warning: real.borel_eq_generate_from_Iio_rat -> Real.borel_eq_generateFrom_Iio_rat is a dubious translation:
lean 3 declaration is
  Eq.{1} (MeasurableSpace.{0} Real) (borel.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (MeasurableSpace.generateFrom.{0} Real (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.hasSingleton.{0} (Set.{0} Real)) (Set.Iio.{0} Real Real.preorder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTC‚Çì.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) a)))))
but is expected to have type
  Eq.{1} (MeasurableSpace.{0} Real) (borel.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (MeasurableSpace.generateFrom.{0} Real (Set.iUnion.{0, 1} (Set.{0} Real) Rat (fun (a : Rat) => Singleton.singleton.{0, 0} (Set.{0} Real) (Set.{0} (Set.{0} Real)) (Set.instSingletonSet.{0} (Set.{0} Real)) (Set.Iio.{0} Real Real.instPreorderReal (Rat.cast.{0} Real Real.ratCast a)))))
Case conversion may be inaccurate. Consider using '#align real.borel_eq_generate_from_Iio_rat Real.borel_eq_generateFrom_Iio_rat‚Çì'. -/
theorem borel_eq_generateFrom_Iio_rat : borel ‚Ñù = generateFrom (‚ãÉ a : ‚Ñö, {Iio a}) :=
  by
  let g : MeasurableSpace ‚Ñù := generate_from (‚ãÉ a : ‚Ñö, {Iio a})
  refine' le_antisymm _ _
  ¬∑ rw [borel_eq_generate_from_Ioo_rat]
    refine' generate_from_le fun t => _
    simp only [mem_Union, mem_singleton_iff]
    rintro ‚ü®a, b, h, rfl‚ü©
    rw [(Set.ext fun x => _ : Ioo (a : ‚Ñù) b = (‚ãÉ c > a, Iio c·∂ú) ‚à© Iio b)]
    ¬∑ have hg : ‚àÄ q : ‚Ñö, measurable_set[g] (Iio q) := fun q =>
        generate_measurable.basic (Iio q) (by simp)
      refine' @MeasurableSet.inter _ g _ _ _ (hg _)
      refine' @MeasurableSet.biUnion _ _ g _ _ (to_countable _) fun c h => _
      exact @MeasurableSet.compl _ _ g (hg _)
    ¬∑ suffices x < ‚Üëb ‚Üí (‚Üëa < x ‚Üî ‚àÉ i : ‚Ñö, a < i ‚àß ‚Üëi ‚â§ x) by simpa
      refine' fun _ => ‚ü®fun h => _, fun ‚ü®i, hai, hix‚ü© => (Rat.cast_lt.2 hai).trans_le hix‚ü©
      rcases exists_rat_btwn h with ‚ü®c, ac, cx‚ü©
      exact ‚ü®c, Rat.cast_lt.1 ac, cx.le‚ü©
  ¬∑ refine' MeasurableSpace.generateFrom_le fun _ => _
    simp only [mem_Union, mem_singleton_iff]
    rintro ‚ü®r, rfl‚ü©
    exact measurableSet_Iio
#align real.borel_eq_generate_from_Iio_rat Real.borel_eq_generateFrom_Iio_rat

end Real

variable [MeasurableSpace Œ±]

#print measurable_real_toNNReal /-
@[measurability]
theorem measurable_real_toNNReal : Measurable Real.toNNReal :=
  continuous_real_toNNReal.Measurable
#align measurable_real_to_nnreal measurable_real_toNNReal
-/

#print Measurable.real_toNNReal /-
@[measurability]
theorem Measurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => Real.toNNReal (f x) :=
  measurable_real_toNNReal.comp hf
#align measurable.real_to_nnreal Measurable.real_toNNReal
-/

#print AEMeasurable.real_toNNReal /-
@[measurability]
theorem AEMeasurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => Real.toNNReal (f x)) Œº :=
  measurable_real_toNNReal.comp_aemeasurable hf
#align ae_measurable.real_to_nnreal AEMeasurable.real_toNNReal
-/

/- warning: measurable_coe_nnreal_real -> measurable_coe_nnreal_real is a dubious translation:
lean 3 declaration is
  Measurable.{0, 0} NNReal Real NNReal.measurableSpace Real.measurableSpace ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTC‚Çì.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))))
but is expected to have type
  Measurable.{0, 0} NNReal Real NNReal.measurableSpace Real.measurableSpace NNReal.toReal
Case conversion may be inaccurate. Consider using '#align measurable_coe_nnreal_real measurable_coe_nnreal_real‚Çì'. -/
@[measurability]
theorem measurable_coe_nnreal_real : Measurable (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù) :=
  NNReal.continuous_coe.Measurable
#align measurable_coe_nnreal_real measurable_coe_nnreal_real

/- warning: measurable.coe_nnreal_real -> Measurable.coe_nnreal_real is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal}, (Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace f) -> (Measurable.{u1, 0} Œ± Real _inst_1 Real.measurableSpace (fun (x : Œ±) => (fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTC‚Çì.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))) (f x)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal}, (Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace f) -> (Measurable.{u1, 0} Œ± Real _inst_1 Real.measurableSpace (fun (x : Œ±) => NNReal.toReal (f x)))
Case conversion may be inaccurate. Consider using '#align measurable.coe_nnreal_real Measurable.coe_nnreal_real‚Çì'. -/
@[measurability]
theorem Measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù) :=
  measurable_coe_nnreal_real.comp hf
#align measurable.coe_nnreal_real Measurable.coe_nnreal_real

/- warning: ae_measurable.coe_nnreal_real -> AEMeasurable.coe_nnreal_real is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1}, (AEMeasurable.{u1, 0} Œ± NNReal NNReal.measurableSpace _inst_1 f Œº) -> (AEMeasurable.{u1, 0} Œ± Real Real.measurableSpace _inst_1 (fun (x : Œ±) => (fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTC‚Çì.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))) (f x)) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1}, (AEMeasurable.{u1, 0} Œ± NNReal NNReal.measurableSpace _inst_1 f Œº) -> (AEMeasurable.{u1, 0} Œ± Real Real.measurableSpace _inst_1 (fun (x : Œ±) => NNReal.toReal (f x)) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable.coe_nnreal_real AEMeasurable.coe_nnreal_real‚Çì'. -/
@[measurability]
theorem AEMeasurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù)) Œº :=
  measurable_coe_nnreal_real.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_real AEMeasurable.coe_nnreal_real

#print measurable_coe_nnreal_ennreal /-
@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.Measurable
#align measurable_coe_nnreal_ennreal measurable_coe_nnreal_ennreal
-/

#print Measurable.coe_nnreal_ennreal /-
@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.Measurable.comp hf
#align measurable.coe_nnreal_ennreal Measurable.coe_nnreal_ennreal
-/

#print AEMeasurable.coe_nnreal_ennreal /-
@[measurability]
theorem AEMeasurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº :=
  ENNReal.continuous_coe.Measurable.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_ennreal AEMeasurable.coe_nnreal_ennreal
-/

#print Measurable.ennreal_ofReal /-
@[measurability]
theorem Measurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => ENNReal.ofReal (f x) :=
  ENNReal.continuous_ofReal.Measurable.comp hf
#align measurable.ennreal_of_real Measurable.ennreal_ofReal
-/

/- warning: measurable_coe_nnreal_real_iff -> measurable_coe_nnreal_real_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal}, Iff (Measurable.{u1, 0} Œ± Real _inst_1 Real.measurableSpace (fun (x : Œ±) => (fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTC‚Çì.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))) (f x))) (Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace f)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal}, Iff (Measurable.{u1, 0} Œ± Real _inst_1 Real.measurableSpace (fun (x : Œ±) => NNReal.toReal (f x))) (Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace f)
Case conversion may be inaccurate. Consider using '#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff‚Çì'. -/
@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    Measurable (fun x => f x : Œ± ‚Üí ‚Ñù) ‚Üî Measurable f :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_to_nnreal, Measurable.coe_nnreal_real‚ü©
#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff

/- warning: ae_measurable_coe_nnreal_real_iff -> aEMeasurable_coe_nnreal_real_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1}, Iff (AEMeasurable.{u1, 0} Œ± Real Real.measurableSpace _inst_1 (fun (x : Œ±) => (fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTC‚Çì.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe))) (f x)) Œº) (AEMeasurable.{u1, 0} Œ± NNReal NNReal.measurableSpace _inst_1 f Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {f : Œ± -> NNReal} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1}, Iff (AEMeasurable.{u1, 0} Œ± Real Real.measurableSpace _inst_1 (fun (x : Œ±) => NNReal.toReal (f x)) Œº) (AEMeasurable.{u1, 0} Œ± NNReal NNReal.measurableSpace _inst_1 f Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable_coe_nnreal_real_iff aEMeasurable_coe_nnreal_real_iff‚Çì'. -/
@[simp, norm_cast]
theorem aEMeasurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => f x : Œ± ‚Üí ‚Ñù) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_to_nnreal, AEMeasurable.coe_nnreal_real‚ü©
#align ae_measurable_coe_nnreal_real_iff aEMeasurable_coe_nnreal_real_iff

/- warning: measurable_equiv.ennreal_equiv_nnreal -> MeasurableEquiv.ennrealEquivNNReal is a dubious translation:
lean 3 declaration is
  MeasurableEquiv.{0, 0} (coeSort.{1, 2} (Set.{0} ENNReal) Type (Set.hasCoeToSort.{0} ENNReal) (setOf.{0} ENNReal (fun (r : ENNReal) => Ne.{1} ENNReal r (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))) NNReal (Subtype.instMeasurableSpace.{0} ENNReal (fun (x : ENNReal) => Membership.Mem.{0, 0} ENNReal (Set.{0} ENNReal) (Set.hasMem.{0} ENNReal) x (setOf.{0} ENNReal (fun (r : ENNReal) => Ne.{1} ENNReal r (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))) ENNReal.measurableSpace) NNReal.measurableSpace
but is expected to have type
  MeasurableEquiv.{0, 0} (Set.Elem.{0} ENNReal (setOf.{0} ENNReal (fun (r : ENNReal) => Ne.{1} ENNReal r (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))) NNReal (Subtype.instMeasurableSpace.{0} ENNReal (fun (x : ENNReal) => Membership.mem.{0, 0} ENNReal (Set.{0} ENNReal) (Set.instMembershipSet.{0} ENNReal) x (setOf.{0} ENNReal (fun (r : ENNReal) => Ne.{1} ENNReal r (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))) ENNReal.measurableSpace) NNReal.measurableSpace
Case conversion may be inaccurate. Consider using '#align measurable_equiv.ennreal_equiv_nnreal MeasurableEquiv.ennrealEquivNNReal‚Çì'. -/
/-- The set of finite `‚Ñù‚â•0‚àû` numbers is `measurable_equiv` to `‚Ñù‚â•0`. -/
def MeasurableEquiv.ennrealEquivNNReal : { r : ‚Ñù‚â•0‚àû | r ‚â† ‚àû } ‚âÉ·µê ‚Ñù‚â•0 :=
  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv
#align measurable_equiv.ennreal_equiv_nnreal MeasurableEquiv.ennrealEquivNNReal

namespace ENNReal

#print ENNReal.measurable_of_measurable_nnreal /-
theorem measurable_of_measurable_nnreal {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} (h : Measurable fun p : ‚Ñù‚â•0 => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton ‚àû
    (MeasurableEquiv.ennrealEquivNNReal.symm.measurable_comp_iff.1 h)
#align ennreal.measurable_of_measurable_nnreal ENNReal.measurable_of_measurable_nnreal
-/

#print ENNReal.ennrealEquivSum /-
/-- `‚Ñù‚â•0‚àû` is `measurable_equiv` to `‚Ñù‚â•0 ‚äï unit`. -/
def ennrealEquivSum : ‚Ñù‚â•0‚àû ‚âÉ·µê Sum ‚Ñù‚â•0 Unit :=
  {
    Equiv.optionEquivSumPUnit
      ‚Ñù‚â•0 with
    measurable_to_fun := measurable_of_measurable_nnreal measurable_inl
    measurable_inv_fun :=
      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const ‚Ñù‚â•0‚àû Unit _ _ ‚àû) }
#align ennreal.ennreal_equiv_sum ENNReal.ennrealEquivSum
-/

open Function (uncurry)

/- warning: ennreal.measurable_of_measurable_nnreal_prod -> ENNReal.measurable_of_measurable_nnreal_prod is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_2 : MeasurableSpace.{u1} Œ≤] [_inst_3 : MeasurableSpace.{u2} Œ≥] {f : (Prod.{0, u1} ENNReal Œ≤) -> Œ≥}, (Measurable.{u1, u2} (Prod.{0, u1} NNReal Œ≤) Œ≥ (Prod.instMeasurableSpace.{0, u1} NNReal Œ≤ NNReal.measurableSpace _inst_2) _inst_3 (fun (p : Prod.{0, u1} NNReal Œ≤) => f (Prod.mk.{0, u1} ENNReal Œ≤ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) (Prod.fst.{0, u1} NNReal Œ≤ p)) (Prod.snd.{0, u1} NNReal Œ≤ p)))) -> (Measurable.{u1, u2} Œ≤ Œ≥ _inst_2 _inst_3 (fun (x : Œ≤) => f (Prod.mk.{0, u1} ENNReal Œ≤ (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) x))) -> (Measurable.{u1, u2} (Prod.{0, u1} ENNReal Œ≤) Œ≥ (Prod.instMeasurableSpace.{0, u1} ENNReal Œ≤ ENNReal.measurableSpace _inst_2) _inst_3 f)
but is expected to have type
  forall {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_2 : MeasurableSpace.{u2} Œ≤] [_inst_3 : MeasurableSpace.{u1} Œ≥] {f : (Prod.{0, u2} ENNReal Œ≤) -> Œ≥}, (Measurable.{u2, u1} (Prod.{0, u2} NNReal Œ≤) Œ≥ (Prod.instMeasurableSpace.{0, u2} NNReal Œ≤ NNReal.measurableSpace _inst_2) _inst_3 (fun (p : Prod.{0, u2} NNReal Œ≤) => f (Prod.mk.{0, u2} ENNReal Œ≤ (ENNReal.some (Prod.fst.{0, u2} NNReal Œ≤ p)) (Prod.snd.{0, u2} NNReal Œ≤ p)))) -> (Measurable.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 (fun (x : Œ≤) => f (Prod.mk.{0, u2} ENNReal Œ≤ (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) x))) -> (Measurable.{u2, u1} (Prod.{0, u2} ENNReal Œ≤) Œ≥ (Prod.instMeasurableSpace.{0, u2} ENNReal Œ≤ ENNReal.measurableSpace _inst_2) _inst_3 f)
Case conversion may be inaccurate. Consider using '#align ennreal.measurable_of_measurable_nnreal_prod ENNReal.measurable_of_measurable_nnreal_prod‚Çì'. -/
theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Œ≤] [MeasurableSpace Œ≥]
    {f : ‚Ñù‚â•0‚àû √ó Œ≤ ‚Üí Œ≥} (H‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó Œ≤ => f (p.1, p.2))
    (H‚ÇÇ : Measurable fun x => f (‚àû, x)) : Measurable f :=
  let e : ‚Ñù‚â•0‚àû √ó Œ≤ ‚âÉ·µê Sum (‚Ñù‚â•0 √ó Œ≤) (Unit √ó Œ≤) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Œ≤)).trans
      (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)
#align ennreal.measurable_of_measurable_nnreal_prod ENNReal.measurable_of_measurable_nnreal_prod

/- warning: ennreal.measurable_of_measurable_nnreal_nnreal -> ENNReal.measurable_of_measurable_nnreal_nnreal is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} [_inst_2 : MeasurableSpace.{u1} Œ≤] {f : (Prod.{0, 0} ENNReal ENNReal) -> Œ≤}, (Measurable.{0, u1} (Prod.{0, 0} NNReal NNReal) Œ≤ (Prod.instMeasurableSpace.{0, 0} NNReal NNReal NNReal.measurableSpace NNReal.measurableSpace) _inst_2 (fun (p : Prod.{0, 0} NNReal NNReal) => f (Prod.mk.{0, 0} ENNReal ENNReal ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) (Prod.fst.{0, 0} NNReal NNReal p)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) (Prod.snd.{0, 0} NNReal NNReal p))))) -> (Measurable.{0, u1} NNReal Œ≤ NNReal.measurableSpace _inst_2 (fun (r : NNReal) => f (Prod.mk.{0, 0} ENNReal ENNReal (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) r)))) -> (Measurable.{0, u1} NNReal Œ≤ NNReal.measurableSpace _inst_2 (fun (r : NNReal) => f (Prod.mk.{0, 0} ENNReal ENNReal ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) r) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))) -> (Measurable.{0, u1} (Prod.{0, 0} ENNReal ENNReal) Œ≤ (Prod.instMeasurableSpace.{0, 0} ENNReal ENNReal ENNReal.measurableSpace ENNReal.measurableSpace) _inst_2 f)
but is expected to have type
  forall {Œ≤ : Type.{u1}} [_inst_2 : MeasurableSpace.{u1} Œ≤] {f : (Prod.{0, 0} ENNReal ENNReal) -> Œ≤}, (Measurable.{0, u1} (Prod.{0, 0} NNReal NNReal) Œ≤ (Prod.instMeasurableSpace.{0, 0} NNReal NNReal NNReal.measurableSpace NNReal.measurableSpace) _inst_2 (fun (p : Prod.{0, 0} NNReal NNReal) => f (Prod.mk.{0, 0} ENNReal ENNReal (ENNReal.some (Prod.fst.{0, 0} NNReal NNReal p)) (ENNReal.some (Prod.snd.{0, 0} NNReal NNReal p))))) -> (Measurable.{0, u1} NNReal Œ≤ NNReal.measurableSpace _inst_2 (fun (r : NNReal) => f (Prod.mk.{0, 0} ENNReal ENNReal (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))) (ENNReal.some r)))) -> (Measurable.{0, u1} NNReal Œ≤ NNReal.measurableSpace _inst_2 (fun (r : NNReal) => f (Prod.mk.{0, 0} ENNReal ENNReal (ENNReal.some r) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))) -> (Measurable.{0, u1} (Prod.{0, 0} ENNReal ENNReal) Œ≤ (Prod.instMeasurableSpace.{0, 0} ENNReal ENNReal ENNReal.measurableSpace ENNReal.measurableSpace) _inst_2 f)
Case conversion may be inaccurate. Consider using '#align ennreal.measurable_of_measurable_nnreal_nnreal ENNReal.measurable_of_measurable_nnreal_nnreal‚Çì'. -/
theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Œ≤] {f : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû ‚Üí Œ≤}
    (h‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0 => f (p.1, p.2)) (h‚ÇÇ : Measurable fun r : ‚Ñù‚â•0 => f (‚àû, r))
    (h‚ÇÉ : Measurable fun r : ‚Ñù‚â•0 => f (r, ‚àû)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)
    (measurable_of_measurable_nnreal h‚ÇÇ)
#align ennreal.measurable_of_measurable_nnreal_nnreal ENNReal.measurable_of_measurable_nnreal_nnreal

#print ENNReal.measurable_ofReal /-
@[measurability]
theorem measurable_ofReal : Measurable ENNReal.ofReal :=
  ENNReal.continuous_ofReal.Measurable
#align ennreal.measurable_of_real ENNReal.measurable_ofReal
-/

#print ENNReal.measurable_toReal /-
@[measurability]
theorem measurable_toReal : Measurable ENNReal.toReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_coe_nnreal_real
#align ennreal.measurable_to_real ENNReal.measurable_toReal
-/

#print ENNReal.measurable_toNNReal /-
@[measurability]
theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_id
#align ennreal.measurable_to_nnreal ENNReal.measurable_toNNReal
-/

instance : MeasurableMul‚ÇÇ ‚Ñù‚â•0‚àû :=
  by
  refine' ‚ü®measurable_of_measurable_nnreal_nnreal _ _ _‚ü©
  ¬∑ simp only [‚Üê ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]
  ¬∑ simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const
  ¬∑ simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const

instance : MeasurableSub‚ÇÇ ‚Ñù‚â•0‚àû :=
  ‚ü®by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [‚Üê WithTop.coe_sub, continuous_sub.measurable.coe_nnreal_ennreal]‚ü©

instance : MeasurableInv ‚Ñù‚â•0‚àû :=
  ‚ü®continuous_inv.Measurable‚ü©

end ENNReal

#print Measurable.ennreal_toNNReal /-
@[measurability]
theorem Measurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x).toNNReal :=
  ENNReal.measurable_toNNReal.comp hf
#align measurable.ennreal_to_nnreal Measurable.ennreal_toNNReal
-/

#print AEMeasurable.ennreal_toNNReal /-
@[measurability]
theorem AEMeasurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toNNReal) Œº :=
  ENNReal.measurable_toNNReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_nnreal AEMeasurable.ennreal_toNNReal
-/

#print measurable_coe_nnreal_ennreal_iff /-
@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (Measurable fun x => (f x : ‚Ñù‚â•0‚àû)) ‚Üî Measurable f :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align measurable_coe_nnreal_ennreal_iff measurable_coe_nnreal_ennreal_iff
-/

#print aemeasurable_coe_nnreal_ennreal_iff /-
@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align ae_measurable_coe_nnreal_ennreal_iff aemeasurable_coe_nnreal_ennreal_iff
-/

#print Measurable.ennreal_toReal /-
@[measurability]
theorem Measurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => ENNReal.toReal (f x) :=
  ENNReal.measurable_toReal.comp hf
#align measurable.ennreal_to_real Measurable.ennreal_toReal
-/

#print AEMeasurable.ennreal_toReal /-
@[measurability]
theorem AEMeasurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => ENNReal.toReal (f x)) Œº :=
  ENNReal.measurable_toReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_real AEMeasurable.ennreal_toReal
-/

/- warning: measurable.ennreal_tsum -> Measurable.ennreal_tsum is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> ENNReal}, (forall (i : Œπ), Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (f i)) -> (Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (fun (x : Œ±) => tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => f i x)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> ENNReal}, (forall (i : Œπ), Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (f i)) -> (Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (fun (x : Œ±) => tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => f i x)))
Case conversion may be inaccurate. Consider using '#align measurable.ennreal_tsum Measurable.ennreal_tsum‚Çì'. -/
/-- note: `‚Ñù‚â•0‚àû` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x :=
  by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply measurable_iSup
  exact fun s => s.measurable_sum fun i _ => h i
#align measurable.ennreal_tsum Measurable.ennreal_tsum

/- warning: measurable.ennreal_tsum' -> Measurable.ennreal_tsum' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> ENNReal}, (forall (i : Œπ), Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (f i)) -> (Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (tsum.{u1, u2} (Œ± -> ENNReal) (Pi.addCommMonoid.{u1, 0} Œ± (fun (·æ∞ : Œ±) => ENNReal) (fun (i : Œ±) => OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (Pi.topologicalSpace.{u1, 0} Œ± (fun (·æ∞ : Œ±) => ENNReal) (fun (a : Œ±) => ENNReal.topologicalSpace)) Œπ (fun (i : Œπ) => f i)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> ENNReal}, (forall (i : Œπ), Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (f i)) -> (Measurable.{u1, 0} Œ± ENNReal _inst_1 ENNReal.measurableSpace (tsum.{u1, u2} (Œ± -> ENNReal) (Pi.addCommMonoid.{u1, 0} Œ± (fun (·æ∞ : Œ±) => ENNReal) (fun (i : Œ±) => LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal))) (Pi.topologicalSpace.{u1, 0} Œ± (fun (·æ∞ : Œ±) => ENNReal) (fun (a : Œ±) => ENNReal.instTopologicalSpaceENNReal)) Œπ (fun (i : Œπ) => f i)))
Case conversion may be inaccurate. Consider using '#align measurable.ennreal_tsum' Measurable.ennreal_tsum'‚Çì'. -/
@[measurability]
theorem Measurable.ennreal_tsum' {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable (‚àë' i, f i) := by
  convert Measurable.ennreal_tsum h
  ext1 x
  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)
#align measurable.ennreal_tsum' Measurable.ennreal_tsum'

/- warning: measurable.nnreal_tsum -> Measurable.nnreal_tsum is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> NNReal}, (forall (i : Œπ), Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace (f i)) -> (Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace (fun (x : Œ±) => tsum.{0, u2} NNReal (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) NNReal.topologicalSpace Œπ (fun (i : Œπ) => f i x)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> NNReal}, (forall (i : Œπ), Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace (f i)) -> (Measurable.{u1, 0} Œ± NNReal _inst_1 NNReal.measurableSpace (fun (x : Œ±) => tsum.{0, u2} NNReal (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) NNReal.instTopologicalSpaceNNReal Œπ (fun (i : Œπ) => f i x)))
Case conversion may be inaccurate. Consider using '#align measurable.nnreal_tsum Measurable.nnreal_tsum‚Çì'. -/
@[measurability]
theorem Measurable.nnreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x :=
  by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align measurable.nnreal_tsum Measurable.nnreal_tsum

/- warning: ae_measurable.ennreal_tsum -> AEMeasurable.ennreal_tsum is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> ENNReal} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1}, (forall (i : Œπ), AEMeasurable.{u1, 0} Œ± ENNReal ENNReal.measurableSpace _inst_1 (f i) Œº) -> (AEMeasurable.{u1, 0} Œ± ENNReal ENNReal.measurableSpace _inst_1 (fun (x : Œ±) => tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => f i x)) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_2 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> ENNReal} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1}, (forall (i : Œπ), AEMeasurable.{u1, 0} Œ± ENNReal ENNReal.measurableSpace _inst_1 (f i) Œº) -> (AEMeasurable.{u1, 0} Œ± ENNReal ENNReal.measurableSpace _inst_1 (fun (x : Œ±) => tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => f i x)) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable.ennreal_tsum AEMeasurable.ennreal_tsum‚Çì'. -/
@[measurability]
theorem AEMeasurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
    (h : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun x => ‚àë' i, f i x) Œº :=
  by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply aemeasurable_iSup
  exact fun s => Finset.aemeasurable_sum s fun i _ => h i
#align ae_measurable.ennreal_tsum AEMeasurable.ennreal_tsum

/- warning: ae_measurable.nnreal_tsum -> AEMeasurable.nnreal_tsum is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_2 : MeasurableSpace.{u1} Œ±] {Œπ : Type.{u2}} [_inst_3 : Countable.{succ u2} Œπ] {f : Œπ -> Œ± -> NNReal} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2}, (forall (i : Œπ), AEMeasurable.{u1, 0} Œ± NNReal NNReal.measurableSpace _inst_2 (f i) Œº) -> (AEMeasurable.{u1, 0} Œ± NNReal NNReal.measurableSpace _inst_2 (fun (x : Œ±) => tsum.{0, u2} NNReal (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) NNReal.topologicalSpace Œπ (fun (i : Œπ) => f i x)) Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_2 : MeasurableSpace.{u2} Œ±] {Œπ : Type.{u1}} [_inst_3 : Countable.{succ u1} Œπ] {f : Œπ -> Œ± -> NNReal} {Œº : MeasureTheory.Measure.{u2} Œ± _inst_2}, (forall (i : Œπ), AEMeasurable.{u2, 0} Œ± NNReal NNReal.measurableSpace _inst_2 (f i) Œº) -> (AEMeasurable.{u2, 0} Œ± NNReal NNReal.measurableSpace _inst_2 (fun (x : Œ±) => tsum.{0, u1} NNReal (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) NNReal.instTopologicalSpaceNNReal Œπ (fun (i : Œπ) => f i x)) Œº)
Case conversion may be inaccurate. Consider using '#align ae_measurable.nnreal_tsum AEMeasurable.nnreal_tsum‚Çì'. -/
@[measurability]
theorem AEMeasurable.nnreal_tsum {Œ± : Type _} [MeasurableSpace Œ±] {Œπ : Type _} [Countable Œπ]
    {f : Œπ ‚Üí Œ± ‚Üí NNReal} {Œº : MeasureTheory.Measure Œ±} (h : ‚àÄ i : Œπ, AEMeasurable (f i) Œº) :
    AEMeasurable (fun x : Œ± => ‚àë' i : Œπ, f i x) Œº :=
  by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align ae_measurable.nnreal_tsum AEMeasurable.nnreal_tsum

#print measurable_coe_real_ereal /-
@[measurability]
theorem measurable_coe_real_ereal : Measurable (coe : ‚Ñù ‚Üí EReal) :=
  continuous_coe_real_ereal.Measurable
#align measurable_coe_real_ereal measurable_coe_real_ereal
-/

#print Measurable.coe_real_ereal /-
@[measurability]
theorem Measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_real_ereal.comp hf
#align measurable.coe_real_ereal Measurable.coe_real_ereal
-/

#print AEMeasurable.coe_real_ereal /-
@[measurability]
theorem AEMeasurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_real_ereal.comp_aemeasurable hf
#align ae_measurable.coe_real_ereal AEMeasurable.coe_real_ereal
-/

/- warning: measurable_equiv.ereal_equiv_real -> MeasurableEquiv.erealEquivReal is a dubious translation:
lean 3 declaration is
  MeasurableEquiv.{0, 0} (coeSort.{1, 2} (Set.{0} EReal) Type (Set.hasCoeToSort.{0} EReal) (HasCompl.compl.{0} (Set.{0} EReal) (BooleanAlgebra.toHasCompl.{0} (Set.{0} EReal) (Set.booleanAlgebra.{0} EReal)) (Insert.insert.{0, 0} EReal (Set.{0} EReal) (Set.hasInsert.{0} EReal) (Bot.bot.{0} EReal EReal.hasBot) (Singleton.singleton.{0, 0} EReal (Set.{0} EReal) (Set.hasSingleton.{0} EReal) (Top.top.{0} EReal EReal.hasTop))))) Real (Subtype.instMeasurableSpace.{0} EReal (fun (x : EReal) => Membership.Mem.{0, 0} EReal (Set.{0} EReal) (Set.hasMem.{0} EReal) x (HasCompl.compl.{0} (Set.{0} EReal) (BooleanAlgebra.toHasCompl.{0} (Set.{0} EReal) (Set.booleanAlgebra.{0} EReal)) (Insert.insert.{0, 0} EReal (Set.{0} EReal) (Set.hasInsert.{0} EReal) (Bot.bot.{0} EReal EReal.hasBot) (Singleton.singleton.{0, 0} EReal (Set.{0} EReal) (Set.hasSingleton.{0} EReal) (Top.top.{0} EReal EReal.hasTop))))) EReal.measurableSpace) Real.measurableSpace
but is expected to have type
  MeasurableEquiv.{0, 0} (Set.Elem.{0} EReal (HasCompl.compl.{0} (Set.{0} EReal) (BooleanAlgebra.toHasCompl.{0} (Set.{0} EReal) (Set.instBooleanAlgebraSet.{0} EReal)) (Insert.insert.{0, 0} EReal (Set.{0} EReal) (Set.instInsertSet.{0} EReal) (Bot.bot.{0} EReal instERealBot) (Singleton.singleton.{0, 0} EReal (Set.{0} EReal) (Set.instSingletonSet.{0} EReal) (Top.top.{0} EReal EReal.instTopEReal))))) Real (Subtype.instMeasurableSpace.{0} EReal (fun (x : EReal) => Membership.mem.{0, 0} EReal (Set.{0} EReal) (Set.instMembershipSet.{0} EReal) x (HasCompl.compl.{0} (Set.{0} EReal) (BooleanAlgebra.toHasCompl.{0} (Set.{0} EReal) (Set.instBooleanAlgebraSet.{0} EReal)) (Insert.insert.{0, 0} EReal (Set.{0} EReal) (Set.instInsertSet.{0} EReal) (Bot.bot.{0} EReal instERealBot) (Singleton.singleton.{0, 0} EReal (Set.{0} EReal) (Set.instSingletonSet.{0} EReal) (Top.top.{0} EReal EReal.instTopEReal))))) EReal.measurableSpace) Real.measurableSpace
Case conversion may be inaccurate. Consider using '#align measurable_equiv.ereal_equiv_real MeasurableEquiv.erealEquivReal‚Çì'. -/
/-- The set of finite `ereal` numbers is `measurable_equiv` to `‚Ñù`. -/
def MeasurableEquiv.erealEquivReal : ({‚ä•, ‚ä§}·∂ú : Set EReal) ‚âÉ·µê ‚Ñù :=
  EReal.neBotTopHomeomorphReal.toMeasurableEquiv
#align measurable_equiv.ereal_equiv_real MeasurableEquiv.erealEquivReal

#print EReal.measurable_of_measurable_real /-
theorem EReal.measurable_of_measurable_real {f : EReal ‚Üí Œ±} (h : Measurable fun p : ‚Ñù => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_finite {‚ä•, ‚ä§} (by simp)
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)
#align ereal.measurable_of_measurable_real EReal.measurable_of_measurable_real
-/

#print measurable_ereal_toReal /-
@[measurability]
theorem measurable_ereal_toReal : Measurable EReal.toReal :=
  EReal.measurable_of_measurable_real (by simpa using measurable_id)
#align measurable_ereal_to_real measurable_ereal_toReal
-/

#print Measurable.ereal_toReal /-
@[measurability]
theorem Measurable.ereal_toReal {f : Œ± ‚Üí EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toReal :=
  measurable_ereal_toReal.comp hf
#align measurable.ereal_to_real Measurable.ereal_toReal
-/

#print AEMeasurable.ereal_toReal /-
@[measurability]
theorem AEMeasurable.ereal_toReal {f : Œ± ‚Üí EReal} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toReal) Œº :=
  measurable_ereal_toReal.comp_aemeasurable hf
#align ae_measurable.ereal_to_real AEMeasurable.ereal_toReal
-/

#print measurable_coe_ennreal_ereal /-
@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable (coe : ‚Ñù‚â•0‚àû ‚Üí EReal) :=
  continuous_coe_ennreal_ereal.Measurable
#align measurable_coe_ennreal_ereal measurable_coe_ennreal_ereal
-/

#print Measurable.coe_ereal_ennreal /-
@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_ennreal_ereal.comp hf
#align measurable.coe_ereal_ennreal Measurable.coe_ereal_ennreal
-/

#print AEMeasurable.coe_ereal_ennreal /-
@[measurability]
theorem AEMeasurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_ennreal_ereal.comp_aemeasurable hf
#align ae_measurable.coe_ereal_ennreal AEMeasurable.coe_ereal_ennreal
-/

section NormedAddCommGroup

variable [NormedAddCommGroup Œ±] [OpensMeasurableSpace Œ±] [MeasurableSpace Œ≤]

#print measurable_norm /-
@[measurability]
theorem measurable_norm : Measurable (norm : Œ± ‚Üí ‚Ñù) :=
  continuous_norm.Measurable
#align measurable_norm measurable_norm
-/

#print Measurable.norm /-
@[measurability]
theorem Measurable.norm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf
#align measurable.norm Measurable.norm
-/

#print AEMeasurable.norm /-
@[measurability]
theorem AEMeasurable.norm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => norm (f a)) Œº :=
  measurable_norm.comp_aemeasurable hf
#align ae_measurable.norm AEMeasurable.norm
-/

#print measurable_nnnorm /-
@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : Œ± ‚Üí ‚Ñù‚â•0) :=
  continuous_nnnorm.Measurable
#align measurable_nnnorm measurable_nnnorm
-/

#print Measurable.nnnorm /-
@[measurability]
theorem Measurable.nnnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => ‚Äñf a‚Äñ‚Çä :=
  measurable_nnnorm.comp hf
#align measurable.nnnorm Measurable.nnnorm
-/

#print AEMeasurable.nnnorm /-
@[measurability]
theorem AEMeasurable.nnnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => ‚Äñf a‚Äñ‚Çä) Œº :=
  measurable_nnnorm.comp_aemeasurable hf
#align ae_measurable.nnnorm AEMeasurable.nnnorm
-/

#print measurable_ennnorm /-
@[measurability]
theorem measurable_ennnorm : Measurable fun x : Œ± => (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  measurable_nnnorm.coe_nnreal_ennreal
#align measurable_ennnorm measurable_ennnorm
-/

#print Measurable.ennnorm /-
@[measurability]
theorem Measurable.ennnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  hf.nnnorm.coe_nnreal_ennreal
#align measurable.ennnorm Measurable.ennnorm
-/

#print AEMeasurable.ennnorm /-
@[measurability]
theorem AEMeasurable.ennnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) Œº :=
  measurable_ennnorm.comp_aemeasurable hf
#align ae_measurable.ennnorm AEMeasurable.ennnorm
-/

end NormedAddCommGroup

