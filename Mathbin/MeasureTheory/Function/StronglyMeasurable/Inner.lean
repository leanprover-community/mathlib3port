/-
Copyright (c) 2021 RÃ©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: RÃ©my Degenne, SÃ©bastien GouÃ«zel

! This file was ported from Lean 3 source module measure_theory.function.strongly_measurable.inner
! leanprover-community/mathlib commit 46b633fd842bef9469441c0209906f6dddd2b4f5
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.MeasureTheory.Function.StronglyMeasurable.Basic
import Mathbin.Analysis.InnerProductSpace.Basic

/-!
# Inner products of strongly measurable functions are strongly measurable.

-/


variable {Î± : Type _}

namespace MeasureTheory

/-! ## Strongly measurable functions -/


namespace StronglyMeasurable

/- warning: measure_theory.strongly_measurable.inner -> MeasureTheory.StronglyMeasurable.inner is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} {E : Type.{u3}} [_inst_1 : IsROrC.{u2} ğ•œ] [_inst_2 : NormedAddCommGroup.{u3} E] [_inst_3 : InnerProductSpace.{u2, u3} ğ•œ E _inst_1 _inst_2] {m : MeasurableSpace.{u1} Î±} {f : Î± -> E} {g : Î± -> E}, (MeasureTheory.StronglyMeasurable.{u1, u3} Î± E (UniformSpace.toTopologicalSpace.{u3} E (PseudoMetricSpace.toUniformSpace.{u3} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} E _inst_2)))) m f) -> (MeasureTheory.StronglyMeasurable.{u1, u3} Î± E (UniformSpace.toTopologicalSpace.{u3} E (PseudoMetricSpace.toUniformSpace.{u3} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} E _inst_2)))) m g) -> (MeasureTheory.StronglyMeasurable.{u1, u2} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u2} ğ•œ (PseudoMetricSpace.toUniformSpace.{u2} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u2} ğ•œ (SeminormedCommRing.toSemiNormedRing.{u2} ğ•œ (NormedCommRing.toSeminormedCommRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))) m (fun (t : Î±) => Inner.inner.{u2, u3} ğ•œ E (InnerProductSpace.toHasInner.{u2, u3} ğ•œ E _inst_1 _inst_2 _inst_3) (f t) (g t)))
but is expected to have type
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u3}} {E : Type.{u2}} [_inst_1 : IsROrC.{u3} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : InnerProductSpace.{u3, u2} ğ•œ E _inst_1 _inst_2] {m : MeasurableSpace.{u1} Î±} {f : Î± -> E} {g : Î± -> E}, (MeasureTheory.StronglyMeasurable.{u1, u2} Î± E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) m f) -> (MeasureTheory.StronglyMeasurable.{u1, u2} Î± E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) m g) -> (MeasureTheory.StronglyMeasurable.{u1, u3} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u3} ğ•œ (PseudoMetricSpace.toUniformSpace.{u3} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u3} ğ•œ (SeminormedCommRing.toSeminormedRing.{u3} ğ•œ (NormedCommRing.toSeminormedCommRing.{u3} ğ•œ (NormedField.toNormedCommRing.{u3} ğ•œ (DenselyNormedField.toNormedField.{u3} ğ•œ (IsROrC.toDenselyNormedField.{u3} ğ•œ _inst_1)))))))) m (fun (t : Î±) => Inner.inner.{u3, u2} ğ•œ E (InnerProductSpace.toInner.{u3, u2} ğ•œ E _inst_1 _inst_2 _inst_3) (f t) (g t)))
Case conversion may be inaccurate. Consider using '#align measure_theory.strongly_measurable.inner MeasureTheory.StronglyMeasurable.innerâ‚“'. -/
protected theorem inner {ğ•œ : Type _} {E : Type _} [IsROrC ğ•œ] [NormedAddCommGroup E]
    [InnerProductSpace ğ•œ E] {m : MeasurableSpace Î±} {f g : Î± â†’ E} (hf : StronglyMeasurable f)
    (hg : StronglyMeasurable g) : StronglyMeasurable fun t => @inner ğ•œ _ _ (f t) (g t) :=
  Continuous.comp_stronglyMeasurable continuous_inner (hf.prod_mk hg)
#align measure_theory.strongly_measurable.inner MeasureTheory.StronglyMeasurable.inner

end StronglyMeasurable

namespace AeStronglyMeasurable

variable {m : MeasurableSpace Î±} {Î¼ : Measure Î±} {ğ•œ : Type _} {E : Type _} [IsROrC ğ•œ]
  [NormedAddCommGroup E] [InnerProductSpace ğ•œ E]

-- mathport name: Â«exprâŸª , âŸ«Â»
local notation "âŸª" x ", " y "âŸ«" => @inner ğ•œ _ _ x y

/- warning: measure_theory.ae_strongly_measurable.re -> MeasureTheory.AEStronglyMeasurable.re is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {m : MeasurableSpace.{u1} Î±} {Î¼ : MeasureTheory.Measure.{u1} Î± m} {ğ•œ : Type.{u2}} [_inst_1 : IsROrC.{u2} ğ•œ] {f : Î± -> ğ•œ}, (MeasureTheory.AEStronglyMeasurable.{u1, u2} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u2} ğ•œ (PseudoMetricSpace.toUniformSpace.{u2} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u2} ğ•œ (SeminormedCommRing.toSemiNormedRing.{u2} ğ•œ (NormedCommRing.toSeminormedCommRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))) m f Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u1, 0} Î± Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) m (fun (x : Î±) => coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u2} ğ•œ (AddMonoidWithOne.toAddMonoid.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ğ•œ (Ring.toAddCommGroupWithOne.{u2} ğ•œ (NormedRing.toRing.{u2} ğ•œ (NormedCommRing.toNormedRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u2} ğ•œ (AddMonoidWithOne.toAddMonoid.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ğ•œ (Ring.toAddCommGroupWithOne.{u2} ğ•œ (NormedRing.toRing.{u2} ğ•œ (NormedCommRing.toNormedRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) => ğ•œ -> Real) (AddMonoidHom.hasCoeToFun.{u2, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u2} ğ•œ (AddMonoidWithOne.toAddMonoid.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ğ•œ (Ring.toAddCommGroupWithOne.{u2} ğ•œ (NormedRing.toRing.{u2} ğ•œ (NormedCommRing.toNormedRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (IsROrC.re.{u2} ğ•œ _inst_1) (f x)) Î¼)
but is expected to have type
  forall {Î± : Type.{u2}} {m : MeasurableSpace.{u2} Î±} {Î¼ : MeasureTheory.Measure.{u2} Î± m} {ğ•œ : Type.{u1}} [_inst_1 : IsROrC.{u1} ğ•œ] {f : Î± -> ğ•œ}, (MeasureTheory.AEStronglyMeasurable.{u2, u1} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1)))))))) m f Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u2, 0} Î± Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) m (fun (x : Î±) => FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) ğ•œ (fun (_x : ğ•œ) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : ğ•œ) => Real) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) ğ•œ Real (AddZeroClass.toAdd.{u1} ğ•œ (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1)))))))))))) (AddZeroClass.toAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal) (AddMonoidHom.addMonoidHomClass.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)))) (IsROrC.re.{u1} ğ•œ _inst_1) (f x)) Î¼)
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_strongly_measurable.re MeasureTheory.AEStronglyMeasurable.reâ‚“'. -/
protected theorem re {f : Î± â†’ ğ•œ} (hf : AEStronglyMeasurable f Î¼) :
    AEStronglyMeasurable (fun x => IsROrC.re (f x)) Î¼ :=
  IsROrC.continuous_re.comp_aestronglyMeasurable hf
#align measure_theory.ae_strongly_measurable.re MeasureTheory.AEStronglyMeasurable.re

/- warning: measure_theory.ae_strongly_measurable.im -> MeasureTheory.AEStronglyMeasurable.im is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {m : MeasurableSpace.{u1} Î±} {Î¼ : MeasureTheory.Measure.{u1} Î± m} {ğ•œ : Type.{u2}} [_inst_1 : IsROrC.{u2} ğ•œ] {f : Î± -> ğ•œ}, (MeasureTheory.AEStronglyMeasurable.{u1, u2} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u2} ğ•œ (PseudoMetricSpace.toUniformSpace.{u2} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u2} ğ•œ (SeminormedCommRing.toSemiNormedRing.{u2} ğ•œ (NormedCommRing.toSeminormedCommRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))) m f Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u1, 0} Î± Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) m (fun (x : Î±) => coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u2} ğ•œ (AddMonoidWithOne.toAddMonoid.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ğ•œ (Ring.toAddCommGroupWithOne.{u2} ğ•œ (NormedRing.toRing.{u2} ğ•œ (NormedCommRing.toNormedRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u2} ğ•œ (AddMonoidWithOne.toAddMonoid.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ğ•œ (Ring.toAddCommGroupWithOne.{u2} ğ•œ (NormedRing.toRing.{u2} ğ•œ (NormedCommRing.toNormedRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) => ğ•œ -> Real) (AddMonoidHom.hasCoeToFun.{u2, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u2} ğ•œ (AddMonoidWithOne.toAddMonoid.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ğ•œ (Ring.toAddCommGroupWithOne.{u2} ğ•œ (NormedRing.toRing.{u2} ğ•œ (NormedCommRing.toNormedRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (IsROrC.im.{u2} ğ•œ _inst_1) (f x)) Î¼)
but is expected to have type
  forall {Î± : Type.{u2}} {m : MeasurableSpace.{u2} Î±} {Î¼ : MeasureTheory.Measure.{u2} Î± m} {ğ•œ : Type.{u1}} [_inst_1 : IsROrC.{u1} ğ•œ] {f : Î± -> ğ•œ}, (MeasureTheory.AEStronglyMeasurable.{u2, u1} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1)))))))) m f Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u2, 0} Î± Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) m (fun (x : Î±) => FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) ğ•œ (fun (_x : ğ•œ) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : ğ•œ) => Real) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) ğ•œ Real (AddZeroClass.toAdd.{u1} ğ•œ (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1)))))))))))) (AddZeroClass.toAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal) (AddMonoidHom.addMonoidHomClass.{u1, 0} ğ•œ Real (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonUnitalSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (CommRing.toRing.{u1} ğ•œ (Field.toCommRing.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1))))))))))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)))) (IsROrC.im.{u1} ğ•œ _inst_1) (f x)) Î¼)
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_strongly_measurable.im MeasureTheory.AEStronglyMeasurable.imâ‚“'. -/
protected theorem im {f : Î± â†’ ğ•œ} (hf : AEStronglyMeasurable f Î¼) :
    AEStronglyMeasurable (fun x => IsROrC.im (f x)) Î¼ :=
  IsROrC.continuous_im.comp_aestronglyMeasurable hf
#align measure_theory.ae_strongly_measurable.im MeasureTheory.AEStronglyMeasurable.im

/- warning: measure_theory.ae_strongly_measurable.inner -> MeasureTheory.AEStronglyMeasurable.inner is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ğ•œ : Type.{u2}} {E : Type.{u3}} [_inst_1 : IsROrC.{u2} ğ•œ] [_inst_2 : NormedAddCommGroup.{u3} E] [_inst_3 : InnerProductSpace.{u2, u3} ğ•œ E _inst_1 _inst_2] {m : MeasurableSpace.{u1} Î±} {Î¼ : MeasureTheory.Measure.{u1} Î± m} {f : Î± -> E} {g : Î± -> E}, (MeasureTheory.AEStronglyMeasurable.{u1, u3} Î± E (UniformSpace.toTopologicalSpace.{u3} E (PseudoMetricSpace.toUniformSpace.{u3} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} E _inst_2)))) m f Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u1, u3} Î± E (UniformSpace.toTopologicalSpace.{u3} E (PseudoMetricSpace.toUniformSpace.{u3} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} E _inst_2)))) m g Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u1, u2} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u2} ğ•œ (PseudoMetricSpace.toUniformSpace.{u2} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u2} ğ•œ (SeminormedCommRing.toSemiNormedRing.{u2} ğ•œ (NormedCommRing.toSeminormedCommRing.{u2} ğ•œ (NormedField.toNormedCommRing.{u2} ğ•œ (DenselyNormedField.toNormedField.{u2} ğ•œ (IsROrC.toDenselyNormedField.{u2} ğ•œ _inst_1)))))))) m (fun (x : Î±) => Inner.inner.{u2, u3} ğ•œ E (InnerProductSpace.toHasInner.{u2, u3} ğ•œ E _inst_1 _inst_2 _inst_3) (f x) (g x)) Î¼)
but is expected to have type
  forall {Î± : Type.{u3}} {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : IsROrC.{u1} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : InnerProductSpace.{u1, u2} ğ•œ E _inst_1 _inst_2] {m : MeasurableSpace.{u3} Î±} {Î¼ : MeasureTheory.Measure.{u3} Î± m} {f : Î± -> E} {g : Î± -> E}, (MeasureTheory.AEStronglyMeasurable.{u3, u2} Î± E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) m f Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u3, u2} Î± E (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))) m g Î¼) -> (MeasureTheory.AEStronglyMeasurable.{u3, u1} Î± ğ•œ (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (DenselyNormedField.toNormedField.{u1} ğ•œ (IsROrC.toDenselyNormedField.{u1} ğ•œ _inst_1)))))))) m (fun (x : Î±) => Inner.inner.{u1, u2} ğ•œ E (InnerProductSpace.toInner.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3) (f x) (g x)) Î¼)
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_strongly_measurable.inner MeasureTheory.AEStronglyMeasurable.innerâ‚“'. -/
protected theorem inner {m : MeasurableSpace Î±} {Î¼ : Measure Î±} {f g : Î± â†’ E}
    (hf : AEStronglyMeasurable f Î¼) (hg : AEStronglyMeasurable g Î¼) :
    AEStronglyMeasurable (fun x => âŸªf x, g xâŸ«) Î¼ :=
  continuous_inner.comp_aestronglyMeasurable (hf.prod_mk hg)
#align measure_theory.ae_strongly_measurable.inner MeasureTheory.AEStronglyMeasurable.inner

end AeStronglyMeasurable

end MeasureTheory

