/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module topology.filter
! leanprover-community/mathlib commit b6da1a0b3e7cd83b1f744c49ce48ef8c6307d2f6
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Order.Filter.Lift
import Mathbin.Topology.Separation
import Mathbin.Data.Set.Intervals.Monotone

/-!
# Topology on the set of filters on a type

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file introduce topology on `filter Î±`. It is generated by the sets
`set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`, `s : set Î±`. A set `s : set (filter Î±)` is open if and
only if it is a union of a family of these basic open sets, see `filter.is_open_iff`.

This topology has the following important properties.

* If `X` is a topological space, then the map `ğ“ : X â†’ filter X` is a topology inducing map.

* In particular, it is a continuous map, so `ğ“ âˆ˜ f` tends to `ğ“ (ğ“ a)` whenever `f` tends to `ğ“ a`.

* If `X` is an ordered topological space with order topology and no max element, then `ğ“ âˆ˜ f` tends
  to `ğ“ filter.at_top` whenever `f` tends to `filter.at_top`.

* It turns `filter X` into a Tâ‚€ space and the order on `filter X` is the dual of the
  `specialization_order (filter X)`.

## Tags

filter, topological space
-/


open Set Filter TopologicalSpace

open Filter Topology

variable {Î¹ : Sort _} {Î± Î² X Y : Type _}

namespace Filter

/-- Topology on `filter Î±` is generated by the sets `set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`,
`s : set Î±`. A set `s : set (filter Î±)` is open if and only if it is a union of a family of these
basic open sets, see `filter.is_open_iff`. -/
instance : TopologicalSpace (Filter Î±) :=
  generateFrom <| range <| Iic âˆ˜ ğ“Ÿ

/- warning: filter.is_open_Iic_principal -> Filter.isOpen_Iic_principal is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {s : Set.{u1} Î±}, IsOpen.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (Filter.principal.{u1} Î± s))
but is expected to have type
  forall {Î± : Type.{u1}} {s : Set.{u1} Î±}, IsOpen.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (Filter.principal.{u1} Î± s))
Case conversion may be inaccurate. Consider using '#align filter.is_open_Iic_principal Filter.isOpen_Iic_principalâ‚“'. -/
theorem isOpen_Iic_principal {s : Set Î±} : IsOpen (Iic (ğ“Ÿ s)) :=
  GenerateOpen.basic _ (mem_range_self _)
#align filter.is_open_Iic_principal Filter.isOpen_Iic_principal

/- warning: filter.is_open_set_of_mem -> Filter.isOpen_setOf_mem is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {s : Set.{u1} Î±}, IsOpen.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (setOf.{u1} (Filter.{u1} Î±) (fun (l : Filter.{u1} Î±) => Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) s l))
but is expected to have type
  forall {Î± : Type.{u1}} {s : Set.{u1} Î±}, IsOpen.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (setOf.{u1} (Filter.{u1} Î±) (fun (l : Filter.{u1} Î±) => Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) s l))
Case conversion may be inaccurate. Consider using '#align filter.is_open_set_of_mem Filter.isOpen_setOf_memâ‚“'. -/
theorem isOpen_setOf_mem {s : Set Î±} : IsOpen { l : Filter Î± | s âˆˆ l } := by
  simpa only [Iic_principal] using is_open_Iic_principal
#align filter.is_open_set_of_mem Filter.isOpen_setOf_mem

/- warning: filter.is_topological_basis_Iic_principal -> Filter.isTopologicalBasis_Iic_principal is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}}, TopologicalSpace.IsTopologicalBasis.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Set.range.{u1, succ u1} (Set.{u1} (Filter.{u1} Î±)) (Set.{u1} Î±) (Function.comp.{succ u1, succ u1, succ u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (Filter.principal.{u1} Î±)))
but is expected to have type
  forall {Î± : Type.{u1}}, TopologicalSpace.IsTopologicalBasis.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Set.range.{u1, succ u1} (Set.{u1} (Filter.{u1} Î±)) (Set.{u1} Î±) (Function.comp.{succ u1, succ u1, succ u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (Filter.principal.{u1} Î±)))
Case conversion may be inaccurate. Consider using '#align filter.is_topological_basis_Iic_principal Filter.isTopologicalBasis_Iic_principalâ‚“'. -/
theorem isTopologicalBasis_Iic_principal :
    IsTopologicalBasis (range (Iic âˆ˜ ğ“Ÿ : Set Î± â†’ Set (Filter Î±))) :=
  { exists_subset_inter := by
      rintro _ âŸ¨s, rflâŸ© _ âŸ¨t, rflâŸ© l hl
      exact âŸ¨Iic (ğ“Ÿ s) âˆ© Iic (ğ“Ÿ t), âŸ¨s âˆ© t, by simpâŸ©, hl, subset.rflâŸ©
    sUnion_eq := sUnion_eq_univ_iff.2 fun l => âŸ¨Iic âŠ¤, âŸ¨univ, congr_arg Iic principal_univâŸ©, le_topâŸ©
    eq_generateFrom := rfl }
#align filter.is_topological_basis_Iic_principal Filter.isTopologicalBasis_Iic_principal

/- warning: filter.is_open_iff -> Filter.isOpen_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {s : Set.{u1} (Filter.{u1} Î±)}, Iff (IsOpen.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) s) (Exists.{succ u1} (Set.{u1} (Set.{u1} Î±)) (fun (T : Set.{u1} (Set.{u1} Î±)) => Eq.{succ u1} (Set.{u1} (Filter.{u1} Î±)) s (Set.iUnion.{u1, succ u1} (Filter.{u1} Î±) (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => Set.iUnion.{u1, 0} (Filter.{u1} Î±) (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Set.{u1} (Set.{u1} Î±)) (Set.hasMem.{u1} (Set.{u1} Î±)) t T) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} Î±) (Set.{u1} (Set.{u1} Î±)) (Set.hasMem.{u1} (Set.{u1} Î±)) t T) => Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (Filter.principal.{u1} Î± t))))))
but is expected to have type
  forall {Î± : Type.{u1}} {s : Set.{u1} (Filter.{u1} Î±)}, Iff (IsOpen.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) s) (Exists.{succ u1} (Set.{u1} (Set.{u1} Î±)) (fun (T : Set.{u1} (Set.{u1} Î±)) => Eq.{succ u1} (Set.{u1} (Filter.{u1} Î±)) s (Set.iUnion.{u1, succ u1} (Filter.{u1} Î±) (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => Set.iUnion.{u1, 0} (Filter.{u1} Î±) (Membership.mem.{u1, u1} (Set.{u1} Î±) (Set.{u1} (Set.{u1} Î±)) (Set.instMembershipSet.{u1} (Set.{u1} Î±)) t T) (fun (H : Membership.mem.{u1, u1} (Set.{u1} Î±) (Set.{u1} (Set.{u1} Î±)) (Set.instMembershipSet.{u1} (Set.{u1} Î±)) t T) => Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (Filter.principal.{u1} Î± t))))))
Case conversion may be inaccurate. Consider using '#align filter.is_open_iff Filter.isOpen_iffâ‚“'. -/
theorem isOpen_iff {s : Set (Filter Î±)} : IsOpen s â†” âˆƒ T : Set (Set Î±), s = â‹ƒ t âˆˆ T, Iic (ğ“Ÿ t) :=
  isTopologicalBasis_Iic_principal.open_iff_eq_sUnion.trans <| by
    simp only [exists_subset_range_iff, sUnion_image]
#align filter.is_open_iff Filter.isOpen_iff

/- warning: filter.nhds_eq -> Filter.nhds_eq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) l) (Filter.lift'.{u1, u1} Î± (Filter.{u1} Î±) l (Function.comp.{succ u1, succ u1, succ u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) (Filter.principal.{u1} Î±)))
but is expected to have type
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) l) (Filter.lift'.{u1, u1} Î± (Filter.{u1} Î±) l (Function.comp.{succ u1, succ u1, succ u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) (Filter.principal.{u1} Î±)))
Case conversion may be inaccurate. Consider using '#align filter.nhds_eq Filter.nhds_eqâ‚“'. -/
theorem nhds_eq (l : Filter Î±) : ğ“ l = l.lift' (Iic âˆ˜ ğ“Ÿ) :=
  nhds_generateFrom.trans <| by
    simp only [mem_set_of_eq, and_comm' (l âˆˆ _), iInf_and, iInf_range, Filter.lift', Filter.lift,
      (Â· âˆ˜ Â·), mem_Iic, le_principal_iff]
#align filter.nhds_eq Filter.nhds_eq

/- warning: filter.nhds_eq' -> Filter.nhds_eq' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) l) (Filter.lift'.{u1, u1} Î± (Filter.{u1} Î±) l (fun (s : Set.{u1} Î±) => setOf.{u1} (Filter.{u1} Î±) (fun (l' : Filter.{u1} Î±) => Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) s l')))
but is expected to have type
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) l) (Filter.lift'.{u1, u1} Î± (Filter.{u1} Î±) l (fun (s : Set.{u1} Î±) => setOf.{u1} (Filter.{u1} Î±) (fun (l' : Filter.{u1} Î±) => Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) s l')))
Case conversion may be inaccurate. Consider using '#align filter.nhds_eq' Filter.nhds_eq'â‚“'. -/
theorem nhds_eq' (l : Filter Î±) : ğ“ l = l.lift' fun s => { l' | s âˆˆ l' } := by
  simpa only [(Â· âˆ˜ Â·), Iic_principal] using nhds_eq l
#align filter.nhds_eq' Filter.nhds_eq'

/- warning: filter.tendsto_nhds -> Filter.tendsto_nhds is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {la : Filter.{u1} Î±} {lb : Filter.{u2} Î²} {f : Î± -> (Filter.{u2} Î²)}, Iff (Filter.Tendsto.{u1, u2} Î± (Filter.{u2} Î²) f la (nhds.{u2} (Filter.{u2} Î²) (Filter.topologicalSpace.{u2} Î²) lb)) (forall (s : Set.{u2} Î²), (Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) s lb) -> (Filter.Eventually.{u1} Î± (fun (a : Î±) => Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) s (f a)) la))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {la : Filter.{u2} Î±} {lb : Filter.{u1} Î²} {f : Î± -> (Filter.{u1} Î²)}, Iff (Filter.Tendsto.{u2, u1} Î± (Filter.{u1} Î²) f la (nhds.{u1} (Filter.{u1} Î²) (Filter.instTopologicalSpaceFilter.{u1} Î²) lb)) (forall (s : Set.{u1} Î²), (Membership.mem.{u1, u1} (Set.{u1} Î²) (Filter.{u1} Î²) (instMembershipSetFilter.{u1} Î²) s lb) -> (Filter.Eventually.{u2} Î± (fun (a : Î±) => Membership.mem.{u1, u1} (Set.{u1} Î²) (Filter.{u1} Î²) (instMembershipSetFilter.{u1} Î²) s (f a)) la))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_nhds Filter.tendsto_nhdsâ‚“'. -/
protected theorem tendsto_nhds {la : Filter Î±} {lb : Filter Î²} {f : Î± â†’ Filter Î²} :
    Tendsto f la (ğ“ lb) â†” âˆ€ s âˆˆ lb, âˆ€á¶  a in la, s âˆˆ f a := by
  simp only [nhds_eq', tendsto_lift', mem_set_of_eq]
#align filter.tendsto_nhds Filter.tendsto_nhds

/- warning: filter.has_basis.nhds -> Filter.HasBasis.nhds is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Sort.{u1}} {Î± : Type.{u2}} {l : Filter.{u2} Î±} {p : Î¹ -> Prop} {s : Î¹ -> (Set.{u2} Î±)}, (Filter.HasBasis.{u2, u1} Î± Î¹ l p s) -> (Filter.HasBasis.{u2, u1} (Filter.{u2} Î±) Î¹ (nhds.{u2} (Filter.{u2} Î±) (Filter.topologicalSpace.{u2} Î±) l) p (fun (i : Î¹) => Set.Iic.{u2} (Filter.{u2} Î±) (PartialOrder.toPreorder.{u2} (Filter.{u2} Î±) (Filter.partialOrder.{u2} Î±)) (Filter.principal.{u2} Î± (s i))))
but is expected to have type
  forall {Î¹ : Sort.{u1}} {Î± : Type.{u2}} {l : Filter.{u2} Î±} {p : Î¹ -> Prop} {s : Î¹ -> (Set.{u2} Î±)}, (Filter.HasBasis.{u2, u1} Î± Î¹ l p s) -> (Filter.HasBasis.{u2, u1} (Filter.{u2} Î±) Î¹ (nhds.{u2} (Filter.{u2} Î±) (Filter.instTopologicalSpaceFilter.{u2} Î±) l) p (fun (i : Î¹) => Set.Iic.{u2} (Filter.{u2} Î±) (PartialOrder.toPreorder.{u2} (Filter.{u2} Î±) (Filter.instPartialOrderFilter.{u2} Î±)) (Filter.principal.{u2} Î± (s i))))
Case conversion may be inaccurate. Consider using '#align filter.has_basis.nhds Filter.HasBasis.nhdsâ‚“'. -/
theorem HasBasis.nhds {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :
    HasBasis (ğ“ l) p fun i => Iic (ğ“Ÿ (s i)) :=
  by
  rw [nhds_eq]
  exact h.lift' monotone_principal.Iic
#align filter.has_basis.nhds Filter.HasBasis.nhds

/-- Neighborhoods of a countably generated filter is a countably generated filter. -/
instance {l : Filter Î±} [IsCountablyGenerated l] : IsCountablyGenerated (ğ“ l) :=
  let âŸ¨b, hbâŸ© := l.exists_antitone_basis
  HasCountableBasis.isCountablyGenerated <| âŸ¨hb.nhds, Set.to_countable _âŸ©

/- warning: filter.has_basis.nhds' -> Filter.HasBasis.nhds' is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Sort.{u1}} {Î± : Type.{u2}} {l : Filter.{u2} Î±} {p : Î¹ -> Prop} {s : Î¹ -> (Set.{u2} Î±)}, (Filter.HasBasis.{u2, u1} Î± Î¹ l p s) -> (Filter.HasBasis.{u2, u1} (Filter.{u2} Î±) Î¹ (nhds.{u2} (Filter.{u2} Î±) (Filter.topologicalSpace.{u2} Î±) l) p (fun (i : Î¹) => setOf.{u2} (Filter.{u2} Î±) (fun (l' : Filter.{u2} Î±) => Membership.Mem.{u2, u2} (Set.{u2} Î±) (Filter.{u2} Î±) (Filter.hasMem.{u2} Î±) (s i) l')))
but is expected to have type
  forall {Î¹ : Sort.{u1}} {Î± : Type.{u2}} {l : Filter.{u2} Î±} {p : Î¹ -> Prop} {s : Î¹ -> (Set.{u2} Î±)}, (Filter.HasBasis.{u2, u1} Î± Î¹ l p s) -> (Filter.HasBasis.{u2, u1} (Filter.{u2} Î±) Î¹ (nhds.{u2} (Filter.{u2} Î±) (Filter.instTopologicalSpaceFilter.{u2} Î±) l) p (fun (i : Î¹) => setOf.{u2} (Filter.{u2} Î±) (fun (l' : Filter.{u2} Î±) => Membership.mem.{u2, u2} (Set.{u2} Î±) (Filter.{u2} Î±) (instMembershipSetFilter.{u2} Î±) (s i) l')))
Case conversion may be inaccurate. Consider using '#align filter.has_basis.nhds' Filter.HasBasis.nhds'â‚“'. -/
theorem HasBasis.nhds' {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :
    HasBasis (ğ“ l) p fun i => { l' | s i âˆˆ l' } := by simpa only [Iic_principal] using h.nhds
#align filter.has_basis.nhds' Filter.HasBasis.nhds'

/- warning: filter.mem_nhds_iff -> Filter.mem_nhds_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {l : Filter.{u1} Î±} {S : Set.{u1} (Filter.{u1} Î±)}, Iff (Membership.Mem.{u1, u1} (Set.{u1} (Filter.{u1} Î±)) (Filter.{u1} (Filter.{u1} Î±)) (Filter.hasMem.{u1} (Filter.{u1} Î±)) S (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) l)) (Exists.{succ u1} (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l) => HasSubset.Subset.{u1} (Set.{u1} (Filter.{u1} Î±)) (Set.hasSubset.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (Filter.principal.{u1} Î± t)) S)))
but is expected to have type
  forall {Î± : Type.{u1}} {l : Filter.{u1} Î±} {S : Set.{u1} (Filter.{u1} Î±)}, Iff (Membership.mem.{u1, u1} (Set.{u1} (Filter.{u1} Î±)) (Filter.{u1} (Filter.{u1} Î±)) (instMembershipSetFilter.{u1} (Filter.{u1} Î±)) S (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) l)) (Exists.{succ u1} (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => And (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) t l) (HasSubset.Subset.{u1} (Set.{u1} (Filter.{u1} Î±)) (Set.instHasSubsetSet.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (Filter.principal.{u1} Î± t)) S)))
Case conversion may be inaccurate. Consider using '#align filter.mem_nhds_iff Filter.mem_nhds_iffâ‚“'. -/
theorem mem_nhds_iff {l : Filter Î±} {S : Set (Filter Î±)} : S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† S :=
  l.basis_sets.nhds.mem_iff
#align filter.mem_nhds_iff Filter.mem_nhds_iff

/- warning: filter.mem_nhds_iff' -> Filter.mem_nhds_iff' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {l : Filter.{u1} Î±} {S : Set.{u1} (Filter.{u1} Î±)}, Iff (Membership.Mem.{u1, u1} (Set.{u1} (Filter.{u1} Î±)) (Filter.{u1} (Filter.{u1} Î±)) (Filter.hasMem.{u1} (Filter.{u1} Î±)) S (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) l)) (Exists.{succ u1} (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l) => forall {{l' : Filter.{u1} Î±}}, (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l') -> (Membership.Mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasMem.{u1} (Filter.{u1} Î±)) l' S))))
but is expected to have type
  forall {Î± : Type.{u1}} {l : Filter.{u1} Î±} {S : Set.{u1} (Filter.{u1} Î±)}, Iff (Membership.mem.{u1, u1} (Set.{u1} (Filter.{u1} Î±)) (Filter.{u1} (Filter.{u1} Î±)) (instMembershipSetFilter.{u1} (Filter.{u1} Î±)) S (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) l)) (Exists.{succ u1} (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => And (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) t l) (forall {{l' : Filter.{u1} Î±}}, (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) t l') -> (Membership.mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.instMembershipSet.{u1} (Filter.{u1} Î±)) l' S))))
Case conversion may be inaccurate. Consider using '#align filter.mem_nhds_iff' Filter.mem_nhds_iff'â‚“'. -/
theorem mem_nhds_iff' {l : Filter Î±} {S : Set (Filter Î±)} :
    S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, âˆ€ â¦ƒl' : Filter Î±â¦„, t âˆˆ l' â†’ l' âˆˆ S :=
  l.basis_sets.nhds'.mem_iff
#align filter.mem_nhds_iff' Filter.mem_nhds_iff'

/- warning: filter.nhds_bot -> Filter.nhds_bot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}}, Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Bot.bot.{u1} (Filter.{u1} Î±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±)))) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} (Filter.{u1} Î±) (Bot.bot.{u1} (Filter.{u1} Î±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))))
but is expected to have type
  forall {Î± : Type.{u1}}, Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Bot.bot.{u1} (Filter.{u1} Î±) (CompleteLattice.toBot.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±)))) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} (Filter.{u1} Î±) (Bot.bot.{u1} (Filter.{u1} Î±) (CompleteLattice.toBot.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))))
Case conversion may be inaccurate. Consider using '#align filter.nhds_bot Filter.nhds_botâ‚“'. -/
@[simp]
theorem nhds_bot : ğ“ (âŠ¥ : Filter Î±) = pure âŠ¥ := by simp [nhds_eq, lift'_bot monotone_principal.Iic]
#align filter.nhds_bot Filter.nhds_bot

/- warning: filter.nhds_top -> Filter.nhds_top is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}}, Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Top.top.{u1} (Filter.{u1} Î±) (Filter.hasTop.{u1} Î±))) (Top.top.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.hasTop.{u1} (Filter.{u1} Î±)))
but is expected to have type
  forall {Î± : Type.{u1}}, Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Top.top.{u1} (Filter.{u1} Î±) (Filter.instTopFilter.{u1} Î±))) (Top.top.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.instTopFilter.{u1} (Filter.{u1} Î±)))
Case conversion may be inaccurate. Consider using '#align filter.nhds_top Filter.nhds_topâ‚“'. -/
@[simp]
theorem nhds_top : ğ“ (âŠ¤ : Filter Î±) = âŠ¤ := by simp [nhds_eq]
#align filter.nhds_top Filter.nhds_top

/- warning: filter.nhds_principal -> Filter.nhds_principal is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} (s : Set.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Filter.principal.{u1} Î± s)) (Filter.principal.{u1} (Filter.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (Filter.principal.{u1} Î± s)))
but is expected to have type
  forall {Î± : Type.{u1}} (s : Set.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Filter.principal.{u1} Î± s)) (Filter.principal.{u1} (Filter.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (Filter.principal.{u1} Î± s)))
Case conversion may be inaccurate. Consider using '#align filter.nhds_principal Filter.nhds_principalâ‚“'. -/
@[simp]
theorem nhds_principal (s : Set Î±) : ğ“ (ğ“Ÿ s) = ğ“Ÿ (Iic (ğ“Ÿ s)) :=
  (hasBasis_principal s).nhds.eq_of_same_basis (hasBasis_principal _)
#align filter.nhds_principal Filter.nhds_principal

/- warning: filter.nhds_pure -> Filter.nhds_pure is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} (x : Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Î± x)) (Filter.principal.{u1} (Filter.{u1} Î±) (Insert.insert.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasInsert.{u1} (Filter.{u1} Î±)) (Bot.bot.{u1} (Filter.{u1} Î±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))) (Singleton.singleton.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasSingleton.{u1} (Filter.{u1} Î±)) (Pure.pure.{u1, u1} Filter.{u1} Filter.hasPure.{u1} Î± x))))
but is expected to have type
  forall {Î± : Type.{u1}} (x : Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î± x)) (Filter.principal.{u1} (Filter.{u1} Î±) (Insert.insert.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.instInsertSet.{u1} (Filter.{u1} Î±)) (Bot.bot.{u1} (Filter.{u1} Î±) (CompleteLattice.toBot.{u1} (Filter.{u1} Î±) (Filter.instCompleteLatticeFilter.{u1} Î±))) (Singleton.singleton.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.instSingletonSet.{u1} (Filter.{u1} Î±)) (Pure.pure.{u1, u1} Filter.{u1} Filter.instPureFilter.{u1} Î± x))))
Case conversion may be inaccurate. Consider using '#align filter.nhds_pure Filter.nhds_pureâ‚“'. -/
@[simp]
theorem nhds_pure (x : Î±) : ğ“ (pure x : Filter Î±) = ğ“Ÿ {âŠ¥, pure x} := by
  rw [â† principal_singleton, nhds_principal, principal_singleton, Iic_pure]
#align filter.nhds_pure Filter.nhds_pure

/- warning: filter.nhds_infi -> Filter.nhds_iInf is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Sort.{u1}} {Î± : Type.{u2}} (f : Î¹ -> (Filter.{u2} Î±)), Eq.{succ u2} (Filter.{u2} (Filter.{u2} Î±)) (nhds.{u2} (Filter.{u2} Î±) (Filter.topologicalSpace.{u2} Î±) (iInf.{u2, u1} (Filter.{u2} Î±) (ConditionallyCompleteLattice.toHasInf.{u2} (Filter.{u2} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Î±) (Filter.completeLattice.{u2} Î±))) Î¹ (fun (i : Î¹) => f i))) (iInf.{u2, u1} (Filter.{u2} (Filter.{u2} Î±)) (ConditionallyCompleteLattice.toHasInf.{u2} (Filter.{u2} (Filter.{u2} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} (Filter.{u2} Î±)) (Filter.completeLattice.{u2} (Filter.{u2} Î±)))) Î¹ (fun (i : Î¹) => nhds.{u2} (Filter.{u2} Î±) (Filter.topologicalSpace.{u2} Î±) (f i)))
but is expected to have type
  forall {Î¹ : Sort.{u1}} {Î± : Type.{u2}} (f : Î¹ -> (Filter.{u2} Î±)), Eq.{succ u2} (Filter.{u2} (Filter.{u2} Î±)) (nhds.{u2} (Filter.{u2} Î±) (Filter.instTopologicalSpaceFilter.{u2} Î±) (iInf.{u2, u1} (Filter.{u2} Î±) (ConditionallyCompleteLattice.toInfSet.{u2} (Filter.{u2} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Î±) (Filter.instCompleteLatticeFilter.{u2} Î±))) Î¹ (fun (i : Î¹) => f i))) (iInf.{u2, u1} (Filter.{u2} (Filter.{u2} Î±)) (ConditionallyCompleteLattice.toInfSet.{u2} (Filter.{u2} (Filter.{u2} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} (Filter.{u2} Î±)) (Filter.instCompleteLatticeFilter.{u2} (Filter.{u2} Î±)))) Î¹ (fun (i : Î¹) => nhds.{u2} (Filter.{u2} Î±) (Filter.instTopologicalSpaceFilter.{u2} Î±) (f i)))
Case conversion may be inaccurate. Consider using '#align filter.nhds_infi Filter.nhds_iInfâ‚“'. -/
@[simp]
theorem nhds_iInf (f : Î¹ â†’ Filter Î±) : ğ“ (â¨… i, f i) = â¨… i, ğ“ (f i) :=
  by
  simp only [nhds_eq]
  apply lift'_infi_of_map_univ <;> simp
#align filter.nhds_infi Filter.nhds_iInf

/- warning: filter.nhds_inf -> Filter.nhds_inf is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} (lâ‚ : Filter.{u1} Î±) (lâ‚‚ : Filter.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Inf.inf.{u1} (Filter.{u1} Î±) (Filter.hasInf.{u1} Î±) lâ‚ lâ‚‚)) (Inf.inf.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.hasInf.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) lâ‚) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) lâ‚‚))
but is expected to have type
  forall {Î± : Type.{u1}} (lâ‚ : Filter.{u1} Î±) (lâ‚‚ : Filter.{u1} Î±), Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Inf.inf.{u1} (Filter.{u1} Î±) (Filter.instInfFilter.{u1} Î±) lâ‚ lâ‚‚)) (Inf.inf.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.instInfFilter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) lâ‚) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) lâ‚‚))
Case conversion may be inaccurate. Consider using '#align filter.nhds_inf Filter.nhds_infâ‚“'. -/
@[simp]
theorem nhds_inf (lâ‚ lâ‚‚ : Filter Î±) : ğ“ (lâ‚ âŠ“ lâ‚‚) = ğ“ lâ‚ âŠ“ ğ“ lâ‚‚ := by
  simpa only [iInf_bool_eq] using nhds_iInf fun b => cond b lâ‚ lâ‚‚
#align filter.nhds_inf Filter.nhds_inf

/- warning: filter.monotone_nhds -> Filter.monotone_nhds is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}}, Monotone.{u1, u1} (Filter.{u1} Î±) (Filter.{u1} (Filter.{u1} Î±)) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (PartialOrder.toPreorder.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.partialOrder.{u1} (Filter.{u1} Î±))) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±))
but is expected to have type
  forall {Î± : Type.{u1}}, Monotone.{u1, u1} (Filter.{u1} Î±) (Filter.{u1} (Filter.{u1} Î±)) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (PartialOrder.toPreorder.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.instPartialOrderFilter.{u1} (Filter.{u1} Î±))) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±))
Case conversion may be inaccurate. Consider using '#align filter.monotone_nhds Filter.monotone_nhdsâ‚“'. -/
theorem monotone_nhds : Monotone (ğ“ : Filter Î± â†’ Filter (Filter Î±)) :=
  Monotone.of_map_inf nhds_inf
#align filter.monotone_nhds Filter.monotone_nhds

/- warning: filter.Inter_nhds -> Filter.sInter_nhds is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Set.{u1} (Filter.{u1} Î±)) (Set.sInter.{u1} (Filter.{u1} Î±) (setOf.{u1} (Set.{u1} (Filter.{u1} Î±)) (fun (s : Set.{u1} (Filter.{u1} Î±)) => Membership.Mem.{u1, u1} (Set.{u1} (Filter.{u1} Î±)) (Filter.{u1} (Filter.{u1} Î±)) (Filter.hasMem.{u1} (Filter.{u1} Î±)) s (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) l)))) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) l)
but is expected to have type
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Set.{u1} (Filter.{u1} Î±)) (Set.sInter.{u1} (Filter.{u1} Î±) (setOf.{u1} (Set.{u1} (Filter.{u1} Î±)) (fun (s : Set.{u1} (Filter.{u1} Î±)) => Membership.mem.{u1, u1} (Set.{u1} (Filter.{u1} Î±)) (Filter.{u1} (Filter.{u1} Î±)) (instMembershipSetFilter.{u1} (Filter.{u1} Î±)) s (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) l)))) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) l)
Case conversion may be inaccurate. Consider using '#align filter.Inter_nhds Filter.sInter_nhdsâ‚“'. -/
theorem sInter_nhds (l : Filter Î±) : â‹‚â‚€ { s | s âˆˆ ğ“ l } = Iic l := by
  simp only [nhds_eq, sInter_lift'_sets monotone_principal.Iic, Iic, le_principal_iff, â†
    set_of_forall, â† Filter.le_def]
#align filter.Inter_nhds Filter.sInter_nhds

/- warning: filter.nhds_mono -> Filter.nhds_mono is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {lâ‚ : Filter.{u1} Î±} {lâ‚‚ : Filter.{u1} Î±}, Iff (LE.le.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Preorder.toLE.{u1} (Filter.{u1} (Filter.{u1} Î±)) (PartialOrder.toPreorder.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.partialOrder.{u1} (Filter.{u1} Î±)))) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) lâ‚) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) lâ‚‚)) (LE.le.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) lâ‚ lâ‚‚)
but is expected to have type
  forall {Î± : Type.{u1}} {lâ‚ : Filter.{u1} Î±} {lâ‚‚ : Filter.{u1} Î±}, Iff (LE.le.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Preorder.toLE.{u1} (Filter.{u1} (Filter.{u1} Î±)) (PartialOrder.toPreorder.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.instPartialOrderFilter.{u1} (Filter.{u1} Î±)))) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) lâ‚) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) lâ‚‚)) (LE.le.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) lâ‚ lâ‚‚)
Case conversion may be inaccurate. Consider using '#align filter.nhds_mono Filter.nhds_monoâ‚“'. -/
@[simp]
theorem nhds_mono {lâ‚ lâ‚‚ : Filter Î±} : ğ“ lâ‚ â‰¤ ğ“ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ :=
  by
  refine' âŸ¨fun h => _, fun h => monotone_nhds hâŸ©
  rw [â† Iic_subset_Iic, â† Inter_nhds, â† Inter_nhds]
  exact sInter_subset_sInter h
#align filter.nhds_mono Filter.nhds_mono

/- warning: filter.mem_interior -> Filter.mem_interior is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {s : Set.{u1} (Filter.{u1} Î±)} {l : Filter.{u1} Î±}, Iff (Membership.Mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasMem.{u1} (Filter.{u1} Î±)) l (interior.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) s)) (Exists.{succ u1} (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l) => HasSubset.Subset.{u1} (Set.{u1} (Filter.{u1} Î±)) (Set.hasSubset.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (Filter.principal.{u1} Î± t)) s)))
but is expected to have type
  forall {Î± : Type.{u1}} {s : Set.{u1} (Filter.{u1} Î±)} {l : Filter.{u1} Î±}, Iff (Membership.mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.instMembershipSet.{u1} (Filter.{u1} Î±)) l (interior.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) s)) (Exists.{succ u1} (Set.{u1} Î±) (fun (t : Set.{u1} Î±) => And (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) t l) (HasSubset.Subset.{u1} (Set.{u1} (Filter.{u1} Î±)) (Set.instHasSubsetSet.{u1} (Filter.{u1} Î±)) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (Filter.principal.{u1} Î± t)) s)))
Case conversion may be inaccurate. Consider using '#align filter.mem_interior Filter.mem_interiorâ‚“'. -/
protected theorem mem_interior {s : Set (Filter Î±)} {l : Filter Î±} :
    l âˆˆ interior s â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† s := by rw [mem_interior_iff_mem_nhds, mem_nhds_iff]
#align filter.mem_interior Filter.mem_interior

/- warning: filter.mem_closure -> Filter.mem_closure is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {s : Set.{u1} (Filter.{u1} Î±)} {l : Filter.{u1} Î±}, Iff (Membership.Mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasMem.{u1} (Filter.{u1} Î±)) l (closure.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) s)) (forall (t : Set.{u1} Î±), (Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l) -> (Exists.{succ u1} (Filter.{u1} Î±) (fun (l' : Filter.{u1} Î±) => Exists.{0} (Membership.Mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasMem.{u1} (Filter.{u1} Î±)) l' s) (fun (H : Membership.Mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasMem.{u1} (Filter.{u1} Î±)) l' s) => Membership.Mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (Filter.hasMem.{u1} Î±) t l'))))
but is expected to have type
  forall {Î± : Type.{u1}} {s : Set.{u1} (Filter.{u1} Î±)} {l : Filter.{u1} Î±}, Iff (Membership.mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.instMembershipSet.{u1} (Filter.{u1} Î±)) l (closure.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) s)) (forall (t : Set.{u1} Î±), (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) t l) -> (Exists.{succ u1} (Filter.{u1} Î±) (fun (l' : Filter.{u1} Î±) => And (Membership.mem.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.instMembershipSet.{u1} (Filter.{u1} Î±)) l' s) (Membership.mem.{u1, u1} (Set.{u1} Î±) (Filter.{u1} Î±) (instMembershipSetFilter.{u1} Î±) t l'))))
Case conversion may be inaccurate. Consider using '#align filter.mem_closure Filter.mem_closureâ‚“'. -/
protected theorem mem_closure {s : Set (Filter Î±)} {l : Filter Î±} :
    l âˆˆ closure s â†” âˆ€ t âˆˆ l, âˆƒ l' âˆˆ s, t âˆˆ l' := by
  simp only [closure_eq_compl_interior_compl, Filter.mem_interior, mem_compl_iff, not_exists,
    not_forall, Classical.not_not, exists_prop, not_and, and_comm', subset_def, mem_Iic,
    le_principal_iff]
#align filter.mem_closure Filter.mem_closure

/- warning: filter.closure_singleton -> Filter.closure_singleton is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Set.{u1} (Filter.{u1} Î±)) (closure.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Singleton.singleton.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.hasSingleton.{u1} (Filter.{u1} Î±)) l)) (Set.Ici.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) l)
but is expected to have type
  forall {Î± : Type.{u1}} (l : Filter.{u1} Î±), Eq.{succ u1} (Set.{u1} (Filter.{u1} Î±)) (closure.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Singleton.singleton.{u1, u1} (Filter.{u1} Î±) (Set.{u1} (Filter.{u1} Î±)) (Set.instSingletonSet.{u1} (Filter.{u1} Î±)) l)) (Set.Ici.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) l)
Case conversion may be inaccurate. Consider using '#align filter.closure_singleton Filter.closure_singletonâ‚“'. -/
@[simp]
protected theorem closure_singleton (l : Filter Î±) : closure {l} = Ici l :=
  by
  ext l'
  simp [Filter.mem_closure, Filter.le_def]
#align filter.closure_singleton Filter.closure_singleton

/- warning: filter.specializes_iff_le -> Filter.specializes_iff_le is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {lâ‚ : Filter.{u1} Î±} {lâ‚‚ : Filter.{u1} Î±}, Iff (Specializes.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) lâ‚ lâ‚‚) (LE.le.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) lâ‚ lâ‚‚)
but is expected to have type
  forall {Î± : Type.{u1}} {lâ‚ : Filter.{u1} Î±} {lâ‚‚ : Filter.{u1} Î±}, Iff (Specializes.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) lâ‚ lâ‚‚) (LE.le.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±))) lâ‚ lâ‚‚)
Case conversion may be inaccurate. Consider using '#align filter.specializes_iff_le Filter.specializes_iff_leâ‚“'. -/
@[simp]
theorem specializes_iff_le {lâ‚ lâ‚‚ : Filter Î±} : lâ‚ â¤³ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ := by
  simp only [specializes_iff_closure_subset, Filter.closure_singleton, Ici_subset_Ici]
#align filter.specializes_iff_le Filter.specializes_iff_le

instance : T0Space (Filter Î±) :=
  âŸ¨fun x y h =>
    (specializes_iff_le.1 h.Specializes).antisymm (specializes_iff_le.1 h.symm.Specializes)âŸ©

/- warning: filter.nhds_at_top -> Filter.nhds_atTop is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Filter.atTop.{u1} Î± _inst_1)) (iInf.{u1, succ u1} (Filter.{u1} (Filter.{u1} Î±)) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} (Filter.{u1} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.completeLattice.{u1} (Filter.{u1} Î±)))) Î± (fun (x : Î±) => Filter.principal.{u1} (Filter.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (Filter.principal.{u1} Î± (Set.Ici.{u1} Î± _inst_1 x)))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Filter.atTop.{u1} Î± _inst_1)) (iInf.{u1, succ u1} (Filter.{u1} (Filter.{u1} Î±)) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} (Filter.{u1} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.instCompleteLatticeFilter.{u1} (Filter.{u1} Î±)))) Î± (fun (x : Î±) => Filter.principal.{u1} (Filter.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (Filter.principal.{u1} Î± (Set.Ici.{u1} Î± _inst_1 x)))))
Case conversion may be inaccurate. Consider using '#align filter.nhds_at_top Filter.nhds_atTopâ‚“'. -/
theorem nhds_atTop [Preorder Î±] : ğ“ atTop = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Ici x))) := by
  simp only [at_top, nhds_iInf, nhds_principal]
#align filter.nhds_at_top Filter.nhds_atTop

/- warning: filter.tendsto_nhds_at_top_iff -> Filter.tendsto_nhds_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> (Filter.{u2} Î²)}, Iff (Filter.Tendsto.{u1, u2} Î± (Filter.{u2} Î²) f l (nhds.{u2} (Filter.{u2} Î²) (Filter.topologicalSpace.{u2} Î²) (Filter.atTop.{u2} Î² _inst_1))) (forall (y : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) (Set.Ici.{u2} Î² _inst_1 y) (f a)) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> (Filter.{u2} Î²)}, Iff (Filter.Tendsto.{u1, u2} Î± (Filter.{u2} Î²) f l (nhds.{u2} (Filter.{u2} Î²) (Filter.instTopologicalSpaceFilter.{u2} Î²) (Filter.atTop.{u2} Î² _inst_1))) (forall (y : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => Membership.mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (instMembershipSetFilter.{u2} Î²) (Set.Ici.{u2} Î² _inst_1 y) (f a)) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_nhds_at_top_iff Filter.tendsto_nhds_atTop_iffâ‚“'. -/
protected theorem tendsto_nhds_atTop_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :
    Tendsto f l (ğ“ atTop) â†” âˆ€ y, âˆ€á¶  a in l, Ici y âˆˆ f a := by
  simp only [nhds_at_top, tendsto_infi, tendsto_principal, mem_Iic, le_principal_iff]
#align filter.tendsto_nhds_at_top_iff Filter.tendsto_nhds_atTop_iff

/- warning: filter.nhds_at_bot -> Filter.nhds_atBot is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.topologicalSpace.{u1} Î±) (Filter.atBot.{u1} Î± _inst_1)) (iInf.{u1, succ u1} (Filter.{u1} (Filter.{u1} Î±)) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} (Filter.{u1} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.completeLattice.{u1} (Filter.{u1} Î±)))) Î± (fun (x : Î±) => Filter.principal.{u1} (Filter.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±)) (Filter.principal.{u1} Î± (Set.Iic.{u1} Î± _inst_1 x)))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : Preorder.{u1} Î±], Eq.{succ u1} (Filter.{u1} (Filter.{u1} Î±)) (nhds.{u1} (Filter.{u1} Î±) (Filter.instTopologicalSpaceFilter.{u1} Î±) (Filter.atBot.{u1} Î± _inst_1)) (iInf.{u1, succ u1} (Filter.{u1} (Filter.{u1} Î±)) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} (Filter.{u1} Î±)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} Î±)) (Filter.instCompleteLatticeFilter.{u1} (Filter.{u1} Î±)))) Î± (fun (x : Î±) => Filter.principal.{u1} (Filter.{u1} Î±) (Set.Iic.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.instPartialOrderFilter.{u1} Î±)) (Filter.principal.{u1} Î± (Set.Iic.{u1} Î± _inst_1 x)))))
Case conversion may be inaccurate. Consider using '#align filter.nhds_at_bot Filter.nhds_atBotâ‚“'. -/
theorem nhds_atBot [Preorder Î±] : ğ“ atBot = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Iic x))) :=
  @nhds_atTop Î±áµ’áµˆ _
#align filter.nhds_at_bot Filter.nhds_atBot

/- warning: filter.tendsto_nhds_at_bot_iff -> Filter.tendsto_nhds_atBot_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> (Filter.{u2} Î²)}, Iff (Filter.Tendsto.{u1, u2} Î± (Filter.{u2} Î²) f l (nhds.{u2} (Filter.{u2} Î²) (Filter.topologicalSpace.{u2} Î²) (Filter.atBot.{u2} Î² _inst_1))) (forall (y : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => Membership.Mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (Filter.hasMem.{u2} Î²) (Set.Iic.{u2} Î² _inst_1 y) (f a)) l)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : Preorder.{u2} Î²] {l : Filter.{u1} Î±} {f : Î± -> (Filter.{u2} Î²)}, Iff (Filter.Tendsto.{u1, u2} Î± (Filter.{u2} Î²) f l (nhds.{u2} (Filter.{u2} Î²) (Filter.instTopologicalSpaceFilter.{u2} Î²) (Filter.atBot.{u2} Î² _inst_1))) (forall (y : Î²), Filter.Eventually.{u1} Î± (fun (a : Î±) => Membership.mem.{u2, u2} (Set.{u2} Î²) (Filter.{u2} Î²) (instMembershipSetFilter.{u2} Î²) (Set.Iic.{u2} Î² _inst_1 y) (f a)) l)
Case conversion may be inaccurate. Consider using '#align filter.tendsto_nhds_at_bot_iff Filter.tendsto_nhds_atBot_iffâ‚“'. -/
protected theorem tendsto_nhds_atBot_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :
    Tendsto f l (ğ“ atBot) â†” âˆ€ y, âˆ€á¶  a in l, Iic y âˆˆ f a :=
  @Filter.tendsto_nhds_atTop_iff Î± Î²áµ’áµˆ _ _ _
#align filter.tendsto_nhds_at_bot_iff Filter.tendsto_nhds_atBot_iff

variable [TopologicalSpace X]

/- warning: filter.nhds_nhds -> Filter.nhds_nhds is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (x : X), Eq.{succ u1} (Filter.{u1} (Filter.{u1} X)) (nhds.{u1} (Filter.{u1} X) (Filter.topologicalSpace.{u1} X) (nhds.{u1} X _inst_1 x)) (iInf.{u1, succ u1} (Filter.{u1} (Filter.{u1} X)) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} (Filter.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} X)) (Filter.completeLattice.{u1} (Filter.{u1} X)))) (Set.{u1} X) (fun (s : Set.{u1} X) => iInf.{u1, 0} (Filter.{u1} (Filter.{u1} X)) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} (Filter.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} X)) (Filter.completeLattice.{u1} (Filter.{u1} X)))) (IsOpen.{u1} X _inst_1 s) (fun (hs : IsOpen.{u1} X _inst_1 s) => iInf.{u1, 0} (Filter.{u1} (Filter.{u1} X)) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} (Filter.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} X)) (Filter.completeLattice.{u1} (Filter.{u1} X)))) (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) (fun (hx : Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) => Filter.principal.{u1} (Filter.{u1} X) (Set.Iic.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X)) (Filter.principal.{u1} X s))))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (x : X), Eq.{succ u1} (Filter.{u1} (Filter.{u1} X)) (nhds.{u1} (Filter.{u1} X) (Filter.instTopologicalSpaceFilter.{u1} X) (nhds.{u1} X _inst_1 x)) (iInf.{u1, succ u1} (Filter.{u1} (Filter.{u1} X)) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} (Filter.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} X)) (Filter.instCompleteLatticeFilter.{u1} (Filter.{u1} X)))) (Set.{u1} X) (fun (s : Set.{u1} X) => iInf.{u1, 0} (Filter.{u1} (Filter.{u1} X)) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} (Filter.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} X)) (Filter.instCompleteLatticeFilter.{u1} (Filter.{u1} X)))) (IsOpen.{u1} X _inst_1 s) (fun (hs : IsOpen.{u1} X _inst_1 s) => iInf.{u1, 0} (Filter.{u1} (Filter.{u1} X)) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} (Filter.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} (Filter.{u1} X)) (Filter.instCompleteLatticeFilter.{u1} (Filter.{u1} X)))) (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) x s) (fun (hx : Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) x s) => Filter.principal.{u1} (Filter.{u1} X) (Set.Iic.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X)) (Filter.principal.{u1} X s))))))
Case conversion may be inaccurate. Consider using '#align filter.nhds_nhds Filter.nhds_nhdsâ‚“'. -/
theorem nhds_nhds (x : X) : ğ“ (ğ“ x) = â¨… (s : Set X) (hs : IsOpen s) (hx : x âˆˆ s), ğ“Ÿ (Iic (ğ“Ÿ s)) :=
  by simp only [(nhds_basis_opens x).nhds.eq_biInf, iInf_and, @iInf_comm _ (_ âˆˆ _)]
#align filter.nhds_nhds Filter.nhds_nhds

/- warning: filter.inducing_nhds -> Filter.inducing_nhds is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X], Inducing.{u1, u1} X (Filter.{u1} X) _inst_1 (Filter.topologicalSpace.{u1} X) (nhds.{u1} X _inst_1)
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X], Inducing.{u1, u1} X (Filter.{u1} X) _inst_1 (Filter.instTopologicalSpaceFilter.{u1} X) (nhds.{u1} X _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.inducing_nhds Filter.inducing_nhdsâ‚“'. -/
theorem inducing_nhds : Inducing (ğ“ : X â†’ Filter X) :=
  inducing_iff_nhds.2 fun x =>
    (nhds_def' _).trans <| by
      simp (config := { contextual := true }) only [nhds_nhds, comap_infi, comap_principal,
        Iic_principal, preimage_set_of_eq, â† mem_interior_iff_mem_nhds, set_of_mem_eq,
        IsOpen.interior_eq]
#align filter.inducing_nhds Filter.inducing_nhds

/- warning: filter.continuous_nhds -> Filter.continuous_nhds is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X], Continuous.{u1, u1} X (Filter.{u1} X) _inst_1 (Filter.topologicalSpace.{u1} X) (nhds.{u1} X _inst_1)
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X], Continuous.{u1, u1} X (Filter.{u1} X) _inst_1 (Filter.instTopologicalSpaceFilter.{u1} X) (nhds.{u1} X _inst_1)
Case conversion may be inaccurate. Consider using '#align filter.continuous_nhds Filter.continuous_nhdsâ‚“'. -/
@[continuity]
theorem continuous_nhds : Continuous (ğ“ : X â†’ Filter X) :=
  inducing_nhds.Continuous
#align filter.continuous_nhds Filter.continuous_nhds

/- warning: filter.tendsto.nhds -> Filter.Tendsto.nhds is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {f : Î± -> X} {l : Filter.{u1} Î±} {x : X}, (Filter.Tendsto.{u1, u2} Î± X f l (nhds.{u2} X _inst_1 x)) -> (Filter.Tendsto.{u1, u2} Î± (Filter.{u2} X) (Function.comp.{succ u1, succ u2, succ u2} Î± X (Filter.{u2} X) (nhds.{u2} X _inst_1) f) l (nhds.{u2} (Filter.{u2} X) (Filter.topologicalSpace.{u2} X) (nhds.{u2} X _inst_1 x)))
but is expected to have type
  forall {Î± : Type.{u2}} {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {f : Î± -> X} {l : Filter.{u2} Î±} {x : X}, (Filter.Tendsto.{u2, u1} Î± X f l (nhds.{u1} X _inst_1 x)) -> (Filter.Tendsto.{u2, u1} Î± (Filter.{u1} X) (Function.comp.{succ u2, succ u1, succ u1} Î± X (Filter.{u1} X) (nhds.{u1} X _inst_1) f) l (nhds.{u1} (Filter.{u1} X) (Filter.instTopologicalSpaceFilter.{u1} X) (nhds.{u1} X _inst_1 x)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.nhds Filter.Tendsto.nhdsâ‚“'. -/
protected theorem Tendsto.nhds {f : Î± â†’ X} {l : Filter Î±} {x : X} (h : Tendsto f l (ğ“ x)) :
    Tendsto (ğ“ âˆ˜ f) l (ğ“ (ğ“ x)) :=
  (continuous_nhds.Tendsto _).comp h
#align filter.tendsto.nhds Filter.Tendsto.nhds

end Filter

variable [TopologicalSpace X] [TopologicalSpace Y] {f : X â†’ Y} {x : X} {s : Set X}

/- warning: continuous_within_at.nhds -> ContinuousWithinAt.nhds is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {f : X -> Y} {x : X} {s : Set.{u1} X}, (ContinuousWithinAt.{u1, u2} X Y _inst_1 _inst_2 f s x) -> (ContinuousWithinAt.{u1, u2} X (Filter.{u2} Y) _inst_1 (Filter.topologicalSpace.{u2} Y) (Function.comp.{succ u1, succ u2, succ u2} X Y (Filter.{u2} Y) (nhds.{u2} Y _inst_2) f) s x)
but is expected to have type
  forall {X : Type.{u2}} {Y : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} X] [_inst_2 : TopologicalSpace.{u1} Y] {f : X -> Y} {x : X} {s : Set.{u2} X}, (ContinuousWithinAt.{u2, u1} X Y _inst_1 _inst_2 f s x) -> (ContinuousWithinAt.{u2, u1} X (Filter.{u1} Y) _inst_1 (Filter.instTopologicalSpaceFilter.{u1} Y) (Function.comp.{succ u2, succ u1, succ u1} X Y (Filter.{u1} Y) (nhds.{u1} Y _inst_2) f) s x)
Case conversion may be inaccurate. Consider using '#align continuous_within_at.nhds ContinuousWithinAt.nhdsâ‚“'. -/
theorem ContinuousWithinAt.nhds (h : ContinuousWithinAt f s x) : ContinuousWithinAt (ğ“ âˆ˜ f) s x :=
  h.nhds
#align continuous_within_at.nhds ContinuousWithinAt.nhds

/- warning: continuous_at.nhds -> ContinuousAt.nhds is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {f : X -> Y} {x : X}, (ContinuousAt.{u1, u2} X Y _inst_1 _inst_2 f x) -> (ContinuousAt.{u1, u2} X (Filter.{u2} Y) _inst_1 (Filter.topologicalSpace.{u2} Y) (Function.comp.{succ u1, succ u2, succ u2} X Y (Filter.{u2} Y) (nhds.{u2} Y _inst_2) f) x)
but is expected to have type
  forall {X : Type.{u2}} {Y : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} X] [_inst_2 : TopologicalSpace.{u1} Y] {f : X -> Y} {x : X}, (ContinuousAt.{u2, u1} X Y _inst_1 _inst_2 f x) -> (ContinuousAt.{u2, u1} X (Filter.{u1} Y) _inst_1 (Filter.instTopologicalSpaceFilter.{u1} Y) (Function.comp.{succ u2, succ u1, succ u1} X Y (Filter.{u1} Y) (nhds.{u1} Y _inst_2) f) x)
Case conversion may be inaccurate. Consider using '#align continuous_at.nhds ContinuousAt.nhdsâ‚“'. -/
theorem ContinuousAt.nhds (h : ContinuousAt f x) : ContinuousAt (ğ“ âˆ˜ f) x :=
  h.nhds
#align continuous_at.nhds ContinuousAt.nhds

/- warning: continuous_on.nhds -> ContinuousOn.nhds is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {f : X -> Y} {s : Set.{u1} X}, (ContinuousOn.{u1, u2} X Y _inst_1 _inst_2 f s) -> (ContinuousOn.{u1, u2} X (Filter.{u2} Y) _inst_1 (Filter.topologicalSpace.{u2} Y) (Function.comp.{succ u1, succ u2, succ u2} X Y (Filter.{u2} Y) (nhds.{u2} Y _inst_2) f) s)
but is expected to have type
  forall {X : Type.{u2}} {Y : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} X] [_inst_2 : TopologicalSpace.{u1} Y] {f : X -> Y} {s : Set.{u2} X}, (ContinuousOn.{u2, u1} X Y _inst_1 _inst_2 f s) -> (ContinuousOn.{u2, u1} X (Filter.{u1} Y) _inst_1 (Filter.instTopologicalSpaceFilter.{u1} Y) (Function.comp.{succ u2, succ u1, succ u1} X Y (Filter.{u1} Y) (nhds.{u1} Y _inst_2) f) s)
Case conversion may be inaccurate. Consider using '#align continuous_on.nhds ContinuousOn.nhdsâ‚“'. -/
theorem ContinuousOn.nhds (h : ContinuousOn f s) : ContinuousOn (ğ“ âˆ˜ f) s := fun x hx =>
  (h x hx).nhds
#align continuous_on.nhds ContinuousOn.nhds

/- warning: continuous.nhds -> Continuous.nhds is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {f : X -> Y}, (Continuous.{u1, u2} X Y _inst_1 _inst_2 f) -> (Continuous.{u1, u2} X (Filter.{u2} Y) _inst_1 (Filter.topologicalSpace.{u2} Y) (Function.comp.{succ u1, succ u2, succ u2} X Y (Filter.{u2} Y) (nhds.{u2} Y _inst_2) f))
but is expected to have type
  forall {X : Type.{u2}} {Y : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} X] [_inst_2 : TopologicalSpace.{u1} Y] {f : X -> Y}, (Continuous.{u2, u1} X Y _inst_1 _inst_2 f) -> (Continuous.{u2, u1} X (Filter.{u1} Y) _inst_1 (Filter.instTopologicalSpaceFilter.{u1} Y) (Function.comp.{succ u2, succ u1, succ u1} X Y (Filter.{u1} Y) (nhds.{u1} Y _inst_2) f))
Case conversion may be inaccurate. Consider using '#align continuous.nhds Continuous.nhdsâ‚“'. -/
theorem Continuous.nhds (h : Continuous f) : Continuous (ğ“ âˆ˜ f) :=
  Filter.continuous_nhds.comp h
#align continuous.nhds Continuous.nhds

