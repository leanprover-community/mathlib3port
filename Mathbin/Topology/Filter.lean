/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Order.Filter.Lift
import Topology.Separation
import Data.Set.Intervals.Monotone

#align_import topology.filter from "leanprover-community/mathlib"@"b6da1a0b3e7cd83b1f744c49ce48ef8c6307d2f6"

/-!
# Topology on the set of filters on a type

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file introduce topology on `filter Î±`. It is generated by the sets
`set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`, `s : set Î±`. A set `s : set (filter Î±)` is open if and
only if it is a union of a family of these basic open sets, see `filter.is_open_iff`.

This topology has the following important properties.

* If `X` is a topological space, then the map `ğ“ : X â†’ filter X` is a topology inducing map.

* In particular, it is a continuous map, so `ğ“ âˆ˜ f` tends to `ğ“ (ğ“ a)` whenever `f` tends to `ğ“ a`.

* If `X` is an ordered topological space with order topology and no max element, then `ğ“ âˆ˜ f` tends
  to `ğ“ filter.at_top` whenever `f` tends to `filter.at_top`.

* It turns `filter X` into a Tâ‚€ space and the order on `filter X` is the dual of the
  `specialization_order (filter X)`.

## Tags

filter, topological space
-/


open Set Filter TopologicalSpace

open scoped Filter Topology

variable {Î¹ : Sort _} {Î± Î² X Y : Type _}

namespace Filter

/-- Topology on `filter Î±` is generated by the sets `set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`,
`s : set Î±`. A set `s : set (filter Î±)` is open if and only if it is a union of a family of these
basic open sets, see `filter.is_open_iff`. -/
instance : TopologicalSpace (Filter Î±) :=
  generateFrom <| range <| Iic âˆ˜ ğ“Ÿ

#print Filter.isOpen_Iic_principal /-
theorem isOpen_Iic_principal {s : Set Î±} : IsOpen (Iic (ğ“Ÿ s)) :=
  GenerateOpen.basic _ (mem_range_self _)
#align filter.is_open_Iic_principal Filter.isOpen_Iic_principal
-/

#print Filter.isOpen_setOf_mem /-
theorem isOpen_setOf_mem {s : Set Î±} : IsOpen {l : Filter Î± | s âˆˆ l} := by
  simpa only [Iic_principal] using is_open_Iic_principal
#align filter.is_open_set_of_mem Filter.isOpen_setOf_mem
-/

#print Filter.isTopologicalBasis_Iic_principal /-
theorem isTopologicalBasis_Iic_principal :
    IsTopologicalBasis (range (Iic âˆ˜ ğ“Ÿ : Set Î± â†’ Set (Filter Î±))) :=
  { exists_subset_inter := by
      rintro _ âŸ¨s, rflâŸ© _ âŸ¨t, rflâŸ© l hl
      exact âŸ¨Iic (ğ“Ÿ s) âˆ© Iic (ğ“Ÿ t), âŸ¨s âˆ© t, by simpâŸ©, hl, subset.rflâŸ©
    sUnion_eq := sUnion_eq_univ_iff.2 fun l => âŸ¨Iic âŠ¤, âŸ¨univ, congr_arg Iic principal_univâŸ©, le_topâŸ©
    eq_generateFrom := rfl }
#align filter.is_topological_basis_Iic_principal Filter.isTopologicalBasis_Iic_principal
-/

#print Filter.isOpen_iff /-
theorem isOpen_iff {s : Set (Filter Î±)} : IsOpen s â†” âˆƒ T : Set (Set Î±), s = â‹ƒ t âˆˆ T, Iic (ğ“Ÿ t) :=
  isTopologicalBasis_Iic_principal.open_iff_eq_sUnion.trans <| by
    simp only [exists_subset_range_iff, sUnion_image]
#align filter.is_open_iff Filter.isOpen_iff
-/

#print Filter.nhds_eq /-
theorem nhds_eq (l : Filter Î±) : ğ“ l = l.lift' (Iic âˆ˜ ğ“Ÿ) :=
  nhds_generateFrom.trans <| by
    simp only [mem_set_of_eq, and_comm' (l âˆˆ _), iInf_and, iInf_range, Filter.lift', Filter.lift,
      (Â· âˆ˜ Â·), mem_Iic, le_principal_iff]
#align filter.nhds_eq Filter.nhds_eq
-/

#print Filter.nhds_eq' /-
theorem nhds_eq' (l : Filter Î±) : ğ“ l = l.lift' fun s => {l' | s âˆˆ l'} := by
  simpa only [(Â· âˆ˜ Â·), Iic_principal] using nhds_eq l
#align filter.nhds_eq' Filter.nhds_eq'
-/

#print Filter.tendsto_nhds /-
protected theorem tendsto_nhds {la : Filter Î±} {lb : Filter Î²} {f : Î± â†’ Filter Î²} :
    Tendsto f la (ğ“ lb) â†” âˆ€ s âˆˆ lb, âˆ€á¶  a in la, s âˆˆ f a := by
  simp only [nhds_eq', tendsto_lift', mem_set_of_eq]
#align filter.tendsto_nhds Filter.tendsto_nhds
-/

#print Filter.HasBasis.nhds /-
theorem HasBasis.nhds {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :
    HasBasis (ğ“ l) p fun i => Iic (ğ“Ÿ (s i)) := by rw [nhds_eq]; exact h.lift' monotone_principal.Iic
#align filter.has_basis.nhds Filter.HasBasis.nhds
-/

/-- Neighborhoods of a countably generated filter is a countably generated filter. -/
instance {l : Filter Î±} [IsCountablyGenerated l] : IsCountablyGenerated (ğ“ l) :=
  let âŸ¨b, hbâŸ© := l.exists_antitone_basis
  HasCountableBasis.isCountablyGenerated <| âŸ¨hb.nhds, Set.to_countable _âŸ©

#print Filter.HasBasis.nhds' /-
theorem HasBasis.nhds' {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :
    HasBasis (ğ“ l) p fun i => {l' | s i âˆˆ l'} := by simpa only [Iic_principal] using h.nhds
#align filter.has_basis.nhds' Filter.HasBasis.nhds'
-/

#print Filter.mem_nhds_iff /-
theorem mem_nhds_iff {l : Filter Î±} {S : Set (Filter Î±)} : S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† S :=
  l.basis_sets.nhds.mem_iff
#align filter.mem_nhds_iff Filter.mem_nhds_iff
-/

#print Filter.mem_nhds_iff' /-
theorem mem_nhds_iff' {l : Filter Î±} {S : Set (Filter Î±)} :
    S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, âˆ€ â¦ƒl' : Filter Î±â¦„, t âˆˆ l' â†’ l' âˆˆ S :=
  l.basis_sets.nhds'.mem_iff
#align filter.mem_nhds_iff' Filter.mem_nhds_iff'
-/

#print Filter.nhds_bot /-
@[simp]
theorem nhds_bot : ğ“ (âŠ¥ : Filter Î±) = pure âŠ¥ := by simp [nhds_eq, lift'_bot monotone_principal.Iic]
#align filter.nhds_bot Filter.nhds_bot
-/

#print Filter.nhds_top /-
@[simp]
theorem nhds_top : ğ“ (âŠ¤ : Filter Î±) = âŠ¤ := by simp [nhds_eq]
#align filter.nhds_top Filter.nhds_top
-/

#print Filter.nhds_principal /-
@[simp]
theorem nhds_principal (s : Set Î±) : ğ“ (ğ“Ÿ s) = ğ“Ÿ (Iic (ğ“Ÿ s)) :=
  (hasBasis_principal s).nhds.eq_of_same_basis (hasBasis_principal _)
#align filter.nhds_principal Filter.nhds_principal
-/

#print Filter.nhds_pure /-
@[simp]
theorem nhds_pure (x : Î±) : ğ“ (pure x : Filter Î±) = ğ“Ÿ {âŠ¥, pure x} := by
  rw [â† principal_singleton, nhds_principal, principal_singleton, Iic_pure]
#align filter.nhds_pure Filter.nhds_pure
-/

#print Filter.nhds_iInf /-
@[simp]
theorem nhds_iInf (f : Î¹ â†’ Filter Î±) : ğ“ (â¨… i, f i) = â¨… i, ğ“ (f i) := by simp only [nhds_eq];
  apply lift'_infi_of_map_univ <;> simp
#align filter.nhds_infi Filter.nhds_iInf
-/

#print Filter.nhds_inf /-
@[simp]
theorem nhds_inf (lâ‚ lâ‚‚ : Filter Î±) : ğ“ (lâ‚ âŠ“ lâ‚‚) = ğ“ lâ‚ âŠ“ ğ“ lâ‚‚ := by
  simpa only [iInf_bool_eq] using nhds_iInf fun b => cond b lâ‚ lâ‚‚
#align filter.nhds_inf Filter.nhds_inf
-/

#print Filter.monotone_nhds /-
theorem monotone_nhds : Monotone (ğ“ : Filter Î± â†’ Filter (Filter Î±)) :=
  Monotone.of_map_inf nhds_inf
#align filter.monotone_nhds Filter.monotone_nhds
-/

#print Filter.sInter_nhds /-
theorem sInter_nhds (l : Filter Î±) : â‹‚â‚€ {s | s âˆˆ ğ“ l} = Iic l := by
  simp only [nhds_eq, sInter_lift'_sets monotone_principal.Iic, Iic, le_principal_iff, â†
    set_of_forall, â† Filter.le_def]
#align filter.Inter_nhds Filter.sInter_nhds
-/

#print Filter.nhds_mono /-
@[simp]
theorem nhds_mono {lâ‚ lâ‚‚ : Filter Î±} : ğ“ lâ‚ â‰¤ ğ“ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ :=
  by
  refine' âŸ¨fun h => _, fun h => monotone_nhds hâŸ©
  rw [â† Iic_subset_Iic, â† Inter_nhds, â† Inter_nhds]
  exact sInter_subset_sInter h
#align filter.nhds_mono Filter.nhds_mono
-/

#print Filter.mem_interior /-
protected theorem mem_interior {s : Set (Filter Î±)} {l : Filter Î±} :
    l âˆˆ interior s â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† s := by rw [mem_interior_iff_mem_nhds, mem_nhds_iff]
#align filter.mem_interior Filter.mem_interior
-/

#print Filter.mem_closure /-
protected theorem mem_closure {s : Set (Filter Î±)} {l : Filter Î±} :
    l âˆˆ closure s â†” âˆ€ t âˆˆ l, âˆƒ l' âˆˆ s, t âˆˆ l' := by
  simp only [closure_eq_compl_interior_compl, Filter.mem_interior, mem_compl_iff, not_exists,
    not_forall, Classical.not_not, exists_prop, not_and, and_comm', subset_def, mem_Iic,
    le_principal_iff]
#align filter.mem_closure Filter.mem_closure
-/

#print Filter.closure_singleton /-
@[simp]
protected theorem closure_singleton (l : Filter Î±) : closure {l} = Ici l := by ext l';
  simp [Filter.mem_closure, Filter.le_def]
#align filter.closure_singleton Filter.closure_singleton
-/

#print Filter.specializes_iff_le /-
@[simp]
theorem specializes_iff_le {lâ‚ lâ‚‚ : Filter Î±} : lâ‚ â¤³ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ := by
  simp only [specializes_iff_closure_subset, Filter.closure_singleton, Ici_subset_Ici]
#align filter.specializes_iff_le Filter.specializes_iff_le
-/

instance : T0Space (Filter Î±) :=
  âŸ¨fun x y h =>
    (specializes_iff_le.1 h.Specializes).antisymm (specializes_iff_le.1 h.symm.Specializes)âŸ©

#print Filter.nhds_atTop /-
theorem nhds_atTop [Preorder Î±] : ğ“ atTop = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Ici x))) := by
  simp only [at_top, nhds_iInf, nhds_principal]
#align filter.nhds_at_top Filter.nhds_atTop
-/

#print Filter.tendsto_nhds_atTop_iff /-
protected theorem tendsto_nhds_atTop_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :
    Tendsto f l (ğ“ atTop) â†” âˆ€ y, âˆ€á¶  a in l, Ici y âˆˆ f a := by
  simp only [nhds_at_top, tendsto_infi, tendsto_principal, mem_Iic, le_principal_iff]
#align filter.tendsto_nhds_at_top_iff Filter.tendsto_nhds_atTop_iff
-/

#print Filter.nhds_atBot /-
theorem nhds_atBot [Preorder Î±] : ğ“ atBot = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Iic x))) :=
  @nhds_atTop Î±áµ’áµˆ _
#align filter.nhds_at_bot Filter.nhds_atBot
-/

#print Filter.tendsto_nhds_atBot_iff /-
protected theorem tendsto_nhds_atBot_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :
    Tendsto f l (ğ“ atBot) â†” âˆ€ y, âˆ€á¶  a in l, Iic y âˆˆ f a :=
  @Filter.tendsto_nhds_atTop_iff Î± Î²áµ’áµˆ _ _ _
#align filter.tendsto_nhds_at_bot_iff Filter.tendsto_nhds_atBot_iff
-/

variable [TopologicalSpace X]

#print Filter.nhds_nhds /-
theorem nhds_nhds (x : X) : ğ“ (ğ“ x) = â¨… (s : Set X) (hs : IsOpen s) (hx : x âˆˆ s), ğ“Ÿ (Iic (ğ“Ÿ s)) :=
  by simp only [(nhds_basis_opens x).nhds.eq_biInf, iInf_and, @iInf_comm _ (_ âˆˆ _)]
#align filter.nhds_nhds Filter.nhds_nhds
-/

#print Filter.inducing_nhds /-
theorem inducing_nhds : Inducing (ğ“ : X â†’ Filter X) :=
  inducing_iff_nhds.2 fun x =>
    (nhds_def' _).trans <| by
      simp (config := { contextual := true }) only [nhds_nhds, comap_infi, comap_principal,
        Iic_principal, preimage_set_of_eq, â† mem_interior_iff_mem_nhds, set_of_mem_eq,
        IsOpen.interior_eq]
#align filter.inducing_nhds Filter.inducing_nhds
-/

#print Filter.continuous_nhds /-
@[continuity]
theorem continuous_nhds : Continuous (ğ“ : X â†’ Filter X) :=
  inducing_nhds.Continuous
#align filter.continuous_nhds Filter.continuous_nhds
-/

#print Filter.Tendsto.nhds /-
protected theorem Tendsto.nhds {f : Î± â†’ X} {l : Filter Î±} {x : X} (h : Tendsto f l (ğ“ x)) :
    Tendsto (ğ“ âˆ˜ f) l (ğ“ (ğ“ x)) :=
  (continuous_nhds.Tendsto _).comp h
#align filter.tendsto.nhds Filter.Tendsto.nhds
-/

end Filter

variable [TopologicalSpace X] [TopologicalSpace Y] {f : X â†’ Y} {x : X} {s : Set X}

#print ContinuousWithinAt.nhds /-
theorem ContinuousWithinAt.nhds (h : ContinuousWithinAt f s x) : ContinuousWithinAt (ğ“ âˆ˜ f) s x :=
  h.nhds
#align continuous_within_at.nhds ContinuousWithinAt.nhds
-/

#print ContinuousAt.nhds /-
theorem ContinuousAt.nhds (h : ContinuousAt f x) : ContinuousAt (ğ“ âˆ˜ f) x :=
  h.nhds
#align continuous_at.nhds ContinuousAt.nhds
-/

#print ContinuousOn.nhds /-
theorem ContinuousOn.nhds (h : ContinuousOn f s) : ContinuousOn (ğ“ âˆ˜ f) s := fun x hx =>
  (h x hx).nhds
#align continuous_on.nhds ContinuousOn.nhds
-/

#print Continuous.nhds /-
theorem Continuous.nhds (h : Continuous f) : Continuous (ğ“ âˆ˜ f) :=
  Filter.continuous_nhds.comp h
#align continuous.nhds Continuous.nhds
-/

