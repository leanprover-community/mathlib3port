import Mathbin.Analysis.SpecificLimits 
import Mathbin.Order.Filter.CountableInter 
import Mathbin.Topology.GDelta

/-!
# Baire theorem

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a GÎ´ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense GÎ´ sets is a dense GÎ´ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

The names of the theorems do not contain the string "Baire", but are instead built from the form of
the statement. "Baire" is however in the docstring of all the theorems, to facilitate grep searches.

We also define the filter `residual Î±` generated by dense `GÎ´` sets and prove that this filter
has the countable intersection property.
-/


noncomputable theory

open_locale Classical TopologicalSpace Filter Ennreal

open Filter Encodable Set

variable{Î± : Type _}{Î² : Type _}{Î³ : Type _}{Î¹ : Type _}

section BaireTheorem

open Emetric Ennreal

variable[EmetricSpace Î±][CompleteSpace Î±]

-- error in Topology.MetricSpace.Baire: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here when
the source space is â„• (and subsumed below by `dense_Inter_of_open` working with any
encodable source space). -/
theorem dense_Inter_of_open_nat
{f : exprâ„•() â†’ set Î±}
(ho : âˆ€ n, is_open (f n))
(hd : âˆ€ n, dense (f n)) : dense Â«exprâ‹‚ , Â»((n), f n) :=
begin
  let [ident B] [":", expr exprâ„•() â†’ Â«exprâ„â‰¥0âˆÂ»()] [":=", expr Î» n, Â«expr / Â»(1, Â«expr ^ Â»(2, n))],
  have [ident Bpos] [":", expr âˆ€ n, Â«expr < Â»(0, B n)] [],
  { intro [ident n],
    simp [] [] ["only"] ["[", expr B, ",", expr one_div, ",", expr one_mul, ",", expr ennreal.inv_pos, "]"] [] [],
    exact [expr pow_ne_top two_ne_top] },
  have [] [":", expr âˆ€
   n
   x
   Î´, Â«expr â‰  Â»(Î´, 0) â†’ Â«exprâˆƒ , Â»((y
     r), Â«expr âˆ§ Â»(Â«expr < Â»(0, r), Â«expr âˆ§ Â»(Â«expr â‰¤ Â»(r, B Â«expr + Â»(n, 1)), Â«expr âŠ† Â»(closed_ball y r, Â«expr âˆ© Â»(closed_ball x Î´, f n)))))] [],
  { assume [binders (n x Î´ Î´pos)],
    have [] [":", expr Â«expr âˆˆ Â»(x, closure (f n))] [":=", expr hd n x],
    rcases [expr emetric.mem_closure_iff.1 this Â«expr / Â»(Î´, 2) (ennreal.half_pos Î´pos), "with", "âŸ¨", ident y, ",", ident ys, ",", ident xy, "âŸ©"],
    rw [expr edist_comm] ["at", ident xy],
    obtain ["âŸ¨", ident r, ",", ident rpos, ",", ident hr, "âŸ©", ":", expr Â«exprâˆƒ , Â»((r Â«expr > Â» 0), Â«expr âŠ† Â»(closed_ball y r, f n)), ":=", expr nhds_basis_closed_eball.mem_iff.1 (is_open_iff_mem_nhds.1 (ho n) y ys)],
    refine [expr âŸ¨y, min (min Â«expr / Â»(Î´, 2) r) (B Â«expr + Â»(n, 1)), _, _, Î» z hz, âŸ¨_, _âŸ©âŸ©],
    show [expr Â«expr < Â»(0, min (min Â«expr / Â»(Î´, 2) r) (B Â«expr + Â»(n, 1)))],
    from [expr lt_min (lt_min (ennreal.half_pos Î´pos) rpos) (Bpos Â«expr + Â»(n, 1))],
    show [expr Â«expr â‰¤ Â»(min (min Â«expr / Â»(Î´, 2) r) (B Â«expr + Â»(n, 1)), B Â«expr + Â»(n, 1))],
    from [expr min_le_right _ _],
    show [expr Â«expr âˆˆ Â»(z, closed_ball x Î´)],
    from [expr calc
       Â«expr â‰¤ Â»(edist z x, Â«expr + Â»(edist z y, edist y x)) : edist_triangle _ _ _
       Â«expr â‰¤ Â»(..., Â«expr + Â»(min (min Â«expr / Â»(Î´, 2) r) (B Â«expr + Â»(n, 1)), Â«expr / Â»(Î´, 2))) : add_le_add hz (le_of_lt xy)
       Â«expr â‰¤ Â»(..., Â«expr + Â»(Â«expr / Â»(Î´, 2), Â«expr / Â»(Î´, 2))) : add_le_add (le_trans (min_le_left _ _) (min_le_left _ _)) (le_refl _)
       Â«expr = Â»(..., Î´) : ennreal.add_halves Î´],
    show [expr Â«expr âˆˆ Â»(z, f n)],
    from [expr hr (calc
        Â«expr â‰¤ Â»(edist z y, min (min Â«expr / Â»(Î´, 2) r) (B Â«expr + Â»(n, 1))) : hz
        Â«expr â‰¤ Â»(..., r) : le_trans (min_le_left _ _) (min_le_right _ _))] },
  choose ["!"] [ident center] [ident radius, ident Hpos, ident HB, ident Hball] ["using", expr this],
  refine [expr Î» x, (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 (Î» Îµ Îµpos, _)],
  let [ident F] [":", expr exprâ„•() â†’ Â«expr Ã— Â»(Î±, Â«exprâ„â‰¥0âˆÂ»())] [":=", expr Î»
   n, nat.rec_on n (prod.mk x (min Îµ (B 0))) (Î» n p, prod.mk (center n p.1 p.2) (radius n p.1 p.2))],
  let [ident c] [":", expr exprâ„•() â†’ Î±] [":=", expr Î» n, (F n).1],
  let [ident r] [":", expr exprâ„•() â†’ Â«exprâ„â‰¥0âˆÂ»()] [":=", expr Î» n, (F n).2],
  have [ident rpos] [":", expr âˆ€ n, Â«expr < Â»(0, r n)] [],
  { assume [binders (n)],
    induction [expr n] [] ["with", ident n, ident hn] [],
    exact [expr lt_min Îµpos (Bpos 0)],
    exact [expr Hpos n (c n) (r n) hn.ne'] },
  have [ident r0] [":", expr âˆ€ n, Â«expr â‰  Â»(r n, 0)] [":=", expr Î» n, (rpos n).ne'],
  have [ident rB] [":", expr âˆ€ n, Â«expr â‰¤ Â»(r n, B n)] [],
  { assume [binders (n)],
    induction [expr n] [] ["with", ident n, ident hn] [],
    exact [expr min_le_right _ _],
    exact [expr HB n (c n) (r n) (r0 n)] },
  have [ident incl] [":", expr âˆ€
   n, Â«expr âŠ† Â»(closed_ball (c Â«expr + Â»(n, 1)) (r Â«expr + Â»(n, 1)), Â«expr âˆ© Â»(closed_ball (c n) (r n), f n))] [":=", expr Î»
   n, Hball n (c n) (r n) (r0 n)],
  have [ident cdist] [":", expr âˆ€ n, Â«expr â‰¤ Â»(edist (c n) (c Â«expr + Â»(n, 1)), B n)] [],
  { assume [binders (n)],
    rw [expr edist_comm] [],
    have [ident A] [":", expr Â«expr âˆˆ Â»(c Â«expr + Â»(n, 1), closed_ball (c Â«expr + Â»(n, 1)) (r Â«expr + Â»(n, 1)))] [":=", expr mem_closed_ball_self],
    have [ident I] [] [":=", expr calc
       Â«expr âŠ† Â»(closed_ball (c Â«expr + Â»(n, 1)) (r Â«expr + Â»(n, 1)), closed_ball (c n) (r n)) : subset.trans (incl n) (inter_subset_left _ _)
       Â«expr âŠ† Â»(..., closed_ball (c n) (B n)) : closed_ball_subset_closed_ball (rB n)],
    exact [expr I A] },
  have [] [":", expr cauchy_seq c] [":=", expr cauchy_seq_of_edist_le_geometric_two _ one_ne_top cdist],
  rcases [expr cauchy_seq_tendsto_of_complete this, "with", "âŸ¨", ident y, ",", ident ylim, "âŸ©"],
  use [expr y],
  simp [] [] ["only"] ["[", expr exists_prop, ",", expr set.mem_Inter, "]"] [] [],
  have [ident I] [":", expr âˆ€ n, âˆ€ m Â«expr â‰¥ Â» n, Â«expr âŠ† Â»(closed_ball (c m) (r m), closed_ball (c n) (r n))] [],
  { assume [binders (n)],
    refine [expr nat.le_induction _ (Î» m hnm h, _)],
    { exact [expr subset.refl _] },
    { exact [expr subset.trans (incl m) (subset.trans (inter_subset_left _ _) h)] } },
  have [ident yball] [":", expr âˆ€ n, Â«expr âˆˆ Â»(y, closed_ball (c n) (r n))] [],
  { assume [binders (n)],
    refine [expr is_closed_ball.mem_of_tendsto ylim _],
    refine [expr (filter.eventually_ge_at_top n).mono (Î» m hm, _)],
    exact [expr I n m hm mem_closed_ball_self] },
  split,
  show [expr âˆ€ n, Â«expr âˆˆ Â»(y, f n)],
  { assume [binders (n)],
    have [] [":", expr Â«expr âŠ† Â»(closed_ball (c Â«expr + Â»(n, 1)) (r Â«expr + Â»(n, 1)), f n)] [":=", expr subset.trans (incl n) (inter_subset_right _ _)],
    exact [expr this (yball Â«expr + Â»(n, 1))] },
  show [expr Â«expr â‰¤ Â»(edist y x, Îµ)],
  from [expr le_trans (yball 0) (min_le_left _ _)]
end

-- error in Topology.MetricSpace.Baire: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/
theorem dense_sInter_of_open
{S : set (set Î±)}
(ho : âˆ€ s Â«expr âˆˆ Â» S, is_open s)
(hS : countable S)
(hd : âˆ€ s Â«expr âˆˆ Â» S, dense s) : dense Â«exprâ‹‚â‚€ Â»(S) :=
begin
  cases [expr S.eq_empty_or_nonempty] ["with", ident h, ident h],
  { simp [] [] [] ["[", expr h, "]"] [] [] },
  { rcases [expr hS.exists_surjective h, "with", "âŸ¨", ident f, ",", ident hf, "âŸ©"],
    have [ident F] [":", expr âˆ€
     n, Â«expr âˆˆ Â»(f n, S)] [":=", expr Î» n, by rw [expr hf] []; exact [expr mem_range_self _]],
    rw ["[", expr hf, ",", expr sInter_range, "]"] [],
    exact [expr dense_Inter_of_open_nat (Î» n, ho _ (F n)) (Î» n, hd _ (F n))] }
end

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_open {S : Set Î²} {f : Î² â†’ Set Î±} (ho : âˆ€ s (_ : s âˆˆ S), IsOpen (f s)) (hS : countable S)
  (hd : âˆ€ s (_ : s âˆˆ S), Dense (f s)) : Dense (â‹‚(s : _)(_ : s âˆˆ S), f s) :=
  by 
    rw [â†sInter_image]
    apply dense_sInter_of_open
    Â·
      rwa [ball_image_iff]
    Â·
      exact hS.image _
    Â·
      rwa [ball_image_iff]

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_open [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ s, IsOpen (f s)) (hd : âˆ€ s, Dense (f s)) :
  Dense (â‹‚s, f s) :=
  by 
    rw [â†sInter_range]
    apply dense_sInter_of_open
    Â·
      rwa [forall_range_iff]
    Â·
      exact countable_range _
    Â·
      rwa [forall_range_iff]

-- error in Topology.MetricSpace.Baire: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/
theorem dense_sInter_of_GÎ´
{S : set (set Î±)}
(ho : âˆ€ s Â«expr âˆˆ Â» S, is_GÎ´ s)
(hS : countable S)
(hd : âˆ€ s Â«expr âˆˆ Â» S, dense s) : dense Â«exprâ‹‚â‚€ Â»(S) :=
begin
  choose [] [ident T] [ident hT] ["using", expr ho],
  have [] [":", expr Â«expr = Â»(Â«exprâ‹‚â‚€ Â»(S), Â«exprâ‹‚â‚€ Â»(Â«exprâ‹ƒ , Â»((s Â«expr âˆˆ Â» S), T s Â«exprâ€¹ â€ºÂ»(_))))] [":=", expr (sInter_bUnion (Î»
     s hs, (hT s hs).2.2)).symm],
  rw [expr this] [],
  refine [expr dense_sInter_of_open _ (hS.bUnion (Î»
     s
     hs, (hT s hs).2.1)) _]; simp [] [] ["only"] ["[", expr set.mem_Union, ",", expr exists_prop, "]"] [] []; rintro [ident t, "âŸ¨", ident s, ",", ident hs, ",", ident tTs, "âŸ©"],
  show [expr is_open t],
  { exact [expr (hT s hs).1 t tTs] },
  show [expr dense t],
  { intro [ident x],
    have [] [] [":=", expr hd s hs x],
    rw [expr (hT s hs).2.2] ["at", ident this],
    exact [expr closure_mono (sInter_subset_of_mem tTs) this] }
end

/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_GÎ´ [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ s, IsGÎ´ (f s)) (hd : âˆ€ s, Dense (f s)) :
  Dense (â‹‚s, f s) :=
  by 
    rw [â†sInter_range]
    exact dense_sInter_of_GÎ´ (forall_range_iff.2 â€¹_â€º) (countable_range _) (forall_range_iff.2 â€¹_â€º)

-- error in Topology.MetricSpace.Baire: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_GÎ´
{S : set Î²}
{f : âˆ€ x Â«expr âˆˆ Â» S, set Î±}
(ho : âˆ€ s Â«expr âˆˆ Â» S, is_GÎ´ (f s Â«exprâ€¹ â€ºÂ»(_)))
(hS : countable S)
(hd : âˆ€ s Â«expr âˆˆ Â» S, dense (f s Â«exprâ€¹ â€ºÂ»(_))) : dense Â«exprâ‹‚ , Â»((s Â«expr âˆˆ Â» S), f s Â«exprâ€¹ â€ºÂ»(_)) :=
begin
  rw [expr bInter_eq_Inter] [],
  haveI [] [] [":=", expr hS.to_encodable],
  exact [expr dense_Inter_of_GÎ´ (Î» s, ho s s.2) (Î» s, hd s s.2)]
end

/-- Baire theorem: the intersection of two dense GÎ´ sets is dense. -/
theorem Dense.inter_of_GÎ´ {s t : Set Î±} (hs : IsGÎ´ s) (ht : IsGÎ´ t) (hsc : Dense s) (htc : Dense t) : Dense (s âˆ© t) :=
  by 
    rw [inter_eq_Inter]
    apply dense_Inter_of_GÎ´ <;> simp [Bool.forall_bool]

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `GÎ´` set. -/
theorem eventually_residual {p : Î± â†’ Prop} :
  (âˆ€á¶ x in residual Î±, p x) â†” âˆƒ t : Set Î±, IsGÎ´ t âˆ§ Dense t âˆ§ âˆ€ x (_ : x âˆˆ t), p x :=
  calc (âˆ€á¶ x in residual Î±, p x) â†” âˆ€á¶ x in â¨…(t : Set Î±)(ht : IsGÎ´ t âˆ§ Dense t), ğ“Ÿ t, p x :=
    by 
      simp only [residual, infi_and]
    _ â†” âˆƒ (t : Set Î±)(ht : IsGÎ´ t âˆ§ Dense t), âˆ€á¶ x in ğ“Ÿ t, p x :=
    mem_binfi_of_directed
      (fun tâ‚ hâ‚ tâ‚‚ hâ‚‚ =>
        âŸ¨tâ‚ âˆ© tâ‚‚, âŸ¨hâ‚.1.inter hâ‚‚.1, Dense.inter_of_GÎ´ hâ‚.1 hâ‚‚.1 hâ‚.2 hâ‚‚.2âŸ©,
          by 
            simp âŸ©)
      âŸ¨univ, is_GÎ´_univ, dense_univâŸ©
    _ â†” _ :=
    by 
      simp [and_assoc]
    

/-- A set is residual (comeagre) if and only if it includes a dense `GÎ´` set. -/
theorem mem_residual {s : Set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : _)(_ : t âŠ† s), IsGÎ´ t âˆ§ Dense t :=
  (@eventually_residual Î± _ _ fun x => x âˆˆ s).trans$
    exists_congr$
      fun t =>
        by 
          rw [exists_prop, and_comm (t âŠ† s), subset_def, and_assoc]

theorem dense_of_mem_residual {s : Set Î±} (hs : s âˆˆ residual Î±) : Dense s :=
  let âŸ¨t, hts, _, hdâŸ© := mem_residual.1 hs 
  hd.mono hts

instance  : CountableInterFilter (residual Î±) :=
  âŸ¨by 
      intro S hSc hS 
      simp only [mem_residual] at *
      choose T hTs hT using hS 
      refine' âŸ¨â‹‚(s : _)(_ : s âˆˆ S), T s â€¹_â€º, _, _, _âŸ©
      Â·
        rw [sInter_eq_bInter]
        exact Inter_subset_Inter fun s => Inter_subset_Inter$ hTs s
      Â·
        exact is_GÎ´_bInter hSc fun s hs => (hT s hs).1
      Â·
        exact dense_bInter_of_GÎ´ (fun s hs => (hT s hs).1) hSc fun s hs => (hT s hs).2âŸ©

-- error in Topology.MetricSpace.Baire: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bUnion_interior_of_closed
{S : set Î²}
{f : Î² â†’ set Î±}
(hc : âˆ€ s Â«expr âˆˆ Â» S, is_closed (f s))
(hS : countable S)
(hU : Â«expr = Â»(Â«exprâ‹ƒ , Â»((s Â«expr âˆˆ Â» S), f s), univ)) : dense Â«exprâ‹ƒ , Â»((s Â«expr âˆˆ Â» S), interior (f s)) :=
begin
  let [ident g] [] [":=", expr Î» s, Â«expr á¶œÂ»(frontier (f s))],
  have [] [":", expr dense Â«exprâ‹‚ , Â»((s Â«expr âˆˆ Â» S), g s)] [],
  { refine [expr dense_bInter_of_open (Î» s hs, _) hS (Î» s hs, _)],
    show [expr is_open (g s)],
    from [expr is_open_compl_iff.2 is_closed_frontier],
    show [expr dense (g s)],
    { intro [ident x],
      simp [] [] [] ["[", expr interior_frontier (hc s hs), "]"] [] [] } },
  refine [expr this.mono _],
  show [expr Â«expr âŠ† Â»(Â«exprâ‹‚ , Â»((s Â«expr âˆˆ Â» S), g s), Â«exprâ‹ƒ , Â»((s Â«expr âˆˆ Â» S), interior (f s)))],
  assume [binders (x hx)],
  have [] [":", expr Â«expr âˆˆ Â»(x, Â«exprâ‹ƒ , Â»((s Â«expr âˆˆ Â» S), f s))] [],
  { have [] [] [":=", expr mem_univ x],
    rwa ["<-", expr hU] ["at", ident this] },
  rcases [expr mem_bUnion_iff.1 this, "with", "âŸ¨", ident s, ",", ident hs, ",", ident xs, "âŸ©"],
  have [] [":", expr Â«expr âˆˆ Â»(x, g s)] [":=", expr mem_bInter_iff.1 hx s hs],
  have [] [":", expr Â«expr âˆˆ Â»(x, interior (f s))] [],
  { have [] [":", expr Â«expr âˆˆ Â»(x, Â«expr \ Â»(f s, frontier (f s)))] [":=", expr mem_inter xs this],
    simpa [] [] [] ["[", expr frontier, ",", expr xs, ",", expr (hc s hs).closure_eq, "]"] [] ["using", expr this] },
  exact [expr mem_bUnion_iff.2 âŸ¨s, âŸ¨hs, thisâŸ©âŸ©]
end

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `â‹ƒâ‚€`. -/
theorem dense_sUnion_interior_of_closed {S : Set (Set Î±)} (hc : âˆ€ s (_ : s âˆˆ S), IsClosed s) (hS : countable S)
  (hU : â‹ƒâ‚€S = univ) : Dense (â‹ƒ(s : _)(_ : s âˆˆ S), Interior s) :=
  by 
    rw [sUnion_eq_bUnion] at hU <;> exact dense_bUnion_interior_of_closed hc hS hU

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_Union_interior_of_closed [Encodable Î²] {f : Î² â†’ Set Î±} (hc : âˆ€ s, IsClosed (f s))
  (hU : (â‹ƒs, f s) = univ) : Dense (â‹ƒs, Interior (f s)) :=
  by 
    rw [â†bUnion_univ]
    apply dense_bUnion_interior_of_closed
    Â·
      simp [hc]
    Â·
      apply countable_encodable
    Â·
      rwa [â†bUnion_univ] at hU

-- error in Topology.MetricSpace.Baire: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_Union_of_closed
[nonempty Î±]
[encodable Î²]
{f : Î² â†’ set Î±}
(hc : âˆ€ s, is_closed (f s))
(hU : Â«expr = Â»(Â«exprâ‹ƒ , Â»((s), f s), univ)) : Â«exprâˆƒ , Â»((s), Â«expr $ Â»(interior, f s).nonempty) :=
begin
  by_contradiction [ident h],
  simp [] [] ["only"] ["[", expr not_exists, ",", expr not_nonempty_iff_eq_empty, "]"] [] ["at", ident h],
  have [] [] [":=", expr calc
     Â«expr = Â»(Â«exprâˆ…Â»(), closure Â«exprâ‹ƒ , Â»((s), interior (f s))) : by simp [] [] [] ["[", expr h, "]"] [] []
     Â«expr = Â»(..., univ) : (dense_Union_interior_of_closed hc hU).closure_eq],
  exact [expr univ_nonempty.ne_empty this.symm]
end

end BaireTheorem

