/-
Copyright (c) 2019 SÃ©bastien GouÃ«zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel
-/
import Mathbin.Analysis.SpecificLimits
import Mathbin.Order.Filter.CountableInter
import Mathbin.Topology.GDelta

/-!
# Baire theorem

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a GÎ´ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense GÎ´ sets is a dense GÎ´ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

The names of the theorems do not contain the string "Baire", but are instead built from the form of
the statement. "Baire" is however in the docstring of all the theorems, to facilitate grep searches.

We also define the filter `residual Î±` generated by dense `GÎ´` sets and prove that this filter
has the countable intersection property.
-/


noncomputable section

open_locale Classical TopologicalSpace Filter Ennreal

open Filter Encodable Set

variable {Î± : Type _} {Î² : Type _} {Î³ : Type _} {Î¹ : Type _}

section BaireTheorem

open Emetric Ennreal

variable [PseudoEmetricSpace Î±] [CompleteSpace Î±]

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here when
the source space is â„• (and subsumed below by `dense_Inter_of_open` working with any
encodable source space). -/
theorem dense_Inter_of_open_nat {f : â„• â†’ Set Î±} (ho : âˆ€ n, IsOpen (f n)) (hd : âˆ€ n, Dense (f n)) : Dense (â‹‚ n, f n) :=
  by
  let B : â„• â†’ â„â‰¥0âˆ := fun n => 1 / 2 ^ n
  have Bpos : âˆ€ n, 0 < B n := by
    intro n
    simp only [B, one_div, one_mulâ‚“, Ennreal.inv_pos]
    exact pow_ne_top two_ne_top
  /- Translate the density assumption into two functions `center` and `radius` associating
    to any n, x, Î´, Î´pos a center and a positive radius such that
    `closed_ball center radius` is included both in `f n` and in `closed_ball x Î´`.
    We can also require `radius â‰¤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
  have : âˆ€ n x Î´, Î´ â‰  0 â†’ âˆƒ y r, 0 < r âˆ§ r â‰¤ B (n + 1) âˆ§ closed_ball y r âŠ† closed_ball x Î´ âˆ© f n := by
    intro n x Î´ Î´pos
    have : x âˆˆ Closure (f n) := hd n x
    rcases Emetric.mem_closure_iff.1 this (Î´ / 2) (Ennreal.half_pos Î´pos) with âŸ¨y, ys, xyâŸ©
    rw [edist_comm] at xy
    obtain âŸ¨r, rpos, hrâŸ© : âˆƒ r > 0, closed_ball y r âŠ† f n :=
      nhds_basis_closed_eball.mem_iff.1 (is_open_iff_mem_nhds.1 (ho n) y ys)
    refine' âŸ¨y, min (min (Î´ / 2) r) (B (n + 1)), _, _, fun z hz => âŸ¨_, _âŸ©âŸ©
    show 0 < min (min (Î´ / 2) r) (B (n + 1))
    exact lt_minâ‚“ (lt_minâ‚“ (Ennreal.half_pos Î´pos) rpos) (Bpos (n + 1))
    show min (min (Î´ / 2) r) (B (n + 1)) â‰¤ B (n + 1)
    exact min_le_rightâ‚“ _ _
    show z âˆˆ closed_ball x Î´
    exact
      calc
        edist z x â‰¤ edist z y + edist y x := edist_triangle _ _ _
        _ â‰¤ min (min (Î´ / 2) r) (B (n + 1)) + Î´ / 2 := add_le_add hz (le_of_ltâ‚“ xy)
        _ â‰¤ Î´ / 2 + Î´ / 2 := add_le_add (le_transâ‚“ (min_le_leftâ‚“ _ _) (min_le_leftâ‚“ _ _)) le_rfl
        _ = Î´ := Ennreal.add_halves Î´
        
    show z âˆˆ f n
    exact
      hr
        (calc
          edist z y â‰¤ min (min (Î´ / 2) r) (B (n + 1)) := hz
          _ â‰¤ r := le_transâ‚“ (min_le_leftâ‚“ _ _) (min_le_rightâ‚“ _ _)
          )
  choose! center radius Hpos HB Hball using this
  refine' fun x => (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 fun Îµ Îµpos => _
  /- `Îµ` is positive. We have to find a point in the ball of radius `Îµ` around `x` belonging to all
    `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed ball
    `closed_ball (c n) (r n)` is included in the previous ball and in `f n`, and such that
    `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a
    limit which belongs to all the `f n`. -/
  let F : â„• â†’ Î± Ã— â„â‰¥0âˆ := fun n =>
    Nat.recOn n (Prod.mk x (min Îµ (B 0))) fun n p => Prod.mk (center n p.1 p.2) (radius n p.1 p.2)
  let c : â„• â†’ Î± := fun n => (F n).1
  let r : â„• â†’ â„â‰¥0âˆ := fun n => (F n).2
  have rpos : âˆ€ n, 0 < r n := by
    intro n
    induction' n with n hn
    exact lt_minâ‚“ Îµpos (Bpos 0)
    exact Hpos n (c n) (r n) hn.ne'
  have r0 : âˆ€ n, r n â‰  0 := fun n => (rpos n).ne'
  have rB : âˆ€ n, r n â‰¤ B n := by
    intro n
    induction' n with n hn
    exact min_le_rightâ‚“ _ _
    exact HB n (c n) (r n) (r0 n)
  have incl : âˆ€ n, closed_ball (c (n + 1)) (r (n + 1)) âŠ† closed_ball (c n) (r n) âˆ© f n := fun n =>
    Hball n (c n) (r n) (r0 n)
  have cdist : âˆ€ n, edist (c n) (c (n + 1)) â‰¤ B n := by
    intro n
    rw [edist_comm]
    have A : c (n + 1) âˆˆ closed_ball (c (n + 1)) (r (n + 1)) := mem_closed_ball_self
    have I :=
      calc
        closed_ball (c (n + 1)) (r (n + 1)) âŠ† closed_ball (c n) (r n) := subset.trans (incl n) (inter_subset_left _ _)
        _ âŠ† closed_ball (c n) (B n) := closed_ball_subset_closed_ball (rB n)
        
    exact I A
  have : CauchySeq c := cauchy_seq_of_edist_le_geometric_two _ one_ne_top cdist
  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.
  rcases cauchy_seq_tendsto_of_complete this with âŸ¨y, ylimâŸ©
  -- this point `y` will be the desired point. We will check that it belongs to all
  -- `f n` and to `ball x Îµ`.
  use y
  simp only [exists_prop, Set.mem_Inter]
  have I : âˆ€ n, âˆ€, âˆ€ m â‰¥ n, âˆ€, closed_ball (c m) (r m) âŠ† closed_ball (c n) (r n) := by
    intro n
    refine' Nat.le_induction _ fun m hnm h => _
    Â· exact subset.refl _
      
    Â· exact subset.trans (incl m) (subset.trans (inter_subset_left _ _) h)
      
  have yball : âˆ€ n, y âˆˆ closed_ball (c n) (r n) := by
    intro n
    refine' is_closed_ball.mem_of_tendsto ylim _
    refine' (Filter.eventually_ge_at_top n).mono fun m hm => _
    exact I n m hm mem_closed_ball_self
  constructor
  show âˆ€ n, y âˆˆ f n
  Â· intro n
    have : closed_ball (c (n + 1)) (r (n + 1)) âŠ† f n := subset.trans (incl n) (inter_subset_right _ _)
    exact this (yball (n + 1))
    
  show edist y x â‰¤ Îµ
  exact le_transâ‚“ (yball 0) (min_le_leftâ‚“ _ _)

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/
theorem dense_sInter_of_open {S : Set (Set Î±)} (ho : âˆ€, âˆ€ s âˆˆ S, âˆ€, IsOpen s) (hS : Countable S)
    (hd : âˆ€, âˆ€ s âˆˆ S, âˆ€, Dense s) : Dense (â‹‚â‚€ S) := by
  cases' S.eq_empty_or_nonempty with h h
  Â· simp [h]
    
  Â· rcases hS.exists_surjective h with âŸ¨f, hfâŸ©
    have F : âˆ€ n, f n âˆˆ S := fun n => by
      rw [hf] <;> exact mem_range_self _
    rw [hf, sInter_range]
    exact dense_Inter_of_open_nat (fun n => ho _ (F n)) fun n => hd _ (F n)
    

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_open {S : Set Î²} {f : Î² â†’ Set Î±} (ho : âˆ€, âˆ€ s âˆˆ S, âˆ€, IsOpen (f s)) (hS : Countable S)
    (hd : âˆ€, âˆ€ s âˆˆ S, âˆ€, Dense (f s)) : Dense (â‹‚ s âˆˆ S, f s) := by
  rw [â† sInter_image]
  apply dense_sInter_of_open
  Â· rwa [ball_image_iff]
    
  Â· exact hS.image _
    
  Â· rwa [ball_image_iff]
    

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_open [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ s, IsOpen (f s)) (hd : âˆ€ s, Dense (f s)) :
    Dense (â‹‚ s, f s) := by
  rw [â† sInter_range]
  apply dense_sInter_of_open
  Â· rwa [forall_range_iff]
    
  Â· exact countable_range _
    
  Â· rwa [forall_range_iff]
    

/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/
theorem dense_sInter_of_GÎ´ {S : Set (Set Î±)} (ho : âˆ€, âˆ€ s âˆˆ S, âˆ€, IsGÎ´ s) (hS : Countable S)
    (hd : âˆ€, âˆ€ s âˆˆ S, âˆ€, Dense s) : Dense (â‹‚â‚€ S) := by
  -- the result follows from the result for a countable intersection of dense open sets,
  -- by rewriting each set as a countable intersection of open sets, which are of course dense.
  choose T hTo hTc hsT using ho
  have : â‹‚â‚€ S = â‹‚â‚€ â‹ƒ s âˆˆ S, T s â€¹_â€º := by
    -- := (sInter_bUnion (Î»s hs, (hT s hs).2.2)).symm,
    simp only [sInter_Union, (hsT _ _).symm, â† sInter_eq_bInter]
  rw [this]
  refine' dense_sInter_of_open _ (hS.bUnion hTc) _ <;> simp only [mem_Union] <;> rintro t âŸ¨s, hs, tTsâŸ©
  show IsOpen t
  exact hTo s hs t tTs
  show Dense t
  Â· intro x
    have := hd s hs x
    rw [hsT s hs] at this
    exact closure_mono (sInter_subset_of_mem tTs) this
    

/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_GÎ´ [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ s, IsGÎ´ (f s)) (hd : âˆ€ s, Dense (f s)) :
    Dense (â‹‚ s, f s) := by
  rw [â† sInter_range]
  exact dense_sInter_of_GÎ´ (forall_range_iff.2 â€¹_â€º) (countable_range _) (forall_range_iff.2 â€¹_â€º)

/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_GÎ´ {S : Set Î²} {f : âˆ€, âˆ€ x âˆˆ S, âˆ€, Set Î±} (ho : âˆ€, âˆ€ s âˆˆ S, âˆ€, IsGÎ´ (f s â€¹_â€º))
    (hS : Countable S) (hd : âˆ€, âˆ€ s âˆˆ S, âˆ€, Dense (f s â€¹_â€º)) : Dense (â‹‚ s âˆˆ S, f s â€¹_â€º) := by
  rw [bInter_eq_Inter]
  have := hS.to_encodable
  exact dense_Inter_of_GÎ´ (fun s => ho s s.2) fun s => hd s s.2

/-- Baire theorem: the intersection of two dense GÎ´ sets is dense. -/
theorem Dense.inter_of_GÎ´ {s t : Set Î±} (hs : IsGÎ´ s) (ht : IsGÎ´ t) (hsc : Dense s) (htc : Dense t) : Dense (s âˆ© t) :=
  by
  rw [inter_eq_Inter]
  apply dense_Inter_of_GÎ´ <;> simp [Bool.forall_bool, *]

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `GÎ´` set. -/
theorem eventually_residual {p : Î± â†’ Prop} :
    (âˆ€á¶  x in residual Î±, p x) â†” âˆƒ t : Set Î±, IsGÎ´ t âˆ§ Dense t âˆ§ âˆ€, âˆ€ x âˆˆ t, âˆ€, p x :=
  calc
    (âˆ€á¶  x in residual Î±, p x) â†” âˆ€á¶  x in â¨… (t : Set Î±) (ht : IsGÎ´ t âˆ§ Dense t), ğ“Ÿ t, p x := by
      simp only [residual, infi_and]
    _ â†” âˆƒ (t : Set Î±)(ht : IsGÎ´ t âˆ§ Dense t), âˆ€á¶  x in ğ“Ÿ t, p x :=
      mem_binfi_of_directed
        (fun tâ‚ hâ‚ tâ‚‚ hâ‚‚ =>
          âŸ¨tâ‚ âˆ© tâ‚‚, âŸ¨hâ‚.1.inter hâ‚‚.1, Dense.inter_of_GÎ´ hâ‚.1 hâ‚‚.1 hâ‚.2 hâ‚‚.2âŸ©, by
            simp âŸ©)
        âŸ¨Univ, is_GÎ´_univ, dense_univâŸ©
    _ â†” _ := by
      simp [and_assoc]
    

-- ././Mathport/Syntax/Translate/Basic.lean:598:2: warning: expanding binder collection (t Â«expr âŠ† Â» s)
/-- A set is residual (comeagre) if and only if it includes a dense `GÎ´` set. -/
theorem mem_residual {s : Set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : _)(_ : t âŠ† s), IsGÎ´ t âˆ§ Dense t :=
  (@eventually_residual Î± _ _ fun x => x âˆˆ s).trans <|
    exists_congr fun t => by
      rw [exists_prop, and_comm (t âŠ† s), subset_def, and_assoc]

theorem dense_of_mem_residual {s : Set Î±} (hs : s âˆˆ residual Î±) : Dense s :=
  let âŸ¨t, hts, _, hdâŸ© := mem_residual.1 hs
  hd.mono hts

instance : CountableInterFilter (residual Î±) :=
  âŸ¨by
    intro S hSc hS
    simp only [mem_residual] at *
    choose T hTs hT using hS
    refine' âŸ¨â‹‚ s âˆˆ S, T s â€¹_â€º, _, _, _âŸ©
    Â· rw [sInter_eq_bInter]
      exact Interâ‚‚_mono hTs
      
    Â· exact is_GÎ´_bInter hSc fun s hs => (hT s hs).1
      
    Â· exact dense_bInter_of_GÎ´ (fun s hs => (hT s hs).1) hSc fun s hs => (hT s hs).2
      âŸ©

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bUnion_interior_of_closed {S : Set Î²} {f : Î² â†’ Set Î±} (hc : âˆ€, âˆ€ s âˆˆ S, âˆ€, IsClosed (f s))
    (hS : Countable S) (hU : (â‹ƒ s âˆˆ S, f s) = univ) : Dense (â‹ƒ s âˆˆ S, Interior (f s)) := by
  let g := fun s => Frontier (f s)á¶œ
  have : Dense (â‹‚ s âˆˆ S, g s) := by
    refine' dense_bInter_of_open (fun s hs => _) hS fun s hs => _
    show IsOpen (g s)
    exact is_open_compl_iff.2 is_closed_frontier
    show Dense (g s)
    Â· intro x
      simp [interior_frontier (hc s hs)]
      
  refine' this.mono _
  show (â‹‚ s âˆˆ S, g s) âŠ† â‹ƒ s âˆˆ S, Interior (f s)
  intro x hx
  have : x âˆˆ â‹ƒ s âˆˆ S, f s := by
    have := mem_univ x
    rwa [â† hU] at this
  rcases mem_Unionâ‚‚.1 this with âŸ¨s, hs, xsâŸ©
  have : x âˆˆ g s := mem_Interâ‚‚.1 hx s hs
  have : x âˆˆ Interior (f s) := by
    have : x âˆˆ f s \ Frontier (f s) := mem_inter xs this
    simpa [Frontier, xs, (hc s hs).closure_eq] using this
  exact mem_Unionâ‚‚.2 âŸ¨s, âŸ¨hs, thisâŸ©âŸ©

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `â‹ƒâ‚€`. -/
theorem dense_sUnion_interior_of_closed {S : Set (Set Î±)} (hc : âˆ€, âˆ€ s âˆˆ S, âˆ€, IsClosed s) (hS : Countable S)
    (hU : â‹ƒâ‚€S = univ) : Dense (â‹ƒ s âˆˆ S, Interior s) := by
  rw [sUnion_eq_bUnion] at hU <;> exact dense_bUnion_interior_of_closed hc hS hU

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_Union_interior_of_closed [Encodable Î²] {f : Î² â†’ Set Î±} (hc : âˆ€ s, IsClosed (f s))
    (hU : (â‹ƒ s, f s) = univ) : Dense (â‹ƒ s, Interior (f s)) := by
  rw [â† bUnion_univ]
  apply dense_bUnion_interior_of_closed
  Â· simp [hc]
    
  Â· apply countable_encodable
    
  Â· rwa [â† bUnion_univ] at hU
    

/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_Union_of_closed [Nonempty Î±] [Encodable Î²] {f : Î² â†’ Set Î±} (hc : âˆ€ s, IsClosed (f s))
    (hU : (â‹ƒ s, f s) = univ) : âˆƒ s, (Interior <| f s).Nonempty := by
  by_contra h
  simp only [not_exists, not_nonempty_iff_eq_empty] at h
  have :=
    calc
      âˆ… = Closure (â‹ƒ s, Interior (f s)) := by
        simp [h]
      _ = univ := (dense_Union_interior_of_closed hc hU).closure_eq
      
  exact univ_nonempty.ne_empty this.symm

end BaireTheorem

