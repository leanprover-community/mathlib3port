/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot

! This file was ported from Lean 3 source module topology.algebra.filter_basis
! leanprover-community/mathlib commit 19cb3751e5e9b3d97adb51023949c50c13b5fdfd
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Order.Filter.Bases
import Mathbin.Topology.Algebra.Module.Basic

/-!
# Group and ring filter bases

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

A `group_filter_basis` is a `filter_basis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `group_filter_basis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

## Main definitions and results

Given a group `G` and a ring `R`:

* `group_filter_basis G`: the type of filter bases that will become neighborhood of `1`
  for a topology on `G` compatible with the group structure
* `group_filter_basis.topology`: the associated topology
* `group_filter_basis.is_topological_group`: the compatibility between the above topology
  and the group structure
* `ring_filter_basis R`: the type of filter bases that will become neighborhood of `0`
  for a topology on `R` compatible with the ring structure
* `ring_filter_basis.topology`: the associated topology
* `ring_filter_basis.is_topological_ring`: the compatibility between the above topology
  and the ring structure

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]
-/


open Filter Set TopologicalSpace Function

open Topology Filter Pointwise

universe u

#print GroupFilterBasis /-
/-- A `group_filter_basis` on a group is a `filter_basis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `group_filter_basis`. Conversely given a `group_filter_basis` one can define a topology
  compatible with the group structure on `G`.  -/
class GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where
  one' : âˆ€ {U}, U âˆˆ sets â†’ (1 : G) âˆˆ U
  mul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V * V âŠ† U
  inv' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x => xâ»Â¹) â»Â¹' U
  conj' : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x => xâ‚€ * x * xâ‚€â»Â¹) â»Â¹' U
#align group_filter_basis GroupFilterBasis
-/

#print AddGroupFilterBasis /-
/-- A `add_group_filter_basis` on an additive group is a `filter_basis` satisfying some additional
  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `add_group_filter_basis`. Conversely given a `add_group_filter_basis` one can define a topology
  compatible with the group structure on `G`. -/
class AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where
  zero' : âˆ€ {U}, U âˆˆ sets â†’ (0 : A) âˆˆ U
  add' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V + V âŠ† U
  neg' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x => -x) â»Â¹' U
  conj' : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x => xâ‚€ + x + -xâ‚€) â»Â¹' U
#align add_group_filter_basis AddGroupFilterBasis
-/

attribute [to_additive] GroupFilterBasis

attribute [to_additive] GroupFilterBasis.one'

attribute [to_additive] GroupFilterBasis.mul'

attribute [to_additive] GroupFilterBasis.inv'

attribute [to_additive] GroupFilterBasis.conj'

attribute [to_additive] GroupFilterBasis.toFilterBasis

/- warning: group_filter_basis_of_comm -> groupFilterBasisOfComm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : CommGroup.{u1} G] (sets : Set.{u1} (Set.{u1} G)), (Set.Nonempty.{u1} (Set.{u1} G) sets) -> (forall (x : Set.{u1} G) (y : Set.{u1} G), (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) x sets) -> (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) y sets) -> (Exists.{succ u1} (Set.{u1} G) (fun (z : Set.{u1} G) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) z sets) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) z sets) => HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) z (Inter.inter.{u1} (Set.{u1} G) (Set.hasInter.{u1} G) x y))))) -> (forall (U : Set.{u1} G), (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) U sets) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))))) U)) -> (forall (U : Set.{u1} G), (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) U sets) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) V sets) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) V sets) => HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))))) V V) U)))) -> (forall (U : Set.{u1} G), (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) U sets) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) V sets) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.hasMem.{u1} (Set.{u1} G)) V sets) => HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) V (Set.preimage.{u1, u1} G G (fun (x : G) => Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))) x) U))))) -> (GroupFilterBasis.{u1} G (CommGroup.toGroup.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : CommGroup.{u1} G] (sets : Set.{u1} (Set.{u1} G)), (Set.Nonempty.{u1} (Set.{u1} G) sets) -> (forall (x : Set.{u1} G) (y : Set.{u1} G), (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) x sets) -> (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) y sets) -> (Exists.{succ u1} (Set.{u1} G) (fun (z : Set.{u1} G) => And (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) z sets) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) z (Inter.inter.{u1} (Set.{u1} G) (Set.instInterSet.{u1} G) x y))))) -> (forall (U : Set.{u1} G), (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) U sets) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (DivisionCommMonoid.toDivisionMonoid.{u1} G (CommGroup.toDivisionCommMonoid.{u1} G _inst_1))))))) U)) -> (forall (U : Set.{u1} G), (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) U sets) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => And (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) V sets) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))))) V V) U)))) -> (forall (U : Set.{u1} G), (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) U sets) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => And (Membership.mem.{u1, u1} (Set.{u1} G) (Set.{u1} (Set.{u1} G)) (Set.instMembershipSet.{u1} (Set.{u1} G)) V sets) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) V (Set.preimage.{u1, u1} G G (fun (x : G) => Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (DivisionCommMonoid.toDivisionMonoid.{u1} G (CommGroup.toDivisionCommMonoid.{u1} G _inst_1))))) x) U))))) -> (GroupFilterBasis.{u1} G (CommGroup.toGroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align group_filter_basis_of_comm groupFilterBasisOfCommâ‚“'. -/
/-- `group_filter_basis` constructor in the commutative group case. -/
@[to_additive "`add_group_filter_basis` constructor in the additive commutative group case."]
def groupFilterBasisOfComm {G : Type _} [CommGroup G] (sets : Set (Set G))
    (nonempty : sets.Nonempty) (inter_sets : âˆ€ x y, x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y)
    (one : âˆ€ U âˆˆ sets, (1 : G) âˆˆ U) (mul : âˆ€ U âˆˆ sets, âˆƒ V âˆˆ sets, V * V âŠ† U)
    (inv : âˆ€ U âˆˆ sets, âˆƒ V âˆˆ sets, V âŠ† (fun x => xâ»Â¹) â»Â¹' U) : GroupFilterBasis G :=
  { sets
    Nonempty
    inter_sets
    one' := one
    mul' := mul
    inv' := inv
    conj' := fun x U U_in => âŸ¨U, U_in, by simpâŸ© }
#align group_filter_basis_of_comm groupFilterBasisOfComm
#align add_group_filter_basis_of_comm addGroupFilterBasisOfComm

namespace GroupFilterBasis

variable {G : Type u} [Group G] {B : GroupFilterBasis G}

@[to_additive]
instance : Membership (Set G) (GroupFilterBasis G) :=
  âŸ¨fun s f => s âˆˆ f.setsâŸ©

/- warning: group_filter_basis.one -> GroupFilterBasis.one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} {U : Set.{u1} G}, (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) U B) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) U)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} {U : Set.{u1} G}, (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) U B) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))) U)
Case conversion may be inaccurate. Consider using '#align group_filter_basis.one GroupFilterBasis.oneâ‚“'. -/
@[to_additive]
theorem one {U : Set G} : U âˆˆ B â†’ (1 : G) âˆˆ U :=
  GroupFilterBasis.one'
#align group_filter_basis.one GroupFilterBasis.one
#align add_group_filter_basis.zero AddGroupFilterBasis.zero

/- warning: group_filter_basis.mul -> GroupFilterBasis.mul is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} {U : Set.{u1} G}, (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) => HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) V V) U)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} {U : Set.{u1} G}, (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => And (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) V B) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) V V) U)))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.mul GroupFilterBasis.mulâ‚“'. -/
@[to_additive]
theorem mul {U : Set G} : U âˆˆ B â†’ âˆƒ V âˆˆ B, V * V âŠ† U :=
  GroupFilterBasis.mul'
#align group_filter_basis.mul GroupFilterBasis.mul
#align add_group_filter_basis.add AddGroupFilterBasis.add

/- warning: group_filter_basis.inv -> GroupFilterBasis.inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} {U : Set.{u1} G}, (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) => HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) V (Set.preimage.{u1, u1} G G (fun (x : G) => Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) U))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} {U : Set.{u1} G}, (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => And (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) V B) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) V (Set.preimage.{u1, u1} G G (fun (x : G) => Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) U))))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.inv GroupFilterBasis.invâ‚“'. -/
@[to_additive]
theorem inv {U : Set G} : U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† (fun x => xâ»Â¹) â»Â¹' U :=
  GroupFilterBasis.inv'
#align group_filter_basis.inv GroupFilterBasis.inv
#align add_group_filter_basis.neg AddGroupFilterBasis.neg

/- warning: group_filter_basis.conj -> GroupFilterBasis.conj is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} (xâ‚€ : G) {U : Set.{u1} G}, (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) => HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) V (Set.preimage.{u1, u1} G G (fun (x : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) xâ‚€ x) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) xâ‚€)) U))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {B : GroupFilterBasis.{u1} G _inst_1} (xâ‚€ : G) {U : Set.{u1} G}, (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} G) (fun (V : Set.{u1} G) => And (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) V B) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) V (Set.preimage.{u1, u1} G G (fun (x : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) xâ‚€ x) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) xâ‚€)) U))))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.conj GroupFilterBasis.conjâ‚“'. -/
@[to_additive]
theorem conj : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† (fun x => xâ‚€ * x * xâ‚€â»Â¹) â»Â¹' U :=
  GroupFilterBasis.conj'
#align group_filter_basis.conj GroupFilterBasis.conj
#align add_group_filter_basis.conj AddGroupFilterBasis.conj

/-- The trivial group filter basis consists of `{1}` only. The associated topology
is discrete. -/
@[to_additive
      "The trivial additive group filter basis consists of `{0}` only. The associated\ntopology is discrete."]
instance : Inhabited (GroupFilterBasis G) :=
  âŸ¨by
    refine'
      { sets := {{1}}
        Nonempty := singleton_nonempty _.. }
    all_goals simp only [exists_prop, mem_singleton_iff]
    Â· rintro - - rfl rfl
      use {1}
      simp
    Â· simp
    Â· rintro - rfl
      use {1}
      simp
    Â· rintro - rfl
      use {1}
      simp
    Â· rintro xâ‚€ - rfl
      use {1}
      simpâŸ©

/- warning: group_filter_basis.prod_subset_self -> GroupFilterBasis.prod_subset_self is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) {U : Set.{u1} G}, (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) U B) -> (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) U (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) U U))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) {U : Set.{u1} G}, (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) U B) -> (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) U (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) U U))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.prod_subset_self GroupFilterBasis.prod_subset_selfâ‚“'. -/
@[to_additive]
theorem prod_subset_self (B : GroupFilterBasis G) {U : Set G} (h : U âˆˆ B) : U âŠ† U * U :=
  fun x x_in => âŸ¨1, x, one h, x_in, one_mul xâŸ©
#align group_filter_basis.prod_subset_self GroupFilterBasis.prod_subset_self
#align add_group_filter_basis.sum_subset_self AddGroupFilterBasis.sum_subset_self

#print GroupFilterBasis.N /-
/-- The neighborhood function of a `group_filter_basis` -/
@[to_additive "The neighborhood function of a `add_group_filter_basis`"]
def N (B : GroupFilterBasis G) : G â†’ Filter G := fun x =>
  map (fun y => x * y) B.toFilterBasis.filterâ‚“
#align group_filter_basis.N GroupFilterBasis.N
#align add_group_filter_basis.N AddGroupFilterBasis.N
-/

/- warning: group_filter_basis.N_one -> GroupFilterBasis.N_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1), Eq.{succ u1} (Filter.{u1} G) (GroupFilterBasis.N.{u1} G _inst_1 B (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (FilterBasis.filter.{u1} G (GroupFilterBasis.toFilterBasis.{u1} G _inst_1 B))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1), Eq.{succ u1} (Filter.{u1} G) (GroupFilterBasis.N.{u1} G _inst_1 B (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) (FilterBasis.filter.{u1} G (GroupFilterBasis.toFilterBasis.{u1} G _inst_1 B))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.N_one GroupFilterBasis.N_oneâ‚“'. -/
@[simp, to_additive]
theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filterâ‚“ := by
  simp only [N, one_mul, map_id']
#align group_filter_basis.N_one GroupFilterBasis.N_one
#align add_group_filter_basis.N_zero AddGroupFilterBasis.N_zero

/- warning: group_filter_basis.has_basis -> GroupFilterBasis.hasBasis is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) (x : G), Filter.HasBasis.{u1, succ u1} G (Set.{u1} G) (GroupFilterBasis.N.{u1} G _inst_1 B x) (fun (V : Set.{u1} G) => Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) (fun (V : Set.{u1} G) => Set.image.{u1, u1} G G (fun (y : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) V)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) (x : G), Filter.HasBasis.{u1, succ u1} G (Set.{u1} G) (GroupFilterBasis.N.{u1} G _inst_1 B x) (fun (V : Set.{u1} G) => Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) V B) (fun (V : Set.{u1} G) => Set.image.{u1, u1} G G (fun (y : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) V)
Case conversion may be inaccurate. Consider using '#align group_filter_basis.has_basis GroupFilterBasis.hasBasisâ‚“'. -/
@[to_additive]
protected theorem hasBasis (B : GroupFilterBasis G) (x : G) :
    HasBasis (B.N x) (fun V : Set G => V âˆˆ B) fun V => (fun y => x * y) '' V :=
  HasBasis.map (fun y => x * y) toFilterBasis.HasBasis
#align group_filter_basis.has_basis GroupFilterBasis.hasBasis
#align add_group_filter_basis.has_basis AddGroupFilterBasis.hasBasis

#print GroupFilterBasis.topology /-
/-- The topological space structure coming from a group filter basis. -/
@[to_additive "The topological space structure coming from an additive group filter basis."]
def topology (B : GroupFilterBasis G) : TopologicalSpace G :=
  TopologicalSpace.mkOfNhds B.N
#align group_filter_basis.topology GroupFilterBasis.topology
#align add_group_filter_basis.topology AddGroupFilterBasis.topology
-/

#print GroupFilterBasis.nhds_eq /-
@[to_additive]
theorem nhds_eq (B : GroupFilterBasis G) {xâ‚€ : G} : @nhds G B.topology xâ‚€ = B.N xâ‚€ :=
  by
  rw [TopologicalSpace.nhds_mkOfNhds]
  Â· intro x U U_in
    rw [(B.has_basis x).mem_iff] at U_in
    rcases U_in with âŸ¨V, V_in, HâŸ©
    simpa [mem_pure] using H (mem_image_of_mem _ (GroupFilterBasis.one V_in))
  Â· intro x U U_in
    rw [(B.has_basis x).mem_iff] at U_in
    rcases U_in with âŸ¨V, V_in, HâŸ©
    rcases GroupFilterBasis.mul V_in with âŸ¨W, W_in, hWâŸ©
    use (fun y => x * y) '' W, image_mem_map (FilterBasis.mem_filter_of_mem _ W_in)
    constructor
    Â· rw [image_subset_iff] at HâŠ¢
      exact ((B.prod_subset_self W_in).trans hW).trans H
    Â· rintro y âŸ¨t, tW, rflâŸ©
      rw [(B.has_basis _).mem_iff]
      use W, W_in
      apply subset.trans _ H
      clear H
      rintro z âŸ¨w, wW, rflâŸ©
      exact âŸ¨t * w, hW (mul_mem_mul tW wW), by simp [mul_assoc]âŸ©
#align group_filter_basis.nhds_eq GroupFilterBasis.nhds_eq
#align add_group_filter_basis.nhds_eq AddGroupFilterBasis.nhds_eq
-/

/- warning: group_filter_basis.nhds_one_eq -> GroupFilterBasis.nhds_one_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1), Eq.{succ u1} (Filter.{u1} G) (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (FilterBasis.filter.{u1} G (GroupFilterBasis.toFilterBasis.{u1} G _inst_1 B))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1), Eq.{succ u1} (Filter.{u1} G) (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) (FilterBasis.filter.{u1} G (GroupFilterBasis.toFilterBasis.{u1} G _inst_1 B))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.nhds_one_eq GroupFilterBasis.nhds_one_eqâ‚“'. -/
@[to_additive]
theorem nhds_one_eq (B : GroupFilterBasis G) :
    @nhds G B.topology (1 : G) = B.toFilterBasis.filterâ‚“ :=
  by
  rw [B.nhds_eq]
  simp only [N, one_mul]
  exact map_id
#align group_filter_basis.nhds_one_eq GroupFilterBasis.nhds_one_eq
#align add_group_filter_basis.nhds_zero_eq AddGroupFilterBasis.nhds_zero_eq

/- warning: group_filter_basis.nhds_has_basis -> GroupFilterBasis.nhds_hasBasis is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) (xâ‚€ : G), Filter.HasBasis.{u1, succ u1} G (Set.{u1} G) (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) xâ‚€) (fun (V : Set.{u1} G) => Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) (fun (V : Set.{u1} G) => Set.image.{u1, u1} G G (fun (y : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) xâ‚€ y) V)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) (xâ‚€ : G), Filter.HasBasis.{u1, succ u1} G (Set.{u1} G) (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) xâ‚€) (fun (V : Set.{u1} G) => Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) V B) (fun (V : Set.{u1} G) => Set.image.{u1, u1} G G (fun (y : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) xâ‚€ y) V)
Case conversion may be inaccurate. Consider using '#align group_filter_basis.nhds_has_basis GroupFilterBasis.nhds_hasBasisâ‚“'. -/
@[to_additive]
theorem nhds_hasBasis (B : GroupFilterBasis G) (xâ‚€ : G) :
    HasBasis (@nhds G B.topology xâ‚€) (fun V : Set G => V âˆˆ B) fun V => (fun y => xâ‚€ * y) '' V :=
  by
  rw [B.nhds_eq]
  apply B.has_basis
#align group_filter_basis.nhds_has_basis GroupFilterBasis.nhds_hasBasis
#align add_group_filter_basis.nhds_has_basis AddGroupFilterBasis.nhds_hasBasis

/- warning: group_filter_basis.nhds_one_has_basis -> GroupFilterBasis.nhds_one_hasBasis is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1), Filter.HasBasis.{u1, succ u1} G (Set.{u1} G) (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (fun (V : Set.{u1} G) => Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) V B) (id.{succ u1} (Set.{u1} G))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1), Filter.HasBasis.{u1, succ u1} G (Set.{u1} G) (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) (fun (V : Set.{u1} G) => Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) V B) (id.{succ u1} (Set.{u1} G))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.nhds_one_has_basis GroupFilterBasis.nhds_one_hasBasisâ‚“'. -/
@[to_additive]
theorem nhds_one_hasBasis (B : GroupFilterBasis G) :
    HasBasis (@nhds G B.topology 1) (fun V : Set G => V âˆˆ B) id :=
  by
  rw [B.nhds_one_eq]
  exact B.to_filter_basis.has_basis
#align group_filter_basis.nhds_one_has_basis GroupFilterBasis.nhds_one_hasBasis
#align add_group_filter_basis.nhds_zero_has_basis AddGroupFilterBasis.nhds_zero_hasBasis

/- warning: group_filter_basis.mem_nhds_one -> GroupFilterBasis.mem_nhds_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) {U : Set.{u1} G}, (Membership.Mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.hasMem.{u1} G _inst_1) U B) -> (Membership.Mem.{u1, u1} (Set.{u1} G) (Filter.{u1} G) (Filter.hasMem.{u1} G) U (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (B : GroupFilterBasis.{u1} G _inst_1) {U : Set.{u1} G}, (Membership.mem.{u1, u1} (Set.{u1} G) (GroupFilterBasis.{u1} G _inst_1) (GroupFilterBasis.instMembershipSetGroupFilterBasis.{u1} G _inst_1) U B) -> (Membership.mem.{u1, u1} (Set.{u1} G) (Filter.{u1} G) (instMembershipSetFilter.{u1} G) U (nhds.{u1} G (GroupFilterBasis.topology.{u1} G _inst_1 B) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align group_filter_basis.mem_nhds_one GroupFilterBasis.mem_nhds_oneâ‚“'. -/
@[to_additive]
theorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U âˆˆ B) : U âˆˆ @nhds G B.topology 1 :=
  by
  rw [B.nhds_one_has_basis.mem_iff]
  exact âŸ¨U, hU, rfl.subsetâŸ©
#align group_filter_basis.mem_nhds_one GroupFilterBasis.mem_nhds_one
#align add_group_filter_basis.mem_nhds_zero AddGroupFilterBasis.mem_nhds_zero

#print GroupFilterBasis.isTopologicalGroup /-
-- See note [lower instance priority]
/-- If a group is endowed with a topological structure coming from a group filter basis then it's a
topological group. -/
@[to_additive
      "If a group is endowed with a topological structure coming from a group filter basis\nthen it's a topological group."]
instance (priority := 100) isTopologicalGroup (B : GroupFilterBasis G) :
    @TopologicalGroup G B.topology _ := by
  letI := B.topology
  have basis := B.nhds_one_has_basis
  have basis' := Basis.prod Basis
  refine' TopologicalGroup.of_nhds_one _ _ _ _
  Â· rw [basis'.tendsto_iff Basis]
    suffices âˆ€ U âˆˆ B, âˆƒ V W, (V âˆˆ B âˆ§ W âˆˆ B) âˆ§ âˆ€ a b, a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U by simpa
    intro U U_in
    rcases mul U_in with âŸ¨V, V_in, hVâŸ©
    use V, V, V_in, V_in
    intro a b a_in b_in
    exact hV âŸ¨a, b, a_in, b_in, rflâŸ©
  Â· rw [basis.tendsto_iff Basis]
    intro U U_in
    simpa using inv U_in
  Â· intro xâ‚€
    rw [nhds_eq, nhds_one_eq]
    rfl
  Â· intro xâ‚€
    rw [basis.tendsto_iff Basis]
    intro U U_in
    exact conj xâ‚€ U_in
#align group_filter_basis.is_topological_group GroupFilterBasis.isTopologicalGroup
#align add_group_filter_basis.is_topological_add_group AddGroupFilterBasis.isTopologicalAddGroup
-/

end GroupFilterBasis

#print RingFilterBasis /-
/-- A `ring_filter_basis` on a ring is a `filter_basis` satisfying some additional axioms.
  Example : if `R` is a topological ring then the neighbourhoods of the identity are a
  `ring_filter_basis`. Conversely given a `ring_filter_basis` on a ring `R`, one can define a
  topology on `R` which is compatible with the ring structure.  -/
class RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where
  mul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V * V âŠ† U
  mul_left' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x => xâ‚€ * x) â»Â¹' U
  mul_right' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x => x * xâ‚€) â»Â¹' U
#align ring_filter_basis RingFilterBasis
-/

namespace RingFilterBasis

variable {R : Type u} [Ring R] (B : RingFilterBasis R)

instance : Membership (Set R) (RingFilterBasis R) :=
  âŸ¨fun s B => s âˆˆ B.setsâŸ©

/- warning: ring_filter_basis.mul -> RingFilterBasis.mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (B : RingFilterBasis.{u1} R _inst_1) {U : Set.{u1} R}, (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) V B) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) V B) => HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)))) V V) U)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (B : RingFilterBasis.{u1} R _inst_1) {U : Set.{u1} R}, (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => And (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R _inst_1) V B) (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) V V) U)))
Case conversion may be inaccurate. Consider using '#align ring_filter_basis.mul RingFilterBasis.mulâ‚“'. -/
theorem mul {U : Set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V * V âŠ† U :=
  mul' hU
#align ring_filter_basis.mul RingFilterBasis.mul

/- warning: ring_filter_basis.mul_left -> RingFilterBasis.mul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (B : RingFilterBasis.{u1} R _inst_1) (xâ‚€ : R) {U : Set.{u1} R}, (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) V B) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) V B) => HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) V (Set.preimage.{u1, u1} R R (fun (x : R) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1))) xâ‚€ x) U))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (B : RingFilterBasis.{u1} R _inst_1) (xâ‚€ : R) {U : Set.{u1} R}, (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => And (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R _inst_1) V B) (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) V (Set.preimage.{u1, u1} R R (fun (x : R) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) xâ‚€ x) U))))
Case conversion may be inaccurate. Consider using '#align ring_filter_basis.mul_left RingFilterBasis.mul_leftâ‚“'. -/
theorem mul_left (xâ‚€ : R) {U : Set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† (fun x => xâ‚€ * x) â»Â¹' U :=
  mul_left' xâ‚€ hU
#align ring_filter_basis.mul_left RingFilterBasis.mul_left

/- warning: ring_filter_basis.mul_right -> RingFilterBasis.mul_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (B : RingFilterBasis.{u1} R _inst_1) (xâ‚€ : R) {U : Set.{u1} R}, (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) V B) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.hasMem.{u1} R _inst_1) V B) => HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) V (Set.preimage.{u1, u1} R R (fun (x : R) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1))) x xâ‚€) U))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (B : RingFilterBasis.{u1} R _inst_1) (xâ‚€ : R) {U : Set.{u1} R}, (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R _inst_1) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => And (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R _inst_1) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R _inst_1) V B) (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) V (Set.preimage.{u1, u1} R R (fun (x : R) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) x xâ‚€) U))))
Case conversion may be inaccurate. Consider using '#align ring_filter_basis.mul_right RingFilterBasis.mul_rightâ‚“'. -/
theorem mul_right (xâ‚€ : R) {U : Set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† (fun x => x * xâ‚€) â»Â¹' U :=
  mul_right' xâ‚€ hU
#align ring_filter_basis.mul_right RingFilterBasis.mul_right

#print RingFilterBasis.topology /-
/-- The topology associated to a ring filter basis.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace R :=
  B.toAddGroupFilterBasis.topology
#align ring_filter_basis.topology RingFilterBasis.topology
-/

#print RingFilterBasis.isTopologicalRing /-
/-- If a ring is endowed with a topological structure coming from
a ring filter basis then it's a topological ring. -/
instance (priority := 100) isTopologicalRing {R : Type u} [Ring R] (B : RingFilterBasis R) :
    @TopologicalRing R B.topology _ :=
  by
  let B' := B.to_add_group_filter_basis
  letI := B'.topology
  have basis := B'.nhds_zero_has_basis
  have basis' := Basis.prod Basis
  haveI := B'.is_topological_add_group
  apply TopologicalRing.of_addGroup_of_nhds_zero
  Â· rw [basis'.tendsto_iff Basis]
    suffices âˆ€ U âˆˆ B', âˆƒ V W, (V âˆˆ B' âˆ§ W âˆˆ B') âˆ§ âˆ€ a b, a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U by simpa
    intro U U_in
    rcases B.mul U_in with âŸ¨V, V_in, hVâŸ©
    use V, V, V_in, V_in
    intro a b a_in b_in
    exact hV âŸ¨a, b, a_in, b_in, rflâŸ©
  Â· intro xâ‚€
    rw [basis.tendsto_iff Basis]
    intro U
    simpa using B.mul_left xâ‚€
  Â· intro xâ‚€
    rw [basis.tendsto_iff Basis]
    intro U
    simpa using B.mul_right xâ‚€
#align ring_filter_basis.is_topological_ring RingFilterBasis.isTopologicalRing
-/

end RingFilterBasis

#print ModuleFilterBasis /-
/-- A `module_filter_basis` on a module is a `filter_basis` satisfying some additional axioms.
  Example : if `M` is a topological module then the neighbourhoods of zero are a
  `module_filter_basis`. Conversely given a `module_filter_basis` one can define a topology
  compatible with the module structure on `M`.  -/
structure ModuleFilterBasis (R M : Type _) [CommRing R] [TopologicalSpace R] [AddCommGroup M]
  [Module R M] extends AddGroupFilterBasis M where
  smul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ ð“ (0 : R), âˆƒ W âˆˆ sets, V â€¢ W âŠ† U
  smul_left' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x => xâ‚€ â€¢ x) â»Â¹' U
  smul_right' : âˆ€ (mâ‚€ : M) {U}, U âˆˆ sets â†’ âˆ€á¶  x in ð“ (0 : R), x â€¢ mâ‚€ âˆˆ U
#align module_filter_basis ModuleFilterBasis
-/

namespace ModuleFilterBasis

variable {R M : Type _} [CommRing R] [TopologicalSpace R] [AddCommGroup M] [Module R M]
  (B : ModuleFilterBasis R M)

#print ModuleFilterBasis.GroupFilterBasis.hasMem /-
instance GroupFilterBasis.hasMem : Membership (Set M) (ModuleFilterBasis R M) :=
  âŸ¨fun s B => s âˆˆ B.setsâŸ©
#align module_filter_basis.group_filter_basis.has_mem ModuleFilterBasis.GroupFilterBasis.hasMem
-/

/- warning: module_filter_basis.smul -> ModuleFilterBasis.smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : TopologicalSpace.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (B : ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) {U : Set.{u2} M}, (Membership.Mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} R) (Filter.{u1} R) (Filter.hasMem.{u1} R) V (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (Filter.{u1} R) (Filter.hasMem.{u1} R) V (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))) => Exists.{succ u2} (Set.{u2} M) (fun (W : Set.{u2} M) => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) W B) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) W B) => HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) (SMul.smul.{u1, u2} (Set.{u1} R) (Set.{u2} M) (Set.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4))))) V W) U)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : TopologicalSpace.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (B : ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) {U : Set.{u2} M}, (Membership.mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) U B) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => And (Membership.mem.{u1, u1} (Set.{u1} R) (Filter.{u1} R) (instMembershipSetFilter.{u1} R) V (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) (Exists.{succ u2} (Set.{u2} M) (fun (W : Set.{u2} M) => And (Membership.mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) W B) (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) (HSMul.hSMul.{u1, u2, u2} (Set.{u1} R) (Set.{u2} M) (Set.{u2} M) (instHSMul.{u1, u2} (Set.{u1} R) (Set.{u2} M) (Set.smul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))))) V W) U)))))
Case conversion may be inaccurate. Consider using '#align module_filter_basis.smul ModuleFilterBasis.smulâ‚“'. -/
theorem smul {U : Set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ ð“ (0 : R), âˆƒ W âˆˆ B, V â€¢ W âŠ† U :=
  B.smul' hU
#align module_filter_basis.smul ModuleFilterBasis.smul

/- warning: module_filter_basis.smul_left -> ModuleFilterBasis.smul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : TopologicalSpace.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (B : ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (xâ‚€ : R) {U : Set.{u2} M}, (Membership.Mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) U B) -> (Exists.{succ u2} (Set.{u2} M) (fun (V : Set.{u2} M) => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) V B) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) V B) => HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) V (Set.preimage.{u2, u2} M M (fun (x : M) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))) xâ‚€ x) U))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : TopologicalSpace.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (B : ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (xâ‚€ : R) {U : Set.{u2} M}, (Membership.mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) U B) -> (Exists.{succ u2} (Set.{u2} M) (fun (V : Set.{u2} M) => And (Membership.mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) V B) (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) V (Set.preimage.{u2, u2} M M (fun (x : M) => HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4))))) xâ‚€ x) U))))
Case conversion may be inaccurate. Consider using '#align module_filter_basis.smul_left ModuleFilterBasis.smul_leftâ‚“'. -/
theorem smul_left (xâ‚€ : R) {U : Set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† (fun x => xâ‚€ â€¢ x) â»Â¹' U :=
  B.smul_left' xâ‚€ hU
#align module_filter_basis.smul_left ModuleFilterBasis.smul_left

/- warning: module_filter_basis.smul_right -> ModuleFilterBasis.smul_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : TopologicalSpace.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (B : ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (mâ‚€ : M) {U : Set.{u2} M}, (Membership.Mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) U B) -> (Filter.Eventually.{u1} R (fun (x : R) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))) x mâ‚€) U) (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : TopologicalSpace.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] (B : ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (mâ‚€ : M) {U : Set.{u2} M}, (Membership.mem.{u2, u2} (Set.{u2} M) (ModuleFilterBasis.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) (ModuleFilterBasis.GroupFilterBasis.hasMem.{u1, u2} R M _inst_1 _inst_2 _inst_3 _inst_4) U B) -> (Filter.Eventually.{u1} R (fun (x : R) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4))))) x mâ‚€) U) (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align module_filter_basis.smul_right ModuleFilterBasis.smul_rightâ‚“'. -/
theorem smul_right (mâ‚€ : M) {U : Set M} (hU : U âˆˆ B) : âˆ€á¶  x in ð“ (0 : R), x â€¢ mâ‚€ âˆˆ U :=
  B.smul_right' mâ‚€ hU
#align module_filter_basis.smul_right ModuleFilterBasis.smul_right

/-- If `R` is discrete then the trivial additive group filter basis on any `R`-module is a
module filter basis. -/
instance [DiscreteTopology R] : Inhabited (ModuleFilterBasis R M) :=
  âŸ¨{
      show AddGroupFilterBasis M from
        default with
      smul' := by
        rintro U (h : U âˆˆ {{(0 : M)}})
        rw [mem_singleton_iff] at h
        use univ, univ_mem, {0}, rfl
        rintro a âŸ¨x, m, -, hm, rflâŸ©
        simp [mem_singleton_iff.1 hm, h]
      smul_left' := by
        rintro xâ‚€ U (h : U âˆˆ {{(0 : M)}})
        rw [mem_singleton_iff] at h
        use {0}, rfl
        simp [h]
      smul_right' := by
        rintro mâ‚€ U (h : U âˆˆ (0 : Set (Set M)))
        rw [Set.mem_zero] at h
        simp [h, nhds_discrete] }âŸ©

#print ModuleFilterBasis.topology /-
/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace M :=
  B.toAddGroupFilterBasis.topology
#align module_filter_basis.topology ModuleFilterBasis.topology
-/

#print ModuleFilterBasis.topology' /-
/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. This version gets the ring
topology by unification instead of type class inference. -/
def topology' {R M : Type _} [CommRing R] {tR : TopologicalSpace R} [AddCommGroup M] [Module R M]
    (B : ModuleFilterBasis R M) : TopologicalSpace M :=
  B.toAddGroupFilterBasis.topology
#align module_filter_basis.topology' ModuleFilterBasis.topology'
-/

/- warning: has_continuous_smul.of_basis_zero -> ContinuousSMul.of_basis_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : TopologicalSpace.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] {Î¹ : Type.{u3}} [_inst_5 : TopologicalRing.{u1} R _inst_2 (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))] [_inst_6 : TopologicalSpace.{u2} M] [_inst_7 : TopologicalAddGroup.{u2} M _inst_6 (AddCommGroup.toAddGroup.{u2} M _inst_3)] {p : Î¹ -> Prop} {b : Î¹ -> (Set.{u2} M)}, (Filter.HasBasis.{u2, succ u3} M Î¹ (nhds.{u2} M _inst_6 (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3))))))))) p b) -> (forall {i : Î¹}, (p i) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} R) (Filter.{u1} R) (Filter.hasMem.{u1} R) V (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (Filter.{u1} R) (Filter.hasMem.{u1} R) V (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))) => Exists.{succ u3} Î¹ (fun (j : Î¹) => Exists.{0} (p j) (fun (hj : p j) => HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) (SMul.smul.{u1, u2} (Set.{u1} R) (Set.{u2} M) (Set.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4))))) V (b j)) (b i))))))) -> (forall (xâ‚€ : R) {i : Î¹}, (p i) -> (Exists.{succ u3} Î¹ (fun (j : Î¹) => Exists.{0} (p j) (fun (hj : p j) => HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) (b j) (Set.preimage.{u2, u2} M M (fun (x : M) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))) xâ‚€ x) (b i)))))) -> (forall (mâ‚€ : M) {i : Î¹}, (p i) -> (Filter.Eventually.{u1} R (fun (x : R) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))) x mâ‚€) (b i)) (nhds.{u1} R _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))))) -> (ContinuousSMul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_4)))) _inst_2 _inst_6)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : TopologicalSpace.{u2} R] [_inst_3 : AddCommGroup.{u1} M] [_inst_4 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3)] {Î¹ : Type.{u3}} [_inst_5 : TopologicalRing.{u2} R _inst_2 (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))] [_inst_6 : TopologicalSpace.{u1} M] [_inst_7 : TopologicalAddGroup.{u1} M _inst_6 (AddCommGroup.toAddGroup.{u1} M _inst_3)] {p : Î¹ -> Prop} {b : Î¹ -> (Set.{u1} M)}, (Filter.HasBasis.{u1, succ u3} M Î¹ (nhds.{u1} M _inst_6 (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3)))))))) p b) -> (forall {i : Î¹}, (p i) -> (Exists.{succ u2} (Set.{u2} R) (fun (V : Set.{u2} R) => And (Membership.mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (instMembershipSetFilter.{u2} R) V (nhds.{u2} R _inst_2 (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))))) (Exists.{succ u3} Î¹ (fun (j : Î¹) => Exists.{0} (p j) (fun (x._@.Mathlib.Topology.Algebra.FilterBasis._hyg.3702 : p j) => HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) (HSMul.hSMul.{u2, u1, u1} (Set.{u2} R) (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} (Set.{u2} R) (Set.{u1} M) (Set.smul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_4)))))) V (b j)) (b i))))))) -> (forall (xâ‚€ : R) {i : Î¹}, (p i) -> (Exists.{succ u3} Î¹ (fun (j : Î¹) => Exists.{0} (p j) (fun (hj : p j) => HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) (b j) (Set.preimage.{u1, u1} M M (fun (x : M) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_4))))) xâ‚€ x) (b i)))))) -> (forall (mâ‚€ : M) {i : Î¹}, (p i) -> (Filter.Eventually.{u2} R (fun (x : R) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_4))))) x mâ‚€) (b i)) (nhds.{u2} R _inst_2 (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) -> (ContinuousSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_4)))) _inst_2 _inst_6)
Case conversion may be inaccurate. Consider using '#align has_continuous_smul.of_basis_zero ContinuousSMul.of_basis_zeroâ‚“'. -/
/-- A topological add group whith a basis of `ð“ 0` satisfying the axioms of `module_filter_basis`
is a topological module.

This lemma is mathematically useless because one could obtain such a result by applying
`module_filter_basis.has_continuous_smul` and use the fact that group topologies are characterized
by their neighborhoods of 0 to obtain the `has_continuous_smul` on the pre-existing topology.

But it turns out it's just easier to get it as a biproduct of the proof, so this is just a free
quality-of-life improvement. -/
theorem ContinuousSMul.of_basis_zero {Î¹ : Type _} [TopologicalRing R] [TopologicalSpace M]
    [TopologicalAddGroup M] {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set M} (h : HasBasis (ð“ 0) p b)
    (hsmul : âˆ€ {i}, p i â†’ âˆƒ V âˆˆ ð“ (0 : R), âˆƒ (j : _)(hj : p j), V â€¢ b j âŠ† b i)
    (hsmul_left : âˆ€ (xâ‚€ : R) {i}, p i â†’ âˆƒ (j : _)(hj : p j), b j âŠ† (fun x => xâ‚€ â€¢ x) â»Â¹' b i)
    (hsmul_right : âˆ€ (mâ‚€ : M) {i}, p i â†’ âˆ€á¶  x in ð“ (0 : R), x â€¢ mâ‚€ âˆˆ b i) : ContinuousSMul R M :=
  by
  apply ContinuousSMul.of_nhds_zero
  Â· rw [h.tendsto_right_iff]
    intro i hi
    rcases hsmul hi with âŸ¨V, V_in, j, hj, hVjâŸ©
    apply mem_of_superset (prod_mem_prod V_in <| h.mem_of_mem hj)
    rintro âŸ¨v, wâŸ© âŸ¨v_in : v âˆˆ V, w_in : w âˆˆ b jâŸ©
    exact hVj (Set.smul_mem_smul v_in w_in)
  Â· intro mâ‚€
    rw [h.tendsto_right_iff]
    intro i hi
    exact hsmul_right mâ‚€ hi
  Â· intro xâ‚€
    rw [h.tendsto_right_iff]
    intro i hi
    rcases hsmul_left xâ‚€ hi with âŸ¨j, hj, hjiâŸ©
    exact mem_of_superset (h.mem_of_mem hj) hji
#align has_continuous_smul.of_basis_zero ContinuousSMul.of_basis_zero

#print ModuleFilterBasis.continuousSMul /-
/-- If a module is endowed with a topological structure coming from
a module filter basis then it's a topological module. -/
instance (priority := 100) continuousSMul [TopologicalRing R] :
    @ContinuousSMul R M _ _ B.topology :=
  by
  let B' := B.to_add_group_filter_basis
  letI := B'.topology
  haveI := B'.is_topological_add_group
  exact
    ContinuousSMul.of_basis_zero B'.nhds_zero_has_basis (fun _ => B.smul) B.smul_left B.smul_right
#align module_filter_basis.has_continuous_smul ModuleFilterBasis.continuousSMul
-/

/- warning: module_filter_basis.of_bases -> ModuleFilterBasis.ofBases is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_5 : CommRing.{u1} R] [_inst_6 : AddCommGroup.{u2} M] [_inst_7 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)] (BR : RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (BM : AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)), (forall {U : Set.{u2} M}, (Membership.Mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.hasMem.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) U BM) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (RingFilterBasis.hasMem.{u1} R (CommRing.toRing.{u1} R _inst_5)) V BR) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (RingFilterBasis.hasMem.{u1} R (CommRing.toRing.{u1} R _inst_5)) V BR) => Exists.{succ u2} (Set.{u2} M) (fun (W : Set.{u2} M) => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.hasMem.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) W BM) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.hasMem.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) W BM) => HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) (SMul.smul.{u1, u2} (Set.{u1} R) (Set.{u2} M) (Set.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6) _inst_7))))) V W) U)))))) -> (forall (xâ‚€ : R) {U : Set.{u2} M}, (Membership.Mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.hasMem.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) U BM) -> (Exists.{succ u2} (Set.{u2} M) (fun (V : Set.{u2} M) => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.hasMem.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) V BM) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.hasMem.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) V BM) => HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) V (Set.preimage.{u2, u2} M M (fun (x : M) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6) _inst_7)))) xâ‚€ x) U))))) -> (forall (mâ‚€ : M) {U : Set.{u2} M}, (Membership.Mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.hasMem.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) U BM) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (RingFilterBasis.hasMem.{u1} R (CommRing.toRing.{u1} R _inst_5)) V BR) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (RingFilterBasis.hasMem.{u1} R (CommRing.toRing.{u1} R _inst_5)) V BR) => HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) V (Set.preimage.{u1, u2} R M (fun (x : R) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6) _inst_7)))) x mâ‚€) U))))) -> (ModuleFilterBasis.{u1, u2} R M _inst_5 (RingFilterBasis.topology.{u1} R (CommRing.toRing.{u1} R _inst_5) BR) _inst_6 _inst_7)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_5 : CommRing.{u1} R] [_inst_6 : AddCommGroup.{u2} M] [_inst_7 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6)] (BR : RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (BM : AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)), (forall {U : Set.{u2} M}, (Membership.mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.instMembershipSetAddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) U BM) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => And (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) V BR) (Exists.{succ u2} (Set.{u2} M) (fun (W : Set.{u2} M) => And (Membership.mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.instMembershipSetAddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) W BM) (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) (HSMul.hSMul.{u1, u2, u2} (Set.{u1} R) (Set.{u2} M) (Set.{u2} M) (instHSMul.{u1, u2} (Set.{u1} R) (Set.{u2} M) (Set.smul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_5))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6) _inst_7)))))) V W) U)))))) -> (forall (xâ‚€ : R) {U : Set.{u2} M}, (Membership.mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.instMembershipSetAddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) U BM) -> (Exists.{succ u2} (Set.{u2} M) (fun (V : Set.{u2} M) => And (Membership.mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.instMembershipSetAddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) V BM) (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) V (Set.preimage.{u2, u2} M M (fun (x : M) => HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_5))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6) _inst_7))))) xâ‚€ x) U))))) -> (forall (mâ‚€ : M) {U : Set.{u2} M}, (Membership.mem.{u2, u2} (Set.{u2} M) (AddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) (AddGroupFilterBasis.instMembershipSetAddGroupFilterBasis.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_6)) U BM) -> (Exists.{succ u1} (Set.{u1} R) (fun (V : Set.{u1} R) => And (Membership.mem.{u1, u1} (Set.{u1} R) (RingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) (RingFilterBasis.instMembershipSetRingFilterBasis.{u1} R (CommRing.toRing.{u1} R _inst_5)) V BR) (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) V (Set.preimage.{u1, u2} R M (fun (x : R) => HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_5))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_6))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_6) _inst_7))))) x mâ‚€) U))))) -> (ModuleFilterBasis.{u1, u2} R M _inst_5 (RingFilterBasis.topology.{u1} R (CommRing.toRing.{u1} R _inst_5) BR) _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align module_filter_basis.of_bases ModuleFilterBasis.ofBasesâ‚“'. -/
/-- Build a module filter basis from compatible ring and additive group filter bases. -/
def ofBases {R M : Type _} [CommRing R] [AddCommGroup M] [Module R M] (BR : RingFilterBasis R)
    (BM : AddGroupFilterBasis M) (smul : âˆ€ {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BR, âˆƒ W âˆˆ BM, V â€¢ W âŠ† U)
    (smul_left : âˆ€ (xâ‚€ : R) {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BM, V âŠ† (fun x => xâ‚€ â€¢ x) â»Â¹' U)
    (smul_right : âˆ€ (mâ‚€ : M) {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BR, V âŠ† (fun x => x â€¢ mâ‚€) â»Â¹' U) :
    @ModuleFilterBasis R M _ BR.topology _ _ :=
  {
    BM with
    smul' := by
      intro U U_in
      rcases smul U_in with âŸ¨V, V_in, W, W_in, HâŸ©
      exact âŸ¨V, BR.to_add_group_filter_basis.mem_nhds_zero V_in, W, W_in, HâŸ©
    smul_left' := smul_left
    smul_right' := by
      intro mâ‚€ U U_in
      rcases smul_right mâ‚€ U_in with âŸ¨V, V_in, HâŸ©
      exact mem_of_superset (BR.to_add_group_filter_basis.mem_nhds_zero V_in) H }
#align module_filter_basis.of_bases ModuleFilterBasis.ofBases

end ModuleFilterBasis

