import Mathbin.Order.Filter.Bases 
import Mathbin.Topology.Algebra.Module

/-!
# Group and ring filter bases

A `group_filter_basis` is a `filter_basis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `group_filter_basis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

## Main definitions and results

Given a group `G` and a ring `R`:

* `group_filter_basis G`: the type of filter bases that will become neighborhood of `1`
  for a topology on `G` compatible with the group structure
* `group_filter_basis.topology`: the associated topology
* `group_filter_basis.is_topological_group`: the compatibility between the above topology
  and the group structure
* `ring_filter_basis R`: the type of filter bases that will become neighborhood of `0`
  for a topology on `R` compatible with the ring structure
* `ring_filter_basis.topology`: the associated topology
* `ring_filter_basis.is_topological_ring`: the compatibility between the above topology
  and the ring structure

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]
-/


open Filter Set TopologicalSpace Function

open_locale TopologicalSpace Filter Pointwise

universe u

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
/-- A `group_filter_basis` on a group is a `filter_basis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `group_filter_basis`. Conversely given a `group_filter_basis` one can define a topology
  compatible with the group structure on `G`.  -/
class GroupFilterBasis (G : Type u) [Group‚Çì G] extends FilterBasis G where 
  one' : ‚àÄ {U}, U ‚àà sets ‚Üí (1 : G) ‚àà U 
  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), (V*V) ‚äÜ U 
  inv' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => x‚Åª¬π) ‚Åª¬π' U 
  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => (x‚ÇÄ*x)*x‚ÇÄ‚Åª¬π) ‚Åª¬π' U

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
/-- A `add_group_filter_basis` on an additive group is a `filter_basis` satisfying some additional
  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `add_group_filter_basis`. Conversely given a `add_group_filter_basis` one can define a topology
  compatible with the group structure on `G`. -/
class AddGroupFilterBasis (A : Type u) [AddGroup‚Çì A] extends FilterBasis A where 
  zero' : ‚àÄ {U}, U ‚àà sets ‚Üí (0 : A) ‚àà U 
  add' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), (V+V) ‚äÜ U 
  neg' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => -x) ‚Åª¬π' U 
  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => (x‚ÇÄ+x)+-x‚ÇÄ) ‚Åª¬π' U

attribute [toAdditive] GroupFilterBasis

attribute [toAdditive] GroupFilterBasis.one'

attribute [toAdditive] GroupFilterBasis.mul'

attribute [toAdditive] GroupFilterBasis.inv'

attribute [toAdditive] GroupFilterBasis.conj'

attribute [toAdditive] GroupFilterBasis.toFilterBasis

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (z ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (U ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (U ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (U ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
/-- `group_filter_basis` constructor in the commutative group case. -/
@[toAdditive "`add_group_filter_basis` constructor in the commutative group case."]
def groupFilterBasisOfComm {G : Type _} [CommGroup‚Çì G] (sets : Set (Set G)) (nonempty : sets.nonempty)
  (inter_sets : ‚àÄ x y, x ‚àà sets ‚Üí y ‚àà sets ‚Üí ‚àÉ (z : _)(_ : z ‚àà sets), z ‚äÜ x ‚à© y) (one : ‚àÄ U _ : U ‚àà sets, (1 : G) ‚àà U)
  (mul : ‚àÄ U _ : U ‚àà sets, ‚àÉ (V : _)(_ : V ‚àà sets), (V*V) ‚äÜ U)
  (inv : ‚àÄ U _ : U ‚àà sets, ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => x‚Åª¬π) ‚Åª¬π' U) : GroupFilterBasis G :=
  { Sets, Nonempty, inter_sets, one' := one, mul' := mul, inv' := inv,
    conj' :=
      fun x U U_in =>
        ‚ü®U, U_in,
          by 
            simp ‚ü© }

namespace GroupFilterBasis

variable {G : Type u} [Group‚Çì G] {B : GroupFilterBasis G}

@[toAdditive]
instance : HasMem (Set G) (GroupFilterBasis G) :=
  ‚ü®fun s f => s ‚àà f.sets‚ü©

@[toAdditive]
theorem one {U : Set G} : U ‚àà B ‚Üí (1 : G) ‚àà U :=
  GroupFilterBasis.one'

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª B)
@[toAdditive]
theorem mul {U : Set G} : U ‚àà B ‚Üí ‚àÉ (V : _)(_ : V ‚àà B), (V*V) ‚äÜ U :=
  GroupFilterBasis.mul'

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª B)
@[toAdditive]
theorem inv {U : Set G} : U ‚àà B ‚Üí ‚àÉ (V : _)(_ : V ‚àà B), V ‚äÜ (fun x => x‚Åª¬π) ‚Åª¬π' U :=
  GroupFilterBasis.inv'

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª B)
@[toAdditive]
theorem conj : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà B ‚Üí ‚àÉ (V : _)(_ : V ‚àà B), V ‚äÜ (fun x => (x‚ÇÄ*x)*x‚ÇÄ‚Åª¬π) ‚Åª¬π' U :=
  GroupFilterBasis.conj'

/-- The trivial group filter basis consists of `{1}` only. The associated topology
is discrete. -/
@[toAdditive "The trivial additive group filter basis consists of `{0}` only. The associated\ntopology is discrete."]
instance : Inhabited (GroupFilterBasis G) :=
  ‚ü®by 
      refine' { Sets := {{1}}, Nonempty := singleton_nonempty _, .. }
      all_goals 
        simp only [exists_prop, mem_singleton_iff]
      ¬∑
        rintro - - rfl rfl 
        use {1}
        simp 
      ¬∑
        simp 
      ¬∑
        rintro - rfl 
        use {1}
        simp 
      ¬∑
        rintro - rfl 
        use {1}
        simp 
      ¬∑
        rintro x‚ÇÄ - rfl 
        use {1}
        simp ‚ü©

@[toAdditive]
theorem prod_subset_self (B : GroupFilterBasis G) {U : Set G} (h : U ‚àà B) : U ‚äÜ U*U :=
  fun x x_in => ‚ü®1, x, one h, x_in, one_mul‚Çì x‚ü©

/-- The neighborhood function of a `group_filter_basis` -/
@[toAdditive "The neighborhood function of a `add_group_filter_basis`"]
def N (B : GroupFilterBasis G) : G ‚Üí Filter G :=
  fun x => map (fun y => x*y) B.to_filter_basis.filter

@[simp, toAdditive]
theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.to_filter_basis.filter :=
  by 
    simp only [N, one_mul‚Çì, map_id']

@[toAdditive]
protected theorem has_basis (B : GroupFilterBasis G) (x : G) :
  has_basis (B.N x) (fun V : Set G => V ‚àà B) fun V => (fun y => x*y) '' V :=
  has_basis.map (fun y => x*y) to_filter_basis.HasBasis

/-- The topological space structure coming from a group filter basis. -/
@[toAdditive "The topological space structure coming from an additive group filter basis."]
def topology (B : GroupFilterBasis G) : TopologicalSpace G :=
  TopologicalSpace.mkOfNhds B.N

@[toAdditive]
theorem nhds_eq (B : GroupFilterBasis G) {x‚ÇÄ : G} : @nhds G B.topology x‚ÇÄ = B.N x‚ÇÄ :=
  by 
    rw [TopologicalSpace.nhds_mk_of_nhds]
    ¬∑
      intro x U U_in 
      rw [(B.has_basis x).mem_iff] at U_in 
      rcases U_in with ‚ü®V, V_in, H‚ü©
      simpa [mem_pure] using H (mem_image_of_mem _ (GroupFilterBasis.one V_in))
    ¬∑
      intro x U U_in 
      rw [(B.has_basis x).mem_iff] at U_in 
      rcases U_in with ‚ü®V, V_in, H‚ü©
      rcases GroupFilterBasis.mul V_in with ‚ü®W, W_in, hW‚ü©
      use (fun y => x*y) '' W, image_mem_map (FilterBasis.mem_filter_of_mem _ W_in)
      constructor
      ¬∑
        rw [image_subset_iff] at H‚ä¢
        exact ((B.prod_subset_self W_in).trans hW).trans H
      ¬∑
        rintro y ‚ü®t, tW, rfl‚ü©
        rw [(B.has_basis _).mem_iff]
        use W, W_in 
        apply subset.trans _ H 
        clear H 
        rintro z ‚ü®w, wW, rfl‚ü©
        exact
          ‚ü®t*w, hW (mul_mem_mul tW wW),
            by 
              simp [mul_assoc‚Çì]‚ü©

@[toAdditive]
theorem nhds_one_eq (B : GroupFilterBasis G) : @nhds G B.topology (1 : G) = B.to_filter_basis.filter :=
  by 
    rw [B.nhds_eq]
    simp only [N, one_mul‚Çì]
    exact map_id

@[toAdditive]
theorem nhds_has_basis (B : GroupFilterBasis G) (x‚ÇÄ : G) :
  has_basis (@nhds G B.topology x‚ÇÄ) (fun V : Set G => V ‚àà B) fun V => (fun y => x‚ÇÄ*y) '' V :=
  by 
    rw [B.nhds_eq]
    apply B.has_basis

@[toAdditive]
theorem nhds_one_has_basis (B : GroupFilterBasis G) : has_basis (@nhds G B.topology 1) (fun V : Set G => V ‚àà B) id :=
  by 
    rw [B.nhds_one_eq]
    exact B.to_filter_basis.has_basis

@[toAdditive]
theorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U ‚àà B) : U ‚àà @nhds G B.topology 1 :=
  by 
    rw [B.nhds_one_has_basis.mem_iff]
    exact ‚ü®U, hU, rfl.subset‚ü©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (U ¬´expr ‚àà ¬ª B)
/-- If a group is endowed with a topological structure coming from
a group filter basis then it's a topological group. -/
@[toAdditive]
instance (priority := 100) is_topological_group (B : GroupFilterBasis G) : @TopologicalGroup G B.topology _ :=
  by 
    let this' := B.topology 
    have basis := B.nhds_one_has_basis 
    have basis' := basis.prod basis 
    refine' TopologicalGroup.of_nhds_one _ _ _ _
    ¬∑
      rw [basis'.tendsto_iff basis]
      suffices  : ‚àÄ U _ : U ‚àà B, ‚àÉ V W, (V ‚àà B ‚àß W ‚àà B) ‚àß ‚àÄ a b, a ‚àà V ‚Üí b ‚àà W ‚Üí (a*b) ‚àà U
      ¬∑
        simpa 
      intro U U_in 
      rcases mul U_in with ‚ü®V, V_in, hV‚ü©
      use V, V, V_in, V_in 
      intro a b a_in b_in 
      exact hV ‚ü®a, b, a_in, b_in, rfl‚ü©
    ¬∑
      rw [basis.tendsto_iff basis]
      intro U U_in 
      simpa using inv U_in
    ¬∑
      intro x‚ÇÄ 
      rw [nhds_eq, nhds_one_eq]
      rfl
    ¬∑
      intro x‚ÇÄ 
      rw [basis.tendsto_iff basis]
      intro U U_in 
      exact conj x‚ÇÄ U_in

end GroupFilterBasis

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
/-- A `ring_filter_basis` on a ring is a `filter_basis` satisfying some additional axioms.
  Example : if `R` is a topological ring then the neighbourhoods of the identity are a
  `ring_filter_basis`. Conversely given a `ring_filter_basis` on a ring `R`, one can define a
  topology on `R` which is compatible with the ring structure.  -/
class RingFilterBasis (R : Type u) [Ring‚Çì R] extends AddGroupFilterBasis R where 
  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), (V*V) ‚äÜ U 
  mul_left' : ‚àÄ x‚ÇÄ : R {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => x‚ÇÄ*x) ‚Åª¬π' U 
  mul_right' : ‚àÄ x‚ÇÄ : R {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => x*x‚ÇÄ) ‚Åª¬π' U

namespace RingFilterBasis

variable {R : Type u} [Ring‚Çì R] (B : RingFilterBasis R)

instance : HasMem (Set R) (RingFilterBasis R) :=
  ‚ü®fun s B => s ‚àà B.sets‚ü©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª B)
theorem mul {U : Set R} (hU : U ‚àà B) : ‚àÉ (V : _)(_ : V ‚àà B), (V*V) ‚äÜ U :=
  mul' hU

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª B)
theorem mul_left (x‚ÇÄ : R) {U : Set R} (hU : U ‚àà B) : ‚àÉ (V : _)(_ : V ‚àà B), V ‚äÜ (fun x => x‚ÇÄ*x) ‚Åª¬π' U :=
  mul_left' x‚ÇÄ hU

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª B)
theorem mul_right (x‚ÇÄ : R) {U : Set R} (hU : U ‚àà B) : ‚àÉ (V : _)(_ : V ‚àà B), V ‚äÜ (fun x => x*x‚ÇÄ) ‚Åª¬π' U :=
  mul_right' x‚ÇÄ hU

/-- The topology associated to a ring filter basis.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace R :=
  B.to_add_group_filter_basis.topology

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (U ¬´expr ‚àà ¬ª B')
/-- If a ring is endowed with a topological structure coming from
a ring filter basis then it's a topological ring. -/
instance (priority := 100) is_topological_ring {R : Type u} [Ring‚Çì R] (B : RingFilterBasis R) :
  @TopologicalRing R B.topology _ :=
  by 
    let B' := B.to_add_group_filter_basis 
    let this' := B'.topology 
    have basis := B'.nhds_zero_has_basis 
    have basis' := basis.prod basis 
    have  := B'.is_topological_add_group 
    apply TopologicalRing.of_add_group_of_nhds_zero
    ¬∑
      rw [basis'.tendsto_iff basis]
      suffices  : ‚àÄ U _ : U ‚àà B', ‚àÉ V W, (V ‚àà B' ‚àß W ‚àà B') ‚àß ‚àÄ a b, a ‚àà V ‚Üí b ‚àà W ‚Üí (a*b) ‚àà U
      ¬∑
        simpa 
      intro U U_in 
      rcases B.mul U_in with ‚ü®V, V_in, hV‚ü©
      use V, V, V_in, V_in 
      intro a b a_in b_in 
      exact hV ‚ü®a, b, a_in, b_in, rfl‚ü©
    ¬∑
      intro x‚ÇÄ 
      rw [basis.tendsto_iff basis]
      intro U 
      simpa using B.mul_left x‚ÇÄ
    ¬∑
      intro x‚ÇÄ 
      rw [basis.tendsto_iff basis]
      intro U 
      simpa using B.mul_right x‚ÇÄ

end RingFilterBasis

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª exprùìù() (0 : R))
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (W ¬´expr ‚àà ¬ª sets)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª sets)
/-- A `module_filter_basis` on a module is a `filter_basis` satisfying some additional axioms.
  Example : if `M` is a topological module then the neighbourhoods of zero are a
  `module_filter_basis`. Conversely given a `module_filter_basis` one can define a topology
  compatible with the module structure on `M`.  -/
structure ModuleFilterBasis (R M : Type _) [CommRing‚Çì R] [TopologicalSpace R] [AddCommGroup‚Çì M] [Module R M] extends
  AddGroupFilterBasis M where 
  smul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà ùìù (0 : R))(W : _)(_ : W ‚àà sets), V ‚Ä¢ W ‚äÜ U 
  smul_left' : ‚àÄ x‚ÇÄ : R {U}, U ‚àà sets ‚Üí ‚àÉ (V : _)(_ : V ‚àà sets), V ‚äÜ (fun x => x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U 
  smul_right' : ‚àÄ m‚ÇÄ : M {U}, U ‚àà sets ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U

namespace ModuleFilterBasis

variable {R M : Type _} [CommRing‚Çì R] [TopologicalSpace R] [AddCommGroup‚Çì M] [Module R M] (B : ModuleFilterBasis R M)

instance GroupFilterBasis.hasMem : HasMem (Set M) (ModuleFilterBasis R M) :=
  ‚ü®fun s B => s ‚àà B.sets‚ü©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª exprùìù() (0 : R))
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (W ¬´expr ‚àà ¬ª B)
theorem smul {U : Set M} (hU : U ‚àà B) : ‚àÉ (V : _)(_ : V ‚àà ùìù (0 : R))(W : _)(_ : W ‚àà B), V ‚Ä¢ W ‚äÜ U :=
  B.smul' hU

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª B)
theorem smul_left (x‚ÇÄ : R) {U : Set M} (hU : U ‚àà B) : ‚àÉ (V : _)(_ : V ‚àà B), V ‚äÜ (fun x => x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U :=
  B.smul_left' x‚ÇÄ hU

theorem smul_right (m‚ÇÄ : M) {U : Set M} (hU : U ‚àà B) : ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U :=
  B.smul_right' m‚ÇÄ hU

/-- If `R` is discrete then the trivial additive group filter basis on any `R`-module is a
module filter basis. -/
instance [DiscreteTopology R] : Inhabited (ModuleFilterBasis R M) :=
  ‚ü®{ default$ AddGroupFilterBasis M with
      smul' :=
        by 
          rintro U (h : U ‚àà {{(0 : M)}})
          rw [mem_singleton_iff] at h 
          use univ, univ_mem, {0}, rfl 
          rintro a ‚ü®x, m, -, hm, rfl‚ü©
          simp [mem_singleton_iff.1 hm, h],
      smul_left' :=
        by 
          rintro x‚ÇÄ U (h : U ‚àà {{(0 : M)}})
          rw [mem_singleton_iff] at h 
          use {0}, rfl 
          simp [h],
      smul_right' :=
        by 
          rintro m‚ÇÄ U (h : U ‚àà {{(0 : M)}})
          rw [mem_singleton_iff] at h 
          simp [h, nhds_discrete] }‚ü©

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace M :=
  B.to_add_group_filter_basis.topology

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. This version gets the ring
topology by unification instead of type class inference. -/
def topology' {R M : Type _} [CommRing‚Çì R] {tR : TopologicalSpace R} [AddCommGroup‚Çì M] [Module R M]
  (B : ModuleFilterBasis R M) : TopologicalSpace M :=
  B.to_add_group_filter_basis.topology

/-- If a module is endowed with a topological structure coming from
a module filter basis then it's a topological module. -/
instance (priority := 100) HasContinuousSmul [TopologicalRing R] : @HasContinuousSmul R M _ _ B.topology :=
  by 
    let B' := B.to_add_group_filter_basis 
    let this' := B'.topology 
    have basis := B'.nhds_zero_has_basis 
    have  := B'.is_topological_add_group 
    apply HasContinuousSmul.of_nhds_zero
    ¬∑
      rw [basis.tendsto_right_iff]
      intro U U_in 
      rcases B.smul U_in with ‚ü®V, V_in, W, W_in, H‚ü©
      apply mem_of_superset (prod_mem_prod V_in$ B'.mem_nhds_zero W_in)
      rintro ‚ü®v, w‚ü© ‚ü®v_in : v ‚àà V, w_in : w ‚àà W‚ü©
      exact H (Set.mem_smul_of_mem v_in w_in)
    ¬∑
      intro m‚ÇÄ 
      rw [basis.tendsto_right_iff]
      intro U U_in 
      exact B.smul_right m‚ÇÄ U_in
    ¬∑
      intro x‚ÇÄ 
      rw [basis.tendsto_right_iff]
      intro U U_in 
      rcases B.smul_left x‚ÇÄ U_in with ‚ü®V, V_in, hV‚ü©
      exact mem_of_superset (B'.mem_nhds_zero V_in) hV

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª BR)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (W ¬´expr ‚àà ¬ª BM)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª BM)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (V ¬´expr ‚àà ¬ª BR)
/-- Build a module filter basis from compatible ring and additive group filter bases. -/
def of_bases {R M : Type _} [CommRing‚Çì R] [AddCommGroup‚Çì M] [Module R M] (BR : RingFilterBasis R)
  (BM : AddGroupFilterBasis M) (smul : ‚àÄ {U}, U ‚àà BM ‚Üí ‚àÉ (V : _)(_ : V ‚àà BR)(W : _)(_ : W ‚àà BM), V ‚Ä¢ W ‚äÜ U)
  (smul_left : ‚àÄ x‚ÇÄ : R {U}, U ‚àà BM ‚Üí ‚àÉ (V : _)(_ : V ‚àà BM), V ‚äÜ (fun x => x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U)
  (smul_right : ‚àÄ m‚ÇÄ : M {U}, U ‚àà BM ‚Üí ‚àÉ (V : _)(_ : V ‚àà BR), V ‚äÜ (fun x => x ‚Ä¢ m‚ÇÄ) ‚Åª¬π' U) :
  @ModuleFilterBasis R M _ BR.topology _ _ :=
  { BM with
    smul' :=
      by 
        intro U U_in 
        rcases smul U_in with ‚ü®V, V_in, W, W_in, H‚ü©
        exact ‚ü®V, BR.to_add_group_filter_basis.mem_nhds_zero V_in, W, W_in, H‚ü©,
    smul_left' := smul_left,
    smul_right' :=
      by 
        intro m‚ÇÄ U U_in 
        rcases smul_right m‚ÇÄ U_in with ‚ü®V, V_in, H‚ü©
        exact mem_of_superset (BR.to_add_group_filter_basis.mem_nhds_zero V_in) H }

end ModuleFilterBasis

