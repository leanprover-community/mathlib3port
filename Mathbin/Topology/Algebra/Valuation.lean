/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot

! This file was ported from Lean 3 source module topology.algebra.valuation
! leanprover-community/mathlib commit 8eb9c42d4d34c77f6ee84ea766ae4070233a973c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Algebra.Nonarchimedean.Bases
import Mathbin.Topology.Algebra.UniformFilterBasis
import Mathbin.RingTheory.Valuation.Basic

/-!
# The topology on a valued ring

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file, we define the non archimedean topology induced by a valuation on a ring.
The main definition is a `valued` type class which equips a ring with a valuation taking
values in a group with zero. Other instances are then deduced from this.
-/


open Classical Topology uniformity

open Set Valuation

noncomputable section

universe v u

variable {R : Type u} [Ring R] {Œì‚ÇÄ : Type v} [LinearOrderedCommGroupWithZero Œì‚ÇÄ]

namespace Valuation

variable (v : Valuation R Œì‚ÇÄ)

#print Valuation.subgroups_basis /-
/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/
theorem subgroups_basis : RingSubgroupsBasis fun Œ≥ : Œì‚ÇÄÀ£ => (v.ltAddSubgroup Œ≥ : AddSubgroup R) :=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp [Valuation.ltAddSubgroup] <;> tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, s, r_in, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := (mul_lt_mul‚ÇÄ r_in s_in)
        _ ‚â§ Œ≥ := by exact_mod_cast h
        
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y (y_in : (v y : Œì‚ÇÄ) < 1)
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ simp only [image_subset_iff, set_of_subset_set_of, preimage_set_of_eq, Valuation.map_mul]
        use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y (y_in : (v y : Œì‚ÇÄ) < 1)
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }
#align valuation.subgroups_basis Valuation.subgroups_basis
-/

end Valuation

#print Valued /-
/-- A valued ring is a ring that comes equipped with a distinguished valuation. The class `valued`
is designed for the situation that there is a canonical valuation on the ring.

TODO: show that there always exists an equivalent valuation taking values in a type belonging to
the same universe as the ring.

See Note [forgetful inheritance] for why we extend `uniform_space`, `uniform_add_group`. -/
class Valued (R : Type u) [Ring R] (Œì‚ÇÄ : outParam (Type v))
  [LinearOrderedCommGroupWithZero Œì‚ÇÄ] extends UniformSpace R, UniformAddGroup R where
  V : Valuation R Œì‚ÇÄ
  is_topological_valuation : ‚àÄ s, s ‚àà ùìù (0 : R) ‚Üî ‚àÉ Œ≥ : Œì‚ÇÄÀ£, { x : R | v x < Œ≥ } ‚äÜ s
#align valued Valued
-/

attribute [nolint dangerous_instance] Valued.toUniformSpace

namespace Valued

#print Valued.mk' /-
/-- Alternative `valued` constructor for use when there is no preferred `uniform_space`
structure. -/
def mk' (v : Valuation R Œì‚ÇÄ) : Valued R Œì‚ÇÄ :=
  { V
    toUniformSpace := @TopologicalAddGroup.toUniformSpace R _ v.subgroups_basis.topology _
    to_uniformAddGroup := @comm_topologicalAddGroup_is_uniform _ _ v.subgroups_basis.topology _
    is_topological_valuation :=
      by
      letI := @TopologicalAddGroup.toUniformSpace R _ v.subgroups_basis.topology _
      intro s
      rw [filter.has_basis_iff.mp v.subgroups_basis.has_basis_nhds_zero s]
      exact exists_congr fun Œ≥ => by simpa }
#align valued.mk' Valued.mk'
-/

variable (R Œì‚ÇÄ) [_i : Valued R Œì‚ÇÄ]

include _i

/- warning: valued.has_basis_nhds_zero -> Valued.hasBasis_nhds_zero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) [_inst_1 : Ring.{u2} R] (Œì‚ÇÄ : Type.{u1}) [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2], Filter.HasBasis.{u2, succ u1} R (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))))) (fun (_x : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => True) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => setOf.{u2} R (fun (x : R) => LT.lt.{u1} Œì‚ÇÄ (Preorder.toLT.{u1} Œì‚ÇÄ (PartialOrder.toPreorder.{u1} Œì‚ÇÄ (OrderedCommMonoid.toPartialOrder.{u1} Œì‚ÇÄ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (CoeTC‚Çì.coe.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (coeBase.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (Units.hasCoe.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))))) Œ≥)))
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Ring.{u2} R] (Œì‚ÇÄ : Type.{u1}) [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2], Filter.HasBasis.{u2, succ u1} R (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) (fun (_x : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => True) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => setOf.{u2} R (fun (x : R) => LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (OrderedCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x) (Units.val.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))) Œ≥)))
Case conversion may be inaccurate. Consider using '#align valued.has_basis_nhds_zero Valued.hasBasis_nhds_zero‚Çì'. -/
theorem hasBasis_nhds_zero :
    (ùìù (0 : R)).HasBasis (fun _ => True) fun Œ≥ : Œì‚ÇÄÀ£ => { x | v x < (Œ≥ : Œì‚ÇÄ) } := by
  simp [Filter.hasBasis_iff, is_topological_valuation]
#align valued.has_basis_nhds_zero Valued.hasBasis_nhds_zero

/- warning: valued.has_basis_uniformity -> Valued.hasBasis_uniformity is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) [_inst_1 : Ring.{u2} R] (Œì‚ÇÄ : Type.{u1}) [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2], Filter.HasBasis.{u2, succ u1} (Prod.{u2, u2} R R) (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (uniformity.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) (fun (_x : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => True) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => setOf.{u2} (Prod.{u2, u2} R R) (fun (p : Prod.{u2, u2} R R) => LT.lt.{u1} Œì‚ÇÄ (Preorder.toLT.{u1} Œì‚ÇÄ (PartialOrder.toPreorder.{u1} Œì‚ÇÄ (OrderedCommMonoid.toPartialOrder.{u1} Œì‚ÇÄ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R _inst_1)))))) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (CoeTC‚Çì.coe.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (coeBase.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (Units.hasCoe.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))))) Œ≥)))
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Ring.{u2} R] (Œì‚ÇÄ : Type.{u1}) [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2], Filter.HasBasis.{u2, succ u1} (Prod.{u2, u2} R R) (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (uniformity.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) (fun (_x : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => True) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => setOf.{u2} (Prod.{u2, u2} R R) (fun (p : Prod.{u2, u2} R R) => LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) (OrderedCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) (Prod.snd.{u2, u2} R R p) (Prod.fst.{u2, u2} R R p))) (Units.val.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))) Œ≥)))
Case conversion may be inaccurate. Consider using '#align valued.has_basis_uniformity Valued.hasBasis_uniformity‚Çì'. -/
theorem hasBasis_uniformity :
    (ùì§ R).HasBasis (fun _ => True) fun Œ≥ : Œì‚ÇÄÀ£ => { p : R √ó R | v (p.2 - p.1) < (Œ≥ : Œì‚ÇÄ) } :=
  by
  rw [uniformity_eq_comap_nhds_zero]
  exact (has_basis_nhds_zero R Œì‚ÇÄ).comap _
#align valued.has_basis_uniformity Valued.hasBasis_uniformity

/- warning: valued.to_uniform_space_eq -> Valued.toUniformSpace_eq is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) [_inst_1 : Ring.{u2} R] (Œì‚ÇÄ : Type.{u1}) [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2], Eq.{succ u2} (UniformSpace.{u2} R) (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (TopologicalAddGroup.toUniformSpace.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R _inst_1))) (RingSubgroupsBasis.topology.{u2, u1} R (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) _inst_1 (instNonempty.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (Units.inhabited.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => Valuation.ltAddSubgroup.{u2, u1} R Œì‚ÇÄ _inst_1 _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) Œ≥) (Valuation.subgroups_basis.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i))) (AddGroupFilterBasis.isTopologicalAddGroup.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R _inst_1))) (RingFilterBasis.toAddGroupFilterBasis.{u2} R _inst_1 (RingSubgroupsBasis.toRingFilterBasis.{u2, u1} R (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) _inst_1 (instNonempty.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (Units.inhabited.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => Valuation.ltAddSubgroup.{u2, u1} R Œì‚ÇÄ _inst_1 _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) Œ≥) (Valuation.subgroups_basis.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i))))))
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Ring.{u2} R] (Œì‚ÇÄ : Type.{u1}) [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2], Eq.{succ u2} (UniformSpace.{u2} R) (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (TopologicalAddGroup.toUniformSpace.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_1)) (RingSubgroupsBasis.topology.{u2, u1} R (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) _inst_1 (instNonempty.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (Units.instInhabitedUnits.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => Valuation.ltAddSubgroup.{u2, u1} R Œì‚ÇÄ _inst_1 _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) Œ≥) (Valuation.subgroups_basis.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i))) (AddGroupFilterBasis.isTopologicalAddGroup.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_1)) (RingFilterBasis.toAddGroupFilterBasis.{u2} R _inst_1 (RingSubgroupsBasis.toRingFilterBasis.{u2, u1} R (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) _inst_1 (instNonempty.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (Units.instInhabitedUnits.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => Valuation.ltAddSubgroup.{u2, u1} R Œì‚ÇÄ _inst_1 _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) Œ≥) (Valuation.subgroups_basis.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i))))))
Case conversion may be inaccurate. Consider using '#align valued.to_uniform_space_eq Valued.toUniformSpace_eq‚Çì'. -/
theorem toUniformSpace_eq :
    toUniformSpace = @TopologicalAddGroup.toUniformSpace R _ v.subgroups_basis.topology _ :=
  uniformSpace_eq
    ((hasBasis_uniformity R Œì‚ÇÄ).eq_of_same_basis <| v.subgroups_basis.hasBasis_nhds_zero.comap _)
#align valued.to_uniform_space_eq Valued.toUniformSpace_eq

variable {R Œì‚ÇÄ}

/- warning: valued.mem_nhds -> Valued.mem_nhds is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {s : Set.{u2} R} {x : R}, Iff (Membership.Mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (Filter.hasMem.{u2} R) s (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) x)) (Exists.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => HasSubset.Subset.{u2} (Set.{u2} R) (Set.hasSubset.{u2} R) (setOf.{u2} R (fun (y : R) => LT.lt.{u1} Œì‚ÇÄ (Preorder.toLT.{u1} Œì‚ÇÄ (PartialOrder.toPreorder.{u1} Œì‚ÇÄ (OrderedCommMonoid.toPartialOrder.{u1} Œì‚ÇÄ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R _inst_1)))))) y x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (CoeTC‚Çì.coe.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (coeBase.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (Units.hasCoe.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))))) Œ≥))) s))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {s : Set.{u2} R} {x : R}, Iff (Membership.mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (instMembershipSetFilter.{u2} R) s (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) x)) (Exists.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => HasSubset.Subset.{u2} (Set.{u2} R) (Set.instHasSubsetSet.{u2} R) (setOf.{u2} R (fun (y : R) => LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (OrderedCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (Units.val.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))) Œ≥))) s))
Case conversion may be inaccurate. Consider using '#align valued.mem_nhds Valued.mem_nhds‚Çì'. -/
theorem mem_nhds {s : Set R} {x : R} : s ‚àà ùìù x ‚Üî ‚àÉ Œ≥ : Œì‚ÇÄÀ£, { y | (v (y - x) : Œì‚ÇÄ) < Œ≥ } ‚äÜ s := by
  simp only [‚Üê nhds_translation_add_neg x, ‚Üê sub_eq_add_neg, preimage_set_of_eq, exists_true_left,
    ((has_basis_nhds_zero R Œì‚ÇÄ).comap fun y => y - x).mem_iff]
#align valued.mem_nhds Valued.mem_nhds

/- warning: valued.mem_nhds_zero -> Valued.mem_nhds_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {s : Set.{u2} R}, Iff (Membership.Mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (Filter.hasMem.{u2} R) s (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))))))) (Exists.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => HasSubset.Subset.{u2} (Set.{u2} R) (Set.hasSubset.{u2} R) (setOf.{u2} R (fun (x : R) => LT.lt.{u1} Œì‚ÇÄ (Preorder.toLT.{u1} Œì‚ÇÄ (PartialOrder.toPreorder.{u1} Œì‚ÇÄ (OrderedCommMonoid.toPartialOrder.{u1} Œì‚ÇÄ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (CoeTC‚Çì.coe.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (coeBase.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (Units.hasCoe.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))))) Œ≥))) s))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {s : Set.{u2} R}, Iff (Membership.mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (instMembershipSetFilter.{u2} R) s (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))))) (Exists.{succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) (fun (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) => HasSubset.Subset.{u2} (Set.{u2} R) (Set.instHasSubsetSet.{u2} R) (setOf.{u2} R (fun (x : R) => LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (OrderedCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x) (Units.val.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))) Œ≥))) s))
Case conversion may be inaccurate. Consider using '#align valued.mem_nhds_zero Valued.mem_nhds_zero‚Çì'. -/
theorem mem_nhds_zero {s : Set R} : s ‚àà ùìù (0 : R) ‚Üî ‚àÉ Œ≥ : Œì‚ÇÄÀ£, { x | v x < (Œ≥ : Œì‚ÇÄ) } ‚äÜ s := by
  simp only [mem_nhds, sub_zero]
#align valued.mem_nhds_zero Valued.mem_nhds_zero

/- warning: valued.loc_const -> Valued.loc_const is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {x : R}, (Ne.{succ u1} Œì‚ÇÄ (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x) (OfNat.ofNat.{u1} Œì‚ÇÄ 0 (OfNat.mk.{u1} Œì‚ÇÄ 0 (Zero.zero.{u1} Œì‚ÇÄ (MulZeroClass.toHasZero.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulZeroClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))))))) -> (Membership.Mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (Filter.hasMem.{u2} R) (setOf.{u2} R (fun (y : R) => Eq.{succ u1} Œì‚ÇÄ (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) y) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x))) (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) x))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {x : R}, (Ne.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommMonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) x) _inst_2))))) -> (Membership.mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (instMembershipSetFilter.{u2} R) (setOf.{u2} R (fun (y : R) => Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) y) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) y) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) x))) (nhds.{u2} R (UniformSpace.toTopologicalSpace.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i)) x))
Case conversion may be inaccurate. Consider using '#align valued.loc_const Valued.loc_const‚Çì'. -/
theorem loc_const {x : R} (h : (v x : Œì‚ÇÄ) ‚â† 0) : { y : R | v y = v x } ‚àà ùìù x :=
  by
  rw [mem_nhds]
  rcases units.exists_iff_ne_zero.mpr h with ‚ü®Œ≥, hx‚ü©
  use Œ≥
  rw [hx]
  intro y y_in
  exact Valuation.map_eq_of_sub_lt _ y_in
#align valued.loc_const Valued.loc_const

instance (priority := 100) : TopologicalRing R :=
  (toUniformSpace_eq R Œì‚ÇÄ).symm ‚ñ∏ v.subgroups_basis.toRingFilterBasis.isTopologicalRing

/- warning: valued.cauchy_iff -> Valued.cauchy_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {F : Filter.{u2} R}, Iff (Cauchy.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) F) (And (Filter.NeBot.{u2} R F) (forall (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))), Exists.{succ u2} (Set.{u2} R) (fun (M : Set.{u2} R) => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (Filter.hasMem.{u2} R) M F) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (Filter.hasMem.{u2} R) M F) => forall (x : R), (Membership.Mem.{u2, u2} R (Set.{u2} R) (Set.hasMem.{u2} R) x M) -> (forall (y : R), (Membership.Mem.{u2, u2} R (Set.{u2} R) (Set.hasMem.{u2} R) y M) -> (LT.lt.{u1} Œì‚ÇÄ (Preorder.toLT.{u1} Œì‚ÇÄ (PartialOrder.toPreorder.{u1} Œì‚ÇÄ (OrderedCommMonoid.toPartialOrder.{u1} Œì‚ÇÄ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) (fun (_x : Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) => R -> Œì‚ÇÄ) (Valuation.hasCoeToFun.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R _inst_1)))))) y x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (CoeTC‚Çì.coe.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (coeBase.{succ u1, succ u1} (Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))) Œì‚ÇÄ (Units.hasCoe.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))))))) Œ≥)))))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {Œì‚ÇÄ : Type.{u1}} [_inst_2 : LinearOrderedCommGroupWithZero.{u1} Œì‚ÇÄ] [_i : Valued.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2] {F : Filter.{u2} R}, Iff (Cauchy.{u2} R (Valued.toUniformSpace.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) F) (And (Filter.NeBot.{u2} R F) (forall (Œ≥ : Units.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2))))), Exists.{succ u2} (Set.{u2} R) (fun (M : Set.{u2} R) => And (Membership.mem.{u2, u2} (Set.{u2} R) (Filter.{u2} R) (instMembershipSetFilter.{u2} R) M F) (forall (x : R), (Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x M) -> (forall (y : R), (Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) y M) -> (LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (OrderedCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Œì‚ÇÄ) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (MulOneClass.toMul.{u1} Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u1} Œì‚ÇÄ (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (MonoidWithZero.toMulZeroOneClass.{u1} Œì‚ÇÄ (CommMonoidWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1) R Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2) _inst_1 (Valuation.instValuationClassValuation.{u2, u1} R Œì‚ÇÄ _inst_1 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Œì‚ÇÄ _inst_2)))))) (Valued.v.{u1, u2} R _inst_1 Œì‚ÇÄ _inst_2 _i) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) y x)) (Units.val.{u1} Œì‚ÇÄ (MonoidWithZero.toMonoid.{u1} Œì‚ÇÄ (GroupWithZero.toMonoidWithZero.{u1} Œì‚ÇÄ (CommGroupWithZero.toGroupWithZero.{u1} Œì‚ÇÄ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} Œì‚ÇÄ _inst_2)))) Œ≥)))))))
Case conversion may be inaccurate. Consider using '#align valued.cauchy_iff Valued.cauchy_iff‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª M) -/
theorem cauchy_iff {F : Filter R} :
    Cauchy F ‚Üî
      F.ne_bot ‚àß ‚àÄ Œ≥ : Œì‚ÇÄÀ£, ‚àÉ M ‚àà F, ‚àÄ (x) (_ : x ‚àà M) (y) (_ : y ‚àà M), (v (y - x) : Œì‚ÇÄ) < Œ≥ :=
  by
  rw [to_uniform_space_eq, AddGroupFilterBasis.cauchy_iff]
  apply and_congr Iff.rfl
  simp_rw [valued.v.subgroups_basis.mem_add_group_filter_basis_iff]
  constructor
  ¬∑ intro h Œ≥
    exact h _ (valued.v.subgroups_basis.mem_add_group_filter_basis _)
  ¬∑ rintro h - ‚ü®Œ≥, rfl‚ü©
    exact h Œ≥
#align valued.cauchy_iff Valued.cauchy_iff

end Valued

