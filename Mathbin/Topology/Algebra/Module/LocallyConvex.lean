/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker

! This file was ported from Lean 3 source module topology.algebra.module.locally_convex
! leanprover-community/mathlib commit 4280f5f32e16755ec7985ce11e189b6cd6ff6735
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Topology

/-!
# Locally convex topological modules

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

A `locally_convex_space` is a topological semimodule over an ordered semiring in which any point
admits a neighborhood basis made of convex sets, or equivalently, in which convex neighborhoods of
a point form a neighborhood basis at that point.

In a module, this is equivalent to `0` satisfying such properties.

## Main results

- `locally_convex_space_iff_zero` : in a module, local convexity at zero gives
  local convexity everywhere
- `seminorm.locally_convex_space` : a topology generated by a family of seminorms is locally convex
- `normed_space.locally_convex_space` : a normed space is locally convex

## TODO

- define a structure `locally_convex_filter_basis`, extending `module_filter_basis`, for filter
  bases generating a locally convex topology

-/


open TopologicalSpace Filter Set

open Topology Pointwise

section Semimodule

#print LocallyConvexSpace /-
/-- A `locally_convex_space` is a topological semimodule over an ordered semiring in which convex
neighborhoods of a point form a neighborhood basis at that point. -/
class LocallyConvexSpace (ğ•œ E : Type _) [OrderedSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E]
  [TopologicalSpace E] : Prop where
  convex_basis : âˆ€ x : E, (ğ“ x).HasBasis (fun s : Set E => s âˆˆ ğ“ x âˆ§ Convex ğ•œ s) id
#align locally_convex_space LocallyConvexSpace
-/

variable (ğ•œ E : Type _) [OrderedSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E] [TopologicalSpace E]

/- warning: locally_convex_space_iff -> locallyConvexSpace_iff is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_4 : TopologicalSpace.{u2} E], Iff (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4) (forall (x : E), Filter.HasBasis.{u2, succ u2} E (Set.{u2} E) (nhds.{u2} E _inst_4 x) (fun (s : Set.{u2} E) => And (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) s (nhds.{u2} E _inst_4 x)) (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3)))) s)) (id.{succ u2} (Set.{u2} E)))
but is expected to have type
  forall (ğ•œ : Type.{u2}) (E : Type.{u1}) [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_4 : TopologicalSpace.{u1} E], Iff (LocallyConvexSpace.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4) (forall (x : E), Filter.HasBasis.{u1, succ u1} E (Set.{u1} E) (nhds.{u1} E _inst_4 x) (fun (s : Set.{u1} E) => And (Membership.mem.{u1, u1} (Set.{u1} E) (Filter.{u1} E) (instMembershipSetFilter.{u1} E) s (nhds.{u1} E _inst_4 x)) (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3)))) s)) (id.{succ u1} (Set.{u1} E)))
Case conversion may be inaccurate. Consider using '#align locally_convex_space_iff locallyConvexSpace_iffâ‚“'. -/
theorem locallyConvexSpace_iff :
    LocallyConvexSpace ğ•œ E â†” âˆ€ x : E, (ğ“ x).HasBasis (fun s : Set E => s âˆˆ ğ“ x âˆ§ Convex ğ•œ s) id :=
  âŸ¨@LocallyConvexSpace.convex_basis _ _ _ _ _ _, LocallyConvexSpace.mkâŸ©
#align locally_convex_space_iff locallyConvexSpace_iff

#print LocallyConvexSpace.ofBases /-
theorem LocallyConvexSpace.ofBases {Î¹ : Type _} (b : E â†’ Î¹ â†’ Set E) (p : E â†’ Î¹ â†’ Prop)
    (hbasis : âˆ€ x : E, (ğ“ x).HasBasis (p x) (b x)) (hconvex : âˆ€ x i, p x i â†’ Convex ğ•œ (b x i)) :
    LocallyConvexSpace ğ•œ E :=
  âŸ¨fun x =>
    (hbasis x).to_hasBasis
      (fun i hi => âŸ¨b x i, âŸ¨âŸ¨(hbasis x).mem_of_mem hi, hconvex x i hiâŸ©, le_refl (b x i)âŸ©âŸ©)
      fun s hs =>
      âŸ¨(hbasis x).index s hs.1, âŸ¨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1âŸ©âŸ©âŸ©
#align locally_convex_space.of_bases LocallyConvexSpace.ofBases
-/

/- warning: locally_convex_space.convex_basis_zero -> LocallyConvexSpace.convex_basis_zero is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4], Filter.HasBasis.{u2, succ u2} E (Set.{u2} E) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))))) (fun (s : Set.{u2} E) => And (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) s (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))))))) (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3)))) s)) (id.{succ u2} (Set.{u2} E))
but is expected to have type
  forall (ğ•œ : Type.{u2}) (E : Type.{u1}) [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : LocallyConvexSpace.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4], Filter.HasBasis.{u1, succ u1} E (Set.{u1} E) (nhds.{u1} E _inst_4 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))))) (fun (s : Set.{u1} E) => And (Membership.mem.{u1, u1} (Set.{u1} E) (Filter.{u1} E) (instMembershipSetFilter.{u1} E) s (nhds.{u1} E _inst_4 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))))) (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3)))) s)) (id.{succ u1} (Set.{u1} E))
Case conversion may be inaccurate. Consider using '#align locally_convex_space.convex_basis_zero LocallyConvexSpace.convex_basis_zeroâ‚“'. -/
theorem LocallyConvexSpace.convex_basis_zero [LocallyConvexSpace ğ•œ E] :
    (ğ“ 0 : Filter E).HasBasis (fun s => s âˆˆ (ğ“ 0 : Filter E) âˆ§ Convex ğ•œ s) id :=
  LocallyConvexSpace.convex_basis 0
#align locally_convex_space.convex_basis_zero LocallyConvexSpace.convex_basis_zero

/- warning: locally_convex_space_iff_exists_convex_subset -> locallyConvexSpace_iff_exists_convex_subset is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_4 : TopologicalSpace.{u2} E], Iff (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4) (forall (x : E) (U : Set.{u2} E), (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) U (nhds.{u2} E _inst_4 x)) -> (Exists.{succ u2} (Set.{u2} E) (fun (S : Set.{u2} E) => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) S (nhds.{u2} E _inst_4 x)) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) S (nhds.{u2} E _inst_4 x)) => And (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3)))) S) (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) S U)))))
but is expected to have type
  forall (ğ•œ : Type.{u2}) (E : Type.{u1}) [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_4 : TopologicalSpace.{u1} E], Iff (LocallyConvexSpace.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4) (forall (x : E) (U : Set.{u1} E), (Membership.mem.{u1, u1} (Set.{u1} E) (Filter.{u1} E) (instMembershipSetFilter.{u1} E) U (nhds.{u1} E _inst_4 x)) -> (Exists.{succ u1} (Set.{u1} E) (fun (S : Set.{u1} E) => And (Membership.mem.{u1, u1} (Set.{u1} E) (Filter.{u1} E) (instMembershipSetFilter.{u1} E) S (nhds.{u1} E _inst_4 x)) (And (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3)))) S) (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) S U)))))
Case conversion may be inaccurate. Consider using '#align locally_convex_space_iff_exists_convex_subset locallyConvexSpace_iff_exists_convex_subsetâ‚“'. -/
theorem locallyConvexSpace_iff_exists_convex_subset :
    LocallyConvexSpace ğ•œ E â†” âˆ€ x : E, âˆ€ U âˆˆ ğ“ x, âˆƒ S âˆˆ ğ“ x, Convex ğ•œ S âˆ§ S âŠ† U :=
  (locallyConvexSpace_iff ğ•œ E).trans (forall_congr' fun x => hasBasis_self)
#align locally_convex_space_iff_exists_convex_subset locallyConvexSpace_iff_exists_convex_subset

end Semimodule

section Module

variable (ğ•œ E : Type _) [OrderedSemiring ğ•œ] [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E]
  [TopologicalAddGroup E]

/- warning: locally_convex_space.of_basis_zero -> LocallyConvexSpace.ofBasisZero is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : TopologicalAddGroup.{u2} E _inst_4 (AddCommGroup.toAddGroup.{u2} E _inst_2)] {Î¹ : Type.{u3}} (b : Î¹ -> (Set.{u2} E)) (p : Î¹ -> Prop), (Filter.HasBasis.{u2, succ u3} E Î¹ (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) p b) -> (forall (i : Î¹), (p i) -> (Convex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (b i))) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 _inst_4)
but is expected to have type
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : TopologicalAddGroup.{u2} E _inst_4 (AddCommGroup.toAddGroup.{u2} E _inst_2)] {Î¹ : Type.{u3}} (b : Î¹ -> (Set.{u2} E)) (p : Î¹ -> Prop), (Filter.HasBasis.{u2, succ u3} E Î¹ (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))) p b) -> (forall (i : Î¹), (p i) -> (Convex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (b i))) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align locally_convex_space.of_basis_zero LocallyConvexSpace.ofBasisZeroâ‚“'. -/
theorem LocallyConvexSpace.ofBasisZero {Î¹ : Type _} (b : Î¹ â†’ Set E) (p : Î¹ â†’ Prop)
    (hbasis : (ğ“ 0).HasBasis p b) (hconvex : âˆ€ i, p i â†’ Convex ğ•œ (b i)) : LocallyConvexSpace ğ•œ E :=
  by
  refine'
    LocallyConvexSpace.ofBases ğ•œ E (fun (x : E) (i : Î¹) => (Â· + Â·) x '' b i) (fun _ => p)
      (fun x => _) fun x i hi => (hconvex i hi).translate x
  rw [â† map_add_left_nhds_zero]
  exact hbasis.map _
#align locally_convex_space.of_basis_zero LocallyConvexSpace.ofBasisZero

/- warning: locally_convex_space_iff_zero -> locallyConvexSpace_iff_zero is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : TopologicalAddGroup.{u2} E _inst_4 (AddCommGroup.toAddGroup.{u2} E _inst_2)], Iff (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 _inst_4) (Filter.HasBasis.{u2, succ u2} E (Set.{u2} E) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) (fun (s : Set.{u2} E) => And (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) s (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))))) (Convex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)) (id.{succ u2} (Set.{u2} E)))
but is expected to have type
  forall (ğ•œ : Type.{u2}) (E : Type.{u1}) [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : TopologicalAddGroup.{u1} E _inst_4 (AddCommGroup.toAddGroup.{u1} E _inst_2)], Iff (LocallyConvexSpace.{u2, u1} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3 _inst_4) (Filter.HasBasis.{u1, succ u1} E (Set.{u1} E) (nhds.{u1} E _inst_4 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2)))))))) (fun (s : Set.{u1} E) => And (Membership.mem.{u1, u1} (Set.{u1} E) (Filter.{u1} E) (instMembershipSetFilter.{u1} E) s (nhds.{u1} E _inst_4 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))))))) (Convex.{u2, u1} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) s)) (id.{succ u1} (Set.{u1} E)))
Case conversion may be inaccurate. Consider using '#align locally_convex_space_iff_zero locallyConvexSpace_iff_zeroâ‚“'. -/
theorem locallyConvexSpace_iff_zero :
    LocallyConvexSpace ğ•œ E â†”
      (ğ“ 0 : Filter E).HasBasis (fun s : Set E => s âˆˆ (ğ“ 0 : Filter E) âˆ§ Convex ğ•œ s) id :=
  âŸ¨fun h => @LocallyConvexSpace.convex_basis _ _ _ _ _ _ h 0, fun h =>
    LocallyConvexSpace.ofBasisZero ğ•œ E _ _ h fun s => And.rightâŸ©
#align locally_convex_space_iff_zero locallyConvexSpace_iff_zero

/- warning: locally_convex_space_iff_exists_convex_subset_zero -> locallyConvexSpace_iff_exists_convex_subset_zero is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : TopologicalAddGroup.{u2} E _inst_4 (AddCommGroup.toAddGroup.{u2} E _inst_2)], Iff (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 _inst_4) (forall (U : Set.{u2} E), (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) U (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))))) -> (Exists.{succ u2} (Set.{u2} E) (fun (S : Set.{u2} E) => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) S (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))))) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) S (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))))) => And (Convex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) S) (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) S U)))))
but is expected to have type
  forall (ğ•œ : Type.{u2}) (E : Type.{u1}) [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : TopologicalAddGroup.{u1} E _inst_4 (AddCommGroup.toAddGroup.{u1} E _inst_2)], Iff (LocallyConvexSpace.{u2, u1} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3 _inst_4) (forall (U : Set.{u1} E), (Membership.mem.{u1, u1} (Set.{u1} E) (Filter.{u1} E) (instMembershipSetFilter.{u1} E) U (nhds.{u1} E _inst_4 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))))))) -> (Exists.{succ u1} (Set.{u1} E) (fun (S : Set.{u1} E) => And (Membership.mem.{u1, u1} (Set.{u1} E) (Filter.{u1} E) (instMembershipSetFilter.{u1} E) S (nhds.{u1} E _inst_4 (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))))))) (And (Convex.{u2, u1} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) S) (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) S U)))))
Case conversion may be inaccurate. Consider using '#align locally_convex_space_iff_exists_convex_subset_zero locallyConvexSpace_iff_exists_convex_subset_zeroâ‚“'. -/
theorem locallyConvexSpace_iff_exists_convex_subset_zero :
    LocallyConvexSpace ğ•œ E â†” âˆ€ U âˆˆ (ğ“ 0 : Filter E), âˆƒ S âˆˆ (ğ“ 0 : Filter E), Convex ğ•œ S âˆ§ S âŠ† U :=
  (locallyConvexSpace_iff_zero ğ•œ E).trans hasBasis_self
#align locally_convex_space_iff_exists_convex_subset_zero locallyConvexSpace_iff_exists_convex_subset_zero

#print LocallyConvexSpace.toLocallyConnectedSpace /-
-- see Note [lower instance priority]
instance (priority := 100) LocallyConvexSpace.toLocallyConnectedSpace [Module â„ E]
    [ContinuousSMul â„ E] [LocallyConvexSpace â„ E] : LocallyConnectedSpace E :=
  locallyConnectedSpace_of_connected_bases _ _
    (fun x => @LocallyConvexSpace.convex_basis â„ _ _ _ _ _ _ x) fun x s hs => hs.2.IsPreconnected
#align locally_convex_space.to_locally_connected_space LocallyConvexSpace.toLocallyConnectedSpace
-/

end Module

section LinearOrderedField

variable (ğ•œ E : Type _) [LinearOrderedField ğ•œ] [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E]
  [TopologicalAddGroup E] [ContinuousConstSMul ğ•œ E]

/- warning: locally_convex_space.convex_open_basis_zero -> LocallyConvexSpace.convex_open_basis_zero is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align locally_convex_space.convex_open_basis_zero LocallyConvexSpace.convex_open_basis_zeroâ‚“'. -/
theorem LocallyConvexSpace.convex_open_basis_zero [LocallyConvexSpace ğ•œ E] :
    (ğ“ 0 : Filter E).HasBasis (fun s => (0 : E) âˆˆ s âˆ§ IsOpen s âˆ§ Convex ğ•œ s) id :=
  (LocallyConvexSpace.convex_basis_zero ğ•œ E).to_hasBasis
    (fun s hs =>
      âŸ¨interior s, âŸ¨mem_interior_iff_mem_nhds.mpr hs.1, isOpen_interior, hs.2.interiorâŸ©,
        interior_subsetâŸ©)
    fun s hs => âŸ¨s, âŸ¨hs.2.1.mem_nhds hs.1, hs.2.2âŸ©, subset_rflâŸ©
#align locally_convex_space.convex_open_basis_zero LocallyConvexSpace.convex_open_basis_zero

variable {ğ•œ E}

/- warning: disjoint.exists_open_convexes -> Disjoint.exists_open_convexes is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align disjoint.exists_open_convexes Disjoint.exists_open_convexesâ‚“'. -/
/-- In a locally convex space, if `s`, `t` are disjoint convex sets, `s` is compact and `t` is
closed, then we can find open disjoint convex sets containing them. -/
theorem Disjoint.exists_open_convexes [LocallyConvexSpace ğ•œ E] {s t : Set E} (disj : Disjoint s t)
    (hsâ‚ : Convex ğ•œ s) (hsâ‚‚ : IsCompact s) (htâ‚ : Convex ğ•œ t) (htâ‚‚ : IsClosed t) :
    âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ Convex ğ•œ u âˆ§ Convex ğ•œ v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint u v :=
  by
  letI : UniformSpace E := TopologicalAddGroup.toUniformSpace E
  haveI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform
  have := (LocallyConvexSpace.convex_open_basis_zero ğ•œ E).comap fun x : E Ã— E => x.2 - x.1
  rw [â† uniformity_eq_comap_nhds_zero] at this
  rcases disj.exists_uniform_thickening_of_basis this hsâ‚‚ htâ‚‚ with âŸ¨V, âŸ¨hV0, hVopen, hVconvexâŸ©, hVâŸ©
  refine'
    âŸ¨s + V, t + V, hVopen.add_left, hVopen.add_left, hsâ‚.add hVconvex, htâ‚.add hVconvex,
      subset_add_left _ hV0, subset_add_left _ hV0, _âŸ©
  simp_rw [â† Union_add_left_image, image_add_left]
  simp_rw [UniformSpace.ball, â† preimage_comp, sub_eq_neg_add] at hV
  exact hV
#align disjoint.exists_open_convexes Disjoint.exists_open_convexes

end LinearOrderedField

section LatticeOps

variable {Î¹ : Sort _} {ğ•œ E F : Type _} [OrderedSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E]
  [AddCommMonoid F] [Module ğ•œ F]

/- warning: locally_convex_space_Inf -> locallyConvexSpace_sInf is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {ts : Set.{u2} (TopologicalSpace.{u2} E)}, (forall (t : TopologicalSpace.{u2} E), (Membership.Mem.{u2, u2} (TopologicalSpace.{u2} E) (Set.{u2} (TopologicalSpace.{u2} E)) (Set.hasMem.{u2} (TopologicalSpace.{u2} E)) t ts) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 t)) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 (InfSet.sInf.{u2} (TopologicalSpace.{u2} E) (ConditionallyCompleteLattice.toHasInf.{u2} (TopologicalSpace.{u2} E) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.{u2} E) (TopologicalSpace.completeLattice.{u2} E))) ts))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {ts : Set.{u2} (TopologicalSpace.{u2} E)}, (forall (t : TopologicalSpace.{u2} E), (Membership.mem.{u2, u2} (TopologicalSpace.{u2} E) (Set.{u2} (TopologicalSpace.{u2} E)) (Set.instMembershipSet.{u2} (TopologicalSpace.{u2} E)) t ts) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 t)) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 (InfSet.sInf.{u2} (TopologicalSpace.{u2} E) (ConditionallyCompleteLattice.toInfSet.{u2} (TopologicalSpace.{u2} E) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.{u2} E) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{u2} E))) ts))
Case conversion may be inaccurate. Consider using '#align locally_convex_space_Inf locallyConvexSpace_sInfâ‚“'. -/
theorem locallyConvexSpace_sInf {ts : Set (TopologicalSpace E)}
    (h : âˆ€ t âˆˆ ts, @LocallyConvexSpace ğ•œ E _ _ _ t) : @LocallyConvexSpace ğ•œ E _ _ _ (sInf ts) :=
  by
  letI : TopologicalSpace E := Inf ts
  refine'
    LocallyConvexSpace.ofBases ğ•œ E (fun x => fun If : Set ts Ã— (ts â†’ Set E) => â‹‚ i âˆˆ If.1, If.2 i)
      (fun x => fun If : Set ts Ã— (ts â†’ Set E) =>
        If.1.Finite âˆ§ âˆ€ i âˆˆ If.1, If.2 i âˆˆ @nhds _ (â†‘i) x âˆ§ Convex ğ•œ (If.2 i))
      (fun x => _) fun x If hif => convex_iInter fun i => convex_iInter fun hi => (hif.2 i hi).2
  rw [nhds_sInf, â† iInf_subtype'']
  exact has_basis_infi' fun i : ts => (@locallyConvexSpace_iff ğ•œ E _ _ _ â†‘i).mp (h (â†‘i) i.2) x
#align locally_convex_space_Inf locallyConvexSpace_sInf

/- warning: locally_convex_space_infi -> locallyConvexSpace_iInf is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Sort.{u1}} {ğ•œ : Type.{u2}} {E : Type.{u3}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : Module.{u2, u3} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {ts' : Î¹ -> (TopologicalSpace.{u3} E)}, (forall (i : Î¹), LocallyConvexSpace.{u2, u3} ğ•œ E _inst_1 _inst_2 _inst_3 (ts' i)) -> (LocallyConvexSpace.{u2, u3} ğ•œ E _inst_1 _inst_2 _inst_3 (iInf.{u3, u1} (TopologicalSpace.{u3} E) (ConditionallyCompleteLattice.toHasInf.{u3} (TopologicalSpace.{u3} E) (CompleteLattice.toConditionallyCompleteLattice.{u3} (TopologicalSpace.{u3} E) (TopologicalSpace.completeLattice.{u3} E))) Î¹ (fun (i : Î¹) => ts' i)))
but is expected to have type
  forall {Î¹ : Sort.{u1}} {ğ•œ : Type.{u2}} {E : Type.{u3}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : Module.{u2, u3} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {ts' : Î¹ -> (TopologicalSpace.{u3} E)}, (forall (i : Î¹), LocallyConvexSpace.{u2, u3} ğ•œ E _inst_1 _inst_2 _inst_3 (ts' i)) -> (LocallyConvexSpace.{u2, u3} ğ•œ E _inst_1 _inst_2 _inst_3 (iInf.{u3, u1} (TopologicalSpace.{u3} E) (ConditionallyCompleteLattice.toInfSet.{u3} (TopologicalSpace.{u3} E) (CompleteLattice.toConditionallyCompleteLattice.{u3} (TopologicalSpace.{u3} E) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{u3} E))) Î¹ (fun (i : Î¹) => ts' i)))
Case conversion may be inaccurate. Consider using '#align locally_convex_space_infi locallyConvexSpace_iInfâ‚“'. -/
theorem locallyConvexSpace_iInf {ts' : Î¹ â†’ TopologicalSpace E}
    (h' : âˆ€ i, @LocallyConvexSpace ğ•œ E _ _ _ (ts' i)) :
    @LocallyConvexSpace ğ•œ E _ _ _ (â¨… i, ts' i) :=
  by
  refine' locallyConvexSpace_sInf _
  rwa [forall_range_iff]
#align locally_convex_space_infi locallyConvexSpace_iInf

/- warning: locally_convex_space_inf -> locallyConvexSpace_inf is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {tâ‚ : TopologicalSpace.{u2} E} {tâ‚‚ : TopologicalSpace.{u2} E}, (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 tâ‚) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 tâ‚‚) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 (Inf.inf.{u2} (TopologicalSpace.{u2} E) (SemilatticeInf.toHasInf.{u2} (TopologicalSpace.{u2} E) (Lattice.toSemilatticeInf.{u2} (TopologicalSpace.{u2} E) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.{u2} E) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.{u2} E) (TopologicalSpace.completeLattice.{u2} E))))) tâ‚ tâ‚‚))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {tâ‚ : TopologicalSpace.{u2} E} {tâ‚‚ : TopologicalSpace.{u2} E}, (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 tâ‚) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 tâ‚‚) -> (LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 (Inf.inf.{u2} (TopologicalSpace.{u2} E) (Lattice.toInf.{u2} (TopologicalSpace.{u2} E) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.{u2} E) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.{u2} E) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{u2} E)))) tâ‚ tâ‚‚))
Case conversion may be inaccurate. Consider using '#align locally_convex_space_inf locallyConvexSpace_infâ‚“'. -/
theorem locallyConvexSpace_inf {tâ‚ tâ‚‚ : TopologicalSpace E} (hâ‚ : @LocallyConvexSpace ğ•œ E _ _ _ tâ‚)
    (hâ‚‚ : @LocallyConvexSpace ğ•œ E _ _ _ tâ‚‚) : @LocallyConvexSpace ğ•œ E _ _ _ (tâ‚ âŠ“ tâ‚‚) := by
  rw [inf_eq_iInf]; refine' locallyConvexSpace_iInf fun b => _; cases b <;> assumption
#align locally_convex_space_inf locallyConvexSpace_inf

/- warning: locally_convex_space_induced -> locallyConvexSpace_induced is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_4 : AddCommMonoid.{u3} F] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_4] {t : TopologicalSpace.{u3} F} [_inst_6 : LocallyConvexSpace.{u1, u3} ğ•œ F _inst_1 _inst_4 _inst_5 t] (f : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_4 _inst_3 _inst_5), LocallyConvexSpace.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 (TopologicalSpace.induced.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_4 _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_4 _inst_3 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f) t)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_4 : AddCommMonoid.{u3} F] [_inst_5 : Module.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_4] {t : TopologicalSpace.{u3} F} [_inst_6 : LocallyConvexSpace.{u2, u3} ğ•œ F _inst_1 _inst_4 _inst_5 t] (f : LinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) E F _inst_2 _inst_4 _inst_3 _inst_5), LocallyConvexSpace.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 (TopologicalSpace.induced.{u1, u3} E F (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) E F _inst_2 _inst_4 _inst_3 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))) f) t)
Case conversion may be inaccurate. Consider using '#align locally_convex_space_induced locallyConvexSpace_inducedâ‚“'. -/
theorem locallyConvexSpace_induced {t : TopologicalSpace F} [LocallyConvexSpace ğ•œ F]
    (f : E â†’â‚—[ğ•œ] F) : @LocallyConvexSpace ğ•œ E _ _ _ (t.induced f) :=
  by
  letI : TopologicalSpace E := t.induced f
  refine'
    LocallyConvexSpace.ofBases ğ•œ E (fun x => preimage f)
      (fun x => fun s : Set F => s âˆˆ ğ“ (f x) âˆ§ Convex ğ•œ s) (fun x => _) fun x s âŸ¨_, hsâŸ© =>
      hs.linear_preimage f
  rw [nhds_induced]
  exact (LocallyConvexSpace.convex_basis <| f x).comap f
#align locally_convex_space_induced locallyConvexSpace_induced

instance {Î¹ : Type _} {X : Î¹ â†’ Type _} [âˆ€ i, AddCommMonoid (X i)] [âˆ€ i, TopologicalSpace (X i)]
    [âˆ€ i, Module ğ•œ (X i)] [âˆ€ i, LocallyConvexSpace ğ•œ (X i)] : LocallyConvexSpace ğ•œ (âˆ€ i, X i) :=
  locallyConvexSpace_iInf fun i => locallyConvexSpace_induced (LinearMap.proj i)

instance [TopologicalSpace E] [TopologicalSpace F] [LocallyConvexSpace ğ•œ E]
    [LocallyConvexSpace ğ•œ F] : LocallyConvexSpace ğ•œ (E Ã— F) :=
  locallyConvexSpace_inf (locallyConvexSpace_induced (LinearMap.fst _ _ _))
    (locallyConvexSpace_induced (LinearMap.snd _ _ _))

end LatticeOps

