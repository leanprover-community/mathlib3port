import Mathbin.Algebra.GroupWithZero.Power 
import Mathbin.Data.Set.Intervals.Pi 
import Mathbin.Order.Filter.Interval 
import Mathbin.Topology.Algebra.Group 
import Mathbin.Tactic.Linarith.Default 
import Mathbin.Tactic.Tfae

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-âˆ, a)` and `(b, +âˆ)`). We define it as `preorder.topology Î±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Î±`). Instead,
we introduce a class `order_topology Î±` (which is a `Prop`, also known as a mixin) saying that on
the type `Î±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Î±` saying that the set of points
`(x, y)` with `x â‰¤ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x â‰¤ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x â‰¤ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z âˆˆ (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z âˆˆ [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x â‰¤ g x`, then `a â‰¤ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x â‰¤ b`
  (resp., `b â‰¤ f x`), then `a â‰¤ b` (resp., `b â‰¤ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x â‰¤ f x â‰¤ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `â„•` or `â„¤`, or `â„` that could inherit a topology as the completion of `â„š`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Î±` though, that can be registered as an instance when necessary, or
for specific types.
-/


open Classical Set Filter TopologicalSpace

open Function

open order_dual(toDual ofDual)

open_locale TopologicalSpace Classical Filter

universe u v w

variable {Î± : Type u} {Î² : Type v} {Î³ : Type w}

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x â‰¤ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class OrderClosedTopology (Î± : Type _) [TopologicalSpace Î±] [Preorderâ‚“ Î±] : Prop where 
  is_closed_le' : IsClosed { p : Î± Ã— Î± | p.1 â‰¤ p.2 }

instance : âˆ€ [TopologicalSpace Î±], TopologicalSpace (OrderDual Î±) :=
  id

instance [TopologicalSpace Î±] [h : first_countable_topology Î±] : first_countable_topology (OrderDual Î±) :=
  h

instance [TopologicalSpace Î±] [h : second_countable_topology Î±] : second_countable_topology (OrderDual Î±) :=
  h

@[toAdditive]
instance [TopologicalSpace Î±] [Mul Î±] [h : HasContinuousMul Î±] : HasContinuousMul (OrderDual Î±) :=
  h

theorem Dense.order_dual [TopologicalSpace Î±] {s : Set Î±} (hs : Dense s) : Dense (OrderDual.ofDual â»Â¹' s) :=
  hs

section OrderClosedTopology

section Preorderâ‚“

variable [TopologicalSpace Î±] [Preorderâ‚“ Î±] [t : OrderClosedTopology Î±]

include t

namespace Subtype

instance {p : Î± â†’ Prop} : OrderClosedTopology (Subtype p) :=
  have this : Continuous fun p : Subtype p Ã— Subtype p => ((p.fst : Î±), (p.snd : Î±)) :=
    (continuous_subtype_coe.comp continuous_fst).prod_mk (continuous_subtype_coe.comp continuous_snd)
  OrderClosedTopology.mk (t.is_closed_le'.preimage this)

end Subtype

theorem is_closed_le_prod : IsClosed { p : Î± Ã— Î± | p.1 â‰¤ p.2 } :=
  t.is_closed_le'

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  is_closed_le
  [ TopologicalSpace Î² ] { f g : Î² â†’ Î± } ( hf : Continuous f ) ( hg : Continuous g ) : IsClosed { b | f b â‰¤ g b }
  := continuous_iff_is_closed . mp hf.prod_mk hg _ is_closed_le_prod

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem is_closed_le' ( a : Î± ) : IsClosed { b | b â‰¤ a } := is_closed_le continuous_id continuous_const

theorem is_closed_Iic {a : Î±} : IsClosed (Iic a) :=
  is_closed_le' a

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem is_closed_ge' ( a : Î± ) : IsClosed { b | a â‰¤ b } := is_closed_le continuous_const continuous_id

theorem is_closed_Ici {a : Î±} : IsClosed (Ici a) :=
  is_closed_ge' a

instance : OrderClosedTopology (OrderDual Î±) :=
  âŸ¨(@OrderClosedTopology.is_closed_le' Î± _ _ _).Preimage continuous_swapâŸ©

theorem is_closed_Icc {a b : Î±} : IsClosed (Icc a b) :=
  IsClosed.inter is_closed_Ici is_closed_Iic

@[simp]
theorem closure_Icc (a b : Î±) : Closure (Icc a b) = Icc a b :=
  is_closed_Icc.closure_eq

@[simp]
theorem closure_Iic (a : Î±) : Closure (Iic a) = Iic a :=
  is_closed_Iic.closure_eq

@[simp]
theorem closure_Ici (a : Î±) : Closure (Ici a) = Ici a :=
  is_closed_Ici.closure_eq

theorem le_of_tendsto_of_tendsto {f g : Î² â†’ Î±} {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} [ne_bot b] (hf : tendsto f b (ğ“ aâ‚))
  (hg : tendsto g b (ğ“ aâ‚‚)) (h : f â‰¤á¶ [b] g) : aâ‚ â‰¤ aâ‚‚ :=
  have  : tendsto (fun b => (f b, g b)) b (ğ“ (aâ‚, aâ‚‚)) :=
    by 
      rw [nhds_prod_eq] <;> exact hf.prod_mk hg 
  show (aâ‚, aâ‚‚) âˆˆ { p : Î± Ã— Î± | p.1 â‰¤ p.2 } from t.is_closed_le'.mem_of_tendsto this h

theorem le_of_tendsto_of_tendsto' {f g : Î² â†’ Î±} {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} [ne_bot b] (hf : tendsto f b (ğ“ aâ‚))
  (hg : tendsto g b (ğ“ aâ‚‚)) (h : âˆ€ x, f x â‰¤ g x) : aâ‚ â‰¤ aâ‚‚ :=
  le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)

theorem le_of_tendsto {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a))
  (h : âˆ€á¶  c in x, f c â‰¤ b) : a â‰¤ b :=
  le_of_tendsto_of_tendsto limâ‚“ tendsto_const_nhds h

theorem le_of_tendsto' {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a)) (h : âˆ€ c, f c â‰¤ b) :
  a â‰¤ b :=
  le_of_tendsto limâ‚“ (eventually_of_forall h)

theorem ge_of_tendsto {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a))
  (h : âˆ€á¶  c in x, b â‰¤ f c) : b â‰¤ a :=
  le_of_tendsto_of_tendsto tendsto_const_nhds limâ‚“ h

theorem ge_of_tendsto' {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a)) (h : âˆ€ c, b â‰¤ f c) :
  b â‰¤ a :=
  ge_of_tendsto limâ‚“ (eventually_of_forall h)

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
@[ simp ]
  theorem
    closure_le_eq
    [ TopologicalSpace Î² ] { f g : Î² â†’ Î± } ( hf : Continuous f ) ( hg : Continuous g )
      : Closure { b | f b â‰¤ g b } = { b | f b â‰¤ g b }
    := is_closed_le hf hg . closure_eq

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  closure_lt_subset_le
  [ TopologicalSpace Î² ] { f g : Î² â†’ Î± } ( hf : Continuous f ) ( hg : Continuous g )
    : Closure { b | f b < g b } âŠ† { b | f b â‰¤ g b }
  := closure_minimal fun x => le_of_ltâ‚“ $ is_closed_le hf hg

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (y Â«expr âˆˆ Â» s)
theorem ContinuousWithinAt.closure_le [TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²} {x : Î²} (hx : x âˆˆ Closure s)
  (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) (h : âˆ€ y _ : y âˆˆ s, f y â‰¤ g y) : f x â‰¤ g x :=
  show (f x, g x) âˆˆ { p : Î± Ã— Î± | p.1 â‰¤ p.2 } from
    OrderClosedTopology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
/--
    If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
    then the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/
  theorem
    IsClosed.is_closed_le
    [ TopologicalSpace Î² ]
        { f g : Î² â†’ Î± }
        { s : Set Î² }
        ( hs : IsClosed s )
        ( hf : ContinuousOn f s )
        ( hg : ContinuousOn g s )
      : IsClosed { x âˆˆ s | f x â‰¤ g x }
    := hf.prod hg . preimage_closed_of_closed hs OrderClosedTopology.is_closed_le'

omit t

theorem nhds_within_Ici_ne_bot {a b : Î±} (Hâ‚‚ : a â‰¤ b) : ne_bot (ğ“[Ici a] b) :=
  nhds_within_ne_bot_of_mem Hâ‚‚

@[instance]
theorem nhds_within_Ici_self_ne_bot (a : Î±) : ne_bot (ğ“[Ici a] a) :=
  nhds_within_Ici_ne_bot (le_reflâ‚“ a)

theorem nhds_within_Iic_ne_bot {a b : Î±} (H : a â‰¤ b) : ne_bot (ğ“[Iic b] a) :=
  nhds_within_ne_bot_of_mem H

@[instance]
theorem nhds_within_Iic_self_ne_bot (a : Î±) : ne_bot (ğ“[Iic a] a) :=
  nhds_within_Iic_ne_bot (le_reflâ‚“ a)

end Preorderâ‚“

section PartialOrderâ‚“

variable [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [t : OrderClosedTopology Î±]

include t

private theorem is_closed_eq_aux : IsClosed { p : Î± Ã— Î± | p.1 = p.2 } :=
  by 
    simp only [le_antisymm_iffâ‚“] <;> exact IsClosed.inter t.is_closed_le' (is_closed_le continuous_snd continuous_fst)

instance (priority := 90) OrderClosedTopology.to_t2_space : T2Space Î± :=
  { t2 :=
      have  : IsOpen { p : Î± Ã— Î± | p.1 â‰  p.2 } := is_closed_eq_aux.is_open_compl 
      fun a b h =>
        let âŸ¨u, v, hu, hv, ha, hb, hâŸ© := is_open_prod_iff.mp this a b h
        âŸ¨u, v, hu, hv, ha, hb,
          Set.eq_empty_iff_forall_not_mem.2$
            fun a âŸ¨hâ‚, hâ‚‚âŸ© =>
              have  : a â‰  a := @h (a, a) âŸ¨hâ‚, hâ‚‚âŸ©
              this rflâŸ© }

end PartialOrderâ‚“

section LinearOrderâ‚“

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±]

theorem is_open_lt_prod : IsOpen { p : Î± Ã— Î± | p.1 < p.2 } :=
  by 
    simpRw [â†is_closed_compl_iff, compl_set_of, not_ltâ‚“]
    exact is_closed_le continuous_snd continuous_fst

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  is_open_lt
  [ TopologicalSpace Î² ] { f g : Î² â†’ Î± } ( hf : Continuous f ) ( hg : Continuous g ) : IsOpen { b | f b < g b }
  := by simp [ lt_iff_not_geâ‚“ , - not_leâ‚“ ] <;> exact is_closed_le hg hf . is_open_compl

variable {a b : Î±}

theorem is_open_Iio : IsOpen (Iio a) :=
  is_open_lt continuous_id continuous_const

theorem is_open_Ioi : IsOpen (Ioi a) :=
  is_open_lt continuous_const continuous_id

theorem is_open_Ioo : IsOpen (Ioo a b) :=
  IsOpen.inter is_open_Ioi is_open_Iio

@[simp]
theorem interior_Ioi : Interior (Ioi a) = Ioi a :=
  is_open_Ioi.interior_eq

@[simp]
theorem interior_Iio : Interior (Iio a) = Iio a :=
  is_open_Iio.interior_eq

@[simp]
theorem interior_Ioo : Interior (Ioo a b) = Ioo a b :=
  is_open_Ioo.interior_eq

theorem Iio_mem_nhds {a b : Î±} (h : a < b) : Iio b âˆˆ ğ“ a :=
  IsOpen.mem_nhds is_open_Iio h

theorem Ioi_mem_nhds {a b : Î±} (h : a < b) : Ioi a âˆˆ ğ“ b :=
  IsOpen.mem_nhds is_open_Ioi h

theorem Iic_mem_nhds {a b : Î±} (h : a < b) : Iic b âˆˆ ğ“ a :=
  mem_of_superset (Iio_mem_nhds h) Iio_subset_Iic_self

theorem Ici_mem_nhds {a b : Î±} (h : a < b) : Ici a âˆˆ ğ“ b :=
  mem_of_superset (Ioi_mem_nhds h) Ioi_subset_Ici_self

theorem Ioo_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ioo a b âˆˆ ğ“ x :=
  IsOpen.mem_nhds is_open_Ioo âŸ¨ha, hbâŸ©

theorem Ioc_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ioc a b âˆˆ ğ“ x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ioc_self

theorem Ico_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ico a b âˆˆ ğ“ x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ico_self

theorem Icc_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Icc a b âˆˆ ğ“ x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Icc_self

theorem eventually_le_of_tendsto_lt {l : Filter Î³} {f : Î³ â†’ Î±} {u v : Î±} (hv : v < u) (h : tendsto f l (ğ“ v)) :
  âˆ€á¶  a in l, f a â‰¤ u :=
  eventually.mono (tendsto_nhds.1 h (Â· < u) is_open_Iio hv) fun v => le_of_ltâ‚“

theorem eventually_ge_of_tendsto_gt {l : Filter Î³} {f : Î³ â†’ Î±} {u v : Î±} (hv : u < v) (h : tendsto f l (ğ“ v)) :
  âˆ€á¶  a in l, u â‰¤ f a :=
  eventually.mono (tendsto_nhds.1 h (Â· > u) is_open_Ioi hv) fun v => le_of_ltâ‚“

variable [TopologicalSpace Î³]

/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `ğ“[Ioi a] a` and
`ğ“[Ici a] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology Î±` -/


/-!
#### Right neighborhoods, point excluded
-/


theorem Ioo_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Ioo a c âˆˆ ğ“[Ioi b] b :=
  mem_nhds_within.2
    âŸ¨Iio c, is_open_Iio, H.2,
      by 
        rw [inter_comm, Ioi_inter_Iio] <;> exact Ioo_subset_Ioo_left H.1âŸ©

theorem Ioc_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Ioc a c âˆˆ ğ“[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Ico a c âˆˆ ğ“[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self

theorem Icc_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Icc a c âˆˆ ğ“[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self

@[simp]
theorem nhds_within_Ioc_eq_nhds_within_Ioi {a b : Î±} (h : a < b) : ğ“[Ioc a b] a = ğ“[Ioi a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ Ioc_subset_Ioi_self)$
    nhds_within_le_of_mem$ Ioc_mem_nhds_within_Ioi$ left_mem_Ico.2 h

@[simp]
theorem nhds_within_Ioo_eq_nhds_within_Ioi {a b : Î±} (h : a < b) : ğ“[Ioo a b] a = ğ“[Ioi a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ Ioo_subset_Ioi_self)$
    nhds_within_le_of_mem$ Ioo_mem_nhds_within_Ioi$ left_mem_Ico.2 h

@[simp]
theorem continuous_within_at_Ioc_iff_Ioi [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ioc a b) a â†” ContinuousWithinAt f (Ioi a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Ioi h]

@[simp]
theorem continuous_within_at_Ioo_iff_Ioi [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ioo a b) a â†” ContinuousWithinAt f (Ioi a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Ioi h]

/-!
#### Left neighborhoods, point excluded
-/


theorem Ioo_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Ioo a c âˆˆ ğ“[Iio b] b :=
  by 
    simpa only [dual_Ioo] using Ioo_mem_nhds_within_Ioi (show to_dual b âˆˆ Ico (to_dual c) (to_dual a) from H.symm)

theorem Ico_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Ico a c âˆˆ ğ“[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Ioc a c âˆˆ ğ“[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self

theorem Icc_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Icc a c âˆˆ ğ“[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self

@[simp]
theorem nhds_within_Ico_eq_nhds_within_Iio {a b : Î±} (h : a < b) : ğ“[Ico a b] b = ğ“[Iio b] b :=
  by 
    simpa only [dual_Ioc] using nhds_within_Ioc_eq_nhds_within_Ioi h.dual

@[simp]
theorem nhds_within_Ioo_eq_nhds_within_Iio {a b : Î±} (h : a < b) : ğ“[Ioo a b] b = ğ“[Iio b] b :=
  by 
    simpa only [dual_Ioo] using nhds_within_Ioo_eq_nhds_within_Ioi h.dual

@[simp]
theorem continuous_within_at_Ico_iff_Iio {a b : Î±} {f : Î± â†’ Î³} (h : a < b) :
  ContinuousWithinAt f (Ico a b) b â†” ContinuousWithinAt f (Iio b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Iio h]

@[simp]
theorem continuous_within_at_Ioo_iff_Iio {a b : Î±} {f : Î± â†’ Î³} (h : a < b) :
  ContinuousWithinAt f (Ioo a b) b â†” ContinuousWithinAt f (Iio b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Iio h]

/-!
#### Right neighborhoods, point included
-/


theorem Ioo_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ioo a c) : Ioo a c âˆˆ ğ“[Ici b] b :=
  mem_nhds_within_of_mem_nhds$ IsOpen.mem_nhds is_open_Ioo H

theorem Ioc_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ioo a c) : Ioc a c âˆˆ ğ“[Ici b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ico a c) : Ico a c âˆˆ ğ“[Ici b] b :=
  mem_nhds_within.2
    âŸ¨Iio c, is_open_Iio, H.2,
      by 
        simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]âŸ©

theorem Icc_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ico a c) : Icc a c âˆˆ ğ“[Ici b] b :=
  mem_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self

@[simp]
theorem nhds_within_Icc_eq_nhds_within_Ici {a b : Î±} (h : a < b) : ğ“[Icc a b] a = ğ“[Ici a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ Icc_subset_Ici_self)$
    nhds_within_le_of_mem$ Icc_mem_nhds_within_Ici$ left_mem_Ico.2 h

@[simp]
theorem nhds_within_Ico_eq_nhds_within_Ici {a b : Î±} (h : a < b) : ğ“[Ico a b] a = ğ“[Ici a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ fun x => And.left)$ nhds_within_le_of_mem$ Ico_mem_nhds_within_Ici$ left_mem_Ico.2 h

@[simp]
theorem continuous_within_at_Icc_iff_Ici [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Icc a b) a â†” ContinuousWithinAt f (Ici a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Ici h]

@[simp]
theorem continuous_within_at_Ico_iff_Ici [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ico a b) a â†” ContinuousWithinAt f (Ici a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Ici h]

/-!
#### Left neighborhoods, point included
-/


theorem Ioo_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioo a c) : Ioo a c âˆˆ ğ“[Iic b] b :=
  mem_nhds_within_of_mem_nhds$ IsOpen.mem_nhds is_open_Ioo H

theorem Ico_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioo a c) : Ico a c âˆˆ ğ“[Iic b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioc a c) : Ioc a c âˆˆ ğ“[Iic b] b :=
  by 
    simpa only [dual_Ico] using Ico_mem_nhds_within_Ici (show to_dual b âˆˆ Ico (to_dual c) (to_dual a) from H.symm)

theorem Icc_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioc a c) : Icc a c âˆˆ ğ“[Iic b] b :=
  mem_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self

@[simp]
theorem nhds_within_Icc_eq_nhds_within_Iic {a b : Î±} (h : a < b) : ğ“[Icc a b] b = ğ“[Iic b] b :=
  by 
    simpa only [dual_Icc] using nhds_within_Icc_eq_nhds_within_Ici h.dual

@[simp]
theorem nhds_within_Ioc_eq_nhds_within_Iic {a b : Î±} (h : a < b) : ğ“[Ioc a b] b = ğ“[Iic b] b :=
  by 
    simpa only [dual_Ico] using nhds_within_Ico_eq_nhds_within_Ici h.dual

@[simp]
theorem continuous_within_at_Icc_iff_Iic [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Icc a b) b â†” ContinuousWithinAt f (Iic b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Iic h]

@[simp]
theorem continuous_within_at_Ioc_iff_Iic [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ioc a b) b â†” ContinuousWithinAt f (Iic b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Iic h]

end LinearOrderâ‚“

section LinearOrderâ‚“

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±] {f g : Î² â†’ Î±}

section 

variable [TopologicalSpace Î²]

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  lt_subset_interior_le
  ( hf : Continuous f ) ( hg : Continuous g ) : { b | f b < g b } âŠ† Interior { b | f b â‰¤ g b }
  := interior_maximal fun p => le_of_ltâ‚“ $ is_open_lt hf hg

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  frontier_le_subset_eq
  ( hf : Continuous f ) ( hg : Continuous g ) : Frontier { b | f b â‰¤ g b } âŠ† { b | f b = g b }
  :=
    by
      rw [ frontier_eq_closure_inter_closure , closure_le_eq hf hg ]
        rintro b âŸ¨ hbâ‚ , hbâ‚‚ âŸ©
        refine' le_antisymmâ‚“ hbâ‚ closure_lt_subset_le hg hf _
        convert hbâ‚‚ using 2
        simp only [ not_le.symm ]
        rfl

theorem frontier_Iic_subset (a : Î±) : Frontier (Iic a) âŠ† {a} :=
  frontier_le_subset_eq (@continuous_id Î± _) continuous_const

theorem frontier_Ici_subset (a : Î±) : Frontier (Ici a) âŠ† {a} :=
  @frontier_Iic_subset (OrderDual Î±) _ _ _ _

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  frontier_lt_subset_eq
  ( hf : Continuous f ) ( hg : Continuous g ) : Frontier { b | f b < g b } âŠ† { b | f b = g b }
  := by rw [ â† frontier_compl ] <;> convert frontier_le_subset_eq hg hf <;> simp [ ext_iff , eq_comm ]

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  continuous_if_le
  [ TopologicalSpace Î³ ]
      [ âˆ€ x , Decidable f x â‰¤ g x ]
      { f' g' : Î² â†’ Î³ }
      ( hf : Continuous f )
      ( hg : Continuous g )
      ( hf' : ContinuousOn f' { x | f x â‰¤ g x } )
      ( hg' : ContinuousOn g' { x | g x â‰¤ f x } )
      ( hfg : âˆ€ x , f x = g x â†’ f' x = g' x )
    : Continuous fun x => if f x â‰¤ g x then f' x else g' x
  :=
    by
      refine' continuous_if fun a ha => hfg _ frontier_le_subset_eq hf hg ha _ hg'.mono _
        Â· rwa [ is_closed_le hf hg . closure_eq ]
        Â· simp only [ not_leâ‚“ ] exact closure_lt_subset_le hg hf

theorem Continuous.if_le [TopologicalSpace Î³] [âˆ€ x, Decidable (f x â‰¤ g x)] {f' g' : Î² â†’ Î³} (hf' : Continuous f')
  (hg' : Continuous g') (hf : Continuous f) (hg : Continuous g) (hfg : âˆ€ x, f x = g x â†’ f' x = g' x) :
  Continuous fun x => if f x â‰¤ g x then f' x else g' x :=
  continuous_if_le hf hg hf'.continuous_on hg'.continuous_on hfg

@[continuity]
theorem Continuous.min (hf : Continuous f) (hg : Continuous g) : Continuous fun b => min (f b) (g b) :=
  by 
    simp only [min_def]
    exact hf.if_le hg hf hg fun x => id

@[continuity]
theorem Continuous.max (hf : Continuous f) (hg : Continuous g) : Continuous fun b => max (f b) (g b) :=
  @Continuous.min (OrderDual Î±) _ _ _ _ _ _ _ hf hg

end 

theorem continuous_min : Continuous fun p : Î± Ã— Î± => min p.1 p.2 :=
  continuous_fst.min continuous_snd

theorem continuous_max : Continuous fun p : Î± Ã— Î± => max p.1 p.2 :=
  continuous_fst.max continuous_snd

theorem Filter.Tendsto.max {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} (hf : tendsto f b (ğ“ aâ‚)) (hg : tendsto g b (ğ“ aâ‚‚)) :
  tendsto (fun b => max (f b) (g b)) b (ğ“ (max aâ‚ aâ‚‚)) :=
  (continuous_max.Tendsto (aâ‚, aâ‚‚)).comp (hf.prod_mk_nhds hg)

theorem Filter.Tendsto.min {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} (hf : tendsto f b (ğ“ aâ‚)) (hg : tendsto g b (ğ“ aâ‚‚)) :
  tendsto (fun b => min (f b) (g b)) b (ğ“ (min aâ‚ aâ‚‚)) :=
  (continuous_min.Tendsto (aâ‚, aâ‚‚)).comp (hf.prod_mk_nhds hg)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (y Â«expr âˆˆ Â» s)
theorem Dense.exists_lt [NoBotOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), y < x :=
  hs.exists_mem_open is_open_Iio (no_bot x)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (y Â«expr âˆˆ Â» s)
theorem Dense.exists_gt [NoTopOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), x < y :=
  hs.order_dual.exists_lt x

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (y Â«expr âˆˆ Â» s)
theorem Dense.exists_le [NoBotOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), y â‰¤ x :=
  (hs.exists_lt x).imp$ fun y hy => âŸ¨hy.fst, hy.snd.leâŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (y Â«expr âˆˆ Â» s)
theorem Dense.exists_ge [NoTopOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), x â‰¤ y :=
  hs.order_dual.exists_le x

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (y Â«expr âˆˆ Â» s)
theorem Dense.exists_le' {s : Set Î±} (hs : Dense s) (hbot : âˆ€ x, IsBot x â†’ x âˆˆ s) (x : Î±) :
  âˆƒ (y : _)(_ : y âˆˆ s), y â‰¤ x :=
  by 
    byCases' hx : IsBot x
    Â·
      exact âŸ¨x, hbot x hx, le_rflâŸ©
    Â·
      simp only [IsBot, not_forall, not_leâ‚“] at hx 
      rcases hs.exists_mem_open is_open_Iio hx with âŸ¨y, hys, hy : y < xâŸ©
      exact âŸ¨y, hys, hy.leâŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (y Â«expr âˆˆ Â» s)
theorem Dense.exists_ge' {s : Set Î±} (hs : Dense s) (htop : âˆ€ x, IsTop x â†’ x âˆˆ s) (x : Î±) :
  âˆƒ (y : _)(_ : y âˆˆ s), x â‰¤ y :=
  hs.order_dual.exists_le' htop x

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (z Â«expr âˆˆ Â» s)
theorem Dense.exists_between [DenselyOrdered Î±] {s : Set Î±} (hs : Dense s) {x y : Î±} (h : x < y) :
  âˆƒ (z : _)(_ : z âˆˆ s), z âˆˆ Ioo x y :=
  hs.exists_mem_open is_open_Ioo (nonempty_Ioo.2 h)

end LinearOrderâ‚“

end OrderClosedTopology

instance [Preorderâ‚“ Î±] [TopologicalSpace Î±] [OrderClosedTopology Î±] [Preorderâ‚“ Î²] [TopologicalSpace Î²]
  [OrderClosedTopology Î²] : OrderClosedTopology (Î± Ã— Î²) :=
  âŸ¨(is_closed_le (continuous_fst.comp continuous_fst) (continuous_fst.comp continuous_snd)).inter
      (is_closed_le (continuous_snd.comp continuous_fst) (continuous_snd.comp continuous_snd))âŸ©

instance {Î¹ : Type _} {Î± : Î¹ â†’ Type _} [âˆ€ i, Preorderâ‚“ (Î± i)] [âˆ€ i, TopologicalSpace (Î± i)]
  [âˆ€ i, OrderClosedTopology (Î± i)] : OrderClosedTopology (âˆ€ i, Î± i) :=
  by 
    constructor 
    simp only [Pi.le_def, set_of_forall]
    exact
      is_closed_Inter
        fun i => is_closed_le ((continuous_apply i).comp continuous_fst) ((continuous_apply i).comp continuous_snd)

instance Pi.order_closed_topology' [Preorderâ‚“ Î²] [TopologicalSpace Î²] [OrderClosedTopology Î²] :
  OrderClosedTopology (Î± â†’ Î²) :=
  Pi.order_closed_topology

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
/--
    The order topology on an ordered type is the topology generated by open intervals. We register
    it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
    We define it as a mixin. If you want to introduce the order topology on a preorder, use
    `preorder.topology`. -/
  class
    OrderTopology
    ( Î± : Type _ ) [ t : TopologicalSpace Î± ] [ Preorderâ‚“ Î± ]
    : Prop
    where topology_eq_generate_intervals : t = generate_from { s | âˆƒ a , s = Ioi a âˆ¨ s = Iio a }

/-- (Order) topology on a partial order `Î±` generated by the subbase of open intervals
`(a, âˆ) = { x âˆ£ a < x }, (-âˆ , b) = {x âˆ£ x < b}` for all `a, b` in `Î±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorderâ‚“.topology (Î± : Type _) [Preorderâ‚“ Î±] : TopologicalSpace Î± :=
  generate_from { s : Set Î± | âˆƒ a : Î±, s = { b : Î± | a < b } âˆ¨ s = { b : Î± | b < a } }

section OrderTopology

instance {Î± : Type _} [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [OrderTopology Î±] : OrderTopology (OrderDual Î±) :=
  âŸ¨by 
      convert @OrderTopology.topology_eq_generate_intervals Î± _ _ _ <;> conv  in _ âˆ¨ _ => rw [Or.comm] <;> rflâŸ©

section PartialOrderâ‚“

variable [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [t : OrderTopology Î±]

include t

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  is_open_iff_generate_intervals
  { s : Set Î± } : IsOpen s â†” generate_open { s | âˆƒ a , s = Ioi a âˆ¨ s = Iio a } s
  := by rw [ t.topology_eq_generate_intervals ] <;> rfl

theorem is_open_lt' (a : Î±) : IsOpen { b : Î± | a < b } :=
  by 
    rw [@is_open_iff_generate_intervals Î± _ _ t] <;> exact generate_open.basic _ âŸ¨a, Or.inl rflâŸ©

theorem is_open_gt' (a : Î±) : IsOpen { b : Î± | b < a } :=
  by 
    rw [@is_open_iff_generate_intervals Î± _ _ t] <;> exact generate_open.basic _ âŸ¨a, Or.inr rflâŸ©

theorem lt_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ b, a < x :=
  IsOpen.mem_nhds (is_open_lt' _) h

theorem le_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ b, a â‰¤ x :=
  (ğ“ b).sets_of_superset (lt_mem_nhds h)$ fun b hb => le_of_ltâ‚“ hb

theorem gt_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ a, x < b :=
  IsOpen.mem_nhds (is_open_gt' _) h

theorem ge_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ a, x â‰¤ b :=
  (ğ“ a).sets_of_superset (gt_mem_nhds h)$ fun b hb => le_of_ltâ‚“ hb

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr âˆˆ Â» Iio a)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr âˆˆ Â» Ioi a)
theorem nhds_eq_order (a : Î±) : ğ“ a = (â¨… (b : _)(_ : b âˆˆ Iio a), ğ“Ÿ (Ioi b))âŠ“â¨… (b : _)(_ : b âˆˆ Ioi a), ğ“Ÿ (Iio b) :=
  by 
    rw [t.topology_eq_generate_intervals, nhds_generate_from] <;>
      exact
        le_antisymmâ‚“
          (le_inf (le_binfi$ fun b hb => infi_le_of_le { c : Î± | b < c }$ infi_le _ âŸ¨hb, b, Or.inl rflâŸ©)
            (le_binfi$ fun b hb => infi_le_of_le { c : Î± | c < b }$ infi_le _ âŸ¨hb, b, Or.inr rflâŸ©))
          (le_infi$
            fun s =>
              le_infi$
                fun âŸ¨ha, b, hsâŸ© =>
                  match s, ha, hs with 
                  | _, h, Or.inl rfl => inf_le_of_left_le$ infi_le_of_le b$ infi_le _ h
                  | _, h, Or.inr rfl => inf_le_of_right_le$ infi_le_of_le b$ infi_le _ h)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (a' Â«expr < Â» a)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (a' Â«expr > Â» a)
theorem tendsto_order {f : Î² â†’ Î±} {a : Î±} {x : Filter Î²} :
  tendsto f x (ğ“ a) â†” (âˆ€ a' _ : a' < a, âˆ€á¶  b in x, a' < f b) âˆ§ âˆ€ a' _ : a' > a, âˆ€á¶  b in x, f b < a' :=
  by 
    simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]

instance tendsto_Icc_class_nhds (a : Î±) : tendsto_Ixx_class Icc (ğ“ a) (ğ“ a) :=
  by 
    simp only [nhds_eq_order, infi_subtype']
    refine' ((has_basis_infi_principal_finite _).inf (has_basis_infi_principal_finite _)).TendstoIxxClass fun s hs => _ 
    refine' ((ord_connected_bInter _).inter (ord_connected_bInter _)).out <;> intro _ _ 
    exacts[ord_connected_Ioi, ord_connected_Iio]

instance tendsto_Ico_class_nhds (a : Î±) : tendsto_Ixx_class Ico (ğ“ a) (ğ“ a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ico_subset_Icc_self

instance tendsto_Ioc_class_nhds (a : Î±) : tendsto_Ixx_class Ioc (ğ“ a) (ğ“ a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ioc_subset_Icc_self

instance tendsto_Ioo_class_nhds (a : Î±) : tendsto_Ixx_class Ioo (ğ“ a) (ğ“ a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ioo_subset_Icc_self

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Î² â†’ Î±} {b : Filter Î²} {a : Î±} (hg : tendsto g b (ğ“ a))
  (hh : tendsto h b (ğ“ a)) (hgf : âˆ€á¶  b in b, g b â‰¤ f b) (hfh : âˆ€á¶  b in b, f b â‰¤ h b) : tendsto f b (ğ“ a) :=
  tendsto_order.2
    âŸ¨fun a' h' =>
        have  : âˆ€á¶  b in b, a' < g b := (tendsto_order.1 hg).left a' h' 
        by 
          filterUpwards [this, hgf] fun a => lt_of_lt_of_leâ‚“,
      fun a' h' =>
        have  : âˆ€á¶  b in b, h b < a' := (tendsto_order.1 hh).right a' h' 
        by 
          filterUpwards [this, hfh] fun a hâ‚ hâ‚‚ => lt_of_le_of_ltâ‚“ hâ‚‚ hâ‚âŸ©

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Î² â†’ Î±} {b : Filter Î²} {a : Î±} (hg : tendsto g b (ğ“ a))
  (hh : tendsto h b (ğ“ a)) (hgf : g â‰¤ f) (hfh : f â‰¤ h) : tendsto f b (ğ“ a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (eventually_of_forall hgf) (eventually_of_forall hfh)

theorem nhds_order_unbounded {a : Î±} (hu : âˆƒ u, a < u) (hl : âˆƒ l, l < a) :
  ğ“ a = â¨… (l : _)(hâ‚‚ : l < a)(u : _)(hâ‚‚ : a < u), ğ“Ÿ (Ioo l u) :=
  have  : âˆƒ u, u âˆˆ Ioi a := hu 
  have  : âˆƒ l, l âˆˆ Iio a := hl 
  by 
    simp only [nhds_eq_order, inf_binfi, binfi_inf, inf_principal, Ioi_inter_Iio]
    rfl

theorem tendsto_order_unbounded {f : Î² â†’ Î±} {a : Î±} {x : Filter Î²} (hu : âˆƒ u, a < u) (hl : âˆƒ l, l < a)
  (h : âˆ€ l u, l < a â†’ a < u â†’ âˆ€á¶  b in x, l < f b âˆ§ f b < u) : tendsto f x (ğ“ a) :=
  by 
    rw [nhds_order_unbounded hu hl] <;>
      exact
        tendsto_infi.2$
          fun l =>
            tendsto_infi.2$
              fun hl => tendsto_infi.2$ fun u => tendsto_infi.2$ fun hu => tendsto_principal.2$ h l u hl hu

end PartialOrderâ‚“

instance tendsto_Ixx_nhds_within {Î± : Type _} [Preorderâ‚“ Î±] [TopologicalSpace Î±] (a : Î±) {s t : Set Î±} {Ixx}
  [tendsto_Ixx_class Ixx (ğ“ a) (ğ“ a)] [tendsto_Ixx_class Ixx (ğ“Ÿ s) (ğ“Ÿ t)] : tendsto_Ixx_class Ixx (ğ“[s] a) (ğ“[t] a) :=
  Filter.tendsto_Ixx_class_inf

instance tendsto_Icc_class_nhds_pi {Î¹ : Type _} {Î± : Î¹ â†’ Type _} [âˆ€ i, PartialOrderâ‚“ (Î± i)]
  [âˆ€ i, TopologicalSpace (Î± i)] [âˆ€ i, OrderTopology (Î± i)] (f : âˆ€ i, Î± i) : tendsto_Ixx_class Icc (ğ“ f) (ğ“ f) :=
  by 
    constructor 
    conv  in (ğ“ f).lift' powerset => rw [nhds_pi, Filter.pi]
    simp only [lift'_infi_powerset, comap_lift'_eq2 monotone_powerset, tendsto_infi, tendsto_lift', mem_powerset_iff,
      subset_def, mem_preimage]
    intro i s hs 
    have  : tendsto (fun g : âˆ€ i, Î± i => g i) (ğ“ f) (ğ“ (f i)) := (continuous_apply i).Tendsto f 
    refine' (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _ 
    exact fun p hp g hg => hp âŸ¨hg.1 _, hg.2 _âŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr < Â» a)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr > Â» a)
-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  induced_order_topology'
  { Î± : Type u }
      { Î² : Type v }
      [ PartialOrderâ‚“ Î± ]
      [ ta : TopologicalSpace Î² ]
      [ PartialOrderâ‚“ Î² ]
      [ OrderTopology Î² ]
      ( f : Î± â†’ Î² )
      ( hf : âˆ€ { x y } , f x < f y â†” x < y )
      ( Hâ‚ : âˆ€ { a x } , x < f a â†’ âˆƒ ( b : _ ) ( _ : b < a ) , x â‰¤ f b )
      ( Hâ‚‚ : âˆ€ { a x } , f a < x â†’ âˆƒ ( b : _ ) ( _ : b > a ) , f b â‰¤ x )
    : @ OrderTopology _ induced f ta _
  :=
    by
      let this' := induced f ta
        refine' âŸ¨ eq_of_nhds_eq_nhds fun a => _ âŸ©
        rw [ nhds_induced , nhds_generate_from , nhds_eq_order f a ]
        apply le_antisymmâ‚“
        Â·
          refine' le_infi fun s => le_infi $ fun hs => le_principal_iff . 2 _
            rcases hs with âŸ¨ ab , b , rfl | rfl âŸ©
            Â·
              exact
                mem_comap . 2
                  âŸ¨
                    { x | f b < x }
                      ,
                      mem_inf_of_left $ mem_infi_of_mem _ $ mem_infi_of_mem hf . 2 ab $ mem_principal_self _
                      ,
                      fun x => hf . 1
                    âŸ©
            Â·
              exact
                mem_comap . 2
                  âŸ¨
                    { x | x < f b }
                      ,
                      mem_inf_of_right $ mem_infi_of_mem _ $ mem_infi_of_mem hf . 2 ab $ mem_principal_self _
                      ,
                      fun x => hf . 1
                    âŸ©
        Â·
          rw [ â† map_le_iff_le_comap ]
            refine' le_inf _ _ <;> refine' le_infi fun x => le_infi $ fun h => le_principal_iff . 2 _ <;> simp
            Â·
              rcases Hâ‚ h with âŸ¨ b , ab , xb âŸ©
                refine' mem_infi_of_mem _ mem_infi_of_mem âŸ¨ ab , b , Or.inl rfl âŸ© mem_principal . 2 _
                exact fun c hc => lt_of_le_of_ltâ‚“ xb hf . 2 hc
            Â·
              rcases Hâ‚‚ h with âŸ¨ b , ab , xb âŸ©
                refine' mem_infi_of_mem _ mem_infi_of_mem âŸ¨ ab , b , Or.inr rfl âŸ© mem_principal . 2 _
                exact fun c hc => lt_of_lt_of_leâ‚“ hf . 2 hc xb

theorem induced_order_topology {Î± : Type u} {Î² : Type v} [PartialOrderâ‚“ Î±] [ta : TopologicalSpace Î²] [PartialOrderâ‚“ Î²]
  [OrderTopology Î²] (f : Î± â†’ Î²) (hf : âˆ€ {x y}, f x < f y â†” x < y) (H : âˆ€ {x y}, x < y â†’ âˆƒ a, x < f a âˆ§ f a < y) :
  @OrderTopology _ (induced f ta) _ :=
  induced_order_topology' f (@hf)
    (fun a x xa =>
      let âŸ¨b, xb, baâŸ© := H xa
      âŸ¨b, hf.1 ba, le_of_ltâ‚“ xbâŸ©)
    fun a x ax =>
      let âŸ¨b, ab, bxâŸ© := H ax
      âŸ¨b, hf.1 ab, le_of_ltâ‚“ bxâŸ©

/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance order_topology_of_ord_connected {Î± : Type u} [ta : TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±]
  {t : Set Î±} [ht : ord_connected t] : OrderTopology t :=
  by 
    let this' := induced (coeâ‚“ : t â†’ Î±) ta 
    refine' âŸ¨eq_of_nhds_eq_nhds fun a => _âŸ©
    rw [nhds_induced, nhds_generate_from, nhds_eq_order (a : Î±)]
    apply le_antisymmâ‚“
    Â·
      refine' le_infi fun s => le_infi$ fun hs => le_principal_iff.2 _ 
      rcases hs with âŸ¨ab, b, rfl | rflâŸ©
      Â·
        refine' âŸ¨Ioi b, _, fun _ => idâŸ©
        refine' mem_inf_of_left (mem_infi_of_mem b _)
        exact mem_infi_of_mem ab (mem_principal_self (Ioi (â†‘b)))
      Â·
        refine' âŸ¨Iio b, _, fun _ => idâŸ©
        refine' mem_inf_of_right (mem_infi_of_mem b _)
        exact mem_infi_of_mem ab (mem_principal_self (Iio b))
    Â·
      rw [â†map_le_iff_le_comap]
      refine' le_inf _ _
      Â·
        refine' le_infi fun x => le_infi$ fun h => le_principal_iff.2 _ 
        byCases' hx : x âˆˆ t
        Â·
          refine' mem_infi_of_mem (Ioi âŸ¨x, hxâŸ©) (mem_infi_of_mem âŸ¨h, âŸ¨âŸ¨x, hxâŸ©, Or.inl rflâŸ©âŸ© _)
          exact fun _ => id 
        simp only [SetCoe.exists, mem_set_of_eq, mem_map']
        convert univ_sets _ 
        suffices hx' : âˆ€ y : t, â†‘y âˆˆ Ioi x
        Â·
          simp [hx']
        intro y 
        revert hx 
        contrapose! 
        exact fun hx => ht.out y.2 a.2 âŸ¨le_of_not_gtâ‚“ hx, le_of_ltâ‚“ hâŸ©
      Â·
        refine' le_infi fun x => le_infi$ fun h => le_principal_iff.2 _ 
        byCases' hx : x âˆˆ t
        Â·
          refine' mem_infi_of_mem (Iio âŸ¨x, hxâŸ©) (mem_infi_of_mem âŸ¨h, âŸ¨âŸ¨x, hxâŸ©, Or.inr rflâŸ©âŸ© _)
          exact fun _ => id 
        simp only [SetCoe.exists, mem_set_of_eq, mem_map']
        convert univ_sets _ 
        suffices hx' : âˆ€ y : t, â†‘y âˆˆ Iio x
        Â·
          simp [hx']
        intro y 
        revert hx 
        contrapose! 
        exact fun hx => ht.out a.2 y.2 âŸ¨le_of_ltâ‚“ h, le_of_not_gtâ‚“ hxâŸ©

theorem nhds_top_order [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [OrderTop Î±] [OrderTopology Î±] :
  ğ“ (âŠ¤ : Î±) = â¨… (l : _)(hâ‚‚ : l < âŠ¤), ğ“Ÿ (Ioi l) :=
  by 
    simp [nhds_eq_order (âŠ¤ : Î±)]

theorem nhds_bot_order [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [OrderBot Î±] [OrderTopology Î±] :
  ğ“ (âŠ¥ : Î±) = â¨… (l : _)(hâ‚‚ : âŠ¥ < l), ğ“Ÿ (Iio l) :=
  by 
    simp [nhds_eq_order (âŠ¥ : Î±)]

theorem nhds_top_basis [TopologicalSpace Î±] [SemilatticeSup Î±] [OrderTop Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] : (ğ“ âŠ¤).HasBasis (fun a : Î± => a < âŠ¤) fun a : Î± => Ioi a :=
  âŸ¨by 
      simp only [nhds_top_order]
      refine' @Filter.mem_binfi_of_directed Î± Î± (fun a => ğ“Ÿ (Ioi a)) (fun a => a < âŠ¤) _ _
      Â·
        rintro a (ha : a < âŠ¤) b (hb : b < âŠ¤)
        use aâŠ”b 
        simp only [Filter.le_principal_iff, ge_iff_le, Order.Preimage]
        exact âŸ¨sup_lt_iff.mpr âŸ¨ha, hbâŸ©, Ioi_subset_Ioi le_sup_left, Ioi_subset_Ioi le_sup_rightâŸ©
      Â·
        obtain âŸ¨a, haâŸ© : âˆƒ a : Î±, a â‰  âŠ¤ := exists_ne âŠ¤
        exact âŸ¨a, lt_top_iff_ne_top.mpr haâŸ©âŸ©

theorem nhds_bot_basis [TopologicalSpace Î±] [SemilatticeInf Î±] [OrderBot Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] : (ğ“ âŠ¥).HasBasis (fun a : Î± => âŠ¥ < a) fun a : Î± => Iio a :=
  @nhds_top_basis (OrderDual Î±) _ _ _ _ _ _

theorem nhds_top_basis_Ici [TopologicalSpace Î±] [SemilatticeSup Î±] [OrderTop Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] [DenselyOrdered Î±] : (ğ“ âŠ¤).HasBasis (fun a : Î± => a < âŠ¤) Ici :=
  nhds_top_basis.to_has_basis
    (fun a ha =>
      let âŸ¨b, hab, hbâŸ© := exists_between ha
      âŸ¨b, hb, Ici_subset_Ioi.mpr habâŸ©)
    fun a ha => âŸ¨a, ha, Ioi_subset_Ici_selfâŸ©

theorem nhds_bot_basis_Iic [TopologicalSpace Î±] [SemilatticeInf Î±] [OrderBot Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] [DenselyOrdered Î±] : (ğ“ âŠ¥).HasBasis (fun a : Î± => âŠ¥ < a) Iic :=
  @nhds_top_basis_Ici (OrderDual Î±) _ _ _ _ _ _ _

theorem tendsto_nhds_top_mono [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderTop Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤á¶ [l] g) : tendsto g l (ğ“ âŠ¤) :=
  by 
    simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hfâŠ¢
    intro x hx 
    filterUpwards [hf x hx, hg]
    exact fun x => lt_of_lt_of_leâ‚“

theorem tendsto_nhds_bot_mono [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderBot Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤á¶ [l] f) : tendsto g l (ğ“ âŠ¥) :=
  @tendsto_nhds_top_mono Î± (OrderDual Î²) _ _ _ _ _ _ _ hf hg

theorem tendsto_nhds_top_mono' [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderTop Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤ g) : tendsto g l (ğ“ âŠ¤) :=
  tendsto_nhds_top_mono hf (eventually_of_forall hg)

theorem tendsto_nhds_bot_mono' [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderBot Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤ f) : tendsto g l (ğ“ âŠ¥) :=
  tendsto_nhds_bot_mono hf (eventually_of_forall hg)

section LinearOrderâ‚“

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±]

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l' Â«expr âˆˆ Â» Ico l a)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr âˆˆ Â» Ioi a)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l' Â«expr âˆˆ Â» Ico l a)
theorem exists_Ioc_subset_of_mem_nhds' {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) {l : Î±} (hl : l < a) :
  âˆƒ (l' : _)(_ : l' âˆˆ Ico l a), Ioc l' a âŠ† s :=
  by 
    rw [nhds_eq_order a] at hs 
    rcases hs with âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, rflâŸ©
    suffices  : âˆƒ (l' : _)(_ : l' âˆˆ Ico l a), Ioi l' âŠ† tâ‚
    Â·
      have A : ğ“Ÿ (Iic a) â‰¤ â¨… (b : _)(_ : b âˆˆ Ioi a), ğ“Ÿ (Iio b)
      exact le_infi$ fun b => le_infi$ fun hb => principal_mono.2$ Iic_subset_Iio.2 hb 
      have B : tâ‚ âˆ© Iic a âŠ† tâ‚ âˆ© tâ‚‚ 
      exact inter_subset_inter_right _ (A htâ‚‚)
      exact this.imp fun l' => Exists.impâ‚“$ fun hl' hl x hx => B âŸ¨hl hx.1, hx.2âŸ©
    clear htâ‚‚ tâ‚‚ 
    rw [mem_binfi_of_directed] at htâ‚
    Â·
      rcases htâ‚ with âŸ¨b, hb, hb'âŸ©
      exact âŸ¨max b l, âŸ¨le_max_rightâ‚“ _ _, max_ltâ‚“ hb hlâŸ©, fun x hx => hb'$ Ioi_subset_Ioi (le_max_leftâ‚“ _ _) hxâŸ©
    Â·
      intro b hb b' hb' 
      simp only [mem_Iio] at hb hb' 
      use max b b', max_ltâ‚“ hb hb' 
      simp [le_reflâ‚“]
    exact âŸ¨l, hlâŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u' Â«expr âˆˆ Â» Ioc a u)
theorem exists_Ico_subset_of_mem_nhds' {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) {u : Î±} (hu : a < u) :
  âˆƒ (u' : _)(_ : u' âˆˆ Ioc a u), Ico a u' âŠ† s :=
  by 
    simpa only [OrderDual.exists, exists_prop, dual_Ico, dual_Ioc] using
      exists_Ioc_subset_of_mem_nhds' (show of_dual â»Â¹' s âˆˆ ğ“ (to_dual a) from hs) hu.dual

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr < Â» a)
theorem exists_Ioc_subset_of_mem_nhds {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ l, l < a) :
  âˆƒ (l : _)(_ : l < a), Ioc l a âŠ† s :=
  let âŸ¨l', hl'âŸ© := h 
  let âŸ¨l, hlâŸ© := exists_Ioc_subset_of_mem_nhds' hs hl'
  âŸ¨l, hl.fst.2, hl.sndâŸ©

theorem exists_Ico_subset_of_mem_nhds {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ u, a < u) :
  âˆƒ (u : _)(_ : a < u), Ico a u âŠ† s :=
  let âŸ¨l', hl'âŸ© := h 
  let âŸ¨l, hlâŸ© := exists_Ico_subset_of_mem_nhds' hs hl'
  âŸ¨l, hl.fst.1, hl.sndâŸ©

theorem IsOpen.exists_Ioo_subset [Nontrivial Î±] {s : Set Î±} (hs : IsOpen s) (h : s.nonempty) :
  âˆƒ a b, a < b âˆ§ Ioo a b âŠ† s :=
  by 
    obtain âŸ¨x, hxâŸ© : âˆƒ x, x âˆˆ s := h 
    obtain âŸ¨y, hyâŸ© : âˆƒ y, y â‰  x := exists_ne x 
    rcases lt_trichotomyâ‚“ x y with (H | rfl | H)
    Â·
      obtain âŸ¨u, xu, huâŸ© : âˆƒ (u : Î±)(hu : x < u), Ico x u âŠ† s := exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) âŸ¨y, HâŸ©
      exact âŸ¨x, u, xu, Ioo_subset_Ico_self.trans huâŸ©
    Â·
      exact (hy rfl).elim
    Â·
      obtain âŸ¨l, lx, hlâŸ© : âˆƒ (l : Î±)(hl : l < x), Ioc l x âŠ† s := exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) âŸ¨y, HâŸ©
      exact âŸ¨l, x, lx, Ioo_subset_Ioc_self.trans hlâŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (bâ‚ Â«expr âˆˆ Â» u)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (bâ‚‚ Â«expr âˆˆ Â» v)
-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  order_separated
  { aâ‚ aâ‚‚ : Î± } ( h : aâ‚ < aâ‚‚ )
    : âˆƒ u v : Set Î± , IsOpen u âˆ§ IsOpen v âˆ§ aâ‚ âˆˆ u âˆ§ aâ‚‚ âˆˆ v âˆ§ âˆ€ bâ‚ _ : bâ‚ âˆˆ u , âˆ€ bâ‚‚ _ : bâ‚‚ âˆˆ v , bâ‚ < bâ‚‚
  :=
    match
      dense_or_discrete aâ‚ aâ‚‚
      with
      |
          Or.inl âŸ¨ a , haâ‚ , haâ‚‚ âŸ©
          =>
          âŸ¨
            { a' | a' < a }
              ,
              { a' | a < a' }
              ,
              is_open_gt' a
              ,
              is_open_lt' a
              ,
              haâ‚
              ,
              haâ‚‚
              ,
              fun bâ‚ hâ‚ bâ‚‚ hâ‚‚ => lt_transâ‚“ hâ‚ hâ‚‚
            âŸ©
        |
          Or.inr âŸ¨ hâ‚ , hâ‚‚ âŸ©
          =>
          âŸ¨
            { a | a < aâ‚‚ }
              ,
              { a | aâ‚ < a }
              ,
              is_open_gt' aâ‚‚
              ,
              is_open_lt' aâ‚
              ,
              h
              ,
              h
              ,
              fun bâ‚ hbâ‚ bâ‚‚ hbâ‚‚ => calc bâ‚ â‰¤ aâ‚ := hâ‚‚ _ hbâ‚ _ < aâ‚‚ := h _ â‰¤ bâ‚‚ := hâ‚ _ hbâ‚‚
            âŸ©

instance (priority := 100) OrderTopology.to_order_closed_topology : OrderClosedTopology Î± :=
  { is_closed_le' :=
      is_open_compl_iff.1$
        is_open_prod_iff.mpr$
          fun aâ‚ aâ‚‚ h : Â¬aâ‚ â‰¤ aâ‚‚ =>
            have h : aâ‚‚ < aâ‚ := lt_of_not_geâ‚“ h 
            let âŸ¨u, v, hu, hv, haâ‚, haâ‚‚, hâŸ© := order_separated h
            âŸ¨v, u, hv, hu, haâ‚‚, haâ‚, fun âŸ¨bâ‚, bâ‚‚âŸ© âŸ¨hâ‚, hâ‚‚âŸ© => not_le_of_gtâ‚“$ h bâ‚‚ hâ‚‚ bâ‚ hâ‚âŸ© }

theorem OrderTopology.t2_space : T2Space Î± :=
  by 
    infer_instance

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» s)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» s)
-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
instance
  ( priority := 100 )
  OrderTopology.regular_space
  : RegularSpace Î±
  :=
    {
      OrderTopology.t2_space with
      regular
        :=
        fun
          s a hs ha
            =>
            have
              hs' : s á¶œ âˆˆ ğ“ a := IsOpen.mem_nhds hs.is_open_compl ha
              have
                : âˆƒ t : Set Î± , IsOpen t âˆ§ âˆ€ l _ : l âˆˆ s , l < a â†’ l âˆˆ t âˆ§ ğ“[ t ] a = âŠ¥
                  :=
                  by_cases
                    fun
                        h : âˆƒ l , l < a
                          =>
                          let
                            âŸ¨ l , hl , h âŸ© := exists_Ioc_subset_of_mem_nhds hs' h
                            match
                              dense_or_discrete l a
                              with
                              |
                                  Or.inl âŸ¨ b , hbâ‚ , hbâ‚‚ âŸ©
                                  =>
                                  âŸ¨
                                    { a | a < b }
                                      ,
                                      is_open_gt' _
                                      ,
                                      fun
                                        c hcs hca
                                          =>
                                          show
                                            c < b
                                            from
                                              lt_of_not_geâ‚“
                                                $
                                                fun hbc => h âŸ¨ lt_of_lt_of_leâ‚“ hbâ‚ hbc , le_of_ltâ‚“ hca âŸ© hcs
                                      ,
                                      inf_principal_eq_bot . 2
                                        $
                                        ğ“ a . sets_of_superset is_open_lt' _ . mem_nhds hbâ‚‚
                                          $
                                          fun x hx : b < x => show Â¬ x < b from not_ltâ‚“ . 2 $ le_of_ltâ‚“ hx
                                    âŸ©
                                |
                                  Or.inr âŸ¨ hâ‚ , hâ‚‚ âŸ©
                                  =>
                                  âŸ¨
                                    { a' | a' < a }
                                      ,
                                      is_open_gt' _
                                      ,
                                      fun b hbs hba => hba
                                      ,
                                      inf_principal_eq_bot . 2
                                        $
                                        ğ“ a . sets_of_superset is_open_lt' _ . mem_nhds hl
                                          $
                                          fun x hx : l < x => show Â¬ x < a from not_ltâ‚“ . 2 $ hâ‚ _ hx
                                    âŸ©
                      fun
                        this : Â¬ âˆƒ l , l < a
                          =>
                          âŸ¨ âˆ… , is_open_empty , fun l _ hl => this âŸ¨ l , hl âŸ© . elim , nhds_within_empty _ âŸ©
                let
                  âŸ¨ tâ‚ , htâ‚o , htâ‚s , htâ‚a âŸ© := this
                  have
                    : âˆƒ t : Set Î± , IsOpen t âˆ§ âˆ€ u _ : u âˆˆ s , u > a â†’ u âˆˆ t âˆ§ ğ“[ t ] a = âŠ¥
                      :=
                      by_cases
                        fun
                            h : âˆƒ u , u > a
                              =>
                              let
                                âŸ¨ u , hu , h âŸ© := exists_Ico_subset_of_mem_nhds hs' h
                                match
                                  dense_or_discrete a u
                                  with
                                  |
                                      Or.inl âŸ¨ b , hbâ‚ , hbâ‚‚ âŸ©
                                      =>
                                      âŸ¨
                                        { a | b < a }
                                          ,
                                          is_open_lt' _
                                          ,
                                          fun
                                            c hcs hca
                                              =>
                                              show
                                                c > b
                                                from
                                                  lt_of_not_geâ‚“
                                                    $
                                                    fun hbc => h âŸ¨ le_of_ltâ‚“ hca , lt_of_le_of_ltâ‚“ hbc hbâ‚‚ âŸ© hcs
                                          ,
                                          inf_principal_eq_bot . 2
                                            $
                                            ğ“ a . sets_of_superset is_open_gt' _ . mem_nhds hbâ‚
                                              $
                                              fun x hx : b > x => show Â¬ x > b from not_ltâ‚“ . 2 $ le_of_ltâ‚“ hx
                                        âŸ©
                                    |
                                      Or.inr âŸ¨ hâ‚ , hâ‚‚ âŸ©
                                      =>
                                      âŸ¨
                                        { a' | a' > a }
                                          ,
                                          is_open_lt' _
                                          ,
                                          fun b hbs hba => hba
                                          ,
                                          inf_principal_eq_bot . 2
                                            $
                                            ğ“ a . sets_of_superset is_open_gt' _ . mem_nhds hu
                                              $
                                              fun x hx : u > x => show Â¬ x > a from not_ltâ‚“ . 2 $ hâ‚‚ _ hx
                                        âŸ©
                          fun
                            this : Â¬ âˆƒ u , u > a
                              =>
                              âŸ¨ âˆ… , is_open_empty , fun l _ hl => this âŸ¨ l , hl âŸ© . elim , nhds_within_empty _ âŸ©
                    let
                      âŸ¨ tâ‚‚ , htâ‚‚o , htâ‚‚s , htâ‚‚a âŸ© := this
                      âŸ¨
                        tâ‚ âˆª tâ‚‚
                          ,
                          IsOpen.union htâ‚o htâ‚‚o
                          ,
                          fun
                            x hx
                              =>
                              have
                                : x â‰  a := fun eq => ha $ Eq â–¸ hx
                                ne_iff_lt_or_gtâ‚“ . mp this . imp htâ‚s _ hx htâ‚‚s _ hx
                          ,
                          by rw [ nhds_within_union , htâ‚a , htâ‚‚a , bot_sup_eq ]
                        âŸ©
      }

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {a : Î±} {s : Set Î±} (hl : âˆƒ l, l < a) (hu : âˆƒ u, a < u) :
  s âˆˆ ğ“ a â†” âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s :=
  by 
    constructor
    Â·
      intro h 
      rcases exists_Ico_subset_of_mem_nhds h hu with âŸ¨u, au, huâŸ©
      rcases exists_Ioc_subset_of_mem_nhds h hl with âŸ¨l, la, hlâŸ©
      refine' âŸ¨l, u, âŸ¨la, auâŸ©, fun x hx => _âŸ©
      cases' le_totalâ‚“ a x with hax hax
      Â·
        exact hu âŸ¨hax, hx.2âŸ©
      Â·
        exact hl âŸ¨hx.1, haxâŸ©
    Â·
      rintro âŸ¨l, u, ha, hâŸ©
      apply mem_of_superset (IsOpen.mem_nhds is_open_Ioo ha) h

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [NoTopOrder Î±] [NoBotOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“ a â†” âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s :=
  mem_nhds_iff_exists_Ioo_subset' (no_bot a) (no_top a)

theorem nhds_basis_Ioo' {a : Î±} (hl : âˆƒ l, l < a) (hu : âˆƒ u, a < u) :
  (ğ“ a).HasBasis (fun b : Î± Ã— Î± => b.1 < a âˆ§ a < b.2) fun b => Ioo b.1 b.2 :=
  âŸ¨fun s =>
      (mem_nhds_iff_exists_Ioo_subset' hl hu).trans$
        by 
          simp âŸ©

theorem nhds_basis_Ioo [NoTopOrder Î±] [NoBotOrder Î±] (a : Î±) :
  (ğ“ a).HasBasis (fun b : Î± Ã— Î± => b.1 < a âˆ§ a < b.2) fun b => Ioo b.1 b.2 :=
  nhds_basis_Ioo' (no_bot a) (no_top a)

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  Filter.Eventually.exists_Ioo_subset
  [ NoTopOrder Î± ] [ NoBotOrder Î± ] { a : Î± } { p : Î± â†’ Prop } ( hp : âˆ€á¶  x in ğ“ a , p x )
    : âˆƒ l u , a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† { x | p x }
  := mem_nhds_iff_exists_Ioo_subset . 1 hp

section Pi

/-!
### Intervals in `Î  i, Ï€ i` belong to `ğ“ x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Î¹ â†’ â„`.
-/


variable {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [Fintype Î¹] [âˆ€ i, LinearOrderâ‚“ (Ï€ i)] [âˆ€ i, TopologicalSpace (Ï€ i)]
  [âˆ€ i, OrderTopology (Ï€ i)] {a b x : âˆ€ i, Ï€ i} {a' b' x' : Î¹ â†’ Î±}

theorem pi_Iic_mem_nhds (ha : âˆ€ i, x i < a i) : Iic a âˆˆ ğ“ x :=
  pi_univ_Iic a â–¸ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Iic_mem_nhds (ha _)

theorem pi_Iic_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iic a' âˆˆ ğ“ x' :=
  pi_Iic_mem_nhds ha

theorem pi_Ici_mem_nhds (ha : âˆ€ i, a i < x i) : Ici a âˆˆ ğ“ x :=
  pi_univ_Ici a â–¸ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Ici_mem_nhds (ha _)

theorem pi_Ici_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ici a' âˆˆ ğ“ x' :=
  pi_Ici_mem_nhds ha

theorem pi_Icc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Icc a b âˆˆ ğ“ x :=
  pi_univ_Icc a b â–¸ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Icc_mem_nhds (ha _) (hb _)

theorem pi_Icc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Icc a' b' âˆˆ ğ“ x' :=
  pi_Icc_mem_nhds ha hb

variable [Nonempty Î¹]

theorem pi_Iio_mem_nhds (ha : âˆ€ i, x i < a i) : Iio a âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Iio_subset a)
    exact Iio_mem_nhds (ha i)

theorem pi_Iio_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iio a' âˆˆ ğ“ x' :=
  pi_Iio_mem_nhds ha

theorem pi_Ioi_mem_nhds (ha : âˆ€ i, a i < x i) : Ioi a âˆˆ ğ“ x :=
  @pi_Iio_mem_nhds Î¹ (fun i => OrderDual (Ï€ i)) _ _ _ _ _ _ _ ha

theorem pi_Ioi_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ioi a' âˆˆ ğ“ x' :=
  pi_Ioi_mem_nhds ha

theorem pi_Ioc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioc a b âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ioc_subset a b)
    exact Ioc_mem_nhds (ha i) (hb i)

theorem pi_Ioc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioc a' b' âˆˆ ğ“ x' :=
  pi_Ioc_mem_nhds ha hb

theorem pi_Ico_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ico a b âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ico_subset a b)
    exact Ico_mem_nhds (ha i) (hb i)

theorem pi_Ico_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ico a' b' âˆˆ ğ“ x' :=
  pi_Ico_mem_nhds ha hb

theorem pi_Ioo_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioo a b âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ioo_subset a b)
    exact Ioo_mem_nhds (ha i) (hb i)

theorem pi_Ioo_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioo a' b' âˆˆ ğ“ x' :=
  pi_Ioo_mem_nhds ha hb

end Pi

theorem disjoint_nhds_at_top [NoTopOrder Î±] (x : Î±) : Disjoint (ğ“ x) at_top :=
  by 
    rw [Filter.disjoint_iff]
    cases' no_top x with a ha 
    use Iio a, Iio_mem_nhds ha, Ici a, mem_at_top a 
    rw [inter_comm, Ici_inter_Iio, Ico_self]

@[simp]
theorem inf_nhds_at_top [NoTopOrder Î±] (x : Î±) : ğ“ xâŠ“at_top = âŠ¥ :=
  disjoint_iff.1 (disjoint_nhds_at_top x)

theorem disjoint_nhds_at_bot [NoBotOrder Î±] (x : Î±) : Disjoint (ğ“ x) at_bot :=
  @disjoint_nhds_at_top (OrderDual Î±) _ _ _ _ x

@[simp]
theorem inf_nhds_at_bot [NoBotOrder Î±] (x : Î±) : ğ“ xâŠ“at_bot = âŠ¥ :=
  @inf_nhds_at_top (OrderDual Î±) _ _ _ _ x

theorem not_tendsto_nhds_of_tendsto_at_top [NoTopOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±}
  (hf : tendsto f F at_top) (x : Î±) : Â¬tendsto f F (ğ“ x) :=
  hf.not_tendsto (disjoint_nhds_at_top x).symm

theorem not_tendsto_at_top_of_tendsto_nhds [NoTopOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±} {x : Î±}
  (hf : tendsto f F (ğ“ x)) : Â¬tendsto f F at_top :=
  hf.not_tendsto (disjoint_nhds_at_top x)

theorem not_tendsto_nhds_of_tendsto_at_bot [NoBotOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±}
  (hf : tendsto f F at_bot) (x : Î±) : Â¬tendsto f F (ğ“ x) :=
  hf.not_tendsto (disjoint_nhds_at_bot x).symm

theorem not_tendsto_at_bot_of_tendsto_nhds [NoBotOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±} {x : Î±}
  (hf : tendsto f F (ğ“ x)) : Â¬tendsto f F at_bot :=
  hf.not_tendsto (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/


-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioc a b)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +âˆ)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u âˆˆ (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ioi {a b : Î±} (hab : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Ioi a] a, s âˆˆ ğ“[Ioc a b] a, s âˆˆ ğ“[Ioo a b] a, âˆƒ (u : _)(_ : u âˆˆ Ioc a b), Ioo a u âŠ† s,
      âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioo a u âŠ† s] :=
  by 
    tfaeHave 1 â†” 2
    Â·
      rw [nhds_within_Ioc_eq_nhds_within_Ioi hab]
    tfaeHave 1 â†” 3
    Â·
      rw [nhds_within_Ioo_eq_nhds_within_Ioi hab]
    tfaeHave 4 â†’ 5 
    exact fun âŸ¨u, umem, huâŸ© => âŸ¨u, umem.1, huâŸ©
    tfaeHave 5 â†’ 1
    Â·
      rintro âŸ¨u, hau, huâŸ©
      exact mem_of_superset (Ioo_mem_nhds_within_Ioi âŸ¨le_reflâ‚“ a, hauâŸ©) hu 
    tfaeHave 1 â†’ 4
    Â·
      intro h 
      rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with âŸ¨v, va, hvâŸ©
      rcases exists_Ico_subset_of_mem_nhds' va hab with âŸ¨u, au, huâŸ©
      refine' âŸ¨u, au, fun x hx => _âŸ©
      refine' hv âŸ¨hu âŸ¨le_of_ltâ‚“ hx.1, hx.2âŸ©, _âŸ©
      exact hx.1
    tfaeFinish

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioc a u')
theorem mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioc a u'), Ioo a u âŠ† s :=
  (tfae_mem_nhds_within_Ioi hu' s).out 0 3

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioo a u âŠ† s :=
  (tfae_mem_nhds_within_Ioi hu' s).out 0 4

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset [NoTopOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioo a u âŠ† s :=
  let âŸ¨u', hu'âŸ© := no_top a 
  mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioc_subset [NoTopOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioc a u âŠ† s :=
  by 
    rw [mem_nhds_within_Ioi_iff_exists_Ioo_subset]
    constructor
    Â·
      rintro âŸ¨u, au, asâŸ©
      rcases exists_between au with âŸ¨v, hvâŸ©
      exact âŸ¨v, hv.1, fun x hx => as âŸ¨hx.1, lt_of_le_of_ltâ‚“ hx.2 hv.2âŸ©âŸ©
    Â·
      rintro âŸ¨u, au, asâŸ©
      exact âŸ¨u, au, subset.trans Ioo_subset_Ioc_self asâŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Ico a b)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio b)
/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-âˆ, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l âˆˆ [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
theorem tfae_mem_nhds_within_Iio {a b : Î±} (h : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Iio b] b, s âˆˆ ğ“[Ico a b] b, s âˆˆ ğ“[Ioo a b] b, âˆƒ (l : _)(_ : l âˆˆ Ico a b), Ioo l b âŠ† s,
      âˆƒ (l : _)(_ : l âˆˆ Iio b), Ioo l b âŠ† s] :=
  by 
    simpa only [exists_prop, OrderDual.exists, dual_Ioi, dual_Ioc, dual_Ioo] using
      tfae_mem_nhds_within_Ioi h.dual (of_dual â»Â¹' s)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Ico l' a)
theorem mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iio a] a â†” âˆƒ (l : _)(_ : l âˆˆ Ico l' a), Ioo l a âŠ† s :=
  (tfae_mem_nhds_within_Iio hl' s).out 0 3

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio a)
/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iio a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioo l a âŠ† s :=
  (tfae_mem_nhds_within_Iio hl' s).out 0 4

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio a)
/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset [NoBotOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iio a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioo l a âŠ† s :=
  let âŸ¨l', hl'âŸ© := no_bot a 
  mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio a)
/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ico_subset [NoBotOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iio a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ico l a âŠ† s :=
  by 
    have  : of_dual â»Â¹' s âˆˆ ğ“[Ioi (to_dual a)] to_dual a â†” _ := mem_nhds_within_Ioi_iff_exists_Ioc_subset 
    simpa only [OrderDual.exists, exists_prop, dual_Ioc] using this

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioc a b)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +âˆ)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u âˆˆ (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ici {a b : Î±} (hab : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Ici a] a, s âˆˆ ğ“[Icc a b] a, s âˆˆ ğ“[Ico a b] a, âˆƒ (u : _)(_ : u âˆˆ Ioc a b), Ico a u âŠ† s,
      âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ico a u âŠ† s] :=
  by 
    tfaeHave 1 â†” 2
    Â·
      rw [nhds_within_Icc_eq_nhds_within_Ici hab]
    tfaeHave 1 â†” 3
    Â·
      rw [nhds_within_Ico_eq_nhds_within_Ici hab]
    tfaeHave 4 â†’ 5 
    exact fun âŸ¨u, umem, huâŸ© => âŸ¨u, umem.1, huâŸ©
    tfaeHave 5 â†’ 1
    Â·
      rintro âŸ¨u, hau, huâŸ©
      exact mem_of_superset (Ico_mem_nhds_within_Ici âŸ¨le_reflâ‚“ a, hauâŸ©) hu 
    tfaeHave 1 â†’ 4
    Â·
      intro h 
      rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with âŸ¨v, va, hvâŸ©
      rcases exists_Ico_subset_of_mem_nhds' va hab with âŸ¨u, au, huâŸ©
      refine' âŸ¨u, au, fun x hx => _âŸ©
      refine' hv âŸ¨hu âŸ¨hx.1, hx.2âŸ©, _âŸ©
      exact hx.1
    tfaeFinish

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioc a u')
theorem mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioc a u'), Ico a u âŠ† s :=
  (tfae_mem_nhds_within_Ici hu' s).out 0 3
    (by 
      normNum)
    (by 
      normNum)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ico a u âŠ† s :=
  (tfae_mem_nhds_within_Ici hu' s).out 0 4
    (by 
      normNum)
    (by 
      normNum)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset [NoTopOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ico a u âŠ† s :=
  let âŸ¨u', hu'âŸ© := no_top a 
  mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (u Â«expr âˆˆ Â» Ioi a)
/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset' [NoTopOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Icc a u âŠ† s :=
  by 
    rw [mem_nhds_within_Ici_iff_exists_Ico_subset]
    constructor
    Â·
      rintro âŸ¨u, au, asâŸ©
      rcases exists_between au with âŸ¨v, hvâŸ©
      exact âŸ¨v, hv.1, fun x hx => as âŸ¨hx.1, lt_of_le_of_ltâ‚“ hx.2 hv.2âŸ©âŸ©
    Â·
      rintro âŸ¨u, au, asâŸ©
      exact âŸ¨u, au, subset.trans Ico_subset_Icc_self asâŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Ico a b)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio b)
/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-âˆ, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l âˆˆ [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
theorem tfae_mem_nhds_within_Iic {a b : Î±} (h : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Iic b] b, s âˆˆ ğ“[Icc a b] b, s âˆˆ ğ“[Ioc a b] b, âˆƒ (l : _)(_ : l âˆˆ Ico a b), Ioc l b âŠ† s,
      âˆƒ (l : _)(_ : l âˆˆ Iio b), Ioc l b âŠ† s] :=
  by 
    simpa only [exists_prop, OrderDual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico] using
      tfae_mem_nhds_within_Ici h.dual (of_dual â»Â¹' s)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Ico l' a)
theorem mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Ico l' a), Ioc l a âŠ† s :=
  (tfae_mem_nhds_within_Iic hl' s).out 0 3
    (by 
      normNum)
    (by 
      normNum)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio a)
/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioc l a âŠ† s :=
  (tfae_mem_nhds_within_Iic hl' s).out 0 4
    (by 
      normNum)
    (by 
      normNum)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio a)
/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset [NoBotOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioc l a âŠ† s :=
  let âŸ¨l', hl'âŸ© := no_bot a 
  mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (l Â«expr âˆˆ Â» Iio a)
/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset' [NoBotOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Icc l a âŠ† s :=
  by 
    convert @mem_nhds_within_Ici_iff_exists_Icc_subset' (OrderDual Î±) _ _ _ _ _ _ _ 
    simpRw [show âˆ€ u : OrderDual Î±, @Icc (OrderDual Î±) _ a u = @Icc Î± _ u a from fun u => dual_Icc]
    rfl

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset [NoTopOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ u, a < u âˆ§ Icc a u âŠ† s :=
  by 
    rw [mem_nhds_within_Ici_iff_exists_Ico_subset]
    constructor
    Â·
      rintro âŸ¨u, au, asâŸ©
      rcases exists_between au with âŸ¨v, hvâŸ©
      exact âŸ¨v, hv.1, fun x hx => as âŸ¨hx.1, lt_of_le_of_ltâ‚“ hx.2 hv.2âŸ©âŸ©
    Â·
      rintro âŸ¨u, au, asâŸ©
      exact âŸ¨u, au, subset.trans Ico_subset_Icc_self asâŸ©

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset [NoBotOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ l, l < a âˆ§ Icc l a âŠ† s :=
  by 
    rw [mem_nhds_within_Iic_iff_exists_Ioc_subset]
    constructor
    Â·
      rintro âŸ¨l, la, asâŸ©
      rcases exists_between la with âŸ¨v, hvâŸ©
      refine' âŸ¨v, hv.2, fun x hx => as âŸ¨lt_of_lt_of_leâ‚“ hv.1 hx.1, hx.2âŸ©âŸ©
    Â·
      rintro âŸ¨l, la, asâŸ©
      exact âŸ¨l, la, subset.trans Ioc_subset_Icc_self asâŸ©

end LinearOrderâ‚“

section LinearOrderedAddCommGroup

variable [TopologicalSpace Î±] [LinearOrderedAddCommGroup Î±] [OrderTopology Î±]

variable {l : Filter Î²} {f g : Î² â†’ Î±}

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (r Â«expr > Â» 0)
-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  nhds_eq_infi_abs_sub
  ( a : Î± ) : ğ“ a = â¨… ( r : _ ) ( _ : r > 0 ) , ğ“Ÿ { b | | a - b | < r }
  :=
    by
      simp
          only
          [
            le_antisymm_iffâ‚“
              ,
              nhds_eq_order
              ,
              le_inf_iff
              ,
              le_infi_iff
              ,
              le_principal_iff
              ,
              mem_Ioi
              ,
              mem_Iio
              ,
              abs_sub_lt_iff
              ,
              @ sub_lt_iff_lt_add _ _ _ _ _ _ a
              ,
              @ sub_lt _ _ _ _ a
              ,
              set_of_and
            ]
        refine' âŸ¨ _ , _ , _ âŸ©
        Â·
          intro Îµ Îµ0
            exact
              inter_mem_inf
                mem_infi_of_mem a - Îµ $ mem_infi_of_mem sub_lt_self a Îµ0 mem_principal_self _
                  mem_infi_of_mem Îµ + a $ mem_infi_of_mem by simpa mem_principal_self _
        Â· intro b hb exact mem_infi_of_mem a - b mem_infi_of_mem sub_pos . 2 hb by simp [ Ioi ]
        Â· intro b hb exact mem_infi_of_mem b - a mem_infi_of_mem sub_pos . 2 hb by simp [ Iio ]

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (r Â«expr > Â» 0)
-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  order_topology_of_nhds_abs
  { Î± : Type _ }
      [ TopologicalSpace Î± ]
      [ LinearOrderedAddCommGroup Î± ]
      ( h_nhds : âˆ€ a : Î± , ğ“ a = â¨… ( r : _ ) ( _ : r > 0 ) , ğ“Ÿ { b | | a - b | < r } )
    : OrderTopology Î±
  :=
    by
      refine' âŸ¨ eq_of_nhds_eq_nhds $ fun a => _ âŸ©
        rw [ h_nhds ]
        let this' := Preorderâ‚“.topology Î±
        let this' : OrderTopology Î± := âŸ¨ rfl âŸ©
        exact nhds_eq_infi_abs_sub a . symm

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (Îµ Â«expr > Â» (0 : Î±))
theorem LinearOrderedAddCommGroup.tendsto_nhds {x : Filter Î²} {a : Î±} :
  tendsto f x (ğ“ a) â†” âˆ€ Îµ _ : Îµ > (0 : Î±), âˆ€á¶  b in x, |f b - a| < Îµ :=
  by 
    simp [nhds_eq_infi_abs_sub, abs_sub_comm a]

theorem eventually_abs_sub_lt (a : Î±) {Îµ : Î±} (hÎµ : 0 < Îµ) : âˆ€á¶  x in ğ“ a, |x - a| < Îµ :=
  (nhds_eq_infi_abs_sub a).symm â–¸
    mem_infi_of_mem Îµ
      (mem_infi_of_mem hÎµ$
        by 
          simp only [abs_sub_comm, mem_principal_self])

instance (priority := 100) LinearOrderedAddCommGroup.topological_add_group : TopologicalAddGroup Î± :=
  { continuous_add :=
      by 
        refine' continuous_iff_continuous_at.2 _ 
        rintro âŸ¨a, bâŸ©
        refine' LinearOrderedAddCommGroup.tendsto_nhds.2 fun Îµ Îµ0 => _ 
        rcases dense_or_discrete 0 Îµ with (âŸ¨Î´, Î´0, Î´ÎµâŸ© | âŸ¨hâ‚, hâ‚‚âŸ©)
        Â·
          filterUpwards [ProdIsOpen.mem_nhds (eventually_abs_sub_lt a Î´0) (eventually_abs_sub_lt b (sub_pos.2 Î´Îµ))]
          rintro âŸ¨x, yâŸ© âŸ¨hx : |x - a| < Î´, hy : |y - b| < Îµ - Î´âŸ©
          rw [add_sub_comm]
          calc |(x - a)+y - b| â‰¤ |x - a|+|y - b| := abs_add _ _ _ < Î´+Îµ - Î´ := add_lt_add hx hy _ = Îµ :=
            add_sub_cancel'_right _ _
        Â·
          have hÎµ : âˆ€ {x y}, |x - y| < Îµ â†’ x = y
          Â·
            intro x y h 
            simpa [sub_eq_zero] using hâ‚‚ _ h 
          filterUpwards [ProdIsOpen.mem_nhds (eventually_abs_sub_lt a Îµ0) (eventually_abs_sub_lt b Îµ0)]
          rintro âŸ¨x, yâŸ© âŸ¨hx : |x - a| < Îµ, hy : |y - b| < ÎµâŸ©
          simpa [hÎµ hx, hÎµ hy],
    continuous_neg :=
      continuous_iff_continuous_at.2$
        fun a =>
          LinearOrderedAddCommGroup.tendsto_nhds.2$
            fun Îµ Îµ0 =>
              (eventually_abs_sub_lt a Îµ0).mono$
                fun x hx =>
                  by 
                    rwa [neg_sub_neg, abs_sub_comm] }

@[continuity]
theorem continuous_abs : Continuous (abs : Î± â†’ Î±) :=
  continuous_id.max continuous_neg

theorem Filter.Tendsto.abs {f : Î² â†’ Î±} {a : Î±} {l : Filter Î²} (h : tendsto f l (ğ“ a)) :
  tendsto (fun x => |f x|) l (ğ“ |a|) :=
  (continuous_abs.Tendsto _).comp h

theorem tendsto_zero_iff_abs_tendsto_zero (f : Î² â†’ Î±) {l : Filter Î²} : tendsto f l (ğ“ 0) â†” tendsto (abs âˆ˜ f) l (ğ“ 0) :=
  by 
    refine' âŸ¨fun h => (abs_zero : |(0 : Î±)| = 0) â–¸ h.abs, fun h => _âŸ©
    have  : tendsto (fun a => -|f a|) l (ğ“ 0) := (neg_zero : -(0 : Î±) = 0) â–¸ h.neg 
    exact tendsto_of_tendsto_of_tendsto_of_le_of_le this h (fun x => neg_abs_le_self$ f x) fun x => le_abs_self$ f x

theorem nhds_basis_Ioo_pos [NoBotOrder Î±] [NoTopOrder Î±] (a : Î±) :
  (ğ“ a).HasBasis (fun Îµ : Î± => (0 : Î±) < Îµ) fun Îµ => Ioo (a - Îµ) (a+Îµ) :=
  âŸ¨by 
      refine' fun t => (nhds_basis_Ioo a).mem_iff.trans âŸ¨_, _âŸ©
      Â·
        rintro âŸ¨âŸ¨l, uâŸ©, âŸ¨hl : l < a, hu : a < uâŸ©, h' : Ioo l u âŠ† tâŸ©
        refine'
          âŸ¨min (a - l) (u - a),
            by 
              apply lt_minâ‚“ <;> rwa [sub_pos],
            _âŸ©
        rintro x âŸ¨hx, hx'âŸ©
        apply h' 
        rw [sub_lt, lt_min_iff, sub_lt_sub_iff_left] at hx 
        rw [â†sub_lt_iff_lt_add', lt_min_iff, sub_lt_sub_iff_right] at hx' 
        exact âŸ¨hx.1, hx'.2âŸ©
      Â·
        rintro âŸ¨Îµ, Îµ_pos, hâŸ©
        exact
          âŸ¨(a - Îµ, a+Îµ),
            by 
              simp [Îµ_pos],
            hâŸ©âŸ©

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  nhds_basis_abs_sub_lt
  [ NoBotOrder Î± ] [ NoTopOrder Î± ] ( a : Î± ) : ğ“ a . HasBasis fun Îµ : Î± => ( 0 : Î± ) < Îµ fun Îµ => { b | | b - a | < Îµ }
  :=
    by
      convert nhds_basis_Ioo_pos a
        Â·
          ext Îµ
            change | x - a | < Îµ â†” a - Îµ < x âˆ§ x < a + Îµ
            simp [ abs_lt , sub_lt_iff_lt_add , add_commâ‚“ Îµ a , add_commâ‚“ x Îµ ]

variable (Î±)

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  nhds_basis_zero_abs_sub_lt
  [ NoBotOrder Î± ] [ NoTopOrder Î± ] : ğ“ ( 0 : Î± ) . HasBasis fun Îµ : Î± => ( 0 : Î± ) < Îµ fun Îµ => { b | | b | < Îµ }
  := by simpa using nhds_basis_abs_sub_lt ( 0 : Î± )

variable {Î±}

/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/
theorem nhds_basis_Ioo_pos_of_pos [NoBotOrder Î±] [NoTopOrder Î±] {a : Î±} (ha : 0 < a) :
  (ğ“ a).HasBasis (fun Îµ : Î± => (0 : Î±) < Îµ âˆ§ Îµ â‰¤ a) fun Îµ => Ioo (a - Îµ) (a+Îµ) :=
  âŸ¨fun t =>
      (nhds_basis_Ioo_pos a).mem_iff.trans
        âŸ¨fun h =>
            let âŸ¨i, hi, hitâŸ© := h
            âŸ¨min i a, âŸ¨lt_minâ‚“ hi ha, min_le_rightâ‚“ i aâŸ©,
              trans (Ioo_subset_Ioo (sub_le_sub_left (min_le_leftâ‚“ i a) a) (add_le_add_left (min_le_leftâ‚“ i a) a)) hitâŸ©,
          fun h =>
            let âŸ¨i, hi, hitâŸ© := h
            âŸ¨i, hi.1, hitâŸ©âŸ©âŸ©

section 

variable [TopologicalSpace Î²] {b : Î²} {a : Î±} {s : Set Î²}

theorem Continuous.abs (h : Continuous f) : Continuous fun x => |f x| :=
  continuous_abs.comp h

theorem ContinuousAt.abs (h : ContinuousAt f b) : ContinuousAt (fun x => |f x|) b :=
  h.abs

theorem ContinuousWithinAt.abs (h : ContinuousWithinAt f s b) : ContinuousWithinAt (fun x => |f x|) s b :=
  h.abs

theorem ContinuousOn.abs (h : ContinuousOn f s) : ContinuousOn (fun x => |f x|) s :=
  fun x hx => (h x hx).abs

theorem tendsto_abs_nhds_within_zero : tendsto (abs : Î± â†’ Î±) (ğ“[{0}á¶œ] 0) (ğ“[Ioi 0] 0) :=
  (continuous_abs.tendsto' (0 : Î±) 0 abs_zero).inf$ tendsto_principal_principal.2$ fun x => abs_pos.2

end 

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.add_at_top {C : Î±} (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  by 
    nontriviality Î± 
    obtain âŸ¨C', hC'âŸ© : âˆƒ C', C' < C := no_bot C 
    refine' tendsto_at_top_add_left_of_le' _ C' _ hg 
    exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_ltâ‚“

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.add_at_bot {C : Î±} (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @Filter.Tendsto.add_at_top (OrderDual Î±) _ _ _ _ _ _ _ _ hf hg

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.at_top_add {C : Î±} (hf : tendsto f l at_top) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x+g x) l at_top :=
  by 
    conv  in _+_ => rw [add_commâ‚“]
    exact hg.add_at_top hf

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_bot_add {C : Î±} (hf : tendsto f l at_bot) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x+g x) l at_bot :=
  by 
    conv  in _+_ => rw [add_commâ‚“]
    exact hg.add_at_bot hf

end LinearOrderedAddCommGroup

section LinearOrderedField

variable [LinearOrderedField Î±] [TopologicalSpace Î±] [OrderTopology Î±]

variable {l : Filter Î²} {f g : Î² â†’ Î±}

section continuous_mul

theorem mul_tendsto_nhds_zero_right (x : Î±) : tendsto (uncurry (Â·*Â· : Î± â†’ Î± â†’ Î±)) (ğ“ 0 Ã—á¶  ğ“ x)$ ğ“ 0 :=
  by 
    have hx : 0 < 2*1+|x| :=
      mul_pos zero_lt_two$ lt_of_lt_of_leâ‚“ zero_lt_one$ le_add_of_le_of_nonneg le_rfl (abs_nonneg x)
    rw [((nhds_basis_zero_abs_sub_lt Î±).Prod$ nhds_basis_abs_sub_lt x).tendsto_iff (nhds_basis_zero_abs_sub_lt Î±)]
    refine' fun Îµ Îµ_pos => âŸ¨(Îµ / 2*1+|x|, 1), âŸ¨div_pos Îµ_pos hx, zero_lt_oneâŸ©, _âŸ©
    suffices  : âˆ€ a b : Î±, (|a| < Îµ / 2*1+|x|) â†’ |b - x| < 1 â†’ (|a|*|b|) < Îµ
    Â·
      simpa only [and_imp, Prod.forall, mem_prod, â†abs_mul]
    intro a b h h' 
    refine' lt_of_le_of_ltâ‚“ (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h)
    calc |b| = |(b - x)+x| :=
      by 
        rw [sub_add_cancel b x]_ â‰¤ |b - x|+|x| :=
      abs_add (b - x) x _ â‰¤ 1+|x| := add_le_add_right (le_of_ltâ‚“ h') |x|_ â‰¤ 2*1+|x| :=
      by 
        linarith

theorem mul_tendsto_nhds_zero_left (x : Î±) : tendsto (uncurry (Â·*Â· : Î± â†’ Î± â†’ Î±)) (ğ“ x Ã—á¶  ğ“ 0)$ ğ“ 0 :=
  by 
    intro s hs 
    have  := mul_tendsto_nhds_zero_right x hs 
    rw [Filter.mem_map, mem_prod_iff] at thisâŠ¢
    obtain âŸ¨U, hU, V, hV, hâŸ© := this 
    exact
      âŸ¨V, hV, U, hU, fun y hy => (mul_commâ‚“ y.2 y.1 â–¸ h (âŸ¨hy.2, hy.1âŸ© : Prod.mk y.2 y.1 âˆˆ U.prod V) : (y.1*y.2) âˆˆ s)âŸ©

theorem nhds_eq_map_mul_left_nhds_one {xâ‚€ : Î±} (hxâ‚€ : xâ‚€ â‰  0) : ğ“ xâ‚€ = map (fun x => xâ‚€*x) (ğ“ 1) :=
  by 
    have hxâ‚€' : 0 < |xâ‚€| := abs_pos.2 hxâ‚€ 
    refine' Filter.ext fun t => _ 
    simp only [exists_prop, set_of_subset_set_of, (nhds_basis_abs_sub_lt xâ‚€).mem_iff,
      (nhds_basis_abs_sub_lt (1 : Î±)).mem_iff, Filter.mem_map']
    refine' âŸ¨fun h => _, fun h => _âŸ©
    Â·
      obtain âŸ¨i, hi, hitâŸ© := h 
      refine' âŸ¨i / |xâ‚€|, div_pos hi (abs_pos.2 hxâ‚€), fun x hx => hit _âŸ©
      calc |(xâ‚€*x) - xâ‚€| = |xâ‚€*x - 1| :=
        congr_argâ‚“ abs
          (by 
            ringNF)_ = |xâ‚€|*|x - 1| :=
        abs_mul xâ‚€ (x - 1)_ < |xâ‚€|*i / |xâ‚€| :=
        mul_lt_mul' le_rfl hx (abs_nonneg (x - 1)) (abs_pos.2 hxâ‚€)_ = (|xâ‚€|*i) / |xâ‚€| :=
        by 
          ring _ = i :=
        mul_div_cancel_left i fun h => hxâ‚€ (abs_eq_zero.1 h)
    Â·
      obtain âŸ¨i, hi, hitâŸ© := h 
      refine' âŸ¨i*|xâ‚€|, mul_pos hi (abs_pos.2 hxâ‚€), fun x hx => _âŸ©
      have  : |x / xâ‚€ - 1| < i 
      calc |x / xâ‚€ - 1| = |x / xâ‚€ - xâ‚€ / xâ‚€| :=
        by 
          rw [div_self hxâ‚€]_ = |(x - xâ‚€) / xâ‚€| :=
        congr_argâ‚“ abs (sub_div x xâ‚€ xâ‚€).symm _ = |x - xâ‚€| / |xâ‚€| := abs_div (x - xâ‚€) xâ‚€ _ < (i*|xâ‚€|) / |xâ‚€| :=
        div_lt_div hx le_rfl (mul_nonneg (le_of_ltâ‚“ hi) (abs_nonneg xâ‚€)) (abs_pos.2 hxâ‚€)_ = i :=
        by 
          rw [â†mul_div_assoc', div_self (ne_of_ltâ‚“$ abs_pos.2 hxâ‚€).symm, mul_oneâ‚“]
      specialize hit (x / xâ‚€) this 
      rwa [mul_div_assoc', mul_div_cancel_left x hxâ‚€] at hit

theorem nhds_eq_map_mul_right_nhds_one {xâ‚€ : Î±} (hxâ‚€ : xâ‚€ â‰  0) : ğ“ xâ‚€ = map (fun x => x*xâ‚€) (ğ“ 1) :=
  by 
    simpRw [mul_commâ‚“ _ xâ‚€, nhds_eq_map_mul_left_nhds_one hxâ‚€]

theorem mul_tendsto_nhds_one_nhds_one : tendsto (uncurry (Â·*Â· : Î± â†’ Î± â†’ Î±)) (ğ“ 1 Ã—á¶  ğ“ 1)$ ğ“ 1 :=
  by 
    rw
      [((nhds_basis_Ioo_pos (1 : Î±)).Prod$ nhds_basis_Ioo_pos (1 : Î±)).tendsto_iff
        (nhds_basis_Ioo_pos_of_pos (zero_lt_one : (0 : Î±) < 1))]
    intro Îµ hÎµ 
    have hÎµ' : 0 â‰¤ 1 - Îµ / 4 :=
      by 
        linarith 
    have Îµ_pos : 0 < Îµ / 4 :=
      by 
        linarith 
    have Îµ_pos' : 0 < Îµ / 2 :=
      by 
        linarith 
    simp only [and_imp, Prod.forall, mem_Ioo, Function.uncurry_apply_pair, mem_prod, Prod.exists]
    refine' âŸ¨Îµ / 4, Îµ / 4, âŸ¨Îµ_pos, Îµ_posâŸ©, fun a b ha ha' hb hb' => _âŸ©
    have ha0 : 0 â‰¤ a := le_transâ‚“ hÎµ' (le_of_ltâ‚“ ha)
    have hb0 : 0 â‰¤ b := le_transâ‚“ hÎµ' (le_of_ltâ‚“ hb)
    refine' âŸ¨lt_of_le_of_ltâ‚“ _ (mul_lt_mul'' ha hb hÎµ' hÎµ'), lt_of_lt_of_leâ‚“ (mul_lt_mul'' ha' hb' ha0 hb0) _âŸ©
    Â·
      calc 1 - Îµ = 1 - Îµ / 2 - Îµ / 2 :=
        by 
          ringNF _ â‰¤ (1 - Îµ / 2 - Îµ / 2)+(Îµ / 2)*Îµ / 2 :=
        le_add_of_nonneg_right (le_of_ltâ‚“ (mul_pos Îµ_pos' Îµ_pos'))_ = (1 - Îµ / 2)*1 - Îµ / 2 :=
        by 
          ringNF _ â‰¤ (1 - Îµ / 4)*1 - Îµ / 4 :=
        mul_le_mul
          (by 
            linarith)
          (by 
            linarith)
          (by 
            linarith)
          hÎµ'
    Â·
      calc ((1+Îµ / 4)*1+Îµ / 4) = (1+Îµ / 2)+(Îµ / 4)*Îµ / 4 :=
        by 
          ringNF _ = (1+Îµ / 2)+(Îµ*Îµ) / 16 :=
        by 
          ringNF _ â‰¤ (1+Îµ / 2)+Îµ / 2 :=
        add_le_add_left
          (div_le_div (le_of_ltâ‚“ hÎµ.1) (le_transâ‚“ ((mul_le_mul_left hÎµ.1).2 hÎµ.2) (le_of_eqâ‚“$ mul_oneâ‚“ Îµ)) zero_lt_two
            (by 
              linarith))
          (1+Îµ / 2)_ â‰¤ 1+Îµ :=
        by 
          ringNF

instance (priority := 100) LinearOrderedField.has_continuous_mul : HasContinuousMul Î± :=
  âŸ¨by 
      rw [continuous_iff_continuous_at]
      rintro âŸ¨xâ‚€, yâ‚€âŸ©
      byCases' hxâ‚€ : xâ‚€ = 0
      Â·
        rw [hxâ‚€, ContinuousAt, zero_mul, nhds_prod_eq]
        exact mul_tendsto_nhds_zero_right yâ‚€ 
      byCases' hyâ‚€ : yâ‚€ = 0
      Â·
        rw [hyâ‚€, ContinuousAt, mul_zero, nhds_prod_eq]
        exact mul_tendsto_nhds_zero_left xâ‚€ 
      have hxy : (xâ‚€*yâ‚€) â‰  0 := mul_ne_zero hxâ‚€ hyâ‚€ 
      have key : (fun p : Î± Ã— Î± => (xâ‚€*p.1)*p.2*yâ‚€) = (((fun x => xâ‚€*x) âˆ˜ fun x => x*yâ‚€) âˆ˜ uncurry (Â·*Â·))
      Â·
        ext p 
        simp [uncurry, mul_assocâ‚“]
      have keyâ‚‚ : ((fun x => xâ‚€*x) âˆ˜ fun x => yâ‚€*x) = fun x => (xâ‚€*yâ‚€)*x
      Â·
        ext x 
        simp 
      calc map (uncurry (Â·*Â·)) (ğ“ (xâ‚€, yâ‚€)) = map (uncurry (Â·*Â·)) (ğ“ xâ‚€ Ã—á¶  ğ“ yâ‚€) :=
        by 
          rw [nhds_prod_eq]_ = map (fun p : Î± Ã— Î± => (xâ‚€*p.1)*p.2*yâ‚€) (ğ“ 1 Ã—á¶  ğ“ 1) :=
        by 
          rw [uncurry, nhds_eq_map_mul_left_nhds_one hxâ‚€, nhds_eq_map_mul_right_nhds_one hyâ‚€, prod_map_map_eq,
            Filter.map_map]_ = map ((fun x => xâ‚€*x) âˆ˜ fun x => x*yâ‚€) (map (uncurry (Â·*Â·)) (ğ“ 1 Ã—á¶  ğ“ 1)) :=
        by 
          rw [key, â†Filter.map_map]_ â‰¤ map ((fun x : Î± => xâ‚€*x) âˆ˜ fun x => x*yâ‚€) (ğ“ 1) :=
        map_mono mul_tendsto_nhds_one_nhds_one _ = ğ“ (xâ‚€*yâ‚€) :=
        by 
          rw [â†Filter.map_map, â†nhds_eq_map_mul_right_nhds_one hyâ‚€, nhds_eq_map_mul_left_nhds_one hyâ‚€, Filter.map_map,
            keyâ‚‚, â†nhds_eq_map_mul_left_nhds_one hxy]âŸ©

end continuous_mul

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a positive constant `C` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.at_top_mul {C : Î±} (hC : 0 < C) (hf : tendsto f l at_top) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    refine' tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))
    filterUpwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually (eventually_ge_at_top 0)]
    exact fun x hg hf => mul_le_mul_of_nonneg_left hg.le hf

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.mul_at_top {C : Î±} (hC : 0 < C) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa only [mul_commâ‚“] using hg.at_top_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a negative constant `C` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_top_mul_neg {C : Î±} (hC : C < 0) (hf : tendsto f l at_top) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [Â· âˆ˜ Â·, neg_mul_eq_mul_neg, neg_negâ‚“] using
      tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.neg_mul_at_top {C : Î±} (hC : C < 0) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [mul_commâ‚“] using hg.at_top_mul_neg hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a positive constant `C` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_bot_mul {C : Î±} (hC : 0 < C) (hf : tendsto f l at_bot) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa [Â· âˆ˜ Â·] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a negative constant `C` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.at_bot_mul_neg {C : Î±} (hC : C < 0) (hf : tendsto f l at_bot) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa [Â· âˆ˜ Â·] using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.mul_at_bot {C : Î±} (hC : 0 < C) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [mul_commâ‚“] using hg.at_bot_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.neg_mul_at_bot {C : Î±} (hC : C < 0) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa only [mul_commâ‚“] using hg.at_bot_mul_neg hC hf

/-- The function `x â†¦ xâ»Â¹` tends to `+âˆ` on the right of `0`. -/
theorem tendsto_inv_zero_at_top : tendsto (fun x : Î± => xâ»Â¹) (ğ“[Set.Ioi (0 : Î±)] 0) at_top :=
  by 
    refine' (at_top_basis' 1).tendsto_right_iff.2 fun b hb => _ 
    have hb' : 0 < b := zero_lt_one.trans_le hb 
    filterUpwards [Ioc_mem_nhds_within_Ioi âŸ¨le_rfl, inv_pos.2 hb'âŸ©]
    exact fun x hx => (le_inv hx.1 hb').1 hx.2

/-- The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆ`. -/
theorem tendsto_inv_at_top_zero' : tendsto (fun r : Î± => râ»Â¹) at_top (ğ“[Set.Ioi (0 : Î±)] 0) :=
  by 
    refine' (has_basis.tendsto_iff at_top_basis âŸ¨fun s => mem_nhds_within_Ioi_iff_exists_Ioc_subsetâŸ©).2 _ 
    refine' fun b hb => âŸ¨bâ»Â¹, trivialâ‚“, fun x hx => _âŸ©
    have  : 0 < x := lt_of_lt_of_leâ‚“ (inv_pos.2 hb) hx 
    exact âŸ¨inv_pos.2 this, (inv_le this hb).2 hxâŸ©

theorem tendsto_inv_at_top_zero : tendsto (fun r : Î± => râ»Â¹) at_top (ğ“ 0) :=
  tendsto_inv_at_top_zero'.mono_right inf_le_left

theorem Filter.Tendsto.div_at_top [HasContinuousMul Î±] {f g : Î² â†’ Î±} {l : Filter Î²} {a : Î±} (h : tendsto f l (ğ“ a))
  (hg : tendsto g l at_top) : tendsto (fun x => f x / g x) l (ğ“ 0) :=
  by 
    simp only [div_eq_mul_inv]
    exact mul_zero a â–¸ h.mul (tendsto_inv_at_top_zero.comp hg)

theorem Filter.Tendsto.inv_tendsto_at_top (h : tendsto f l at_top) : tendsto (fâ»Â¹) l (ğ“ 0) :=
  tendsto_inv_at_top_zero.comp h

theorem Filter.Tendsto.inv_tendsto_zero (h : tendsto f l (ğ“[Set.Ioi 0] 0)) : tendsto (fâ»Â¹) l at_top :=
  tendsto_inv_zero_at_top.comp h

/-- The function `x^(-n)` tends to `0` at `+âˆ` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_neg_at_top`. -/
theorem tendsto_pow_neg_at_top {n : â„•} (hn : 1 â‰¤ n) : tendsto (fun x : Î± => x ^ -(n : â„¤)) at_top (ğ“ 0) :=
  tendsto.congr (fun x => (zpow_negâ‚€ x n).symm)
    (Filter.Tendsto.inv_tendsto_at_top
      (by 
        simpa [zpow_coe_nat] using tendsto_pow_at_top hn))

theorem tendsto_zpow_at_top_zero {n : â„¤} (hn : n < 0) : tendsto (fun x : Î± => x ^ n) at_top (ğ“ 0) :=
  by 
    have  : 1 â‰¤ -n := le_neg.mp (Int.le_of_lt_add_one (hn.trans_le (neg_add_selfâ‚“ 1).symm.le))
    apply
      tendsto.congr
        (show âˆ€ x : Î±, x ^ - -n = x ^ n by 
          simp )
    lift -n to â„• using le_of_ltâ‚“ (neg_pos.mpr hn) with N 
    exact
      tendsto_pow_neg_at_top
        (by 
          exactModCast this)

theorem tendsto_const_mul_zpow_at_top_zero {n : â„¤} {c : Î±} (hn : n < 0) : tendsto (fun x => c*x ^ n) at_top (ğ“ 0) :=
  mul_zero c â–¸ Filter.Tendsto.const_mul c (tendsto_zpow_at_top_zero hn)

theorem tendsto_const_mul_pow_nhds_iff {n : â„•} {c d : Î±} (hc : c â‰  0) :
  tendsto (fun x : Î± => c*x ^ n) at_top (ğ“ d) â†” n = 0 âˆ§ c = d :=
  by 
    refine' âŸ¨fun h => _, fun h => _âŸ©
    Â·
      have hn : n = 0
      Â·
        byContra hn 
        have hn : 1 â‰¤ n := Nat.succ_le_iff.2 (lt_of_le_of_neâ‚“ (zero_le _) (Ne.symm hn))
        byCases' hc' : 0 < c
        Â·
          have  := (tendsto_const_mul_pow_at_top_iff c n).2 âŸ¨hn, hc'âŸ©
          exact not_tendsto_nhds_of_tendsto_at_top this d h
        Â·
          have  := (tendsto_neg_const_mul_pow_at_top_iff c n).2 âŸ¨hn, lt_of_le_of_neâ‚“ (not_ltâ‚“.1 hc') hcâŸ©
          exact not_tendsto_nhds_of_tendsto_at_bot this d h 
      have  : (fun x : Î± => c*x ^ n) = fun x : Î± => c
      Â·
        simp [hn]
      rw [this, tendsto_const_nhds_iff] at h 
      exact âŸ¨hn, hâŸ©
    Â·
      obtain âŸ¨hn, hcdâŸ© := h 
      simpa [hn, hcd] using tendsto_const_nhds

theorem tendsto_const_mul_zpow_at_top_zero_iff {n : â„¤} {c d : Î±} (hc : c â‰  0) :
  tendsto (fun x : Î± => c*x ^ n) at_top (ğ“ d) â†” n = 0 âˆ§ c = d âˆ¨ n < 0 âˆ§ d = 0 :=
  by 
    refine' âŸ¨fun h => _, fun h => _âŸ©
    Â·
      byCases' hn : 0 â‰¤ n
      Â·
        lift n to â„• using hn 
        simp only [zpow_coe_nat] at h 
        rw [tendsto_const_mul_pow_nhds_iff hc, â†Int.coe_nat_eq_zero] at h 
        exact Or.inl h
      Â·
        rw [not_leâ‚“] at hn 
        refine' Or.inr âŸ¨hn, tendsto_nhds_unique h (tendsto_const_mul_zpow_at_top_zero hn)âŸ©
    Â·
      cases h
      Â·
        simp only [h.left, h.right, zpow_zero, mul_oneâ‚“]
        exact tendsto_const_nhds
      Â·
        exact h.2.symm â–¸ tendsto_const_mul_zpow_at_top_zero h.1

end LinearOrderedField

theorem preimage_neg [AddGroupâ‚“ Î±] : preimage (Neg.neg : Î± â†’ Î±) = image (Neg.neg : Î± â†’ Î±) :=
  (image_eq_preimage_of_inverse neg_negâ‚“ neg_negâ‚“).symm

theorem Filter.map_neg [AddGroupâ‚“ Î±] : map (Neg.neg : Î± â†’ Î±) = comap (Neg.neg : Î± â†’ Î±) :=
  funext$ fun f => map_eq_comap_of_inverse (funext neg_negâ‚“) (funext neg_negâ‚“)

section OrderTopology

variable [TopologicalSpace Î±] [TopologicalSpace Î²] [LinearOrderâ‚“ Î±] [LinearOrderâ‚“ Î²] [OrderTopology Î±] [OrderTopology Î²]

theorem IsLub.frequently_mem {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : âˆƒá¶  x in ğ“[Iic a] a, x âˆˆ s :=
  by 
    rcases hs with âŸ¨a', ha'âŸ©
    intro h 
    rcases(ha.1 ha').eq_or_lt with (rfl | ha'a)
    Â·
      exact h.self_of_nhds_within le_rfl ha'
    Â·
      rcases(mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h with âŸ¨b, hba, hbâŸ©
      rcases ha.exists_between hba with âŸ¨b', hb's, hb'âŸ©
      exact hb hb' hb's

theorem IsLub.frequently_nhds_mem {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : âˆƒá¶  x in ğ“ a, x âˆˆ s :=
  (ha.frequently_mem hs).filter_mono inf_le_left

theorem IsGlb.frequently_mem {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) : âˆƒá¶  x in ğ“[Ici a] a, x âˆˆ s :=
  @IsLub.frequently_mem (OrderDual Î±) _ _ _ _ _ ha hs

theorem IsGlb.frequently_nhds_mem {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) : âˆƒá¶  x in ğ“ a, x âˆˆ s :=
  (ha.frequently_mem hs).filter_mono inf_le_left

theorem IsLub.mem_closure {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : a âˆˆ Closure s :=
  (ha.frequently_nhds_mem hs).mem_closure

theorem IsGlb.mem_closure {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) : a âˆˆ Closure s :=
  (ha.frequently_nhds_mem hs).mem_closure

theorem IsLub.nhds_within_ne_bot {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : ne_bot (ğ“[s] a) :=
  mem_closure_iff_nhds_within_ne_bot.1 (ha.mem_closure hs)

theorem IsGlb.nhds_within_ne_bot : âˆ€ {a : Î±} {s : Set Î±}, IsGlb s a â†’ s.nonempty â†’ ne_bot (ğ“[s] a) :=
  @IsLub.nhds_within_ne_bot (OrderDual Î±) _ _ _

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
theorem
  is_lub_of_mem_nhds
  { s : Set Î± } { a : Î± } { f : Filter Î± } ( hsa : a âˆˆ UpperBounds s ) ( hsf : s âˆˆ f ) [ ne_bot f âŠ“ ğ“ a ] : IsLub s a
  :=
    âŸ¨
      hsa
        ,
        fun
          b hb
            =>
            not_ltâ‚“ . 1
              $
              fun
                hba
                  =>
                  have
                    : s âˆ© { a | b < a } âˆˆ f âŠ“ ğ“ a := inter_mem_inf hsf IsOpen.mem_nhds is_open_lt' _ hba
                    let
                      âŸ¨ x , âŸ¨ hxs , hxb âŸ© âŸ© := Filter.nonempty_of_mem this
                      have : b < b := lt_of_lt_of_leâ‚“ hxb $ hb hxs lt_irreflâ‚“ b this
      âŸ©

theorem is_lub_of_mem_closure {s : Set Î±} {a : Î±} (hsa : a âˆˆ UpperBounds s) (hsf : a âˆˆ Closure s) : IsLub s a :=
  by 
    rw [mem_closure_iff_cluster_pt, ClusterPt, inf_comm] at hsf 
    have  : (ğ“Ÿ sâŠ“ğ“ a).ne_bot := hsf 
    exact is_lub_of_mem_nhds hsa (mem_principal_self s)

theorem is_glb_of_mem_nhds :
  âˆ€ {s : Set Î±} {a : Î±} {f : Filter Î±}, a âˆˆ LowerBounds s â†’ s âˆˆ f â†’ ne_bot (fâŠ“ğ“ a) â†’ IsGlb s a :=
  @is_lub_of_mem_nhds (OrderDual Î±) _ _ _

theorem is_glb_of_mem_closure {s : Set Î±} {a : Î±} (hsa : a âˆˆ LowerBounds s) (hsf : a âˆˆ Closure s) : IsGlb s a :=
  @is_lub_of_mem_closure (OrderDual Î±) _ _ _ s a hsa hsf

theorem IsLub.mem_upper_bounds_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³}
  {s : Set Î±} {a : Î±} {b : Î³} (hf : MonotoneOn f s) (ha : IsLub s a) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  b âˆˆ UpperBounds (f '' s) :=
  by 
    rintro _ âŸ¨x, hx, rflâŸ©
    replace ha := ha.inter_Ici_of_mem hx 
    have  := ha.nhds_within_ne_bot âŸ¨x, hx, le_rflâŸ©
    refine' ge_of_tendsto (hb.mono_left (nhds_within_mono _ (inter_subset_left s (Ici x)))) _ 
    exact mem_of_superset self_mem_nhds_within fun y hy => hf hx hy.1 hy.2

theorem IsLub.is_lub_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³} {s : Set Î±}
  {a : Î±} {b : Î³} (hf : MonotoneOn f s) (ha : IsLub s a) (hs : s.nonempty) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  IsLub (f '' s) b :=
  by 
    have  := ha.nhds_within_ne_bot hs 
    exact
      âŸ¨ha.mem_upper_bounds_of_tendsto hf hb,
        fun b' hb' => le_of_tendsto hb (mem_of_superset self_mem_nhds_within$ fun x hx => hb'$ mem_image_of_mem _ hx)âŸ©

theorem IsGlb.mem_lower_bounds_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³}
  {s : Set Î±} {a : Î±} {b : Î³} (hf : MonotoneOn f s) (ha : IsGlb s a) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  b âˆˆ LowerBounds (f '' s) :=
  @IsLub.mem_upper_bounds_of_tendsto (OrderDual Î±) (OrderDual Î³) _ _ _ _ _ _ _ _ _ _ hf.dual ha hb

theorem IsGlb.is_glb_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³} {s : Set Î±}
  {a : Î±} {b : Î³} (hf : MonotoneOn f s) : IsGlb s a â†’ s.nonempty â†’ tendsto f (ğ“[s] a) (ğ“ b) â†’ IsGlb (f '' s) b :=
  @IsLub.is_lub_of_tendsto (OrderDual Î±) (OrderDual Î³) _ _ _ _ _ _ f s a b hf.dual

theorem IsLub.mem_lower_bounds_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³}
  {s : Set Î±} {a : Î±} {b : Î³} (hf : AntitoneOn f s) (ha : IsLub s a) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  b âˆˆ LowerBounds (f '' s) :=
  @IsLub.mem_upper_bounds_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _ _ _ _ _ hf ha hb

theorem IsLub.is_glb_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] :
  âˆ€ {f : Î± â†’ Î³} {s : Set Î±} {a : Î±} {b : Î³},
    AntitoneOn f s â†’ IsLub s a â†’ s.nonempty â†’ tendsto f (ğ“[s] a) (ğ“ b) â†’ IsGlb (f '' s) b :=
  @IsLub.is_lub_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _

theorem IsGlb.mem_upper_bounds_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³}
  {s : Set Î±} {a : Î±} {b : Î³} (hf : AntitoneOn f s) (ha : IsGlb s a) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  b âˆˆ UpperBounds (f '' s) :=
  @IsGlb.mem_lower_bounds_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _ _ _ _ _ hf ha hb

theorem IsGlb.is_lub_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] :
  âˆ€ {f : Î± â†’ Î³} {s : Set Î±} {a : Î±} {b : Î³},
    AntitoneOn f s â†’ IsGlb s a â†’ s.nonempty â†’ tendsto f (ğ“[s] a) (ğ“ b) â†’ IsLub (f '' s) b :=
  @IsGlb.is_glb_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _

theorem IsLub.mem_of_is_closed {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) (sc : IsClosed s) : a âˆˆ s :=
  sc.closure_subset$ ha.mem_closure hs

alias IsLub.mem_of_is_closed â† IsClosed.is_lub_mem

theorem IsGlb.mem_of_is_closed {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) (sc : IsClosed s) : a âˆˆ s :=
  sc.closure_subset$ ha.mem_closure hs

alias IsGlb.mem_of_is_closed â† IsClosed.is_glb_mem

/-!
### Existence of sequences tending to Inf or Sup of a given set
-/


theorem IsLub.exists_seq_strict_mono_tendsto_of_not_mem {t : Set Î±} {x : Î±} [is_countably_generated (ğ“ x)]
  (htx : IsLub t x) (not_mem : x âˆ‰ t) (ht : t.nonempty) :
  âˆƒ u : â„• â†’ Î±, StrictMono u âˆ§ (âˆ€ n, u n < x) âˆ§ tendsto u at_top (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :=
  by 
    rcases ht with âŸ¨l, hlâŸ©
    have hl : l < x 
    exact (htx.1 hl).eq_or_lt.resolve_left fun h => (not_mem$ h â–¸ hl).elim 
    obtain âŸ¨s, hsâŸ© : âˆƒ s : â„• â†’ Set Î±, (ğ“ x).HasBasis (fun _x : â„• => True) s :=
      let âŸ¨s, hsâŸ© := (ğ“ x).exists_antitone_basis
      âŸ¨s, hs.to_has_basisâŸ©
    have  : âˆ€ n k, k < x â†’ âˆƒ y, Icc y x âŠ† s n âˆ§ k < y âˆ§ y < x âˆ§ y âˆˆ t
    Â·
      intro n k hk 
      obtain âŸ¨L, hL, hâŸ© : âˆƒ (L : Î±)(hL : L âˆˆ Ico k x), Ioc L x âŠ† s n :=
        exists_Ioc_subset_of_mem_nhds' (hs.mem_of_mem trivialâ‚“) hk 
      obtain âŸ¨y, hyâŸ© : âˆƒ y : Î±, L < y âˆ§ y < x âˆ§ y âˆˆ t
      Â·
        rcases htx.exists_between' not_mem hL.2 with âŸ¨y, yt, hyâŸ©
        refine' âŸ¨y, hy.1, hy.2, ytâŸ©
      exact âŸ¨y, fun z hz => h âŸ¨hy.1.trans_le hz.1, hz.2âŸ©, hL.1.trans_lt hy.1, hy.2âŸ©
    choose! f hf using this 
    let u : â„• â†’ Î± := fun n => Nat.recOn n (f 0 l) fun n h => f n.succ h 
    have I : âˆ€ n, u n < x
    Â·
      intro n 
      induction' n with n IH
      Â·
        exact (hf 0 l hl).2.2.1
      Â·
        exact (hf n.succ _ IH).2.2.1
    have S : StrictMono u := strict_mono_nat_of_lt_succ fun n => (hf n.succ _ (I n)).2.1
    refine' âŸ¨u, S, I, hs.tendsto_right_iff.2 fun n _ => _, fun n => _âŸ©
    Â·
      simp only [ge_iff_le, eventually_at_top]
      refine' âŸ¨n, fun p hp => _âŸ©
      have up : u p âˆˆ Icc (u n) x := âŸ¨S.monotone hp, (I p).leâŸ©
      have  : Icc (u n) x âŠ† s n
      Â·
        Â·
          cases n
          Â·
            exact (hf 0 l hl).1
          Â·
            exact (hf n.succ (u n) (I n)).1 
      exact this up
    Â·
      cases n
      Â·
        exact (hf 0 l hl).2.2.2
      Â·
        exact (hf n.succ _ (I n)).2.2.2

theorem IsLub.exists_seq_monotone_tendsto {t : Set Î±} {x : Î±} [is_countably_generated (ğ“ x)] (htx : IsLub t x)
  (ht : t.nonempty) : âˆƒ u : â„• â†’ Î±, Monotone u âˆ§ (âˆ€ n, u n â‰¤ x) âˆ§ tendsto u at_top (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :=
  by 
    byCases' h : x âˆˆ t
    Â·
      exact âŸ¨fun n => x, monotone_const, fun n => le_rfl, tendsto_const_nhds, fun n => hâŸ©
    Â·
      rcases htx.exists_seq_strict_mono_tendsto_of_not_mem h ht with âŸ¨u, huâŸ©
      exact âŸ¨u, hu.1.Monotone, fun n => (hu.2.1 n).le, hu.2.2âŸ©

theorem exists_seq_strict_mono_tendsto' {Î± : Type _} [LinearOrderâ‚“ Î±] [TopologicalSpace Î±] [DenselyOrdered Î±]
  [OrderTopology Î±] [first_countable_topology Î±] {x y : Î±} (hy : y < x) :
  âˆƒ u : â„• â†’ Î±, StrictMono u âˆ§ (âˆ€ n, u n < x) âˆ§ tendsto u at_top (ğ“ x) :=
  by 
    have hx : x âˆ‰ Iio x := fun h => (lt_irreflâ‚“ x h).elim 
    have ht : Set.Nonempty (Iio x) := âŸ¨y, hyâŸ©
    rcases is_lub_Iio.exists_seq_strict_mono_tendsto_of_not_mem hx ht with âŸ¨u, huâŸ©
    exact âŸ¨u, hu.1, hu.2.1, hu.2.2.1âŸ©

theorem exists_seq_strict_mono_tendsto [DenselyOrdered Î±] [NoBotOrder Î±] [first_countable_topology Î±] (x : Î±) :
  âˆƒ u : â„• â†’ Î±, StrictMono u âˆ§ (âˆ€ n, u n < x) âˆ§ tendsto u at_top (ğ“ x) :=
  by 
    obtain âŸ¨y, hyâŸ© : âˆƒ y, y < x := no_bot _ 
    exact exists_seq_strict_mono_tendsto' hy

theorem exists_seq_tendsto_Sup {Î± : Type _} [ConditionallyCompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  [first_countable_topology Î±] {S : Set Î±} (hS : S.nonempty) (hS' : BddAbove S) :
  âˆƒ u : â„• â†’ Î±, Monotone u âˆ§ tendsto u at_top (ğ“ (Sup S)) âˆ§ âˆ€ n, u n âˆˆ S :=
  by 
    rcases(is_lub_cSup hS hS').exists_seq_monotone_tendsto hS with âŸ¨u, huâŸ©
    exact âŸ¨u, hu.1, hu.2.2âŸ©

theorem IsGlb.exists_seq_strict_anti_tendsto_of_not_mem {t : Set Î±} {x : Î±} [is_countably_generated (ğ“ x)]
  (htx : IsGlb t x) (not_mem : x âˆ‰ t) (ht : t.nonempty) :
  âˆƒ u : â„• â†’ Î±, StrictAnti u âˆ§ (âˆ€ n, x < u n) âˆ§ tendsto u at_top (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :=
  @IsLub.exists_seq_strict_mono_tendsto_of_not_mem (OrderDual Î±) _ _ _ t x _ htx not_mem ht

theorem IsGlb.exists_seq_antitone_tendsto {t : Set Î±} {x : Î±} [is_countably_generated (ğ“ x)] (htx : IsGlb t x)
  (ht : t.nonempty) : âˆƒ u : â„• â†’ Î±, Antitone u âˆ§ (âˆ€ n, x â‰¤ u n) âˆ§ tendsto u at_top (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :=
  @IsLub.exists_seq_monotone_tendsto (OrderDual Î±) _ _ _ t x _ htx ht

theorem exists_seq_strict_anti_tendsto' [DenselyOrdered Î±] [first_countable_topology Î±] {x y : Î±} (hy : x < y) :
  âˆƒ u : â„• â†’ Î±, StrictAnti u âˆ§ (âˆ€ n, x < u n) âˆ§ tendsto u at_top (ğ“ x) :=
  @exists_seq_strict_mono_tendsto' (OrderDual Î±) _ _ _ _ _ x y hy

theorem exists_seq_strict_anti_tendsto [DenselyOrdered Î±] [NoTopOrder Î±] [first_countable_topology Î±] (x : Î±) :
  âˆƒ u : â„• â†’ Î±, StrictAnti u âˆ§ (âˆ€ n, x < u n) âˆ§ tendsto u at_top (ğ“ x) :=
  @exists_seq_strict_mono_tendsto (OrderDual Î±) _ _ _ _ _ _ x

theorem exists_seq_tendsto_Inf {Î± : Type _} [ConditionallyCompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  [first_countable_topology Î±] {S : Set Î±} (hS : S.nonempty) (hS' : BddBelow S) :
  âˆƒ u : â„• â†’ Î±, Antitone u âˆ§ tendsto u at_top (ğ“ (Inf S)) âˆ§ âˆ€ n, u n âˆˆ S :=
  @exists_seq_tendsto_Sup (OrderDual Î±) _ _ _ _ S hS hS'

/-- A compact set is bounded below -/
theorem IsCompact.bdd_below {Î± : Type u} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±] [Nonempty Î±]
  {s : Set Î±} (hs : IsCompact s) : BddBelow s :=
  by 
    byContra H 
    rcases hs.elim_finite_subcover_image (fun x _ : x âˆˆ s => @is_open_Ioi _ _ _ _ x) _ with âŸ¨t, st, ft, htâŸ©
    Â·
      refine' H (ft.bdd_below.imp$ fun C hC y hy => _)
      rcases mem_bUnion_iff.1 (ht hy) with âŸ¨x, hx, xyâŸ©
      exact le_transâ‚“ (hC hx) (le_of_ltâ‚“ xy)
    Â·
      refine' fun x hx => mem_bUnion_iff.2 (not_imp_comm.1 _ H)
      exact fun h => âŸ¨x, fun y hy => le_of_not_ltâ‚“ (h.imp$ fun ys => âŸ¨_, hy, ysâŸ©)âŸ©

/-- A compact set is bounded above -/
theorem IsCompact.bdd_above {Î± : Type u} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±] :
  âˆ€ [Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddAbove s :=
  @IsCompact.bdd_below (OrderDual Î±) _ _ _

end OrderTopology

section DenselyOrdered

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±] [DenselyOrdered Î±] {a b : Î±} {s : Set Î±}

/-- The closure of the interval `(a, +âˆ)` is the closed interval `[a, +âˆ)`, unless `a` is a top
element. -/
theorem closure_Ioi' {a : Î±} (h : (Ioi a).Nonempty) : Closure (Ioi a) = Ici a :=
  by 
    apply subset.antisymm
    Â·
      exact closure_minimal Ioi_subset_Ici_self is_closed_Ici
    Â·
      rw [â†diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff]
      exact is_glb_Ioi.mem_closure h

/-- The closure of the interval `(a, +âˆ)` is the closed interval `[a, +âˆ)`. -/
@[simp]
theorem closure_Ioi (a : Î±) [NoTopOrder Î±] : Closure (Ioi a) = Ici a :=
  closure_Ioi' nonempty_Ioi

/-- The closure of the interval `(-âˆ, a)` is the closed interval `(-âˆ, a]`, unless `a` is a bottom
element. -/
theorem closure_Iio' {a : Î±} (h : (Iio a).Nonempty) : Closure (Iio a) = Iic a :=
  @closure_Ioi' (OrderDual Î±) _ _ _ _ _ h

/-- The closure of the interval `(-âˆ, a)` is the interval `(-âˆ, a]`. -/
@[simp]
theorem closure_Iio (a : Î±) [NoBotOrder Î±] : Closure (Iio a) = Iic a :=
  closure_Iio' nonempty_Iio

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioo {a b : Î±} (hab : a < b) : Closure (Ioo a b) = Icc a b :=
  by 
    apply subset.antisymm
    Â·
      exact closure_minimal Ioo_subset_Icc_self is_closed_Icc
    Â·
      rw [â†diff_subset_closure_iff, Icc_diff_Ioo_same hab.le]
      have hab' : (Ioo a b).Nonempty 
      exact nonempty_Ioo.2 hab 
      simp only [insert_subset, singleton_subset_iff]
      exact âŸ¨(is_glb_Ioo hab).mem_closure hab', (is_lub_Ioo hab).mem_closure hab'âŸ©

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioc {a b : Î±} (hab : a < b) : Closure (Ioc a b) = Icc a b :=
  by 
    apply subset.antisymm
    Â·
      exact closure_minimal Ioc_subset_Icc_self is_closed_Icc
    Â·
      apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)
      rw [closure_Ioo hab]

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ico {a b : Î±} (hab : a < b) : Closure (Ico a b) = Icc a b :=
  by 
    apply subset.antisymm
    Â·
      exact closure_minimal Ico_subset_Icc_self is_closed_Icc
    Â·
      apply subset.trans _ (closure_mono Ioo_subset_Ico_self)
      rw [closure_Ioo hab]

@[simp]
theorem interior_Ici' {a : Î±} (ha : (Iio a).Nonempty) : Interior (Ici a) = Ioi a :=
  by 
    rw [â†compl_Iio, interior_compl, closure_Iio' ha, compl_Iic]

theorem interior_Ici [NoBotOrder Î±] {a : Î±} : Interior (Ici a) = Ioi a :=
  interior_Ici' nonempty_Iio

@[simp]
theorem interior_Iic' {a : Î±} (ha : (Ioi a).Nonempty) : Interior (Iic a) = Iio a :=
  @interior_Ici' (OrderDual Î±) _ _ _ _ _ ha

theorem interior_Iic [NoTopOrder Î±] {a : Î±} : Interior (Iic a) = Iio a :=
  interior_Iic' nonempty_Ioi

@[simp]
theorem interior_Icc [NoBotOrder Î±] [NoTopOrder Î±] {a b : Î±} : Interior (Icc a b) = Ioo a b :=
  by 
    rw [â†Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]

@[simp]
theorem interior_Ico [NoBotOrder Î±] {a b : Î±} : Interior (Ico a b) = Ioo a b :=
  by 
    rw [â†Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]

@[simp]
theorem interior_Ioc [NoTopOrder Î±] {a b : Î±} : Interior (Ioc a b) = Ioo a b :=
  by 
    rw [â†Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]

@[simp]
theorem frontier_Ici' {a : Î±} (ha : (Iio a).Nonempty) : Frontier (Ici a) = {a} :=
  by 
    simp [Frontier, ha]

theorem frontier_Ici [NoBotOrder Î±] {a : Î±} : Frontier (Ici a) = {a} :=
  frontier_Ici' nonempty_Iio

@[simp]
theorem frontier_Iic' {a : Î±} (ha : (Ioi a).Nonempty) : Frontier (Iic a) = {a} :=
  by 
    simp [Frontier, ha]

theorem frontier_Iic [NoTopOrder Î±] {a : Î±} : Frontier (Iic a) = {a} :=
  frontier_Iic' nonempty_Ioi

@[simp]
theorem frontier_Ioi' {a : Î±} (ha : (Ioi a).Nonempty) : Frontier (Ioi a) = {a} :=
  by 
    simp [Frontier, closure_Ioi' ha, Iic_diff_Iio, Icc_self]

theorem frontier_Ioi [NoTopOrder Î±] {a : Î±} : Frontier (Ioi a) = {a} :=
  frontier_Ioi' nonempty_Ioi

@[simp]
theorem frontier_Iio' {a : Î±} (ha : (Iio a).Nonempty) : Frontier (Iio a) = {a} :=
  by 
    simp [Frontier, closure_Iio' ha, Iic_diff_Iio, Icc_self]

theorem frontier_Iio [NoBotOrder Î±] {a : Î±} : Frontier (Iio a) = {a} :=
  frontier_Iio' nonempty_Iio

@[simp]
theorem frontier_Icc [NoBotOrder Î±] [NoTopOrder Î±] {a b : Î±} (h : a < b) : Frontier (Icc a b) = {a, b} :=
  by 
    simp [Frontier, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ioo {a b : Î±} (h : a < b) : Frontier (Ioo a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ico [NoBotOrder Î±] {a b : Î±} (h : a < b) : Frontier (Ico a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ioc [NoTopOrder Î±] {a b : Î±} (h : a < b) : Frontier (Ioc a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

theorem nhds_within_Ioi_ne_bot' {a b : Î±} (Hâ‚ : (Ioi a).Nonempty) (Hâ‚‚ : a â‰¤ b) : ne_bot (ğ“[Ioi a] b) :=
  mem_closure_iff_nhds_within_ne_bot.1$
    by 
      rwa [closure_Ioi' Hâ‚]

theorem nhds_within_Ioi_ne_bot [NoTopOrder Î±] {a b : Î±} (H : a â‰¤ b) : ne_bot (ğ“[Ioi a] b) :=
  nhds_within_Ioi_ne_bot' nonempty_Ioi H

theorem nhds_within_Ioi_self_ne_bot' {a : Î±} (H : (Ioi a).Nonempty) : ne_bot (ğ“[Ioi a] a) :=
  nhds_within_Ioi_ne_bot' H (le_reflâ‚“ a)

@[instance]
theorem nhds_within_Ioi_self_ne_bot [NoTopOrder Î±] (a : Î±) : ne_bot (ğ“[Ioi a] a) :=
  nhds_within_Ioi_ne_bot (le_reflâ‚“ a)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr > Â» a)
theorem Filter.Eventually.exists_gt [NoTopOrder Î±] {a : Î±} {p : Î± â†’ Prop} (h : âˆ€á¶  x in ğ“ a, p x) :
  âˆƒ (b : _)(_ : b > a), p b :=
  by 
    simpa only [exists_prop, gt_iff_lt, and_comm] using
      ((h.filter_mono (@nhds_within_le_nhds _ _ a (Ioi a))).And self_mem_nhds_within).exists

theorem nhds_within_Iio_ne_bot' {b c : Î±} (Hâ‚ : (Iio c).Nonempty) (Hâ‚‚ : b â‰¤ c) : ne_bot (ğ“[Iio c] b) :=
  mem_closure_iff_nhds_within_ne_bot.1$
    by 
      rwa [closure_Iio' Hâ‚]

theorem nhds_within_Iio_ne_bot [NoBotOrder Î±] {a b : Î±} (H : a â‰¤ b) : ne_bot (ğ“[Iio b] a) :=
  nhds_within_Iio_ne_bot' nonempty_Iio H

theorem nhds_within_Iio_self_ne_bot' {b : Î±} (H : (Iio b).Nonempty) : ne_bot (ğ“[Iio b] b) :=
  nhds_within_Iio_ne_bot' H (le_reflâ‚“ b)

@[instance]
theorem nhds_within_Iio_self_ne_bot [NoBotOrder Î±] (a : Î±) : ne_bot (ğ“[Iio a] a) :=
  nhds_within_Iio_ne_bot (le_reflâ‚“ a)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr < Â» a)
theorem Filter.Eventually.exists_lt [NoBotOrder Î±] {a : Î±} {p : Î± â†’ Prop} (h : âˆ€á¶  x in ğ“ a, p x) :
  âˆƒ (b : _)(_ : b < a), p b :=
  @Filter.Eventually.exists_gt (OrderDual Î±) _ _ _ _ _ _ _ h

theorem right_nhds_within_Ico_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ico a b] b) :=
  (is_lub_Ico H).nhds_within_ne_bot (nonempty_Ico.2 H)

theorem left_nhds_within_Ioc_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioc a b] a) :=
  (is_glb_Ioc H).nhds_within_ne_bot (nonempty_Ioc.2 H)

theorem left_nhds_within_Ioo_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioo a b] a) :=
  (is_glb_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

theorem right_nhds_within_Ioo_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioo a b] b) :=
  (is_lub_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (a Â«expr < Â» b)
theorem comap_coe_nhds_within_Iio_of_Ioo_subset (hb : s âŠ† Iio b) (hs : s.nonempty â†’ âˆƒ (a : _)(_ : a < b), Ioo a b âŠ† s) :
  comap (coeâ‚“ : s â†’ Î±) (ğ“[Iio b] b) = at_top :=
  by 
    nontriviality 
    have  : Nonempty s := nontrivial_iff_nonempty.1 â€¹_â€º
    rcases hs (nonempty_subtype.1 â€¹_â€º) with âŸ¨a, h, hsâŸ©
    ext u 
    constructor
    Â·
      rintro âŸ¨t, ht, htsâŸ©
      obtain âŸ¨x, âŸ¨hxa : a â‰¤ x, hxb : x < bâŸ©, hxt : Ioo x b âŠ† tâŸ© :=
        (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht 
      obtain âŸ¨y, hxy, hybâŸ© := exists_between hxb 
      refine' mem_of_superset (mem_at_top âŸ¨y, hs âŸ¨hxa.trans_lt hxy, hybâŸ©âŸ©) _ 
      rintro âŸ¨z, hzsâŸ© (hyz : y â‰¤ z)
      refine' hts (hxt âŸ¨hxy.trans_le _, hb _âŸ©) <;> assumption
    Â·
      intro hu 
      obtain âŸ¨x : s, hx : âˆ€ z, x â‰¤ z â†’ z âˆˆ uâŸ© := mem_at_top_sets.1 hu 
      exact âŸ¨Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2$ hb x.2), fun z hz => hx _ hz.1.leâŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr > Â» a)
theorem comap_coe_nhds_within_Ioi_of_Ioo_subset (ha : s âŠ† Ioi a) (hs : s.nonempty â†’ âˆƒ (b : _)(_ : b > a), Ioo a b âŠ† s) :
  comap (coeâ‚“ : s â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Iio_of_Ioo_subset (show of_dual â»Â¹' s âŠ† Iio (to_dual a) from ha)
    fun h =>
      by 
        simpa only [OrderDual.exists, dual_Ioo] using hs h

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (a' Â«expr < Â» b)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (a Â«expr < Â» b)
theorem map_coe_at_top_of_Ioo_subset (hb : s âŠ† Iio b) (hs : âˆ€ a' _ : a' < b, âˆƒ (a : _)(_ : a < b), Ioo a b âŠ† s) :
  map (coeâ‚“ : s â†’ Î±) at_top = ğ“[Iio b] b :=
  by 
    rcases eq_empty_or_nonempty (Iio b) with (hb' | âŸ¨a, haâŸ©)
    Â·
      rw [filter_eq_bot_of_is_empty at_top, map_bot, hb', nhds_within_empty]
      exact âŸ¨fun x => hb'.subset (hb x.2)âŸ©
    Â·
      rw [â†comap_coe_nhds_within_Iio_of_Ioo_subset hb fun _ => hs a ha, map_comap_of_mem]
      rw [Subtype.range_coe]
      exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b' Â«expr > Â» a)
-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (b Â«expr > Â» a)
theorem map_coe_at_bot_of_Ioo_subset (ha : s âŠ† Ioi a) (hs : âˆ€ b' _ : b' > a, âˆƒ (b : _)(_ : b > a), Ioo a b âŠ† s) :
  map (coeâ‚“ : s â†’ Î±) at_bot = ğ“[Ioi a] a :=
  by 
    refine' (map_coe_at_top_of_Ioo_subset (show of_dual â»Â¹' s âŠ† Iio (to_dual a) from ha) fun b' hb' => _ : _)
    simpa only [OrderDual.exists, dual_Ioo] using hs b' hb'

/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Iio (a b : Î±) : comap (coeâ‚“ : Ioo a b â†’ Î±) (ğ“[Iio b] b) = at_top :=
  comap_coe_nhds_within_Iio_of_Ioo_subset Ioo_subset_Iio_self$ fun h => âŸ¨a, nonempty_Ioo.1 h, subset.refl _âŸ©

/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Ioi (a b : Î±) : comap (coeâ‚“ : Ioo a b â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Ioi_of_Ioo_subset Ioo_subset_Ioi_self$ fun h => âŸ¨b, nonempty_Ioo.1 h, subset.refl _âŸ©

theorem comap_coe_Ioi_nhds_within_Ioi (a : Î±) : comap (coeâ‚“ : Ioi a â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Ioi_of_Ioo_subset (subset.refl _)$ fun âŸ¨x, hxâŸ© => âŸ¨x, hx, Ioo_subset_Ioi_selfâŸ©

theorem comap_coe_Iio_nhds_within_Iio (a : Î±) : comap (coeâ‚“ : Iio a â†’ Î±) (ğ“[Iio a] a) = at_top :=
  @comap_coe_Ioi_nhds_within_Ioi (OrderDual Î±) _ _ _ _ a

@[simp]
theorem map_coe_Ioo_at_top {a b : Î±} (h : a < b) : map (coeâ‚“ : Ioo a b â†’ Î±) at_top = ğ“[Iio b] b :=
  map_coe_at_top_of_Ioo_subset Ioo_subset_Iio_self$ fun _ _ => âŸ¨_, h, subset.refl _âŸ©

@[simp]
theorem map_coe_Ioo_at_bot {a b : Î±} (h : a < b) : map (coeâ‚“ : Ioo a b â†’ Î±) at_bot = ğ“[Ioi a] a :=
  map_coe_at_bot_of_Ioo_subset Ioo_subset_Ioi_self$ fun _ _ => âŸ¨_, h, subset.refl _âŸ©

@[simp]
theorem map_coe_Ioi_at_bot (a : Î±) : map (coeâ‚“ : Ioi a â†’ Î±) at_bot = ğ“[Ioi a] a :=
  map_coe_at_bot_of_Ioo_subset (subset.refl _)$ fun b hb => âŸ¨b, hb, Ioo_subset_Ioi_selfâŸ©

@[simp]
theorem map_coe_Iio_at_top (a : Î±) : map (coeâ‚“ : Iio a â†’ Î±) at_top = ğ“[Iio a] a :=
  @map_coe_Ioi_at_bot (OrderDual Î±) _ _ _ _ _

variable {l : Filter Î²} {f : Î± â†’ Î²}

@[simp]
theorem tendsto_comp_coe_Ioo_at_top (h : a < b) :
  tendsto (fun x : Ioo a b => f x) at_top l â†” tendsto f (ğ“[Iio b] b) l :=
  by 
    rw [â†map_coe_Ioo_at_top h, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Ioo_at_bot (h : a < b) :
  tendsto (fun x : Ioo a b => f x) at_bot l â†” tendsto f (ğ“[Ioi a] a) l :=
  by 
    rw [â†map_coe_Ioo_at_bot h, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Ioi_at_bot : tendsto (fun x : Ioi a => f x) at_bot l â†” tendsto f (ğ“[Ioi a] a) l :=
  by 
    rw [â†map_coe_Ioi_at_bot, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Iio_at_top : tendsto (fun x : Iio a => f x) at_top l â†” tendsto f (ğ“[Iio a] a) l :=
  by 
    rw [â†map_coe_Iio_at_top, tendsto_map'_iff]

@[simp]
theorem tendsto_Ioo_at_top {f : Î² â†’ Ioo a b} : tendsto f l at_top â†” tendsto (fun x => (f x : Î±)) l (ğ“[Iio b] b) :=
  by 
    rw [â†comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]

@[simp]
theorem tendsto_Ioo_at_bot {f : Î² â†’ Ioo a b} : tendsto f l at_bot â†” tendsto (fun x => (f x : Î±)) l (ğ“[Ioi a] a) :=
  by 
    rw [â†comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]

@[simp]
theorem tendsto_Ioi_at_bot {f : Î² â†’ Ioi a} : tendsto f l at_bot â†” tendsto (fun x => (f x : Î±)) l (ğ“[Ioi a] a) :=
  by 
    rw [â†comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]

@[simp]
theorem tendsto_Iio_at_top {f : Î² â†’ Iio a} : tendsto f l at_top â†” tendsto (fun x => (f x : Î±)) l (ğ“[Iio a] a) :=
  by 
    rw [â†comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (c Â«expr âˆˆ Â» s)
theorem dense_iff_forall_lt_exists_mem [Nontrivial Î±] {s : Set Î±} :
  Dense s â†” âˆ€ a b, a < b â†’ âˆƒ (c : _)(_ : c âˆˆ s), a < c âˆ§ c < b :=
  by 
    constructor
    Â·
      intro h a b hab 
      obtain âŸ¨c, âŸ¨hc, csâŸ©âŸ© : (Ioo a b âˆ© s).Nonempty :=
        dense_iff_inter_open.1 h (Ioo a b) is_open_Ioo (nonempty_Ioo.2 hab)
      exact âŸ¨c, cs, hcâŸ©
    Â·
      intro h 
      apply dense_iff_inter_open.2 fun U U_open U_nonempty => _ 
      obtain âŸ¨a, b, hab, HâŸ© : âˆƒ a b : Î±, a < b âˆ§ Ioo a b âŠ† U := U_open.exists_Ioo_subset U_nonempty 
      obtain âŸ¨x, xs, hxâŸ© : âˆƒ (x : Î±)(H : x âˆˆ s), a < x âˆ§ x < b := h a b hab 
      exact âŸ¨x, âŸ¨H hx, xsâŸ©âŸ©

instance (x : Î±) [Nontrivial Î±] : ne_bot (ğ“[{x}á¶œ] x) :=
  by 
    apply forall_mem_nonempty_iff_ne_bot.1 fun s hs => _ 
    obtain âŸ¨u, u_open, xu, usâŸ© : âˆƒ u : Set Î±, IsOpen u âˆ§ x âˆˆ u âˆ§ u âˆ© {x}á¶œ âŠ† s := mem_nhds_within.1 hs 
    obtain âŸ¨a, b, a_lt_b, habâŸ© : âˆƒ a b : Î±, a < b âˆ§ Ioo a b âŠ† u := u_open.exists_Ioo_subset âŸ¨x, xuâŸ©
    obtain âŸ¨y, hyâŸ© : âˆƒ y, a < y âˆ§ y < b := exists_between a_lt_b 
    rcases ne_or_eq x y with (xy | rfl)
    Â·
      exact âŸ¨y, us âŸ¨hab hy, xy.symmâŸ©âŸ©
    obtain âŸ¨z, hzâŸ© : âˆƒ z, a < z âˆ§ z < x := exists_between hy.1 
    exact âŸ¨z, us âŸ¨hab âŸ¨hz.1, hz.2.trans hy.2âŸ©, hz.2.NeâŸ©âŸ©

-- ././Mathport/Syntax/Translate/Basic.lean:452:2: warning: expanding binder collection (t Â«expr âŠ† Â» s)
-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
/--
    Let `s` be a dense set in a nontrivial dense linear order `Î±`. If `s` is a
    separable space (e.g., if `Î±` has a second countable topology), then there exists a countable
    dense subset `t âŠ† s` such that `t` does not contain bottom/top elements of `Î±`. -/
  theorem
    Dense.exists_countable_dense_subset_no_bot_top
    [ Nontrivial Î± ] { s : Set Î± } [ separable_space s ] ( hs : Dense s )
      : âˆƒ ( t : _ ) ( _ : t âŠ† s ) , countable t âˆ§ Dense t âˆ§ âˆ€ x , IsBot x â†’ x âˆ‰ t âˆ§ âˆ€ x , IsTop x â†’ x âˆ‰ t
    :=
      by
        rcases hs.exists_countable_dense_subset with âŸ¨ t , hts , htc , htd âŸ©
          refine' âŸ¨ t \ { x | IsBot x } âˆª { x | IsTop x } , _ , _ , _ , _ , _ âŸ©
          Â· exact diff_subset _ _ . trans hts
          Â· exact htc.mono diff_subset _ _
          Â· exact htd.diff_finite subsingleton_is_bot Î± . Finite . union subsingleton_is_top Î± . Finite
          Â· intro x hx simp [ hx ]
          Â· intro x hx simp [ hx ]

variable (Î±)

/-- If `Î±` is a nontrivial separable dense linear order, then there exists a
countable dense set `s : set Î±` that contains neither top nor bottom elements of `Î±`.
For a dense set containing both bot and top elements, see
`exists_countable_dense_bot_top`. -/
theorem exists_countable_dense_no_bot_top [separable_space Î±] [Nontrivial Î±] :
  âˆƒ s : Set Î±, countable s âˆ§ Dense s âˆ§ (âˆ€ x, IsBot x â†’ x âˆ‰ s) âˆ§ âˆ€ x, IsTop x â†’ x âˆ‰ s :=
  by 
    simpa using dense_univ.exists_countable_dense_subset_no_bot_top

end DenselyOrdered

section CompleteLinearOrder

variable [CompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [CompleteLinearOrder Î²] [TopologicalSpace Î²]
  [OrderTopology Î²] [Nonempty Î³]

theorem Sup_mem_closure {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) : Sup s âˆˆ Closure s :=
  (is_lub_Sup s).mem_closure hs

theorem Inf_mem_closure {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) : Inf s âˆˆ Closure s :=
  (is_glb_Inf s).mem_closure hs

theorem IsClosed.Sup_mem {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) (hc : IsClosed s) : Sup s âˆˆ s :=
  (is_lub_Sup s).mem_of_is_closed hs hc

theorem IsClosed.Inf_mem {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) (hc : IsClosed s) : Inf s âˆˆ s :=
  (is_glb_Inf s).mem_of_is_closed hs hc

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone' {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (hs : s.nonempty) : f (Sup s) = Sup (f '' s) :=
  ((is_lub_Sup _).is_lub_of_tendsto (fun x hx y hy xy => Mf xy) hs$ Cf.mono_left inf_le_left).Sup_eq.symm

/-- A monotone function `s` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (fbot : f âŠ¥ = âŠ¥) : f (Sup s) = Sup (f '' s) :=
  by 
    cases' s.eq_empty_or_nonempty with h h
    Â·
      simp [h, fbot]
    Â·
      exact map_Sup_of_continuous_at_of_monotone' Cf Mf h

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone' {Î¹ : Sort _} [Nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : ContinuousAt f (supr g)) (Mf : Monotone f) : f (â¨† i, g i) = â¨† i, f (g i) :=
  by 
    rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), â†range_comp, supr]

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone {Î¹ : Sort _} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (supr g))
  (Mf : Monotone f) (fbot : f âŠ¥ = âŠ¥) : f (â¨† i, g i) = â¨† i, f (g i) :=
  by 
    rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, â†range_comp, supr]

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone' {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (hs : s.nonempty) : f (Inf s) = Inf (f '' s) :=
  @map_Sup_of_continuous_at_of_monotone' (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ f s Cf Mf.dual hs

/-- A monotone function `s` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (ftop : f âŠ¤ = âŠ¤) : f (Inf s) = Inf (f '' s) :=
  @map_Sup_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ f s Cf Mf.dual ftop

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone' {Î¹ : Sort _} [Nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : ContinuousAt f (infi g)) (Mf : Monotone f) : f (â¨… i, g i) = â¨… i, f (g i) :=
  @map_supr_of_continuous_at_of_monotone' (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ Î¹ _ f g Cf Mf.dual

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone {Î¹ : Sort _} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (infi g))
  (Mf : Monotone f) (ftop : f âŠ¤ = âŠ¤) : f (infi g) = infi (f âˆ˜ g) :=
  @map_supr_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ Î¹ f g Cf Mf.dual ftop

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  [ConditionallyCompleteLinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] [Nonempty Î³]

theorem cSup_mem_closure {s : Set Î±} (hs : s.nonempty) (B : BddAbove s) : Sup s âˆˆ Closure s :=
  (is_lub_cSup hs B).mem_closure hs

theorem cInf_mem_closure {s : Set Î±} (hs : s.nonempty) (B : BddBelow s) : Inf s âˆˆ Closure s :=
  (is_glb_cInf hs B).mem_closure hs

theorem IsClosed.cSup_mem {s : Set Î±} (hc : IsClosed s) (hs : s.nonempty) (B : BddAbove s) : Sup s âˆˆ s :=
  (is_lub_cSup hs B).mem_of_is_closed hs hc

theorem IsClosed.cInf_mem {s : Set Î±} (hc : IsClosed s) (hs : s.nonempty) (B : BddBelow s) : Inf s âˆˆ s :=
  (is_glb_cInf hs B).mem_of_is_closed hs hc

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
theorem map_cSup_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (ne : s.nonempty) (H : BddAbove s) : f (Sup s) = Sup (f '' s) :=
  by 
    refine' ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm 
    refine' (is_lub_cSup Ne H).is_lub_of_tendsto (fun x hx y hy xy => Mf xy) Ne _ 
    exact Cf.mono_left inf_le_left

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
theorem map_csupr_of_continuous_at_of_monotone {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : ContinuousAt f (â¨† i, g i))
  (Mf : Monotone f) (H : BddAbove (range g)) : f (â¨† i, g i) = â¨† i, f (g i) :=
  by 
    rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, â†range_comp, supr]

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
theorem map_cInf_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (ne : s.nonempty) (H : BddBelow s) : f (Inf s) = Inf (f '' s) :=
  @map_cSup_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ f s Cf Mf.dual Ne H

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
theorem map_cinfi_of_continuous_at_of_monotone {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : ContinuousAt f (â¨… i, g i))
  (Mf : Monotone f) (H : BddBelow (range g)) : f (â¨… i, g i) = â¨… i, f (g i) :=
  @map_csupr_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ _ _ _ _ Cf Mf.dual H

/-- A monotone map has a limit to the left of any point `x`, equal to `Sup (f '' (Iio x))`. -/
theorem Monotone.tendsto_nhds_within_Iio {Î± : Type _} [LinearOrderâ‚“ Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  {f : Î± â†’ Î²} (Mf : Monotone f) (x : Î±) : tendsto f (ğ“[Iio x] x) (ğ“ (Sup (f '' Iio x))) :=
  by 
    rcases eq_empty_or_nonempty (Iio x) with (h | h)
    Â·
      simp [h]
    refine' tendsto_order.2 âŸ¨fun l hl => _, fun m hm => _âŸ©
    Â·
      obtain âŸ¨z, zx, lzâŸ© : âˆƒ a : Î±, a < x âˆ§ l < f a
      Â·
        simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using
          exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl 
      exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 âŸ¨z, zx, fun y hy => lz.trans_le (Mf hy.1.le)âŸ©
    Â·
      filterUpwards [self_mem_nhds_within]
      intro y hy 
      apply lt_of_le_of_ltâ‚“ _ hm 
      exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy)

/-- A monotone map has a limit to the right of any point `x`, equal to `Inf (f '' (Ioi x))`. -/
theorem Monotone.tendsto_nhds_within_Ioi {Î± : Type _} [LinearOrderâ‚“ Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  {f : Î± â†’ Î²} (Mf : Monotone f) (x : Î±) : tendsto f (ğ“[Ioi x] x) (ğ“ (Inf (f '' Ioi x))) :=
  @Monotone.tendsto_nhds_within_Iio (OrderDual Î²) _ _ _ (OrderDual Î±) _ _ _ f Mf.dual x

end ConditionallyCompleteLinearOrder

end OrderTopology

