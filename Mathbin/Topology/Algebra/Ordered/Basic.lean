import Mathbin.Algebra.GroupWithZero.Power 
import Mathbin.Data.Set.Intervals.Pi 
import Mathbin.Order.Filter.Interval 
import Mathbin.Topology.Algebra.Group 
import Mathbin.Tactic.Linarith.Default 
import Mathbin.Tactic.Tfae

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-âˆ, a)` and `(b, +âˆ)`). We define it as `preorder.topology Î±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Î±`). Instead,
we introduce a class `order_topology Î±` (which is a `Prop`, also known as a mixin) saying that on
the type `Î±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Î±` saying that the set of points
`(x, y)` with `x â‰¤ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x â‰¤ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x â‰¤ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z âˆˆ (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z âˆˆ [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x â‰¤ g x`, then `a â‰¤ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x â‰¤ b`
  (resp., `b â‰¤ f x`), then `a â‰¤ b` (resp., `b â‰¤ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x â‰¤ f x â‰¤ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `â„•` or `â„¤`, or `â„` that could inherit a topology as the completion of `â„š`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Î±` though, that can be registered as an instance when necessary, or
for specific types.
-/


open Classical Set Filter TopologicalSpace

open Function

open order_dual(toDual ofDual)

open_locale TopologicalSpace Classical Filter

universe u v w

variable {Î± : Type u} {Î² : Type v} {Î³ : Type w}

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x â‰¤ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class OrderClosedTopology (Î± : Type _) [TopologicalSpace Î±] [Preorderâ‚“ Î±] : Prop where 
  is_closed_le' : IsClosed { p:Î± Ã— Î± | p.1 â‰¤ p.2 }

instance : âˆ€ [TopologicalSpace Î±], TopologicalSpace (OrderDual Î±) :=
  id

instance [TopologicalSpace Î±] [h : first_countable_topology Î±] : first_countable_topology (OrderDual Î±) :=
  h

instance [TopologicalSpace Î±] [h : second_countable_topology Î±] : second_countable_topology (OrderDual Î±) :=
  h

@[toAdditive]
instance [TopologicalSpace Î±] [Mul Î±] [h : HasContinuousMul Î±] : HasContinuousMul (OrderDual Î±) :=
  h

theorem Dense.order_dual [TopologicalSpace Î±] {s : Set Î±} (hs : Dense s) : Dense (OrderDual.ofDual â»Â¹' s) :=
  hs

section OrderClosedTopology

section Preorderâ‚“

variable [TopologicalSpace Î±] [Preorderâ‚“ Î±] [t : OrderClosedTopology Î±]

include t

namespace Subtype

instance {p : Î± â†’ Prop} : OrderClosedTopology (Subtype p) :=
  have this : Continuous fun p : Subtype p Ã— Subtype p => ((p.fst : Î±), (p.snd : Î±)) :=
    (continuous_subtype_coe.comp continuous_fst).prod_mk (continuous_subtype_coe.comp continuous_snd)
  OrderClosedTopology.mk (t.is_closed_le'.preimage this)

end Subtype

theorem is_closed_le_prod : IsClosed { p:Î± Ã— Î± | p.1 â‰¤ p.2 } :=
  t.is_closed_le'

theorem is_closed_le [TopologicalSpace Î²] {f g : Î² â†’ Î±} (hf : Continuous f) (hg : Continuous g) :
  IsClosed { b | f b â‰¤ g b } :=
  continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_le_prod

theorem is_closed_le' (a : Î±) : IsClosed { b | b â‰¤ a } :=
  is_closed_le continuous_id continuous_const

theorem is_closed_Iic {a : Î±} : IsClosed (Iic a) :=
  is_closed_le' a

theorem is_closed_ge' (a : Î±) : IsClosed { b | a â‰¤ b } :=
  is_closed_le continuous_const continuous_id

theorem is_closed_Ici {a : Î±} : IsClosed (Ici a) :=
  is_closed_ge' a

instance : OrderClosedTopology (OrderDual Î±) :=
  âŸ¨(@OrderClosedTopology.is_closed_le' Î± _ _ _).Preimage continuous_swapâŸ©

theorem is_closed_Icc {a b : Î±} : IsClosed (Icc a b) :=
  IsClosed.inter is_closed_Ici is_closed_Iic

@[simp]
theorem closure_Icc (a b : Î±) : Closure (Icc a b) = Icc a b :=
  is_closed_Icc.closure_eq

@[simp]
theorem closure_Iic (a : Î±) : Closure (Iic a) = Iic a :=
  is_closed_Iic.closure_eq

@[simp]
theorem closure_Ici (a : Î±) : Closure (Ici a) = Ici a :=
  is_closed_Ici.closure_eq

theorem le_of_tendsto_of_tendsto {f g : Î² â†’ Î±} {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} [ne_bot b] (hf : tendsto f b (ğ“ aâ‚))
  (hg : tendsto g b (ğ“ aâ‚‚)) (h : f â‰¤á¶ [b] g) : aâ‚ â‰¤ aâ‚‚ :=
  have  : tendsto (fun b => (f b, g b)) b (ğ“ (aâ‚, aâ‚‚)) :=
    by 
      rw [nhds_prod_eq] <;> exact hf.prod_mk hg 
  show (aâ‚, aâ‚‚) âˆˆ { p:Î± Ã— Î± | p.1 â‰¤ p.2 } from t.is_closed_le'.mem_of_tendsto this h

theorem le_of_tendsto_of_tendsto' {f g : Î² â†’ Î±} {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} [ne_bot b] (hf : tendsto f b (ğ“ aâ‚))
  (hg : tendsto g b (ğ“ aâ‚‚)) (h : âˆ€ x, f x â‰¤ g x) : aâ‚ â‰¤ aâ‚‚ :=
  le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)

theorem le_of_tendsto {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a))
  (h : âˆ€á¶ c in x, f c â‰¤ b) : a â‰¤ b :=
  le_of_tendsto_of_tendsto limâ‚“ tendsto_const_nhds h

theorem le_of_tendsto' {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a)) (h : âˆ€ c, f c â‰¤ b) :
  a â‰¤ b :=
  le_of_tendsto limâ‚“ (eventually_of_forall h)

theorem ge_of_tendsto {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a))
  (h : âˆ€á¶ c in x, b â‰¤ f c) : b â‰¤ a :=
  le_of_tendsto_of_tendsto tendsto_const_nhds limâ‚“ h

theorem ge_of_tendsto' {f : Î² â†’ Î±} {a b : Î±} {x : Filter Î²} [ne_bot x] (lim : tendsto f x (ğ“ a)) (h : âˆ€ c, b â‰¤ f c) :
  b â‰¤ a :=
  ge_of_tendsto limâ‚“ (eventually_of_forall h)

@[simp]
theorem closure_le_eq [TopologicalSpace Î²] {f g : Î² â†’ Î±} (hf : Continuous f) (hg : Continuous g) :
  Closure { b | f b â‰¤ g b } = { b | f b â‰¤ g b } :=
  (is_closed_le hf hg).closure_eq

theorem closure_lt_subset_le [TopologicalSpace Î²] {f g : Î² â†’ Î±} (hf : Continuous f) (hg : Continuous g) :
  Closure { b | f b < g b } âŠ† { b | f b â‰¤ g b } :=
  by 
    rw [â†closure_le_eq hf hg]
    exact closure_mono fun b => le_of_ltâ‚“

theorem ContinuousWithinAt.closure_le [TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²} {x : Î²} (hx : x âˆˆ Closure s)
  (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) (h : âˆ€ y _ : y âˆˆ s, f y â‰¤ g y) : f x â‰¤ g x :=
  show (f x, g x) âˆˆ { p:Î± Ã— Î± | p.1 â‰¤ p.2 } from
    OrderClosedTopology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)

/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/
theorem IsClosed.is_closed_le [TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²} (hs : IsClosed s) (hf : ContinuousOn f s)
  (hg : ContinuousOn g s) : IsClosed { xâˆˆs | f x â‰¤ g x } :=
  (hf.prod hg).preimage_closed_of_closed hs OrderClosedTopology.is_closed_le'

omit t

theorem nhds_within_Ici_ne_bot {a b : Î±} (Hâ‚‚ : a â‰¤ b) : ne_bot (ğ“[Ici a] b) :=
  nhds_within_ne_bot_of_mem Hâ‚‚

@[instance]
theorem nhds_within_Ici_self_ne_bot (a : Î±) : ne_bot (ğ“[Ici a] a) :=
  nhds_within_Ici_ne_bot (le_reflâ‚“ a)

theorem nhds_within_Iic_ne_bot {a b : Î±} (H : a â‰¤ b) : ne_bot (ğ“[Iic b] a) :=
  nhds_within_ne_bot_of_mem H

@[instance]
theorem nhds_within_Iic_self_ne_bot (a : Î±) : ne_bot (ğ“[Iic a] a) :=
  nhds_within_Iic_ne_bot (le_reflâ‚“ a)

end Preorderâ‚“

section PartialOrderâ‚“

variable [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [t : OrderClosedTopology Î±]

include t

private theorem is_closed_eq_aux : IsClosed { p:Î± Ã— Î± | p.1 = p.2 } :=
  by 
    simp only [le_antisymm_iffâ‚“] <;> exact IsClosed.inter t.is_closed_le' (is_closed_le continuous_snd continuous_fst)

instance (priority := 90) OrderClosedTopology.to_t2_space : T2Space Î± :=
  { t2 :=
      have  : IsOpen { p:Î± Ã— Î± | p.1 â‰  p.2 } := is_closed_eq_aux.is_open_compl 
      fun a b h =>
        let âŸ¨u, v, hu, hv, ha, hb, hâŸ© := is_open_prod_iff.mp this a b h
        âŸ¨u, v, hu, hv, ha, hb,
          Set.eq_empty_iff_forall_not_mem.2$
            fun a âŸ¨hâ‚, hâ‚‚âŸ© =>
              have  : a â‰  a := @h (a, a) âŸ¨hâ‚, hâ‚‚âŸ©
              this rflâŸ© }

end PartialOrderâ‚“

section LinearOrderâ‚“

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±]

theorem is_open_lt_prod : IsOpen { p:Î± Ã— Î± | p.1 < p.2 } :=
  by 
    simpRw [â†is_closed_compl_iff, compl_set_of, not_ltâ‚“]
    exact is_closed_le continuous_snd continuous_fst

theorem is_open_lt [TopologicalSpace Î²] {f g : Î² â†’ Î±} (hf : Continuous f) (hg : Continuous g) :
  IsOpen { b | f b < g b } :=
  by 
    simp [lt_iff_not_geâ‚“, -not_leâ‚“] <;> exact (is_closed_le hg hf).is_open_compl

variable {a b : Î±}

theorem is_open_Iio : IsOpen (Iio a) :=
  is_open_lt continuous_id continuous_const

theorem is_open_Ioi : IsOpen (Ioi a) :=
  is_open_lt continuous_const continuous_id

theorem is_open_Ioo : IsOpen (Ioo a b) :=
  IsOpen.inter is_open_Ioi is_open_Iio

@[simp]
theorem interior_Ioi : Interior (Ioi a) = Ioi a :=
  is_open_Ioi.interior_eq

@[simp]
theorem interior_Iio : Interior (Iio a) = Iio a :=
  is_open_Iio.interior_eq

@[simp]
theorem interior_Ioo : Interior (Ioo a b) = Ioo a b :=
  is_open_Ioo.interior_eq

theorem Iio_mem_nhds {a b : Î±} (h : a < b) : Iio b âˆˆ ğ“ a :=
  IsOpen.mem_nhds is_open_Iio h

theorem Ioi_mem_nhds {a b : Î±} (h : a < b) : Ioi a âˆˆ ğ“ b :=
  IsOpen.mem_nhds is_open_Ioi h

theorem Iic_mem_nhds {a b : Î±} (h : a < b) : Iic b âˆˆ ğ“ a :=
  mem_of_superset (Iio_mem_nhds h) Iio_subset_Iic_self

theorem Ici_mem_nhds {a b : Î±} (h : a < b) : Ici a âˆˆ ğ“ b :=
  mem_of_superset (Ioi_mem_nhds h) Ioi_subset_Ici_self

theorem Ioo_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ioo a b âˆˆ ğ“ x :=
  IsOpen.mem_nhds is_open_Ioo âŸ¨ha, hbâŸ©

theorem Ioc_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ioc a b âˆˆ ğ“ x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ioc_self

theorem Ico_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ico a b âˆˆ ğ“ x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ico_self

theorem Icc_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Icc a b âˆˆ ğ“ x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Icc_self

theorem eventually_le_of_tendsto_lt {l : Filter Î³} {f : Î³ â†’ Î±} {u v : Î±} (hv : v < u) (h : tendsto f l (ğ“ v)) :
  âˆ€á¶ a in l, f a â‰¤ u :=
  eventually.mono (tendsto_nhds.1 h (Â· < u) is_open_Iio hv) fun v => le_of_ltâ‚“

theorem eventually_ge_of_tendsto_gt {l : Filter Î³} {f : Î³ â†’ Î±} {u v : Î±} (hv : u < v) (h : tendsto f l (ğ“ v)) :
  âˆ€á¶ a in l, u â‰¤ f a :=
  eventually.mono (tendsto_nhds.1 h (Â· > u) is_open_Ioi hv) fun v => le_of_ltâ‚“

variable [TopologicalSpace Î³]

/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `ğ“[Ioi a] a` and
`ğ“[Ici a] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology Î±` -/


/-!
#### Right neighborhoods, point excluded
-/


theorem Ioo_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Ioo a c âˆˆ ğ“[Ioi b] b :=
  mem_nhds_within.2
    âŸ¨Iio c, is_open_Iio, H.2,
      by 
        rw [inter_comm, Ioi_inter_Iio] <;> exact Ioo_subset_Ioo_left H.1âŸ©

theorem Ioc_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Ioc a c âˆˆ ğ“[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Ico a c âˆˆ ğ“[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self

theorem Icc_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) : Icc a c âˆˆ ğ“[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self

@[simp]
theorem nhds_within_Ioc_eq_nhds_within_Ioi {a b : Î±} (h : a < b) : ğ“[Ioc a b] a = ğ“[Ioi a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ Ioc_subset_Ioi_self)$
    nhds_within_le_of_mem$ Ioc_mem_nhds_within_Ioi$ left_mem_Ico.2 h

@[simp]
theorem nhds_within_Ioo_eq_nhds_within_Ioi {a b : Î±} (h : a < b) : ğ“[Ioo a b] a = ğ“[Ioi a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ Ioo_subset_Ioi_self)$
    nhds_within_le_of_mem$ Ioo_mem_nhds_within_Ioi$ left_mem_Ico.2 h

@[simp]
theorem continuous_within_at_Ioc_iff_Ioi [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ioc a b) a â†” ContinuousWithinAt f (Ioi a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Ioi h]

@[simp]
theorem continuous_within_at_Ioo_iff_Ioi [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ioo a b) a â†” ContinuousWithinAt f (Ioi a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Ioi h]

/-!
#### Left neighborhoods, point excluded
-/


theorem Ioo_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Ioo a c âˆˆ ğ“[Iio b] b :=
  by 
    simpa only [dual_Ioo] using Ioo_mem_nhds_within_Ioi (show to_dual b âˆˆ Ico (to_dual c) (to_dual a) from H.symm)

theorem Ico_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Ico a c âˆˆ ğ“[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Ioc a c âˆˆ ğ“[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self

theorem Icc_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) : Icc a c âˆˆ ğ“[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self

@[simp]
theorem nhds_within_Ico_eq_nhds_within_Iio {a b : Î±} (h : a < b) : ğ“[Ico a b] b = ğ“[Iio b] b :=
  by 
    simpa only [dual_Ioc] using nhds_within_Ioc_eq_nhds_within_Ioi h.dual

@[simp]
theorem nhds_within_Ioo_eq_nhds_within_Iio {a b : Î±} (h : a < b) : ğ“[Ioo a b] b = ğ“[Iio b] b :=
  by 
    simpa only [dual_Ioo] using nhds_within_Ioo_eq_nhds_within_Ioi h.dual

@[simp]
theorem continuous_within_at_Ico_iff_Iio {a b : Î±} {f : Î± â†’ Î³} (h : a < b) :
  ContinuousWithinAt f (Ico a b) b â†” ContinuousWithinAt f (Iio b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Iio h]

@[simp]
theorem continuous_within_at_Ioo_iff_Iio {a b : Î±} {f : Î± â†’ Î³} (h : a < b) :
  ContinuousWithinAt f (Ioo a b) b â†” ContinuousWithinAt f (Iio b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Iio h]

/-!
#### Right neighborhoods, point included
-/


theorem Ioo_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ioo a c) : Ioo a c âˆˆ ğ“[Ici b] b :=
  mem_nhds_within_of_mem_nhds$ IsOpen.mem_nhds is_open_Ioo H

theorem Ioc_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ioo a c) : Ioc a c âˆˆ ğ“[Ici b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ico a c) : Ico a c âˆˆ ğ“[Ici b] b :=
  mem_nhds_within.2
    âŸ¨Iio c, is_open_Iio, H.2,
      by 
        simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]âŸ©

theorem Icc_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ico a c) : Icc a c âˆˆ ğ“[Ici b] b :=
  mem_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self

@[simp]
theorem nhds_within_Icc_eq_nhds_within_Ici {a b : Î±} (h : a < b) : ğ“[Icc a b] a = ğ“[Ici a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ Icc_subset_Ici_self)$
    nhds_within_le_of_mem$ Icc_mem_nhds_within_Ici$ left_mem_Ico.2 h

@[simp]
theorem nhds_within_Ico_eq_nhds_within_Ici {a b : Î±} (h : a < b) : ğ“[Ico a b] a = ğ“[Ici a] a :=
  le_antisymmâ‚“ (nhds_within_mono _ fun x => And.left)$ nhds_within_le_of_mem$ Ico_mem_nhds_within_Ici$ left_mem_Ico.2 h

@[simp]
theorem continuous_within_at_Icc_iff_Ici [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Icc a b) a â†” ContinuousWithinAt f (Ici a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Ici h]

@[simp]
theorem continuous_within_at_Ico_iff_Ici [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ico a b) a â†” ContinuousWithinAt f (Ici a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Ici h]

/-!
#### Left neighborhoods, point included
-/


theorem Ioo_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioo a c) : Ioo a c âˆˆ ğ“[Iic b] b :=
  mem_nhds_within_of_mem_nhds$ IsOpen.mem_nhds is_open_Ioo H

theorem Ico_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioo a c) : Ico a c âˆˆ ğ“[Iic b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioc a c) : Ioc a c âˆˆ ğ“[Iic b] b :=
  by 
    simpa only [dual_Ico] using Ico_mem_nhds_within_Ici (show to_dual b âˆˆ Ico (to_dual c) (to_dual a) from H.symm)

theorem Icc_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioc a c) : Icc a c âˆˆ ğ“[Iic b] b :=
  mem_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self

@[simp]
theorem nhds_within_Icc_eq_nhds_within_Iic {a b : Î±} (h : a < b) : ğ“[Icc a b] b = ğ“[Iic b] b :=
  by 
    simpa only [dual_Icc] using nhds_within_Icc_eq_nhds_within_Ici h.dual

@[simp]
theorem nhds_within_Ioc_eq_nhds_within_Iic {a b : Î±} (h : a < b) : ğ“[Ioc a b] b = ğ“[Iic b] b :=
  by 
    simpa only [dual_Ico] using nhds_within_Ico_eq_nhds_within_Ici h.dual

@[simp]
theorem continuous_within_at_Icc_iff_Iic [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Icc a b) b â†” ContinuousWithinAt f (Iic b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Iic h]

@[simp]
theorem continuous_within_at_Ioc_iff_Iic [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  ContinuousWithinAt f (Ioc a b) b â†” ContinuousWithinAt f (Iic b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Iic h]

end LinearOrderâ‚“

section LinearOrderâ‚“

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±] {f g : Î² â†’ Î±}

section 

variable [TopologicalSpace Î²]

theorem frontier_le_subset_eq (hf : Continuous f) (hg : Continuous g) :
  Frontier { b | f b â‰¤ g b } âŠ† { b | f b = g b } :=
  by 
    rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg]
    rintro b âŸ¨hbâ‚, hbâ‚‚âŸ©
    refine' le_antisymmâ‚“ hbâ‚ (closure_lt_subset_le hg hf _)
    convert hbâ‚‚ using 2
    simp only [not_le.symm]
    rfl

theorem frontier_Iic_subset (a : Î±) : Frontier (Iic a) âŠ† {a} :=
  frontier_le_subset_eq (@continuous_id Î± _) continuous_const

theorem frontier_Ici_subset (a : Î±) : Frontier (Ici a) âŠ† {a} :=
  @frontier_Iic_subset (OrderDual Î±) _ _ _ _

theorem frontier_lt_subset_eq (hf : Continuous f) (hg : Continuous g) :
  Frontier { b | f b < g b } âŠ† { b | f b = g b } :=
  by 
    rw [â†frontier_compl] <;> convert frontier_le_subset_eq hg hf <;> simp [ext_iff, eq_comm]

theorem continuous_if_le [TopologicalSpace Î³] [âˆ€ x, Decidable (f x â‰¤ g x)] {f' g' : Î² â†’ Î³} (hf : Continuous f)
  (hg : Continuous g) (hf' : ContinuousOn f' { x | f x â‰¤ g x }) (hg' : ContinuousOn g' { x | g x â‰¤ f x })
  (hfg : âˆ€ x, f x = g x â†’ f' x = g' x) : Continuous fun x => if f x â‰¤ g x then f' x else g' x :=
  by 
    refine' continuous_if (fun a ha => hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _)
    Â·
      rwa [(is_closed_le hf hg).closure_eq]
    Â·
      simp only [not_leâ‚“]
      exact closure_lt_subset_le hg hf

theorem Continuous.if_le [TopologicalSpace Î³] [âˆ€ x, Decidable (f x â‰¤ g x)] {f' g' : Î² â†’ Î³} (hf' : Continuous f')
  (hg' : Continuous g') (hf : Continuous f) (hg : Continuous g) (hfg : âˆ€ x, f x = g x â†’ f' x = g' x) :
  Continuous fun x => if f x â‰¤ g x then f' x else g' x :=
  continuous_if_le hf hg hf'.continuous_on hg'.continuous_on hfg

@[continuity]
theorem Continuous.min (hf : Continuous f) (hg : Continuous g) : Continuous fun b => min (f b) (g b) :=
  by 
    simp only [min_def]
    exact hf.if_le hg hf hg fun x => id

@[continuity]
theorem Continuous.max (hf : Continuous f) (hg : Continuous g) : Continuous fun b => max (f b) (g b) :=
  @Continuous.min (OrderDual Î±) _ _ _ _ _ _ _ hf hg

end 

theorem continuous_min : Continuous fun p : Î± Ã— Î± => min p.1 p.2 :=
  continuous_fst.min continuous_snd

theorem continuous_max : Continuous fun p : Î± Ã— Î± => max p.1 p.2 :=
  continuous_fst.max continuous_snd

theorem Filter.Tendsto.max {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} (hf : tendsto f b (ğ“ aâ‚)) (hg : tendsto g b (ğ“ aâ‚‚)) :
  tendsto (fun b => max (f b) (g b)) b (ğ“ (max aâ‚ aâ‚‚)) :=
  (continuous_max.Tendsto (aâ‚, aâ‚‚)).comp (hf.prod_mk_nhds hg)

theorem Filter.Tendsto.min {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} (hf : tendsto f b (ğ“ aâ‚)) (hg : tendsto g b (ğ“ aâ‚‚)) :
  tendsto (fun b => min (f b) (g b)) b (ğ“ (min aâ‚ aâ‚‚)) :=
  (continuous_min.Tendsto (aâ‚, aâ‚‚)).comp (hf.prod_mk_nhds hg)

theorem Dense.exists_lt [NoBotOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), y < x :=
  hs.exists_mem_open is_open_Iio (no_bot x)

theorem Dense.exists_gt [NoTopOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), x < y :=
  hs.order_dual.exists_lt x

theorem Dense.exists_le [NoBotOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), y â‰¤ x :=
  (hs.exists_lt x).imp$ fun y hy => âŸ¨hy.fst, hy.snd.leâŸ©

theorem Dense.exists_ge [NoTopOrder Î±] {s : Set Î±} (hs : Dense s) (x : Î±) : âˆƒ (y : _)(_ : y âˆˆ s), x â‰¤ y :=
  hs.order_dual.exists_le x

theorem Dense.exists_le' {s : Set Î±} (hs : Dense s) (hbot : âˆ€ x, IsBot x â†’ x âˆˆ s) (x : Î±) :
  âˆƒ (y : _)(_ : y âˆˆ s), y â‰¤ x :=
  by 
    byCases' hx : IsBot x
    Â·
      exact âŸ¨x, hbot x hx, le_rflâŸ©
    Â·
      simp only [IsBot, not_forall, not_leâ‚“] at hx 
      rcases hs.exists_mem_open is_open_Iio hx with âŸ¨y, hys, hy : y < xâŸ©
      exact âŸ¨y, hys, hy.leâŸ©

theorem Dense.exists_ge' {s : Set Î±} (hs : Dense s) (htop : âˆ€ x, IsTop x â†’ x âˆˆ s) (x : Î±) :
  âˆƒ (y : _)(_ : y âˆˆ s), x â‰¤ y :=
  hs.order_dual.exists_le' htop x

theorem Dense.exists_between [DenselyOrdered Î±] {s : Set Î±} (hs : Dense s) {x y : Î±} (h : x < y) :
  âˆƒ (z : _)(_ : z âˆˆ s), z âˆˆ Ioo x y :=
  hs.exists_mem_open is_open_Ioo (nonempty_Ioo.2 h)

end LinearOrderâ‚“

end OrderClosedTopology

instance [Preorderâ‚“ Î±] [TopologicalSpace Î±] [OrderClosedTopology Î±] [Preorderâ‚“ Î²] [TopologicalSpace Î²]
  [OrderClosedTopology Î²] : OrderClosedTopology (Î± Ã— Î²) :=
  âŸ¨(is_closed_le (continuous_fst.comp continuous_fst) (continuous_fst.comp continuous_snd)).inter
      (is_closed_le (continuous_snd.comp continuous_fst) (continuous_snd.comp continuous_snd))âŸ©

instance {Î¹ : Type _} {Î± : Î¹ â†’ Type _} [âˆ€ i, Preorderâ‚“ (Î± i)] [âˆ€ i, TopologicalSpace (Î± i)]
  [âˆ€ i, OrderClosedTopology (Î± i)] : OrderClosedTopology (âˆ€ i, Î± i) :=
  by 
    constructor 
    simp only [Pi.le_def, set_of_forall]
    exact
      is_closed_Inter
        fun i => is_closed_le ((continuous_apply i).comp continuous_fst) ((continuous_apply i).comp continuous_snd)

instance Pi.order_closed_topology' [Preorderâ‚“ Î²] [TopologicalSpace Î²] [OrderClosedTopology Î²] :
  OrderClosedTopology (Î± â†’ Î²) :=
  Pi.order_closed_topology

/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class OrderTopology (Î± : Type _) [t : TopologicalSpace Î±] [Preorderâ‚“ Î±] : Prop where 
  topology_eq_generate_intervals : t = generate_from { s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a }

/-- (Order) topology on a partial order `Î±` generated by the subbase of open intervals
`(a, âˆ) = { x âˆ£ a < x }, (-âˆ , b) = {x âˆ£ x < b}` for all `a, b` in `Î±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorderâ‚“.topology (Î± : Type _) [Preorderâ‚“ Î±] : TopologicalSpace Î± :=
  generate_from { s:Set Î± | âˆƒ a : Î±, s = { b:Î± | a < b } âˆ¨ s = { b:Î± | b < a } }

section OrderTopology

instance {Î± : Type _} [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [OrderTopology Î±] : OrderTopology (OrderDual Î±) :=
  âŸ¨by 
      convert @OrderTopology.topology_eq_generate_intervals Î± _ _ _ <;> conv  in _ âˆ¨ _ => rw [Or.comm] <;> rflâŸ©

section PartialOrderâ‚“

variable [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [t : OrderTopology Î±]

include t

theorem is_open_iff_generate_intervals {s : Set Î±} : IsOpen s â†” generate_open { s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a } s :=
  by 
    rw [t.topology_eq_generate_intervals] <;> rfl

theorem is_open_lt' (a : Î±) : IsOpen { b:Î± | a < b } :=
  by 
    rw [@is_open_iff_generate_intervals Î± _ _ t] <;> exact generate_open.basic _ âŸ¨a, Or.inl rflâŸ©

theorem is_open_gt' (a : Î±) : IsOpen { b:Î± | b < a } :=
  by 
    rw [@is_open_iff_generate_intervals Î± _ _ t] <;> exact generate_open.basic _ âŸ¨a, Or.inr rflâŸ©

theorem lt_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶ x in ğ“ b, a < x :=
  IsOpen.mem_nhds (is_open_lt' _) h

theorem le_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶ x in ğ“ b, a â‰¤ x :=
  (ğ“ b).sets_of_superset (lt_mem_nhds h)$ fun b hb => le_of_ltâ‚“ hb

theorem gt_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶ x in ğ“ a, x < b :=
  IsOpen.mem_nhds (is_open_gt' _) h

theorem ge_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶ x in ğ“ a, x â‰¤ b :=
  (ğ“ a).sets_of_superset (gt_mem_nhds h)$ fun b hb => le_of_ltâ‚“ hb

theorem nhds_eq_order (a : Î±) : ğ“ a = (â¨…(b : _)(_ : b âˆˆ Iio a), ğ“Ÿ (Ioi b))âŠ“â¨…(b : _)(_ : b âˆˆ Ioi a), ğ“Ÿ (Iio b) :=
  by 
    rw [t.topology_eq_generate_intervals, nhds_generate_from] <;>
      exact
        le_antisymmâ‚“
          (le_inf (le_binfi$ fun b hb => infi_le_of_le { c:Î± | b < c }$ infi_le _ âŸ¨hb, b, Or.inl rflâŸ©)
            (le_binfi$ fun b hb => infi_le_of_le { c:Î± | c < b }$ infi_le _ âŸ¨hb, b, Or.inr rflâŸ©))
          (le_infi$
            fun s =>
              le_infi$
                fun âŸ¨ha, b, hsâŸ© =>
                  match s, ha, hs with 
                  | _, h, Or.inl rfl => inf_le_of_left_le$ infi_le_of_le b$ infi_le _ h
                  | _, h, Or.inr rfl => inf_le_of_right_le$ infi_le_of_le b$ infi_le _ h)

theorem tendsto_order {f : Î² â†’ Î±} {a : Î±} {x : Filter Î²} :
  tendsto f x (ğ“ a) â†” (âˆ€ a' _ : a' < a, âˆ€á¶ b in x, a' < f b) âˆ§ âˆ€ a' _ : a' > a, âˆ€á¶ b in x, f b < a' :=
  by 
    simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]

instance tendsto_Icc_class_nhds (a : Î±) : tendsto_Ixx_class Icc (ğ“ a) (ğ“ a) :=
  by 
    simp only [nhds_eq_order, infi_subtype']
    refine' ((has_basis_infi_principal_finite _).inf (has_basis_infi_principal_finite _)).TendstoIxxClass fun s hs => _ 
    refine' ((ord_connected_bInter _).inter (ord_connected_bInter _)).out <;> intro _ _ 
    exacts[ord_connected_Ioi, ord_connected_Iio]

instance tendsto_Ico_class_nhds (a : Î±) : tendsto_Ixx_class Ico (ğ“ a) (ğ“ a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ico_subset_Icc_self

instance tendsto_Ioc_class_nhds (a : Î±) : tendsto_Ixx_class Ioc (ğ“ a) (ğ“ a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ioc_subset_Icc_self

instance tendsto_Ioo_class_nhds (a : Î±) : tendsto_Ixx_class Ioo (ğ“ a) (ğ“ a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ioo_subset_Icc_self

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Î² â†’ Î±} {b : Filter Î²} {a : Î±} (hg : tendsto g b (ğ“ a))
  (hh : tendsto h b (ğ“ a)) (hgf : âˆ€á¶ b in b, g b â‰¤ f b) (hfh : âˆ€á¶ b in b, f b â‰¤ h b) : tendsto f b (ğ“ a) :=
  tendsto_order.2
    âŸ¨fun a' h' =>
        have  : âˆ€á¶ b in b, a' < g b := (tendsto_order.1 hg).left a' h' 
        by 
          filterUpwards [this, hgf] fun a => lt_of_lt_of_leâ‚“,
      fun a' h' =>
        have  : âˆ€á¶ b in b, h b < a' := (tendsto_order.1 hh).right a' h' 
        by 
          filterUpwards [this, hfh] fun a hâ‚ hâ‚‚ => lt_of_le_of_ltâ‚“ hâ‚‚ hâ‚âŸ©

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Î² â†’ Î±} {b : Filter Î²} {a : Î±} (hg : tendsto g b (ğ“ a))
  (hh : tendsto h b (ğ“ a)) (hgf : g â‰¤ f) (hfh : f â‰¤ h) : tendsto f b (ğ“ a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (eventually_of_forall hgf) (eventually_of_forall hfh)

theorem nhds_order_unbounded {a : Î±} (hu : âˆƒ u, a < u) (hl : âˆƒ l, l < a) :
  ğ“ a = â¨…(l : _)(hâ‚‚ : l < a)(u : _)(hâ‚‚ : a < u), ğ“Ÿ (Ioo l u) :=
  have  : âˆƒ u, u âˆˆ Ioi a := hu 
  have  : âˆƒ l, l âˆˆ Iio a := hl 
  by 
    simp only [nhds_eq_order, inf_binfi, binfi_inf, inf_principal, Ioi_inter_Iio]
    rfl

theorem tendsto_order_unbounded {f : Î² â†’ Î±} {a : Î±} {x : Filter Î²} (hu : âˆƒ u, a < u) (hl : âˆƒ l, l < a)
  (h : âˆ€ l u, l < a â†’ a < u â†’ âˆ€á¶ b in x, l < f b âˆ§ f b < u) : tendsto f x (ğ“ a) :=
  by 
    rw [nhds_order_unbounded hu hl] <;>
      exact
        tendsto_infi.2$
          fun l =>
            tendsto_infi.2$
              fun hl => tendsto_infi.2$ fun u => tendsto_infi.2$ fun hu => tendsto_principal.2$ h l u hl hu

end PartialOrderâ‚“

instance tendsto_Ixx_nhds_within {Î± : Type _} [Preorderâ‚“ Î±] [TopologicalSpace Î±] (a : Î±) {s t : Set Î±} {Ixx}
  [tendsto_Ixx_class Ixx (ğ“ a) (ğ“ a)] [tendsto_Ixx_class Ixx (ğ“Ÿ s) (ğ“Ÿ t)] : tendsto_Ixx_class Ixx (ğ“[s] a) (ğ“[t] a) :=
  Filter.tendsto_Ixx_class_inf

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance tendsto_Icc_class_nhds_pi
{Î¹ : Type*}
{Î± : Î¹ â†’ Type*}
[âˆ€ i, partial_order (Î± i)]
[âˆ€ i, topological_space (Î± i)]
[âˆ€ i, order_topology (Î± i)]
(f : âˆ€ i, Î± i) : tendsto_Ixx_class Icc (exprğ“() f) (exprğ“() f) :=
begin
  constructor,
  conv [] ["in", expr (exprğ“() f).lift' powerset] { rw ["[", expr nhds_pi, ",", expr filter.pi, "]"] },
  simp [] [] ["only"] ["[", expr lift'_infi_powerset, ",", expr comap_lift'_eq2 monotone_powerset, ",", expr tendsto_infi, ",", expr tendsto_lift', ",", expr mem_powerset_iff, ",", expr subset_def, ",", expr mem_preimage, "]"] [] [],
  intros [ident i, ident s, ident hs],
  have [] [":", expr tendsto (Î»
    g : âˆ€ i, Î± i, g i) (exprğ“() f) (exprğ“() (f i))] [":=", expr (continuous_apply i).tendsto f],
  refine [expr (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _],
  exact [expr Î» p hp g hg, hp âŸ¨hg.1 _, hg.2 _âŸ©]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem induced_order_topology'
{Î± : Type u}
{Î² : Type v}
[partial_order Î±]
[ta : topological_space Î²]
[partial_order Î²]
[order_topology Î²]
(f : Î± â†’ Î²)
(hf : âˆ€ {x y}, Â«expr â†” Â»(Â«expr < Â»(f x, f y), Â«expr < Â»(x, y)))
(Hâ‚ : âˆ€ {a x}, Â«expr < Â»(x, f a) â†’ Â«exprâˆƒ , Â»((b Â«expr < Â» a), Â«expr â‰¤ Â»(x, f b)))
(Hâ‚‚ : âˆ€
 {a x}, Â«expr < Â»(f a, x) â†’ Â«exprâˆƒ , Â»((b Â«expr > Â» a), Â«expr â‰¤ Â»(f b, x))) : @order_topology _ (induced f ta) _ :=
begin
  letI [] [] [":=", expr induced f ta],
  refine [expr âŸ¨eq_of_nhds_eq_nhds (Î» a, _)âŸ©],
  rw ["[", expr nhds_induced, ",", expr nhds_generate_from, ",", expr nhds_eq_order (f a), "]"] [],
  apply [expr le_antisymm],
  { refine [expr le_infi (Î» s, Â«expr $ Â»(le_infi, Î» hs, le_principal_iff.2 _))],
    rcases [expr hs, "with", "âŸ¨", ident ab, ",", ident b, ",", ident rfl, "|", ident rfl, "âŸ©"],
    { exact [expr mem_comap.2 âŸ¨{x | Â«expr < Â»(f b, x)}, Â«expr $ Â»(mem_inf_of_left, Â«expr $ Â»(mem_infi_of_mem _, Â«expr $ Â»(mem_infi_of_mem (hf.2 ab), mem_principal_self _))), Î»
        x, hf.1âŸ©] },
    { exact [expr mem_comap.2 âŸ¨{x | Â«expr < Â»(x, f b)}, Â«expr $ Â»(mem_inf_of_right, Â«expr $ Â»(mem_infi_of_mem _, Â«expr $ Â»(mem_infi_of_mem (hf.2 ab), mem_principal_self _))), Î»
        x, hf.1âŸ©] } },
  { rw ["[", "<-", expr map_le_iff_le_comap, "]"] [],
    refine [expr le_inf _ _]; refine [expr le_infi (Î»
      x, Â«expr $ Â»(le_infi, Î» h, le_principal_iff.2 _))]; simp [] [] [] [] [] [],
    { rcases [expr Hâ‚ h, "with", "âŸ¨", ident b, ",", ident ab, ",", ident xb, "âŸ©"],
      refine [expr mem_infi_of_mem _ (mem_infi_of_mem âŸ¨ab, b, or.inl rflâŸ© (mem_principal.2 _))],
      exact [expr Î» c hc, lt_of_le_of_lt xb (hf.2 hc)] },
    { rcases [expr Hâ‚‚ h, "with", "âŸ¨", ident b, ",", ident ab, ",", ident xb, "âŸ©"],
      refine [expr mem_infi_of_mem _ (mem_infi_of_mem âŸ¨ab, b, or.inr rflâŸ© (mem_principal.2 _))],
      exact [expr Î» c hc, lt_of_lt_of_le (hf.2 hc) xb] } }
end

theorem induced_order_topology {Î± : Type u} {Î² : Type v} [PartialOrderâ‚“ Î±] [ta : TopologicalSpace Î²] [PartialOrderâ‚“ Î²]
  [OrderTopology Î²] (f : Î± â†’ Î²) (hf : âˆ€ {x y}, f x < f y â†” x < y) (H : âˆ€ {x y}, x < y â†’ âˆƒ a, x < f a âˆ§ f a < y) :
  @OrderTopology _ (induced f ta) _ :=
  induced_order_topology' f (@hf)
    (fun a x xa =>
      let âŸ¨b, xb, baâŸ© := H xa
      âŸ¨b, hf.1 ba, le_of_ltâ‚“ xbâŸ©)
    fun a x ax =>
      let âŸ¨b, ab, bxâŸ© := H ax
      âŸ¨b, hf.1 ab, le_of_ltâ‚“ bxâŸ©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance order_topology_of_ord_connected
{Î± : Type u}
[ta : topological_space Î±]
[linear_order Î±]
[order_topology Î±]
{t : set Î±}
[ht : ord_connected t] : order_topology t :=
begin
  letI [] [] [":=", expr induced (coe : t â†’ Î±) ta],
  refine [expr âŸ¨eq_of_nhds_eq_nhds (Î» a, _)âŸ©],
  rw ["[", expr nhds_induced, ",", expr nhds_generate_from, ",", expr nhds_eq_order (a : Î±), "]"] [],
  apply [expr le_antisymm],
  { refine [expr le_infi (Î» s, Â«expr $ Â»(le_infi, Î» hs, le_principal_iff.2 _))],
    rcases [expr hs, "with", "âŸ¨", ident ab, ",", ident b, ",", ident rfl, "|", ident rfl, "âŸ©"],
    { refine [expr âŸ¨Ioi b, _, Î» _, idâŸ©],
      refine [expr mem_inf_of_left (mem_infi_of_mem b _)],
      exact [expr mem_infi_of_mem ab (mem_principal_self (Ioi Â«exprâ†‘ Â»(b)))] },
    { refine [expr âŸ¨Iio b, _, Î» _, idâŸ©],
      refine [expr mem_inf_of_right (mem_infi_of_mem b _)],
      exact [expr mem_infi_of_mem ab (mem_principal_self (Iio b))] } },
  { rw ["[", "<-", expr map_le_iff_le_comap, "]"] [],
    refine [expr le_inf _ _],
    { refine [expr le_infi (Î» x, Â«expr $ Â»(le_infi, Î» h, le_principal_iff.2 _))],
      by_cases [expr hx, ":", expr Â«expr âˆˆ Â»(x, t)],
      { refine [expr mem_infi_of_mem (Ioi âŸ¨x, hxâŸ©) (mem_infi_of_mem âŸ¨h, âŸ¨âŸ¨x, hxâŸ©, or.inl rflâŸ©âŸ© _)],
        exact [expr Î» _, id] },
      simp [] [] ["only"] ["[", expr set_coe.exists, ",", expr mem_set_of_eq, ",", expr mem_map', "]"] [] [],
      convert [] [expr univ_sets _] [],
      suffices [ident hx'] [":", expr âˆ€ y : t, Â«expr âˆˆ Â»(Â«exprâ†‘ Â»(y), Ioi x)],
      { simp [] [] [] ["[", expr hx', "]"] [] [] },
      intros [ident y],
      revert [ident hx],
      contrapose ["!"] [],
      exact [expr Î» hx, ht.out y.2 a.2 âŸ¨le_of_not_gt hx, le_of_lt hâŸ©] },
    { refine [expr le_infi (Î» x, Â«expr $ Â»(le_infi, Î» h, le_principal_iff.2 _))],
      by_cases [expr hx, ":", expr Â«expr âˆˆ Â»(x, t)],
      { refine [expr mem_infi_of_mem (Iio âŸ¨x, hxâŸ©) (mem_infi_of_mem âŸ¨h, âŸ¨âŸ¨x, hxâŸ©, or.inr rflâŸ©âŸ© _)],
        exact [expr Î» _, id] },
      simp [] [] ["only"] ["[", expr set_coe.exists, ",", expr mem_set_of_eq, ",", expr mem_map', "]"] [] [],
      convert [] [expr univ_sets _] [],
      suffices [ident hx'] [":", expr âˆ€ y : t, Â«expr âˆˆ Â»(Â«exprâ†‘ Â»(y), Iio x)],
      { simp [] [] [] ["[", expr hx', "]"] [] [] },
      intros [ident y],
      revert [ident hx],
      contrapose ["!"] [],
      exact [expr Î» hx, ht.out a.2 y.2 âŸ¨le_of_lt h, le_of_not_gt hxâŸ©] } }
end

theorem nhds_top_order [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [OrderTop Î±] [OrderTopology Î±] :
  ğ“ (âŠ¤ : Î±) = â¨…(l : _)(hâ‚‚ : l < âŠ¤), ğ“Ÿ (Ioi l) :=
  by 
    simp [nhds_eq_order (âŠ¤ : Î±)]

theorem nhds_bot_order [TopologicalSpace Î±] [PartialOrderâ‚“ Î±] [OrderBot Î±] [OrderTopology Î±] :
  ğ“ (âŠ¥ : Î±) = â¨…(l : _)(hâ‚‚ : âŠ¥ < l), ğ“Ÿ (Iio l) :=
  by 
    simp [nhds_eq_order (âŠ¥ : Î±)]

theorem nhds_top_basis [TopologicalSpace Î±] [SemilatticeSup Î±] [OrderTop Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] : (ğ“ âŠ¤).HasBasis (fun a : Î± => a < âŠ¤) fun a : Î± => Ioi a :=
  âŸ¨by 
      simp only [nhds_top_order]
      refine' @Filter.mem_binfi_of_directed Î± Î± (fun a => ğ“Ÿ (Ioi a)) (fun a => a < âŠ¤) _ _
      Â·
        rintro a (ha : a < âŠ¤) b (hb : b < âŠ¤)
        use aâŠ”b 
        simp only [Filter.le_principal_iff, ge_iff_le, Order.Preimage]
        exact âŸ¨sup_lt_iff.mpr âŸ¨ha, hbâŸ©, Ioi_subset_Ioi le_sup_left, Ioi_subset_Ioi le_sup_rightâŸ©
      Â·
        obtain âŸ¨a, haâŸ© : âˆƒ a : Î±, a â‰  âŠ¤ := exists_ne âŠ¤
        exact âŸ¨a, lt_top_iff_ne_top.mpr haâŸ©âŸ©

theorem nhds_bot_basis [TopologicalSpace Î±] [SemilatticeInf Î±] [OrderBot Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] : (ğ“ âŠ¥).HasBasis (fun a : Î± => âŠ¥ < a) fun a : Î± => Iio a :=
  @nhds_top_basis (OrderDual Î±) _ _ _ _ _ _

theorem nhds_top_basis_Ici [TopologicalSpace Î±] [SemilatticeSup Î±] [OrderTop Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] [DenselyOrdered Î±] : (ğ“ âŠ¤).HasBasis (fun a : Î± => a < âŠ¤) Ici :=
  nhds_top_basis.to_has_basis
    (fun a ha =>
      let âŸ¨b, hab, hbâŸ© := exists_between ha
      âŸ¨b, hb, Ici_subset_Ioi.mpr habâŸ©)
    fun a ha => âŸ¨a, ha, Ioi_subset_Ici_selfâŸ©

theorem nhds_bot_basis_Iic [TopologicalSpace Î±] [SemilatticeInf Î±] [OrderBot Î±] [IsTotal Î± LE.le] [OrderTopology Î±]
  [Nontrivial Î±] [DenselyOrdered Î±] : (ğ“ âŠ¥).HasBasis (fun a : Î± => âŠ¥ < a) Iic :=
  @nhds_top_basis_Ici (OrderDual Î±) _ _ _ _ _ _ _

theorem tendsto_nhds_top_mono [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderTop Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤á¶ [l] g) : tendsto g l (ğ“ âŠ¤) :=
  by 
    simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hfâŠ¢
    intro x hx 
    filterUpwards [hf x hx, hg]
    exact fun x => lt_of_lt_of_leâ‚“

theorem tendsto_nhds_bot_mono [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderBot Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤á¶ [l] f) : tendsto g l (ğ“ âŠ¥) :=
  @tendsto_nhds_top_mono Î± (OrderDual Î²) _ _ _ _ _ _ _ hf hg

theorem tendsto_nhds_top_mono' [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderTop Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤ g) : tendsto g l (ğ“ âŠ¤) :=
  tendsto_nhds_top_mono hf (eventually_of_forall hg)

theorem tendsto_nhds_bot_mono' [TopologicalSpace Î²] [PartialOrderâ‚“ Î²] [OrderBot Î²] [OrderTopology Î²] {l : Filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤ f) : tendsto g l (ğ“ âŠ¥) :=
  tendsto_nhds_bot_mono hf (eventually_of_forall hg)

section LinearOrderâ‚“

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±]

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem exists_Ioc_subset_of_mem_nhds'
{a : Î±}
{s : set Î±}
(hs : Â«expr âˆˆ Â»(s, exprğ“() a))
{l : Î±}
(hl : Â«expr < Â»(l, a)) : Â«exprâˆƒ , Â»((l' Â«expr âˆˆ Â» Ico l a), Â«expr âŠ† Â»(Ioc l' a, s)) :=
begin
  rw ["[", expr nhds_eq_order a, "]"] ["at", ident hs],
  rcases [expr hs, "with", "âŸ¨", ident tâ‚, ",", ident htâ‚, ",", ident tâ‚‚, ",", ident htâ‚‚, ",", ident rfl, "âŸ©"],
  suffices [] [":", expr Â«exprâˆƒ , Â»((l' Â«expr âˆˆ Â» Ico l a), Â«expr âŠ† Â»(Ioi l', tâ‚))],
  { have [ident A] [":", expr Â«expr â‰¤ Â»(exprğ“Ÿ() (Iic a), Â«exprâ¨… , Â»((b Â«expr âˆˆ Â» Ioi a), exprğ“Ÿ() (Iio b)))] [],
    from [expr Â«expr $ Â»(le_infi, Î» b, Â«expr $ Â»(le_infi, Î» hb, Â«expr $ Â»(principal_mono.2, Iic_subset_Iio.2 hb)))],
    have [ident B] [":", expr Â«expr âŠ† Â»(Â«expr âˆ© Â»(tâ‚, Iic a), Â«expr âˆ© Â»(tâ‚, tâ‚‚))] [],
    from [expr inter_subset_inter_right _ (A htâ‚‚)],
    from [expr this.imp (Î» l', Â«expr $ Â»(Exists.imp, Î» hl' hl x hx, B âŸ¨hl hx.1, hx.2âŸ©))] },
  clear [ident htâ‚‚, ident tâ‚‚],
  rw ["[", expr mem_binfi_of_directed, "]"] ["at", ident htâ‚],
  { rcases [expr htâ‚, "with", "âŸ¨", ident b, ",", ident hb, ",", ident hb', "âŸ©"],
    exact [expr âŸ¨max b l, âŸ¨le_max_right _ _, max_lt hb hlâŸ©, Î»
      x hx, Â«expr $ Â»(hb', Ioi_subset_Ioi (le_max_left _ _) hx)âŸ©] },
  { intros [ident b, ident hb, ident b', ident hb'],
    simp [] [] ["only"] ["[", expr mem_Iio, "]"] [] ["at", ident hb, ident hb'],
    use ["[", expr max b b', ",", expr max_lt hb hb', "]"],
    simp [] [] [] ["[", expr le_refl, "]"] [] [] },
  exact [expr âŸ¨l, hlâŸ©]
end

theorem exists_Ico_subset_of_mem_nhds' {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) {u : Î±} (hu : a < u) :
  âˆƒ (u' : _)(_ : u' âˆˆ Ioc a u), Ico a u' âŠ† s :=
  by 
    simpa only [OrderDual.exists, exists_prop, dual_Ico, dual_Ioc] using
      exists_Ioc_subset_of_mem_nhds' (show of_dual â»Â¹' s âˆˆ ğ“ (to_dual a) from hs) hu.dual

theorem exists_Ioc_subset_of_mem_nhds {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ l, l < a) :
  âˆƒ (l : _)(_ : l < a), Ioc l a âŠ† s :=
  let âŸ¨l', hl'âŸ© := h 
  let âŸ¨l, hlâŸ© := exists_Ioc_subset_of_mem_nhds' hs hl'
  âŸ¨l, hl.fst.2, hl.sndâŸ©

theorem exists_Ico_subset_of_mem_nhds {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ u, a < u) :
  âˆƒ (u : _)(_ : a < u), Ico a u âŠ† s :=
  let âŸ¨l', hl'âŸ© := h 
  let âŸ¨l, hlâŸ© := exists_Ico_subset_of_mem_nhds' hs hl'
  âŸ¨l, hl.fst.1, hl.sndâŸ©

theorem IsOpen.exists_Ioo_subset [Nontrivial Î±] {s : Set Î±} (hs : IsOpen s) (h : s.nonempty) :
  âˆƒ a b, a < b âˆ§ Ioo a b âŠ† s :=
  by 
    obtain âŸ¨x, hxâŸ© : âˆƒ x, x âˆˆ s := h 
    obtain âŸ¨y, hyâŸ© : âˆƒ y, y â‰  x := exists_ne x 
    rcases lt_trichotomyâ‚“ x y with (H | rfl | H)
    Â·
      obtain âŸ¨u, xu, huâŸ© : âˆƒ (u : Î±)(hu : x < u), Ico x u âŠ† s := exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) âŸ¨y, HâŸ©
      exact âŸ¨x, u, xu, Ioo_subset_Ico_self.trans huâŸ©
    Â·
      exact (hy rfl).elim
    Â·
      obtain âŸ¨l, lx, hlâŸ© : âˆƒ (l : Î±)(hl : l < x), Ioc l x âŠ† s := exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) âŸ¨y, HâŸ©
      exact âŸ¨l, x, lx, Ioo_subset_Ioc_self.trans hlâŸ©

theorem order_separated {aâ‚ aâ‚‚ : Î±} (h : aâ‚ < aâ‚‚) :
  âˆƒ u v : Set Î±, IsOpen u âˆ§ IsOpen v âˆ§ aâ‚ âˆˆ u âˆ§ aâ‚‚ âˆˆ v âˆ§ âˆ€ bâ‚ _ : bâ‚ âˆˆ u, âˆ€ bâ‚‚ _ : bâ‚‚ âˆˆ v, bâ‚ < bâ‚‚ :=
  match dense_or_discrete aâ‚ aâ‚‚ with 
  | Or.inl âŸ¨a, haâ‚, haâ‚‚âŸ© =>
    âŸ¨{ a' | a' < a }, { a' | a < a' }, is_open_gt' a, is_open_lt' a, haâ‚, haâ‚‚, fun bâ‚ hâ‚ bâ‚‚ hâ‚‚ => lt_transâ‚“ hâ‚ hâ‚‚âŸ©
  | Or.inr âŸ¨hâ‚, hâ‚‚âŸ© =>
    âŸ¨{ a | a < aâ‚‚ }, { a | aâ‚ < a }, is_open_gt' aâ‚‚, is_open_lt' aâ‚, h, h,
      fun bâ‚ hbâ‚ bâ‚‚ hbâ‚‚ =>
        calc bâ‚ â‰¤ aâ‚ := hâ‚‚ _ hbâ‚ 
          _ < aâ‚‚ := h 
          _ â‰¤ bâ‚‚ := hâ‚ _ hbâ‚‚
          âŸ©

instance (priority := 100) OrderTopology.to_order_closed_topology : OrderClosedTopology Î± :=
  { is_closed_le' :=
      is_open_compl_iff.1$
        is_open_prod_iff.mpr$
          fun aâ‚ aâ‚‚ h : Â¬aâ‚ â‰¤ aâ‚‚ =>
            have h : aâ‚‚ < aâ‚ := lt_of_not_geâ‚“ h 
            let âŸ¨u, v, hu, hv, haâ‚, haâ‚‚, hâŸ© := order_separated h
            âŸ¨v, u, hv, hu, haâ‚‚, haâ‚, fun âŸ¨bâ‚, bâ‚‚âŸ© âŸ¨hâ‚, hâ‚‚âŸ© => not_le_of_gtâ‚“$ h bâ‚‚ hâ‚‚ bâ‚ hâ‚âŸ© }

theorem OrderTopology.t2_space : T2Space Î± :=
  by 
    infer_instance

instance (priority := 100) OrderTopology.regular_space : RegularSpace Î± :=
  { OrderTopology.t2_space with
    regular :=
      fun s a hs ha =>
        have hs' : Â«expr á¶œÂ» s âˆˆ ğ“ a := IsOpen.mem_nhds hs.is_open_compl ha 
        have  : âˆƒ t : Set Î±, IsOpen t âˆ§ (âˆ€ l _ : l âˆˆ s, l < a â†’ l âˆˆ t) âˆ§ ğ“[t] a = âŠ¥ :=
          by_cases
            (fun h : âˆƒ l, l < a =>
              let âŸ¨l, hl, hâŸ© := exists_Ioc_subset_of_mem_nhds hs' h 
              match dense_or_discrete l a with 
              | Or.inl âŸ¨b, hbâ‚, hbâ‚‚âŸ© =>
                âŸ¨{ a | a < b }, is_open_gt' _,
                  fun c hcs hca =>
                    show c < b from lt_of_not_geâ‚“$ fun hbc => h âŸ¨lt_of_lt_of_leâ‚“ hbâ‚ hbc, le_of_ltâ‚“ hcaâŸ© hcs,
                  inf_principal_eq_bot.2$
                    (ğ“ a).sets_of_superset ((is_open_lt' _).mem_nhds hbâ‚‚)$
                      fun x hx : b < x => show Â¬x < b from not_ltâ‚“.2$ le_of_ltâ‚“ hxâŸ©
              | Or.inr âŸ¨hâ‚, hâ‚‚âŸ© =>
                âŸ¨{ a' | a' < a }, is_open_gt' _, fun b hbs hba => hba,
                  inf_principal_eq_bot.2$
                    (ğ“ a).sets_of_superset ((is_open_lt' _).mem_nhds hl)$
                      fun x hx : l < x => show Â¬x < a from not_ltâ‚“.2$ hâ‚ _ hxâŸ©)
            fun this : Â¬âˆƒ l, l < a => âŸ¨âˆ…, is_open_empty, fun l _ hl => (this âŸ¨l, hlâŸ©).elim, nhds_within_empty _âŸ©
        let âŸ¨tâ‚, htâ‚o, htâ‚s, htâ‚aâŸ© := this 
        have  : âˆƒ t : Set Î±, IsOpen t âˆ§ (âˆ€ u _ : u âˆˆ s, u > a â†’ u âˆˆ t) âˆ§ ğ“[t] a = âŠ¥ :=
          by_cases
            (fun h : âˆƒ u, u > a =>
              let âŸ¨u, hu, hâŸ© := exists_Ico_subset_of_mem_nhds hs' h 
              match dense_or_discrete a u with 
              | Or.inl âŸ¨b, hbâ‚, hbâ‚‚âŸ© =>
                âŸ¨{ a | b < a }, is_open_lt' _,
                  fun c hcs hca =>
                    show c > b from lt_of_not_geâ‚“$ fun hbc => h âŸ¨le_of_ltâ‚“ hca, lt_of_le_of_ltâ‚“ hbc hbâ‚‚âŸ© hcs,
                  inf_principal_eq_bot.2$
                    (ğ“ a).sets_of_superset ((is_open_gt' _).mem_nhds hbâ‚)$
                      fun x hx : b > x => show Â¬x > b from not_ltâ‚“.2$ le_of_ltâ‚“ hxâŸ©
              | Or.inr âŸ¨hâ‚, hâ‚‚âŸ© =>
                âŸ¨{ a' | a' > a }, is_open_lt' _, fun b hbs hba => hba,
                  inf_principal_eq_bot.2$
                    (ğ“ a).sets_of_superset ((is_open_gt' _).mem_nhds hu)$
                      fun x hx : u > x => show Â¬x > a from not_ltâ‚“.2$ hâ‚‚ _ hxâŸ©)
            fun this : Â¬âˆƒ u, u > a => âŸ¨âˆ…, is_open_empty, fun l _ hl => (this âŸ¨l, hlâŸ©).elim, nhds_within_empty _âŸ©
        let âŸ¨tâ‚‚, htâ‚‚o, htâ‚‚s, htâ‚‚aâŸ© := this
        âŸ¨tâ‚ âˆª tâ‚‚, IsOpen.union htâ‚o htâ‚‚o,
          fun x hx =>
            have  : x â‰  a := fun eq => ha$ Eq â–¸ hx
            (ne_iff_lt_or_gtâ‚“.mp this).imp (htâ‚s _ hx) (htâ‚‚s _ hx),
          by 
            rw [nhds_within_union, htâ‚a, htâ‚‚a, bot_sup_eq]âŸ© }

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {a : Î±} {s : Set Î±} (hl : âˆƒ l, l < a) (hu : âˆƒ u, a < u) :
  s âˆˆ ğ“ a â†” âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s :=
  by 
    split 
    Â·
      intro h 
      rcases exists_Ico_subset_of_mem_nhds h hu with âŸ¨u, au, huâŸ©
      rcases exists_Ioc_subset_of_mem_nhds h hl with âŸ¨l, la, hlâŸ©
      refine' âŸ¨l, u, âŸ¨la, auâŸ©, fun x hx => _âŸ©
      cases' le_totalâ‚“ a x with hax hax
      Â·
        exact hu âŸ¨hax, hx.2âŸ©
      Â·
        exact hl âŸ¨hx.1, haxâŸ©
    Â·
      rintro âŸ¨l, u, ha, hâŸ©
      apply mem_of_superset (IsOpen.mem_nhds is_open_Ioo ha) h

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [NoTopOrder Î±] [NoBotOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“ a â†” âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s :=
  mem_nhds_iff_exists_Ioo_subset' (no_bot a) (no_top a)

theorem nhds_basis_Ioo' {a : Î±} (hl : âˆƒ l, l < a) (hu : âˆƒ u, a < u) :
  (ğ“ a).HasBasis (fun b : Î± Ã— Î± => b.1 < a âˆ§ a < b.2) fun b => Ioo b.1 b.2 :=
  âŸ¨fun s =>
      (mem_nhds_iff_exists_Ioo_subset' hl hu).trans$
        by 
          simp âŸ©

theorem nhds_basis_Ioo [NoTopOrder Î±] [NoBotOrder Î±] (a : Î±) :
  (ğ“ a).HasBasis (fun b : Î± Ã— Î± => b.1 < a âˆ§ a < b.2) fun b => Ioo b.1 b.2 :=
  nhds_basis_Ioo' (no_bot a) (no_top a)

theorem Filter.Eventually.exists_Ioo_subset [NoTopOrder Î±] [NoBotOrder Î±] {a : Î±} {p : Î± â†’ Prop}
  (hp : âˆ€á¶ x in ğ“ a, p x) : âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† { x | p x } :=
  mem_nhds_iff_exists_Ioo_subset.1 hp

section Pi

/-!
### Intervals in `Î  i, Ï€ i` belong to `ğ“ x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Î¹ â†’ â„`.
-/


variable {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [Fintype Î¹] [âˆ€ i, LinearOrderâ‚“ (Ï€ i)] [âˆ€ i, TopologicalSpace (Ï€ i)]
  [âˆ€ i, OrderTopology (Ï€ i)] {a b x : âˆ€ i, Ï€ i} {a' b' x' : Î¹ â†’ Î±}

theorem pi_Iic_mem_nhds (ha : âˆ€ i, x i < a i) : Iic a âˆˆ ğ“ x :=
  pi_univ_Iic a â–¸ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Iic_mem_nhds (ha _)

theorem pi_Iic_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iic a' âˆˆ ğ“ x' :=
  pi_Iic_mem_nhds ha

theorem pi_Ici_mem_nhds (ha : âˆ€ i, a i < x i) : Ici a âˆˆ ğ“ x :=
  pi_univ_Ici a â–¸ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Ici_mem_nhds (ha _)

theorem pi_Ici_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ici a' âˆˆ ğ“ x' :=
  pi_Ici_mem_nhds ha

theorem pi_Icc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Icc a b âˆˆ ğ“ x :=
  pi_univ_Icc a b â–¸ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Icc_mem_nhds (ha _) (hb _)

theorem pi_Icc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Icc a' b' âˆˆ ğ“ x' :=
  pi_Icc_mem_nhds ha hb

variable [Nonempty Î¹]

theorem pi_Iio_mem_nhds (ha : âˆ€ i, x i < a i) : Iio a âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Iio_subset a)
    exact Iio_mem_nhds (ha i)

theorem pi_Iio_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iio a' âˆˆ ğ“ x' :=
  pi_Iio_mem_nhds ha

theorem pi_Ioi_mem_nhds (ha : âˆ€ i, a i < x i) : Ioi a âˆˆ ğ“ x :=
  @pi_Iio_mem_nhds Î¹ (fun i => OrderDual (Ï€ i)) _ _ _ _ _ _ _ ha

theorem pi_Ioi_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ioi a' âˆˆ ğ“ x' :=
  pi_Ioi_mem_nhds ha

theorem pi_Ioc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioc a b âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ioc_subset a b)
    exact Ioc_mem_nhds (ha i) (hb i)

theorem pi_Ioc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioc a' b' âˆˆ ğ“ x' :=
  pi_Ioc_mem_nhds ha hb

theorem pi_Ico_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ico a b âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ico_subset a b)
    exact Ico_mem_nhds (ha i) (hb i)

theorem pi_Ico_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ico a' b' âˆˆ ğ“ x' :=
  pi_Ico_mem_nhds ha hb

theorem pi_Ioo_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioo a b âˆˆ ğ“ x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ioo_subset a b)
    exact Ioo_mem_nhds (ha i) (hb i)

theorem pi_Ioo_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioo a' b' âˆˆ ğ“ x' :=
  pi_Ioo_mem_nhds ha hb

end Pi

theorem disjoint_nhds_at_top [NoTopOrder Î±] (x : Î±) : Disjoint (ğ“ x) at_top :=
  by 
    rw [Filter.disjoint_iff]
    cases' no_top x with a ha 
    use Iio a, Iio_mem_nhds ha, Ici a, mem_at_top a 
    rw [inter_comm, Ici_inter_Iio, Ico_self]

@[simp]
theorem inf_nhds_at_top [NoTopOrder Î±] (x : Î±) : ğ“ xâŠ“at_top = âŠ¥ :=
  disjoint_iff.1 (disjoint_nhds_at_top x)

theorem disjoint_nhds_at_bot [NoBotOrder Î±] (x : Î±) : Disjoint (ğ“ x) at_bot :=
  @disjoint_nhds_at_top (OrderDual Î±) _ _ _ _ x

@[simp]
theorem inf_nhds_at_bot [NoBotOrder Î±] (x : Î±) : ğ“ xâŠ“at_bot = âŠ¥ :=
  @inf_nhds_at_top (OrderDual Î±) _ _ _ _ x

theorem not_tendsto_nhds_of_tendsto_at_top [NoTopOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±}
  (hf : tendsto f F at_top) (x : Î±) : Â¬tendsto f F (ğ“ x) :=
  hf.not_tendsto (disjoint_nhds_at_top x).symm

theorem not_tendsto_at_top_of_tendsto_nhds [NoTopOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±} {x : Î±}
  (hf : tendsto f F (ğ“ x)) : Â¬tendsto f F at_top :=
  hf.not_tendsto (disjoint_nhds_at_top x)

theorem not_tendsto_nhds_of_tendsto_at_bot [NoBotOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±}
  (hf : tendsto f F at_bot) (x : Î±) : Â¬tendsto f F (ğ“ x) :=
  hf.not_tendsto (disjoint_nhds_at_bot x).symm

theorem not_tendsto_at_bot_of_tendsto_nhds [NoBotOrder Î±] {F : Filter Î²} [ne_bot F] {f : Î² â†’ Î±} {x : Î±}
  (hf : tendsto f F (ğ“ x)) : Â¬tendsto f F at_bot :=
  hf.not_tendsto (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/


/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +âˆ)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u âˆˆ (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ioi {a b : Î±} (hab : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Ioi a] a, s âˆˆ ğ“[Ioc a b] a, s âˆˆ ğ“[Ioo a b] a, âˆƒ (u : _)(_ : u âˆˆ Ioc a b), Ioo a u âŠ† s,
      âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioo a u âŠ† s] :=
  by 
    tfaeHave 1 â†” 2
    Â·
      rw [nhds_within_Ioc_eq_nhds_within_Ioi hab]
    tfaeHave 1 â†” 3
    Â·
      rw [nhds_within_Ioo_eq_nhds_within_Ioi hab]
    tfaeHave 4 â†’ 5 
    exact fun âŸ¨u, umem, huâŸ© => âŸ¨u, umem.1, huâŸ©
    tfaeHave 5 â†’ 1
    Â·
      rintro âŸ¨u, hau, huâŸ©
      exact mem_of_superset (Ioo_mem_nhds_within_Ioi âŸ¨le_reflâ‚“ a, hauâŸ©) hu 
    tfaeHave 1 â†’ 4
    Â·
      intro h 
      rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with âŸ¨v, va, hvâŸ©
      rcases exists_Ico_subset_of_mem_nhds' va hab with âŸ¨u, au, huâŸ©
      refine' âŸ¨u, au, fun x hx => _âŸ©
      refine' hv âŸ¨hu âŸ¨le_of_ltâ‚“ hx.1, hx.2âŸ©, _âŸ©
      exact hx.1
    tfaeFinish

theorem mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioc a u'), Ioo a u âŠ† s :=
  (tfae_mem_nhds_within_Ioi hu' s).out 0 3

/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioo a u âŠ† s :=
  (tfae_mem_nhds_within_Ioi hu' s).out 0 4

/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset [NoTopOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioo a u âŠ† s :=
  let âŸ¨u', hu'âŸ© := no_top a 
  mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioc_subset [NoTopOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ioc a u âŠ† s :=
  by 
    rw [mem_nhds_within_Ioi_iff_exists_Ioo_subset]
    split 
    Â·
      rintro âŸ¨u, au, asâŸ©
      rcases exists_between au with âŸ¨v, hvâŸ©
      exact âŸ¨v, hv.1, fun x hx => as âŸ¨hx.1, lt_of_le_of_ltâ‚“ hx.2 hv.2âŸ©âŸ©
    Â·
      rintro âŸ¨u, au, asâŸ©
      exact âŸ¨u, au, subset.trans Ioo_subset_Ioc_self asâŸ©

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-âˆ, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l âˆˆ [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
theorem tfae_mem_nhds_within_Iio {a b : Î±} (h : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Iio b] b, s âˆˆ ğ“[Ico a b] b, s âˆˆ ğ“[Ioo a b] b, âˆƒ (l : _)(_ : l âˆˆ Ico a b), Ioo l b âŠ† s,
      âˆƒ (l : _)(_ : l âˆˆ Iio b), Ioo l b âŠ† s] :=
  by 
    simpa only [exists_prop, OrderDual.exists, dual_Ioi, dual_Ioc, dual_Ioo] using
      tfae_mem_nhds_within_Ioi h.dual (of_dual â»Â¹' s)

theorem mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iio a] a â†” âˆƒ (l : _)(_ : l âˆˆ Ico l' a), Ioo l a âŠ† s :=
  (tfae_mem_nhds_within_Iio hl' s).out 0 3

/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iio a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioo l a âŠ† s :=
  (tfae_mem_nhds_within_Iio hl' s).out 0 4

/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset [NoBotOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iio a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioo l a âŠ† s :=
  let âŸ¨l', hl'âŸ© := no_bot a 
  mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ico_subset
[no_bot_order Î±]
[densely_ordered Î±]
{a : Î±}
{s : set Î±} : Â«expr â†” Â»(Â«expr âˆˆ Â»(s, Â«exprğ“[ ] Â»(Iio a, a)), Â«exprâˆƒ , Â»((l Â«expr âˆˆ Â» Iio a), Â«expr âŠ† Â»(Ico l a, s))) :=
begin
  have [] [":", expr Â«expr â†” Â»(Â«expr âˆˆ Â»(Â«expr â»Â¹' Â»(of_dual, s), Â«exprğ“[ ] Â»(Ioi (to_dual a), to_dual a)), _)] [":=", expr mem_nhds_within_Ioi_iff_exists_Ioc_subset],
  simpa [] [] ["only"] ["[", expr order_dual.exists, ",", expr exists_prop, ",", expr dual_Ioc, "]"] [] ["using", expr this]
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +âˆ)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u âˆˆ (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ici {a b : Î±} (hab : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Ici a] a, s âˆˆ ğ“[Icc a b] a, s âˆˆ ğ“[Ico a b] a, âˆƒ (u : _)(_ : u âˆˆ Ioc a b), Ico a u âŠ† s,
      âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ico a u âŠ† s] :=
  by 
    tfaeHave 1 â†” 2
    Â·
      rw [nhds_within_Icc_eq_nhds_within_Ici hab]
    tfaeHave 1 â†” 3
    Â·
      rw [nhds_within_Ico_eq_nhds_within_Ici hab]
    tfaeHave 4 â†’ 5 
    exact fun âŸ¨u, umem, huâŸ© => âŸ¨u, umem.1, huâŸ©
    tfaeHave 5 â†’ 1
    Â·
      rintro âŸ¨u, hau, huâŸ©
      exact mem_of_superset (Ico_mem_nhds_within_Ici âŸ¨le_reflâ‚“ a, hauâŸ©) hu 
    tfaeHave 1 â†’ 4
    Â·
      intro h 
      rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with âŸ¨v, va, hvâŸ©
      rcases exists_Ico_subset_of_mem_nhds' va hab with âŸ¨u, au, huâŸ©
      refine' âŸ¨u, au, fun x hx => _âŸ©
      refine' hv âŸ¨hu âŸ¨hx.1, hx.2âŸ©, _âŸ©
      exact hx.1
    tfaeFinish

theorem mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioc a u'), Ico a u âŠ† s :=
  (tfae_mem_nhds_within_Ici hu' s).out 0 3
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Î±} {s : Set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ico a u âŠ† s :=
  (tfae_mem_nhds_within_Ici hu' s).out 0 4
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset [NoTopOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Ico a u âŠ† s :=
  let âŸ¨u', hu'âŸ© := no_top a 
  mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset' [NoTopOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ (u : _)(_ : u âˆˆ Ioi a), Icc a u âŠ† s :=
  by 
    rw [mem_nhds_within_Ici_iff_exists_Ico_subset]
    split 
    Â·
      rintro âŸ¨u, au, asâŸ©
      rcases exists_between au with âŸ¨v, hvâŸ©
      exact âŸ¨v, hv.1, fun x hx => as âŸ¨hx.1, lt_of_le_of_ltâ‚“ hx.2 hv.2âŸ©âŸ©
    Â·
      rintro âŸ¨u, au, asâŸ©
      exact âŸ¨u, au, subset.trans Ico_subset_Icc_self asâŸ©

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-âˆ, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l âˆˆ [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
theorem tfae_mem_nhds_within_Iic {a b : Î±} (h : a < b) (s : Set Î±) :
  tfae
    [s âˆˆ ğ“[Iic b] b, s âˆˆ ğ“[Icc a b] b, s âˆˆ ğ“[Ioc a b] b, âˆƒ (l : _)(_ : l âˆˆ Ico a b), Ioc l b âŠ† s,
      âˆƒ (l : _)(_ : l âˆˆ Iio b), Ioc l b âŠ† s] :=
  by 
    simpa only [exists_prop, OrderDual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico] using
      tfae_mem_nhds_within_Ici h.dual (of_dual â»Â¹' s)

theorem mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Ico l' a), Ioc l a âŠ† s :=
  (tfae_mem_nhds_within_Iic hl' s).out 0 3
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Î±} {s : Set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioc l a âŠ† s :=
  (tfae_mem_nhds_within_Iic hl' s).out 0 4
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset [NoBotOrder Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Ioc l a âŠ† s :=
  let âŸ¨l', hl'âŸ© := no_bot a 
  mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset' [NoBotOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ (l : _)(_ : l âˆˆ Iio a), Icc l a âŠ† s :=
  by 
    convert @mem_nhds_within_Ici_iff_exists_Icc_subset' (OrderDual Î±) _ _ _ _ _ _ _ 
    simpRw [show âˆ€ u : OrderDual Î±, @Icc (OrderDual Î±) _ a u = @Icc Î± _ u a from fun u => dual_Icc]
    rfl

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset [NoTopOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Ici a] a â†” âˆƒ u, a < u âˆ§ Icc a u âŠ† s :=
  by 
    rw [mem_nhds_within_Ici_iff_exists_Ico_subset]
    split 
    Â·
      rintro âŸ¨u, au, asâŸ©
      rcases exists_between au with âŸ¨v, hvâŸ©
      exact âŸ¨v, hv.1, fun x hx => as âŸ¨hx.1, lt_of_le_of_ltâ‚“ hx.2 hv.2âŸ©âŸ©
    Â·
      rintro âŸ¨u, au, asâŸ©
      exact âŸ¨u, au, subset.trans Ico_subset_Icc_self asâŸ©

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset [NoBotOrder Î±] [DenselyOrdered Î±] {a : Î±} {s : Set Î±} :
  s âˆˆ ğ“[Iic a] a â†” âˆƒ l, l < a âˆ§ Icc l a âŠ† s :=
  by 
    rw [mem_nhds_within_Iic_iff_exists_Ioc_subset]
    split 
    Â·
      rintro âŸ¨l, la, asâŸ©
      rcases exists_between la with âŸ¨v, hvâŸ©
      refine' âŸ¨v, hv.2, fun x hx => as âŸ¨lt_of_lt_of_leâ‚“ hv.1 hx.1, hx.2âŸ©âŸ©
    Â·
      rintro âŸ¨l, la, asâŸ©
      exact âŸ¨l, la, subset.trans Ioc_subset_Icc_self asâŸ©

end LinearOrderâ‚“

section LinearOrderedAddCommGroup

variable [TopologicalSpace Î±] [LinearOrderedAddCommGroup Î±] [OrderTopology Î±]

variable {l : Filter Î²} {f g : Î² â†’ Î±}

theorem nhds_eq_infi_abs_sub (a : Î±) : ğ“ a = â¨…(r : _)(_ : r > 0), ğ“Ÿ { b | |a - b| < r } :=
  by 
    simp only [le_antisymm_iffâ‚“, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi, mem_Iio,
      abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt _ _ _ _ a, set_of_and]
    refine' âŸ¨_, _, _âŸ©
    Â·
      intro Îµ Îµ0 
      exact
        inter_mem_inf (mem_infi_of_mem (a - Îµ)$ mem_infi_of_mem (sub_lt_self a Îµ0) (mem_principal_self _))
          (mem_infi_of_mem (Îµ+a)$
            mem_infi_of_mem
              (by 
                simpa)
              (mem_principal_self _))
    Â·
      intro b hb 
      exact
        mem_infi_of_mem (a - b)
          (mem_infi_of_mem (sub_pos.2 hb)
            (by 
              simp [Ioi]))
    Â·
      intro b hb 
      exact
        mem_infi_of_mem (b - a)
          (mem_infi_of_mem (sub_pos.2 hb)
            (by 
              simp [Iio]))

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem order_topology_of_nhds_abs
{Î± : Type*}
[topological_space Î±]
[linear_ordered_add_comm_group Î±]
(h_nhds : âˆ€
 a : Î±, Â«expr = Â»(exprğ“() a, Â«exprâ¨… , Â»((r Â«expr > Â» 0), exprğ“Ÿ() {b | Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(a, b)), r)}))) : order_topology Î± :=
begin
  refine [expr âŸ¨Â«expr $ Â»(eq_of_nhds_eq_nhds, Î» a, _)âŸ©],
  rw ["[", expr h_nhds, "]"] [],
  letI [] [] [":=", expr preorder.topology Î±],
  letI [] [":", expr order_topology Î±] [":=", expr âŸ¨rflâŸ©],
  exact [expr (nhds_eq_infi_abs_sub a).symm]
end

theorem LinearOrderedAddCommGroup.tendsto_nhds {x : Filter Î²} {a : Î±} :
  tendsto f x (ğ“ a) â†” âˆ€ Îµ _ : Îµ > (0 : Î±), âˆ€á¶ b in x, |f b - a| < Îµ :=
  by 
    simp [nhds_eq_infi_abs_sub, abs_sub_comm a]

theorem eventually_abs_sub_lt (a : Î±) {Îµ : Î±} (hÎµ : 0 < Îµ) : âˆ€á¶ x in ğ“ a, |x - a| < Îµ :=
  (nhds_eq_infi_abs_sub a).symm â–¸
    mem_infi_of_mem Îµ
      (mem_infi_of_mem hÎµ$
        by 
          simp only [abs_sub_comm, mem_principal_self])

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[priority 100] instance linear_ordered_add_comm_group.topological_add_group : topological_add_group Î± :=
{ continuous_add := begin
    refine [expr continuous_iff_continuous_at.2 _],
    rintro ["âŸ¨", ident a, ",", ident b, "âŸ©"],
    refine [expr linear_ordered_add_comm_group.tendsto_nhds.2 (Î» Îµ Îµ0, _)],
    rcases [expr dense_or_discrete 0 Îµ, "with", "(", "âŸ¨", ident Î´, ",", ident Î´0, ",", ident Î´Îµ, "âŸ©", "|", "âŸ¨", ident hâ‚, ",", ident hâ‚‚, "âŸ©", ")"],
    { filter_upwards ["[", expr prod_is_open.mem_nhds (eventually_abs_sub_lt a Î´0) (eventually_abs_sub_lt b (sub_pos.2 Î´Îµ)), "]"] [],
      rintros ["âŸ¨", ident x, ",", ident y, "âŸ©", "âŸ¨", ident hx, ":", expr Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(x, a)), Î´), ",", ident hy, ":", expr Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(y, b)), Â«expr - Â»(Îµ, Î´)), "âŸ©"],
      rw ["[", expr add_sub_comm, "]"] [],
      calc
        Â«expr â‰¤ Â»(Â«expr| |Â»(Â«expr + Â»(Â«expr - Â»(x, a), Â«expr - Â»(y, b))), Â«expr + Â»(Â«expr| |Â»(Â«expr - Â»(x, a)), Â«expr| |Â»(Â«expr - Â»(y, b)))) : abs_add _ _
        Â«expr < Â»(..., Â«expr + Â»(Î´, Â«expr - Â»(Îµ, Î´))) : add_lt_add hx hy
        Â«expr = Â»(..., Îµ) : add_sub_cancel'_right _ _ },
    { have [ident hÎµ] [":", expr âˆ€ {x y}, Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(x, y)), Îµ) â†’ Â«expr = Â»(x, y)] [],
      { intros [ident x, ident y, ident h],
        simpa [] [] [] ["[", expr sub_eq_zero, "]"] [] ["using", expr hâ‚‚ _ h] },
      filter_upwards ["[", expr prod_is_open.mem_nhds (eventually_abs_sub_lt a Îµ0) (eventually_abs_sub_lt b Îµ0), "]"] [],
      rintros ["âŸ¨", ident x, ",", ident y, "âŸ©", "âŸ¨", ident hx, ":", expr Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(x, a)), Îµ), ",", ident hy, ":", expr Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(y, b)), Îµ), "âŸ©"],
      simpa [] [] [] ["[", expr hÎµ hx, ",", expr hÎµ hy, "]"] [] [] }
  end,
  continuous_neg := Â«expr $ Â»(continuous_iff_continuous_at.2, Î»
   a, Â«expr $ Â»(linear_ordered_add_comm_group.tendsto_nhds.2, Î»
    Îµ
    Îµ0, Â«expr $ Â»((eventually_abs_sub_lt a Îµ0).mono, Î»
     x hx, by rwa ["[", expr neg_sub_neg, ",", expr abs_sub_comm, "]"] []))) }

@[continuity]
theorem continuous_abs : Continuous (abs : Î± â†’ Î±) :=
  continuous_id.max continuous_neg

theorem Filter.Tendsto.abs {f : Î² â†’ Î±} {a : Î±} {l : Filter Î²} (h : tendsto f l (ğ“ a)) :
  tendsto (fun x => |f x|) l (ğ“ |a|) :=
  (continuous_abs.Tendsto _).comp h

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_zero_iff_abs_tendsto_zero
(f : Î² â†’ Î±)
{l : filter Î²} : Â«expr â†” Â»(tendsto f l (exprğ“() 0), tendsto Â«expr âˆ˜ Â»(abs, f) l (exprğ“() 0)) :=
begin
  refine [expr âŸ¨Î» h, Â«expr â–¸ Â»((abs_zero : Â«expr = Â»(Â«expr| |Â»((0 : Î±)), 0)), h.abs), Î» h, _âŸ©],
  have [] [":", expr tendsto (Î»
    a, Â«expr- Â»(Â«expr| |Â»(f a))) l (exprğ“() 0)] [":=", expr Â«expr â–¸ Â»((neg_zero : Â«expr = Â»(Â«expr- Â»((0 : Î±)), 0)), h.neg)],
  exact [expr tendsto_of_tendsto_of_tendsto_of_le_of_le this h (Î»
    x, Â«expr $ Â»(neg_abs_le_self, f x)) (Î» x, Â«expr $ Â»(le_abs_self, f x))]
end

theorem nhds_basis_Ioo_pos [NoBotOrder Î±] [NoTopOrder Î±] (a : Î±) :
  (ğ“ a).HasBasis (fun Îµ : Î± => (0 : Î±) < Îµ) fun Îµ => Ioo (a - Îµ) (a+Îµ) :=
  âŸ¨by 
      refine' fun t => (nhds_basis_Ioo a).mem_iff.trans âŸ¨_, _âŸ©
      Â·
        rintro âŸ¨âŸ¨l, uâŸ©, âŸ¨hl : l < a, hu : a < uâŸ©, h' : Ioo l u âŠ† tâŸ©
        refine'
          âŸ¨min (a - l) (u - a),
            by 
              apply lt_minâ‚“ <;> rwa [sub_pos],
            _âŸ©
        rintro x âŸ¨hx, hx'âŸ©
        apply h' 
        rw [sub_lt, lt_min_iff, sub_lt_sub_iff_left] at hx 
        rw [â†sub_lt_iff_lt_add', lt_min_iff, sub_lt_sub_iff_right] at hx' 
        exact âŸ¨hx.1, hx'.2âŸ©
      Â·
        rintro âŸ¨Îµ, Îµ_pos, hâŸ©
        exact
          âŸ¨(a - Îµ, a+Îµ),
            by 
              simp [Îµ_pos],
            hâŸ©âŸ©

theorem nhds_basis_abs_sub_lt [NoBotOrder Î±] [NoTopOrder Î±] (a : Î±) :
  (ğ“ a).HasBasis (fun Îµ : Î± => (0 : Î±) < Îµ) fun Îµ => { b | |b - a| < Îµ } :=
  by 
    convert nhds_basis_Ioo_pos a
    Â·
      ext Îµ 
      change |x - a| < Îµ â†” a - Îµ < x âˆ§ x < a+Îµ 
      simp [abs_lt, sub_lt_iff_lt_add, add_commâ‚“ Îµ a, add_commâ‚“ x Îµ]

variable (Î±)

theorem nhds_basis_zero_abs_sub_lt [NoBotOrder Î±] [NoTopOrder Î±] :
  (ğ“ (0 : Î±)).HasBasis (fun Îµ : Î± => (0 : Î±) < Îµ) fun Îµ => { b | |b| < Îµ } :=
  by 
    simpa using nhds_basis_abs_sub_lt (0 : Î±)

variable {Î±}

/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/
theorem nhds_basis_Ioo_pos_of_pos [NoBotOrder Î±] [NoTopOrder Î±] {a : Î±} (ha : 0 < a) :
  (ğ“ a).HasBasis (fun Îµ : Î± => (0 : Î±) < Îµ âˆ§ Îµ â‰¤ a) fun Îµ => Ioo (a - Îµ) (a+Îµ) :=
  âŸ¨fun t =>
      (nhds_basis_Ioo_pos a).mem_iff.trans
        âŸ¨fun h =>
            let âŸ¨i, hi, hitâŸ© := h
            âŸ¨min i a, âŸ¨lt_minâ‚“ hi ha, min_le_rightâ‚“ i aâŸ©,
              trans (Ioo_subset_Ioo (sub_le_sub_left (min_le_leftâ‚“ i a) a) (add_le_add_left (min_le_leftâ‚“ i a) a)) hitâŸ©,
          fun h =>
            let âŸ¨i, hi, hitâŸ© := h
            âŸ¨i, hi.1, hitâŸ©âŸ©âŸ©

section 

variable [TopologicalSpace Î²] {b : Î²} {a : Î±} {s : Set Î²}

theorem Continuous.abs (h : Continuous f) : Continuous fun x => |f x| :=
  continuous_abs.comp h

theorem ContinuousAt.abs (h : ContinuousAt f b) : ContinuousAt (fun x => |f x|) b :=
  h.abs

theorem ContinuousWithinAt.abs (h : ContinuousWithinAt f s b) : ContinuousWithinAt (fun x => |f x|) s b :=
  h.abs

theorem ContinuousOn.abs (h : ContinuousOn f s) : ContinuousOn (fun x => |f x|) s :=
  fun x hx => (h x hx).abs

theorem tendsto_abs_nhds_within_zero : tendsto (abs : Î± â†’ Î±) (ğ“[Â«expr á¶œÂ» {0}] 0) (ğ“[Ioi 0] 0) :=
  (continuous_abs.tendsto' (0 : Î±) 0 abs_zero).inf$ tendsto_principal_principal.2$ fun x => abs_pos.2

end 

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.add_at_top {C : Î±} (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  by 
    nontriviality Î± 
    obtain âŸ¨C', hC'âŸ© : âˆƒ C', C' < C := no_bot C 
    refine' tendsto_at_top_add_left_of_le' _ C' _ hg 
    exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_ltâ‚“

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.add_at_bot {C : Î±} (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @Filter.Tendsto.add_at_top (OrderDual Î±) _ _ _ _ _ _ _ _ hf hg

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.at_top_add {C : Î±} (hf : tendsto f l at_top) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x+g x) l at_top :=
  by 
    conv  in _+_ => rw [add_commâ‚“]
    exact hg.add_at_top hf

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_bot_add {C : Î±} (hf : tendsto f l at_bot) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x+g x) l at_bot :=
  by 
    conv  in _+_ => rw [add_commâ‚“]
    exact hg.add_at_bot hf

end LinearOrderedAddCommGroup

section LinearOrderedField

variable [LinearOrderedField Î±] [TopologicalSpace Î±] [OrderTopology Î±]

variable {l : Filter Î²} {f g : Î² â†’ Î±}

section continuous_mul

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mul_tendsto_nhds_zero_right
(x : Î±) : Â«expr $ Â»(tendsto (uncurry ((Â«expr * Â») : Î± â†’ Î± â†’ Î±)) Â«expr Ã—á¶  Â»(exprğ“() 0, exprğ“() x), exprğ“() 0) :=
begin
  have [ident hx] [":", expr Â«expr < Â»(0, Â«expr * Â»(2, Â«expr + Â»(1, Â«expr| |Â»(x))))] [":=", expr Â«expr $ Â»(mul_pos zero_lt_two, Â«expr $ Â»(lt_of_lt_of_le zero_lt_one, le_add_of_le_of_nonneg le_rfl (abs_nonneg x)))],
  rw [expr Â«expr $ Â»((nhds_basis_zero_abs_sub_lt Î±).prod, nhds_basis_abs_sub_lt x).tendsto_iff (nhds_basis_zero_abs_sub_lt Î±)] [],
  refine [expr Î»
   Îµ Îµ_pos, âŸ¨(Â«expr / Â»(Îµ, Â«expr * Â»(2, Â«expr + Â»(1, Â«expr| |Â»(x)))), 1), âŸ¨div_pos Îµ_pos hx, zero_lt_oneâŸ©, _âŸ©],
  suffices [] [":", expr âˆ€
   a
   b : Î±, Â«expr < Â»(Â«expr| |Â»(a), Â«expr / Â»(Îµ, Â«expr * Â»(2, Â«expr + Â»(1, Â«expr| |Â»(x))))) â†’ Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(b, x)), 1) â†’ Â«expr < Â»(Â«expr * Â»(Â«expr| |Â»(a), Â«expr| |Â»(b)), Îµ)],
  by simpa [] [] ["only"] ["[", expr and_imp, ",", expr prod.forall, ",", expr mem_prod, ",", "<-", expr abs_mul, "]"] [] [],
  intros [ident a, ident b, ident h, ident h'],
  refine [expr lt_of_le_of_lt (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h)],
  calc
    Â«expr = Â»(Â«expr| |Â»(b), Â«expr| |Â»(Â«expr + Â»(Â«expr - Â»(b, x), x))) : by rw [expr sub_add_cancel b x] []
    Â«expr â‰¤ Â»(..., Â«expr + Â»(Â«expr| |Â»(Â«expr - Â»(b, x)), Â«expr| |Â»(x))) : abs_add Â«expr - Â»(b, x) x
    Â«expr â‰¤ Â»(..., Â«expr + Â»(1, Â«expr| |Â»(x))) : add_le_add_right (le_of_lt h') Â«expr| |Â»(x)
    Â«expr â‰¤ Â»(..., Â«expr * Â»(2, Â«expr + Â»(1, Â«expr| |Â»(x)))) : by linarith [] [] []
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mul_tendsto_nhds_zero_left
(x : Î±) : Â«expr $ Â»(tendsto (uncurry ((Â«expr * Â») : Î± â†’ Î± â†’ Î±)) Â«expr Ã—á¶  Â»(exprğ“() x, exprğ“() 0), exprğ“() 0) :=
begin
  intros [ident s, ident hs],
  have [] [] [":=", expr mul_tendsto_nhds_zero_right x hs],
  rw ["[", expr filter.mem_map, ",", expr mem_prod_iff, "]"] ["at", ident this, "âŠ¢"],
  obtain ["âŸ¨", ident U, ",", ident hU, ",", ident V, ",", ident hV, ",", ident h, "âŸ©", ":=", expr this],
  exact [expr âŸ¨V, hV, U, hU, Î»
    y
    hy, (Â«expr â–¸ Â»(mul_comm y.2 y.1, h (âŸ¨hy.2, hy.1âŸ© : Â«expr âˆˆ Â»(prod.mk y.2 y.1, U.prod V))) : Â«expr âˆˆ Â»(Â«expr * Â»(y.1, y.2), s))âŸ©]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nhds_eq_map_mul_left_nhds_one
{xâ‚€ : Î±}
(hxâ‚€ : Â«expr â‰  Â»(xâ‚€, 0)) : Â«expr = Â»(exprğ“() xâ‚€, map (Î» x, Â«expr * Â»(xâ‚€, x)) (exprğ“() 1)) :=
begin
  have [ident hxâ‚€'] [":", expr Â«expr < Â»(0, Â«expr| |Â»(xâ‚€))] [":=", expr abs_pos.2 hxâ‚€],
  refine [expr filter.ext (Î» t, _)],
  simp [] [] ["only"] ["[", expr exists_prop, ",", expr set_of_subset_set_of, ",", expr (nhds_basis_abs_sub_lt xâ‚€).mem_iff, ",", expr (nhds_basis_abs_sub_lt (1 : Î±)).mem_iff, ",", expr filter.mem_map', "]"] [] [],
  refine [expr âŸ¨Î» h, _, Î» h, _âŸ©],
  { obtain ["âŸ¨", ident i, ",", ident hi, ",", ident hit, "âŸ©", ":=", expr h],
    refine [expr âŸ¨Â«expr / Â»(i, Â«expr| |Â»(xâ‚€)), div_pos hi (abs_pos.2 hxâ‚€), Î» x hx, hit _âŸ©],
    calc
      Â«expr = Â»(Â«expr| |Â»(Â«expr - Â»(Â«expr * Â»(xâ‚€, x), xâ‚€)), Â«expr| |Â»(Â«expr * Â»(xâ‚€, Â«expr - Â»(x, 1)))) : congr_arg abs (by ring_nf [] [] [])
      Â«expr = Â»(..., Â«expr * Â»(Â«expr| |Â»(xâ‚€), Â«expr| |Â»(Â«expr - Â»(x, 1)))) : abs_mul xâ‚€ Â«expr - Â»(x, 1)
      Â«expr < Â»(..., Â«expr * Â»(Â«expr| |Â»(xâ‚€), Â«expr / Â»(i, Â«expr| |Â»(xâ‚€)))) : mul_lt_mul' le_rfl hx (abs_nonneg Â«expr - Â»(x, 1)) (abs_pos.2 hxâ‚€)
      Â«expr = Â»(..., Â«expr / Â»(Â«expr * Â»(Â«expr| |Â»(xâ‚€), i), Â«expr| |Â»(xâ‚€))) : by ring []
      Â«expr = Â»(..., i) : mul_div_cancel_left i (Î» h, hxâ‚€ (abs_eq_zero.1 h)) },
  { obtain ["âŸ¨", ident i, ",", ident hi, ",", ident hit, "âŸ©", ":=", expr h],
    refine [expr âŸ¨Â«expr * Â»(i, Â«expr| |Â»(xâ‚€)), mul_pos hi (abs_pos.2 hxâ‚€), Î» x hx, _âŸ©],
    have [] [":", expr Â«expr < Â»(Â«expr| |Â»(Â«expr - Â»(Â«expr / Â»(x, xâ‚€), 1)), i)] [],
    calc
      Â«expr = Â»(Â«expr| |Â»(Â«expr - Â»(Â«expr / Â»(x, xâ‚€), 1)), Â«expr| |Â»(Â«expr - Â»(Â«expr / Â»(x, xâ‚€), Â«expr / Â»(xâ‚€, xâ‚€)))) : by rw [expr div_self hxâ‚€] []
      Â«expr = Â»(..., Â«expr| |Â»(Â«expr / Â»(Â«expr - Â»(x, xâ‚€), xâ‚€))) : congr_arg abs (sub_div x xâ‚€ xâ‚€).symm
      Â«expr = Â»(..., Â«expr / Â»(Â«expr| |Â»(Â«expr - Â»(x, xâ‚€)), Â«expr| |Â»(xâ‚€))) : abs_div Â«expr - Â»(x, xâ‚€) xâ‚€
      Â«expr < Â»(..., Â«expr / Â»(Â«expr * Â»(i, Â«expr| |Â»(xâ‚€)), Â«expr| |Â»(xâ‚€))) : div_lt_div hx le_rfl (mul_nonneg (le_of_lt hi) (abs_nonneg xâ‚€)) (abs_pos.2 hxâ‚€)
      Â«expr = Â»(..., i) : by rw ["[", "<-", expr mul_div_assoc', ",", expr div_self Â«expr $ Â»(ne_of_lt, abs_pos.2 hxâ‚€).symm, ",", expr mul_one, "]"] [],
    specialize [expr hit Â«expr / Â»(x, xâ‚€) this],
    rwa ["[", expr mul_div_assoc', ",", expr mul_div_cancel_left x hxâ‚€, "]"] ["at", ident hit] }
end

theorem nhds_eq_map_mul_right_nhds_one {xâ‚€ : Î±} (hxâ‚€ : xâ‚€ â‰  0) : ğ“ xâ‚€ = map (fun x => x*xâ‚€) (ğ“ 1) :=
  by 
    simpRw [mul_commâ‚“ _ xâ‚€, nhds_eq_map_mul_left_nhds_one hxâ‚€]

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mul_tendsto_nhds_one_nhds_one : Â«expr $ Â»(tendsto (uncurry ((Â«expr * Â») : Î± â†’ Î± â†’ Î±)) Â«expr Ã—á¶  Â»(exprğ“() 1, exprğ“() 1), exprğ“() 1) :=
begin
  rw [expr Â«expr $ Â»((nhds_basis_Ioo_pos (1 : Î±)).prod, nhds_basis_Ioo_pos (1 : Î±)).tendsto_iff (nhds_basis_Ioo_pos_of_pos (zero_lt_one : Â«expr < Â»((0 : Î±), 1)))] [],
  intros [ident Îµ, ident hÎµ],
  have [ident hÎµ'] [":", expr Â«expr â‰¤ Â»(0, Â«expr - Â»(1, Â«expr / Â»(Îµ, 4)))] [":=", expr by linarith [] [] []],
  have [ident Îµ_pos] [":", expr Â«expr < Â»(0, Â«expr / Â»(Îµ, 4))] [":=", expr by linarith [] [] []],
  have [ident Îµ_pos'] [":", expr Â«expr < Â»(0, Â«expr / Â»(Îµ, 2))] [":=", expr by linarith [] [] []],
  simp [] [] ["only"] ["[", expr and_imp, ",", expr prod.forall, ",", expr mem_Ioo, ",", expr function.uncurry_apply_pair, ",", expr mem_prod, ",", expr prod.exists, "]"] [] [],
  refine [expr âŸ¨Â«expr / Â»(Îµ, 4), Â«expr / Â»(Îµ, 4), âŸ¨Îµ_pos, Îµ_posâŸ©, Î» a b ha ha' hb hb', _âŸ©],
  have [ident ha0] [":", expr Â«expr â‰¤ Â»(0, a)] [":=", expr le_trans hÎµ' (le_of_lt ha)],
  have [ident hb0] [":", expr Â«expr â‰¤ Â»(0, b)] [":=", expr le_trans hÎµ' (le_of_lt hb)],
  refine [expr âŸ¨lt_of_le_of_lt _ (mul_lt_mul'' ha hb hÎµ' hÎµ'), lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _âŸ©],
  { calc
      Â«expr = Â»(Â«expr - Â»(1, Îµ), Â«expr - Â»(Â«expr - Â»(1, Â«expr / Â»(Îµ, 2)), Â«expr / Â»(Îµ, 2))) : by ring_nf [] [] []
      Â«expr â‰¤ Â»(..., Â«expr + Â»(Â«expr - Â»(Â«expr - Â»(1, Â«expr / Â»(Îµ, 2)), Â«expr / Â»(Îµ, 2)), Â«expr * Â»(Â«expr / Â»(Îµ, 2), Â«expr / Â»(Îµ, 2)))) : le_add_of_nonneg_right (le_of_lt (mul_pos Îµ_pos' Îµ_pos'))
      Â«expr = Â»(..., Â«expr * Â»(Â«expr - Â»(1, Â«expr / Â»(Îµ, 2)), Â«expr - Â»(1, Â«expr / Â»(Îµ, 2)))) : by ring_nf [] [] []
      Â«expr â‰¤ Â»(..., Â«expr * Â»(Â«expr - Â»(1, Â«expr / Â»(Îµ, 4)), Â«expr - Â»(1, Â«expr / Â»(Îµ, 4)))) : mul_le_mul (by linarith [] [] []) (by linarith [] [] []) (by linarith [] [] []) hÎµ' },
  { calc
      Â«expr = Â»(Â«expr * Â»(Â«expr + Â»(1, Â«expr / Â»(Îµ, 4)), Â«expr + Â»(1, Â«expr / Â»(Îµ, 4))), Â«expr + Â»(Â«expr + Â»(1, Â«expr / Â»(Îµ, 2)), Â«expr * Â»(Â«expr / Â»(Îµ, 4), Â«expr / Â»(Îµ, 4)))) : by ring_nf [] [] []
      Â«expr = Â»(..., Â«expr + Â»(Â«expr + Â»(1, Â«expr / Â»(Îµ, 2)), Â«expr / Â»(Â«expr * Â»(Îµ, Îµ), 16))) : by ring_nf [] [] []
      Â«expr â‰¤ Â»(..., Â«expr + Â»(Â«expr + Â»(1, Â«expr / Â»(Îµ, 2)), Â«expr / Â»(Îµ, 2))) : add_le_add_left (div_le_div (le_of_lt hÎµ.1) (le_trans ((mul_le_mul_left hÎµ.1).2 hÎµ.2) Â«expr $ Â»(le_of_eq, mul_one Îµ)) zero_lt_two (by linarith [] [] [])) Â«expr + Â»(1, Â«expr / Â»(Îµ, 2))
      Â«expr â‰¤ Â»(..., Â«expr + Â»(1, Îµ)) : by ring_nf [] [] [] }
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[priority 100] instance linear_ordered_field.has_continuous_mul : has_continuous_mul Î± :=
âŸ¨begin
   rw [expr continuous_iff_continuous_at] [],
   rintro ["âŸ¨", ident xâ‚€, ",", ident yâ‚€, "âŸ©"],
   by_cases [expr hxâ‚€, ":", expr Â«expr = Â»(xâ‚€, 0)],
   { rw ["[", expr hxâ‚€, ",", expr continuous_at, ",", expr zero_mul, ",", expr nhds_prod_eq, "]"] [],
     exact [expr mul_tendsto_nhds_zero_right yâ‚€] },
   by_cases [expr hyâ‚€, ":", expr Â«expr = Â»(yâ‚€, 0)],
   { rw ["[", expr hyâ‚€, ",", expr continuous_at, ",", expr mul_zero, ",", expr nhds_prod_eq, "]"] [],
     exact [expr mul_tendsto_nhds_zero_left xâ‚€] },
   have [ident hxy] [":", expr Â«expr â‰  Â»(Â«expr * Â»(xâ‚€, yâ‚€), 0)] [":=", expr mul_ne_zero hxâ‚€ hyâ‚€],
   have [ident key] [":", expr Â«expr = Â»(Î»
     p : Â«expr Ã— Â»(Î±, Î±), Â«expr * Â»(Â«expr * Â»(xâ‚€, p.1), Â«expr * Â»(p.2, yâ‚€)), Â«expr âˆ˜ Â»(Â«expr âˆ˜ Â»(Î»
       x, Â«expr * Â»(xâ‚€, x), Î» x, Â«expr * Â»(x, yâ‚€)), uncurry ((Â«expr * Â»))))] [],
   { ext [] [ident p] [],
     simp [] [] [] ["[", expr uncurry, ",", expr mul_assoc, "]"] [] [] },
   have [ident keyâ‚‚] [":", expr Â«expr = Â»(Â«expr âˆ˜ Â»(Î»
      x, Â«expr * Â»(xâ‚€, x), Î» x, Â«expr * Â»(yâ‚€, x)), Î» x, Â«expr * Â»(Â«expr * Â»(xâ‚€, yâ‚€), x))] [],
   { ext [] [ident x] [],
     simp [] [] [] [] [] [] },
   calc
     Â«expr = Â»(map (uncurry ((Â«expr * Â»))) (exprğ“() (xâ‚€, yâ‚€)), map (uncurry ((Â«expr * Â»))) Â«expr Ã—á¶  Â»(exprğ“() xâ‚€, exprğ“() yâ‚€)) : by rw [expr nhds_prod_eq] []
     Â«expr = Â»(..., map (Î»
       p : Â«expr Ã— Â»(Î±, Î±), Â«expr * Â»(Â«expr * Â»(xâ‚€, p.1), Â«expr * Â»(p.2, yâ‚€))) Â«expr Ã—á¶  Â»(exprğ“() 1, exprğ“() 1)) : by rw ["[", expr uncurry, ",", expr nhds_eq_map_mul_left_nhds_one hxâ‚€, ",", expr nhds_eq_map_mul_right_nhds_one hyâ‚€, ",", expr prod_map_map_eq, ",", expr filter.map_map, "]"] []
     Â«expr = Â»(..., map Â«expr âˆ˜ Â»(Î»
       x, Â«expr * Â»(xâ‚€, x), Î»
       x, Â«expr * Â»(x, yâ‚€)) (map (uncurry ((Â«expr * Â»))) Â«expr Ã—á¶  Â»(exprğ“() 1, exprğ“() 1))) : by rw ["[", expr key, ",", "<-", expr filter.map_map, "]"] []
     Â«expr â‰¤ Â»(..., map Â«expr âˆ˜ Â»(Î»
       x : Î±, Â«expr * Â»(xâ‚€, x), Î» x, Â«expr * Â»(x, yâ‚€)) (exprğ“() 1)) : map_mono mul_tendsto_nhds_one_nhds_one
     Â«expr = Â»(..., exprğ“() Â«expr * Â»(xâ‚€, yâ‚€)) : by rw ["[", "<-", expr filter.map_map, ",", "<-", expr nhds_eq_map_mul_right_nhds_one hyâ‚€, ",", expr nhds_eq_map_mul_left_nhds_one hyâ‚€, ",", expr filter.map_map, ",", expr keyâ‚‚, ",", "<-", expr nhds_eq_map_mul_left_nhds_one hxy, "]"] []
 endâŸ©

end continuous_mul

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a positive constant `C` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.at_top_mul {C : Î±} (hC : 0 < C) (hf : tendsto f l at_top) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    refine' tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))
    filterUpwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually (eventually_ge_at_top 0)]
    exact fun x hg hf => mul_le_mul_of_nonneg_left hg.le hf

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.mul_at_top {C : Î±} (hC : 0 < C) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa only [mul_commâ‚“] using hg.at_top_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a negative constant `C` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_top_mul_neg {C : Î±} (hC : C < 0) (hf : tendsto f l at_top) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [Â· âˆ˜ Â·, neg_mul_eq_mul_neg, neg_negâ‚“] using
      tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.neg_mul_at_top {C : Î±} (hC : C < 0) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [mul_commâ‚“] using hg.at_top_mul_neg hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a positive constant `C` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_bot_mul {C : Î±} (hC : 0 < C) (hf : tendsto f l at_bot) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa [Â· âˆ˜ Â·] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a negative constant `C` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.at_bot_mul_neg {C : Î±} (hC : C < 0) (hf : tendsto f l at_bot) (hg : tendsto g l (ğ“ C)) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa [Â· âˆ˜ Â·] using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.mul_at_bot {C : Î±} (hC : 0 < C) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [mul_commâ‚“] using hg.at_bot_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.neg_mul_at_bot {C : Î±} (hC : C < 0) (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa only [mul_commâ‚“] using hg.at_bot_mul_neg hC hf

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `x â†¦ xâ»Â¹` tends to `+âˆ` on the right of `0`. -/
theorem tendsto_inv_zero_at_top : tendsto (Î» x : Î±, Â«expr â»Â¹Â»(x)) Â«exprğ“[ ] Â»(set.Ioi (0 : Î±), 0) at_top :=
begin
  refine [expr (at_top_basis' 1).tendsto_right_iff.2 (Î» b hb, _)],
  have [ident hb'] [":", expr Â«expr < Â»(0, b)] [":=", expr zero_lt_one.trans_le hb],
  filter_upwards ["[", expr Ioc_mem_nhds_within_Ioi âŸ¨le_rfl, inv_pos.2 hb'âŸ©, "]"] [],
  exact [expr Î» x hx, (le_inv hx.1 hb').1 hx.2]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆ`. -/
theorem tendsto_inv_at_top_zero' : tendsto (Î» r : Î±, Â«expr â»Â¹Â»(r)) at_top Â«exprğ“[ ] Â»(set.Ioi (0 : Î±), 0) :=
begin
  refine [expr (has_basis.tendsto_iff at_top_basis âŸ¨Î» s, mem_nhds_within_Ioi_iff_exists_Ioc_subsetâŸ©).2 _],
  refine [expr Î» b hb, âŸ¨Â«expr â»Â¹Â»(b), trivial, Î» x hx, _âŸ©],
  have [] [":", expr Â«expr < Â»(0, x)] [":=", expr lt_of_lt_of_le (inv_pos.2 hb) hx],
  exact [expr âŸ¨inv_pos.2 this, (inv_le this hb).2 hxâŸ©]
end

theorem tendsto_inv_at_top_zero : tendsto (fun r : Î± => râ»Â¹) at_top (ğ“ 0) :=
  tendsto_inv_at_top_zero'.mono_right inf_le_left

theorem Filter.Tendsto.div_at_top [HasContinuousMul Î±] {f g : Î² â†’ Î±} {l : Filter Î²} {a : Î±} (h : tendsto f l (ğ“ a))
  (hg : tendsto g l at_top) : tendsto (fun x => f x / g x) l (ğ“ 0) :=
  by 
    simp only [div_eq_mul_inv]
    exact mul_zero a â–¸ h.mul (tendsto_inv_at_top_zero.comp hg)

theorem Filter.Tendsto.inv_tendsto_at_top (h : tendsto f l at_top) : tendsto (fâ»Â¹) l (ğ“ 0) :=
  tendsto_inv_at_top_zero.comp h

theorem Filter.Tendsto.inv_tendsto_zero (h : tendsto f l (ğ“[Set.Ioi 0] 0)) : tendsto (fâ»Â¹) l at_top :=
  tendsto_inv_zero_at_top.comp h

/-- The function `x^(-n)` tends to `0` at `+âˆ` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_neg_at_top`. -/
theorem tendsto_pow_neg_at_top {n : â„•} (hn : 1 â‰¤ n) : tendsto (fun x : Î± => x ^ -(n : â„¤)) at_top (ğ“ 0) :=
  tendsto.congr (fun x => (zpow_negâ‚€ x n).symm)
    (Filter.Tendsto.inv_tendsto_at_top
      (by 
        simpa [zpow_coe_nat] using tendsto_pow_at_top hn))

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_zpow_at_top_zero
{n : exprâ„¤()}
(hn : Â«expr < Â»(n, 0)) : tendsto (Î» x : Î±, Â«expr ^ Â»(x, n)) at_top (exprğ“() 0) :=
begin
  have [] [":", expr Â«expr â‰¤ Â»(1, Â«expr- Â»(n))] [":=", expr le_neg.mp (int.le_of_lt_add_one (hn.trans_le (neg_add_self 1).symm.le))],
  apply [expr tendsto.congr (show âˆ€
    x : Î±, Â«expr = Â»(Â«expr ^ Â»(x, Â«expr- Â»(Â«expr- Â»(n))), Â«expr ^ Â»(x, n)), by simp [] [] [] [] [] [])],
  lift [expr Â«expr- Â»(n)] ["to", expr exprâ„•()] ["using", expr le_of_lt (neg_pos.mpr hn)] ["with", ident N],
  exact [expr tendsto_pow_neg_at_top (by exact_mod_cast [expr this])]
end

theorem tendsto_const_mul_zpow_at_top_zero {n : â„¤} {c : Î±} (hn : n < 0) : tendsto (fun x => c*x ^ n) at_top (ğ“ 0) :=
  mul_zero c â–¸ Filter.Tendsto.const_mul c (tendsto_zpow_at_top_zero hn)

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_const_mul_pow_nhds_iff
{n : exprâ„•()}
{c d : Î±}
(hc : Â«expr â‰  Â»(c, 0)) : Â«expr â†” Â»(tendsto (Î»
  x : Î±, Â«expr * Â»(c, Â«expr ^ Â»(x, n))) at_top (exprğ“() d), Â«expr âˆ§ Â»(Â«expr = Â»(n, 0), Â«expr = Â»(c, d))) :=
begin
  refine [expr âŸ¨Î» h, _, Î» h, _âŸ©],
  { have [ident hn] [":", expr Â«expr = Â»(n, 0)] [],
    { by_contradiction [ident hn],
      have [ident hn] [":", expr Â«expr â‰¤ Â»(1, n)] [":=", expr nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn))],
      by_cases [expr hc', ":", expr Â«expr < Â»(0, c)],
      { have [] [] [":=", expr (tendsto_const_mul_pow_at_top_iff c n).2 âŸ¨hn, hc'âŸ©],
        exact [expr not_tendsto_nhds_of_tendsto_at_top this d h] },
      { have [] [] [":=", expr (tendsto_neg_const_mul_pow_at_top_iff c n).2 âŸ¨hn, lt_of_le_of_ne (not_lt.1 hc') hcâŸ©],
        exact [expr not_tendsto_nhds_of_tendsto_at_bot this d h] } },
    have [] [":", expr Â«expr = Â»(Î» x : Î±, Â«expr * Â»(c, Â«expr ^ Â»(x, n)), Î» x : Î±, c)] [],
    by simp [] [] [] ["[", expr hn, "]"] [] [],
    rw ["[", expr this, ",", expr tendsto_const_nhds_iff, "]"] ["at", ident h],
    exact [expr âŸ¨hn, hâŸ©] },
  { obtain ["âŸ¨", ident hn, ",", ident hcd, "âŸ©", ":=", expr h],
    simpa [] [] [] ["[", expr hn, ",", expr hcd, "]"] [] ["using", expr tendsto_const_nhds] }
end

theorem tendsto_const_mul_zpow_at_top_zero_iff {n : â„¤} {c d : Î±} (hc : c â‰  0) :
  tendsto (fun x : Î± => c*x ^ n) at_top (ğ“ d) â†” n = 0 âˆ§ c = d âˆ¨ n < 0 âˆ§ d = 0 :=
  by 
    refine' âŸ¨fun h => _, fun h => _âŸ©
    Â·
      byCases' hn : 0 â‰¤ n
      Â·
        lift n to â„• using hn 
        simp only [zpow_coe_nat] at h 
        rw [tendsto_const_mul_pow_nhds_iff hc, â†Int.coe_nat_eq_zero] at h 
        exact Or.inl h
      Â·
        rw [not_leâ‚“] at hn 
        refine' Or.inr âŸ¨hn, tendsto_nhds_unique h (tendsto_const_mul_zpow_at_top_zero hn)âŸ©
    Â·
      cases h
      Â·
        simp only [h.left, h.right, zpow_zero, mul_oneâ‚“]
        exact tendsto_const_nhds
      Â·
        exact h.2.symm â–¸ tendsto_const_mul_zpow_at_top_zero h.1

end LinearOrderedField

theorem preimage_neg [AddGroupâ‚“ Î±] : preimage (Neg.neg : Î± â†’ Î±) = image (Neg.neg : Î± â†’ Î±) :=
  (image_eq_preimage_of_inverse neg_negâ‚“ neg_negâ‚“).symm

theorem Filter.map_neg [AddGroupâ‚“ Î±] : map (Neg.neg : Î± â†’ Î±) = comap (Neg.neg : Î± â†’ Î±) :=
  funext$ fun f => map_eq_comap_of_inverse (funext neg_negâ‚“) (funext neg_negâ‚“)

section OrderTopology

variable [TopologicalSpace Î±] [TopologicalSpace Î²] [LinearOrderâ‚“ Î±] [LinearOrderâ‚“ Î²] [OrderTopology Î±] [OrderTopology Î²]

theorem IsLub.frequently_mem {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : âˆƒá¶ x in ğ“[Iic a] a, x âˆˆ s :=
  by 
    rcases hs with âŸ¨a', ha'âŸ©
    intro h 
    rcases(ha.1 ha').eq_or_lt with (rfl | ha'a)
    Â·
      exact h.self_of_nhds_within le_rfl ha'
    Â·
      rcases(mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h with âŸ¨b, hba, hbâŸ©
      rcases ha.exists_between hba with âŸ¨b', hb's, hb'âŸ©
      exact hb hb' hb's

theorem IsLub.frequently_nhds_mem {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : âˆƒá¶ x in ğ“ a, x âˆˆ s :=
  (ha.frequently_mem hs).filter_mono inf_le_left

theorem IsGlb.frequently_mem {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) : âˆƒá¶ x in ğ“[Ici a] a, x âˆˆ s :=
  @IsLub.frequently_mem (OrderDual Î±) _ _ _ _ _ ha hs

theorem IsGlb.frequently_nhds_mem {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) : âˆƒá¶ x in ğ“ a, x âˆˆ s :=
  (ha.frequently_mem hs).filter_mono inf_le_left

theorem IsLub.mem_closure {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : a âˆˆ Closure s :=
  (ha.frequently_nhds_mem hs).mem_closure

theorem IsGlb.mem_closure {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) : a âˆˆ Closure s :=
  (ha.frequently_nhds_mem hs).mem_closure

theorem IsLub.nhds_within_ne_bot {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) : ne_bot (ğ“[s] a) :=
  mem_closure_iff_nhds_within_ne_bot.1 (ha.mem_closure hs)

theorem IsGlb.nhds_within_ne_bot : âˆ€ {a : Î±} {s : Set Î±}, IsGlb s a â†’ s.nonempty â†’ ne_bot (ğ“[s] a) :=
  @IsLub.nhds_within_ne_bot (OrderDual Î±) _ _ _

theorem is_lub_of_mem_nhds {s : Set Î±} {a : Î±} {f : Filter Î±} (hsa : a âˆˆ UpperBounds s) (hsf : s âˆˆ f) [ne_bot (fâŠ“ğ“ a)] :
  IsLub s a :=
  âŸ¨hsa,
    fun b hb =>
      not_ltâ‚“.1$
        fun hba =>
          have  : s âˆ© { a | b < a } âˆˆ fâŠ“ğ“ a := inter_mem_inf hsf (IsOpen.mem_nhds (is_open_lt' _) hba)
          let âŸ¨x, âŸ¨hxs, hxbâŸ©âŸ© := Filter.nonempty_of_mem this 
          have  : b < b := lt_of_lt_of_leâ‚“ hxb$ hb hxs 
          lt_irreflâ‚“ b thisâŸ©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub_of_mem_closure
{s : set Î±}
{a : Î±}
(hsa : Â«expr âˆˆ Â»(a, upper_bounds s))
(hsf : Â«expr âˆˆ Â»(a, closure s)) : is_lub s a :=
begin
  rw ["[", expr mem_closure_iff_cluster_pt, ",", expr cluster_pt, ",", expr inf_comm, "]"] ["at", ident hsf],
  haveI [] [":", expr Â«expr âŠ“ Â»(exprğ“Ÿ() s, exprğ“() a).ne_bot] [":=", expr hsf],
  exact [expr is_lub_of_mem_nhds hsa (mem_principal_self s)]
end

theorem is_glb_of_mem_nhds :
  âˆ€ {s : Set Î±} {a : Î±} {f : Filter Î±}, a âˆˆ LowerBounds s â†’ s âˆˆ f â†’ ne_bot (fâŠ“ğ“ a) â†’ IsGlb s a :=
  @is_lub_of_mem_nhds (OrderDual Î±) _ _ _

theorem is_glb_of_mem_closure {s : Set Î±} {a : Î±} (hsa : a âˆˆ LowerBounds s) (hsf : a âˆˆ Closure s) : IsGlb s a :=
  @is_lub_of_mem_closure (OrderDual Î±) _ _ _ s a hsa hsf

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub.mem_upper_bounds_of_tendsto
[preorder Î³]
[topological_space Î³]
[order_closed_topology Î³]
{f : Î± â†’ Î³}
{s : set Î±}
{a : Î±}
{b : Î³}
(hf : monotone_on f s)
(ha : is_lub s a)
(hb : tendsto f Â«exprğ“[ ] Â»(s, a) (exprğ“() b)) : Â«expr âˆˆ Â»(b, upper_bounds Â«expr '' Â»(f, s)) :=
begin
  rintro ["_", "âŸ¨", ident x, ",", ident hx, ",", ident rfl, "âŸ©"],
  replace [ident ha] [] [":=", expr ha.inter_Ici_of_mem hx],
  haveI [] [] [":=", expr ha.nhds_within_ne_bot âŸ¨x, hx, le_rflâŸ©],
  refine [expr ge_of_tendsto (hb.mono_left (nhds_within_mono _ (inter_subset_left s (Ici x)))) _],
  exact [expr mem_of_superset self_mem_nhds_within (Î» y hy, hf hx hy.1 hy.2)]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub.is_lub_of_tendsto
[preorder Î³]
[topological_space Î³]
[order_closed_topology Î³]
{f : Î± â†’ Î³}
{s : set Î±}
{a : Î±}
{b : Î³}
(hf : monotone_on f s)
(ha : is_lub s a)
(hs : s.nonempty)
(hb : tendsto f Â«exprğ“[ ] Â»(s, a) (exprğ“() b)) : is_lub Â«expr '' Â»(f, s) b :=
begin
  haveI [] [] [":=", expr ha.nhds_within_ne_bot hs],
  exact [expr âŸ¨ha.mem_upper_bounds_of_tendsto hf hb, Î»
    b'
    hb', le_of_tendsto hb Â«expr $ Â»(mem_of_superset self_mem_nhds_within, Î»
     x hx, Â«expr $ Â»(hb', mem_image_of_mem _ hx))âŸ©]
end

theorem IsGlb.mem_lower_bounds_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³}
  {s : Set Î±} {a : Î±} {b : Î³} (hf : MonotoneOn f s) (ha : IsGlb s a) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  b âˆˆ LowerBounds (f '' s) :=
  @IsLub.mem_upper_bounds_of_tendsto (OrderDual Î±) (OrderDual Î³) _ _ _ _ _ _ _ _ _ _ hf.dual ha hb

theorem IsGlb.is_glb_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³} {s : Set Î±}
  {a : Î±} {b : Î³} (hf : MonotoneOn f s) : IsGlb s a â†’ s.nonempty â†’ tendsto f (ğ“[s] a) (ğ“ b) â†’ IsGlb (f '' s) b :=
  @IsLub.is_lub_of_tendsto (OrderDual Î±) (OrderDual Î³) _ _ _ _ _ _ f s a b hf.dual

theorem IsLub.mem_lower_bounds_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³}
  {s : Set Î±} {a : Î±} {b : Î³} (hf : AntitoneOn f s) (ha : IsLub s a) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  b âˆˆ LowerBounds (f '' s) :=
  @IsLub.mem_upper_bounds_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _ _ _ _ _ hf ha hb

theorem IsLub.is_glb_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] :
  âˆ€ {f : Î± â†’ Î³} {s : Set Î±} {a : Î±} {b : Î³},
    AntitoneOn f s â†’ IsLub s a â†’ s.nonempty â†’ tendsto f (ğ“[s] a) (ğ“ b) â†’ IsGlb (f '' s) b :=
  @IsLub.is_lub_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _

theorem IsGlb.mem_upper_bounds_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] {f : Î± â†’ Î³}
  {s : Set Î±} {a : Î±} {b : Î³} (hf : AntitoneOn f s) (ha : IsGlb s a) (hb : tendsto f (ğ“[s] a) (ğ“ b)) :
  b âˆˆ UpperBounds (f '' s) :=
  @IsGlb.mem_lower_bounds_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _ _ _ _ _ hf ha hb

theorem IsGlb.is_lub_of_tendsto [Preorderâ‚“ Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³] :
  âˆ€ {f : Î± â†’ Î³} {s : Set Î±} {a : Î±} {b : Î³},
    AntitoneOn f s â†’ IsGlb s a â†’ s.nonempty â†’ tendsto f (ğ“[s] a) (ğ“ b) â†’ IsLub (f '' s) b :=
  @IsGlb.is_glb_of_tendsto Î± (OrderDual Î³) _ _ _ _ _ _

theorem IsLub.mem_of_is_closed {a : Î±} {s : Set Î±} (ha : IsLub s a) (hs : s.nonempty) (sc : IsClosed s) : a âˆˆ s :=
  sc.closure_subset$ ha.mem_closure hs

alias IsLub.mem_of_is_closed â† IsClosed.is_lub_mem

theorem IsGlb.mem_of_is_closed {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) (sc : IsClosed s) : a âˆˆ s :=
  sc.closure_subset$ ha.mem_closure hs

alias IsGlb.mem_of_is_closed â† IsClosed.is_glb_mem

/-!
### Existence of sequences tending to Inf or Sup of a given set
-/


-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub.exists_seq_strict_mono_tendsto_of_not_mem
{t : set Î±}
{x : Î±}
[is_countably_generated (exprğ“() x)]
(htx : is_lub t x)
(not_mem : Â«expr âˆ‰ Â»(x, t))
(ht : t.nonempty) : Â«exprâˆƒ , Â»((u : exprâ„•() â†’ Î±), Â«expr âˆ§ Â»(strict_mono u, Â«expr âˆ§ Â»(âˆ€
   n, Â«expr < Â»(u n, x), Â«expr âˆ§ Â»(tendsto u at_top (exprğ“() x), âˆ€ n, Â«expr âˆˆ Â»(u n, t))))) :=
begin
  rcases [expr ht, "with", "âŸ¨", ident l, ",", ident hl, "âŸ©"],
  have [ident hl] [":", expr Â«expr < Â»(l, x)] [],
  from [expr (htx.1 hl).eq_or_lt.resolve_left (Î» h, Â«expr $ Â»(not_mem, Â«expr â–¸ Â»(h, hl)).elim)],
  obtain ["âŸ¨", ident s, ",", ident hs, "âŸ©", ":", expr Â«exprâˆƒ , Â»((s : exprâ„•() â†’ set Î±), (exprğ“() x).has_basis (Î»
     _x : exprâ„•(), true) s), ":=", expr let âŸ¨s, hsâŸ© := (exprğ“() x).exists_antitone_basis in
   âŸ¨s, hs.to_has_basisâŸ©],
  have [] [":", expr âˆ€
   n
   k, Â«expr < Â»(k, x) â†’ Â«exprâˆƒ , Â»((y), Â«expr âˆ§ Â»(Â«expr âŠ† Â»(Icc y x, s n), Â«expr âˆ§ Â»(Â«expr < Â»(k, y), Â«expr âˆ§ Â»(Â«expr < Â»(y, x), Â«expr âˆˆ Â»(y, t)))))] [],
  { assume [binders (n k hk)],
    obtain ["âŸ¨", ident L, ",", ident hL, ",", ident h, "âŸ©", ":", expr Â«exprâˆƒ , Â»((L : Î±)
      (hL : Â«expr âˆˆ Â»(L, Ico k x)), Â«expr âŠ† Â»(Ioc L x, s n)), ":=", expr exists_Ioc_subset_of_mem_nhds' (hs.mem_of_mem trivial) hk],
    obtain ["âŸ¨", ident y, ",", ident hy, "âŸ©", ":", expr Â«exprâˆƒ , Â»((y : Î±), Â«expr âˆ§ Â»(Â«expr < Â»(L, y), Â«expr âˆ§ Â»(Â«expr < Â»(y, x), Â«expr âˆˆ Â»(y, t))))],
    { rcases [expr htx.exists_between' not_mem hL.2, "with", "âŸ¨", ident y, ",", ident yt, ",", ident hy, "âŸ©"],
      refine [expr âŸ¨y, hy.1, hy.2, ytâŸ©] },
    exact [expr âŸ¨y, Î» z hz, h âŸ¨hy.1.trans_le hz.1, hz.2âŸ©, hL.1.trans_lt hy.1, hy.2âŸ©] },
  choose ["!"] [ident f] [ident hf] ["using", expr this],
  let [ident u] [":", expr exprâ„•() â†’ Î±] [":=", expr Î» n, nat.rec_on n (f 0 l) (Î» n h, f n.succ h)],
  have [ident I] [":", expr âˆ€ n, Â«expr < Â»(u n, x)] [],
  { assume [binders (n)],
    induction [expr n] [] ["with", ident n, ident IH] [],
    { exact [expr (hf 0 l hl).2.2.1] },
    { exact [expr (hf n.succ _ IH).2.2.1] } },
  have [ident S] [":", expr strict_mono u] [":=", expr strict_mono_nat_of_lt_succ (Î» n, (hf n.succ _ (I n)).2.1)],
  refine [expr âŸ¨u, S, I, hs.tendsto_right_iff.2 (Î» n _, _), Î» n, _âŸ©],
  { simp [] [] ["only"] ["[", expr ge_iff_le, ",", expr eventually_at_top, "]"] [] [],
    refine [expr âŸ¨n, Î» p hp, _âŸ©],
    have [ident up] [":", expr Â«expr âˆˆ Â»(u p, Icc (u n) x)] [":=", expr âŸ¨S.monotone hp, (I p).leâŸ©],
    have [] [":", expr Â«expr âŠ† Â»(Icc (u n) x, s n)] [],
    by { cases [expr n] [],
      { exact [expr (hf 0 l hl).1] },
      { exact [expr (hf n.succ (u n) (I n)).1] } },
    exact [expr this up] },
  { cases [expr n] [],
    { exact [expr (hf 0 l hl).2.2.2] },
    { exact [expr (hf n.succ _ (I n)).2.2.2] } }
end

theorem IsLub.exists_seq_monotone_tendsto {t : Set Î±} {x : Î±} [is_countably_generated (ğ“ x)] (htx : IsLub t x)
  (ht : t.nonempty) : âˆƒ u : â„• â†’ Î±, Monotone u âˆ§ (âˆ€ n, u n â‰¤ x) âˆ§ tendsto u at_top (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :=
  by 
    byCases' h : x âˆˆ t
    Â·
      exact âŸ¨fun n => x, monotone_const, fun n => le_rfl, tendsto_const_nhds, fun n => hâŸ©
    Â·
      rcases htx.exists_seq_strict_mono_tendsto_of_not_mem h ht with âŸ¨u, huâŸ©
      exact âŸ¨u, hu.1.Monotone, fun n => (hu.2.1 n).le, hu.2.2âŸ©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem exists_seq_strict_mono_tendsto'
{Î± : Type*}
[linear_order Î±]
[topological_space Î±]
[densely_ordered Î±]
[order_topology Î±]
[first_countable_topology Î±]
{x y : Î±}
(hy : Â«expr < Â»(y, x)) : Â«exprâˆƒ , Â»((u : exprâ„•() â†’ Î±), Â«expr âˆ§ Â»(strict_mono u, Â«expr âˆ§ Â»(âˆ€
   n, Â«expr < Â»(u n, x), tendsto u at_top (exprğ“() x)))) :=
begin
  have [ident hx] [":", expr Â«expr âˆ‰ Â»(x, Iio x)] [":=", expr Î» h, (lt_irrefl x h).elim],
  have [ident ht] [":", expr set.nonempty (Iio x)] [":=", expr âŸ¨y, hyâŸ©],
  rcases [expr is_lub_Iio.exists_seq_strict_mono_tendsto_of_not_mem hx ht, "with", "âŸ¨", ident u, ",", ident hu, "âŸ©"],
  exact [expr âŸ¨u, hu.1, hu.2.1, hu.2.2.1âŸ©]
end

theorem exists_seq_strict_mono_tendsto [DenselyOrdered Î±] [NoBotOrder Î±] [first_countable_topology Î±] (x : Î±) :
  âˆƒ u : â„• â†’ Î±, StrictMono u âˆ§ (âˆ€ n, u n < x) âˆ§ tendsto u at_top (ğ“ x) :=
  by 
    obtain âŸ¨y, hyâŸ© : âˆƒ y, y < x := no_bot _ 
    exact exists_seq_strict_mono_tendsto' hy

theorem exists_seq_tendsto_Sup {Î± : Type _} [ConditionallyCompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  [first_countable_topology Î±] {S : Set Î±} (hS : S.nonempty) (hS' : BddAbove S) :
  âˆƒ u : â„• â†’ Î±, Monotone u âˆ§ tendsto u at_top (ğ“ (Sup S)) âˆ§ âˆ€ n, u n âˆˆ S :=
  by 
    rcases(is_lub_cSup hS hS').exists_seq_monotone_tendsto hS with âŸ¨u, huâŸ©
    exact âŸ¨u, hu.1, hu.2.2âŸ©

theorem IsGlb.exists_seq_strict_anti_tendsto_of_not_mem {t : Set Î±} {x : Î±} [is_countably_generated (ğ“ x)]
  (htx : IsGlb t x) (not_mem : x âˆ‰ t) (ht : t.nonempty) :
  âˆƒ u : â„• â†’ Î±, StrictAnti u âˆ§ (âˆ€ n, x < u n) âˆ§ tendsto u at_top (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :=
  @IsLub.exists_seq_strict_mono_tendsto_of_not_mem (OrderDual Î±) _ _ _ t x _ htx not_mem ht

theorem IsGlb.exists_seq_antitone_tendsto {t : Set Î±} {x : Î±} [is_countably_generated (ğ“ x)] (htx : IsGlb t x)
  (ht : t.nonempty) : âˆƒ u : â„• â†’ Î±, Antitone u âˆ§ (âˆ€ n, x â‰¤ u n) âˆ§ tendsto u at_top (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :=
  @IsLub.exists_seq_monotone_tendsto (OrderDual Î±) _ _ _ t x _ htx ht

theorem exists_seq_strict_anti_tendsto' [DenselyOrdered Î±] [first_countable_topology Î±] {x y : Î±} (hy : x < y) :
  âˆƒ u : â„• â†’ Î±, StrictAnti u âˆ§ (âˆ€ n, x < u n) âˆ§ tendsto u at_top (ğ“ x) :=
  @exists_seq_strict_mono_tendsto' (OrderDual Î±) _ _ _ _ _ x y hy

theorem exists_seq_strict_anti_tendsto [DenselyOrdered Î±] [NoTopOrder Î±] [first_countable_topology Î±] (x : Î±) :
  âˆƒ u : â„• â†’ Î±, StrictAnti u âˆ§ (âˆ€ n, x < u n) âˆ§ tendsto u at_top (ğ“ x) :=
  @exists_seq_strict_mono_tendsto (OrderDual Î±) _ _ _ _ _ _ x

theorem exists_seq_tendsto_Inf {Î± : Type _} [ConditionallyCompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  [first_countable_topology Î±] {S : Set Î±} (hS : S.nonempty) (hS' : BddBelow S) :
  âˆƒ u : â„• â†’ Î±, Antitone u âˆ§ tendsto u at_top (ğ“ (Inf S)) âˆ§ âˆ€ n, u n âˆˆ S :=
  @exists_seq_tendsto_Sup (OrderDual Î±) _ _ _ _ S hS hS'

/-- A compact set is bounded below -/
theorem IsCompact.bdd_below {Î± : Type u} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±] [Nonempty Î±]
  {s : Set Î±} (hs : IsCompact s) : BddBelow s :=
  by 
    byContra H 
    rcases hs.elim_finite_subcover_image (fun x _ : x âˆˆ s => @is_open_Ioi _ _ _ _ x) _ with âŸ¨t, st, ft, htâŸ©
    Â·
      refine' H (ft.bdd_below.imp$ fun C hC y hy => _)
      rcases mem_bUnion_iff.1 (ht hy) with âŸ¨x, hx, xyâŸ©
      exact le_transâ‚“ (hC hx) (le_of_ltâ‚“ xy)
    Â·
      refine' fun x hx => mem_bUnion_iff.2 (not_imp_comm.1 _ H)
      exact fun h => âŸ¨x, fun y hy => le_of_not_ltâ‚“ (h.imp$ fun ys => âŸ¨_, hy, ysâŸ©)âŸ©

/-- A compact set is bounded above -/
theorem IsCompact.bdd_above {Î± : Type u} [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderClosedTopology Î±] :
  âˆ€ [Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddAbove s :=
  @IsCompact.bdd_below (OrderDual Î±) _ _ _

end OrderTopology

section DenselyOrdered

variable [TopologicalSpace Î±] [LinearOrderâ‚“ Î±] [OrderTopology Î±] [DenselyOrdered Î±] {a b : Î±} {s : Set Î±}

/-- The closure of the interval `(a, +âˆ)` is the closed interval `[a, +âˆ)`, unless `a` is a top
element. -/
theorem closure_Ioi' {a b : Î±} (hab : a < b) : Closure (Ioi a) = Ici a :=
  by 
    apply subset.antisymm
    Â·
      exact closure_minimal Ioi_subset_Ici_self is_closed_Ici
    Â·
      rw [â†diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff]
      exact is_glb_Ioi.mem_closure âŸ¨_, habâŸ©

/-- The closure of the interval `(a, +âˆ)` is the closed interval `[a, +âˆ)`. -/
@[simp]
theorem closure_Ioi (a : Î±) [NoTopOrder Î±] : Closure (Ioi a) = Ici a :=
  let âŸ¨b, hbâŸ© := no_top a 
  closure_Ioi' hb

/-- The closure of the interval `(-âˆ, a)` is the closed interval `(-âˆ, a]`, unless `a` is a bottom
element. -/
theorem closure_Iio' {a b : Î±} (hab : b < a) : Closure (Iio a) = Iic a :=
  @closure_Ioi' (OrderDual Î±) _ _ _ _ _ _ hab

/-- The closure of the interval `(-âˆ, a)` is the interval `(-âˆ, a]`. -/
@[simp]
theorem closure_Iio (a : Î±) [NoBotOrder Î±] : Closure (Iio a) = Iic a :=
  let âŸ¨b, hbâŸ© := no_bot a 
  closure_Iio' hb

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioo {a b : Î±} (hab : Â«expr < Â»(a, b)) : Â«expr = Â»(closure (Ioo a b), Icc a b) :=
begin
  apply [expr subset.antisymm],
  { exact [expr closure_minimal Ioo_subset_Icc_self is_closed_Icc] },
  { rw ["[", "<-", expr diff_subset_closure_iff, ",", expr Icc_diff_Ioo_same hab.le, "]"] [],
    have [ident hab'] [":", expr (Ioo a b).nonempty] [],
    from [expr nonempty_Ioo.2 hab],
    simp [] [] ["only"] ["[", expr insert_subset, ",", expr singleton_subset_iff, "]"] [] [],
    exact [expr âŸ¨(is_glb_Ioo hab).mem_closure hab', (is_lub_Ioo hab).mem_closure hab'âŸ©] }
end

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioc {a b : Î±} (hab : a < b) : Closure (Ioc a b) = Icc a b :=
  by 
    apply subset.antisymm
    Â·
      exact closure_minimal Ioc_subset_Icc_self is_closed_Icc
    Â·
      apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)
      rw [closure_Ioo hab]

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ico {a b : Î±} (hab : a < b) : Closure (Ico a b) = Icc a b :=
  by 
    apply subset.antisymm
    Â·
      exact closure_minimal Ico_subset_Icc_self is_closed_Icc
    Â·
      apply subset.trans _ (closure_mono Ioo_subset_Ico_self)
      rw [closure_Ioo hab]

@[simp]
theorem interior_Ici [NoBotOrder Î±] {a : Î±} : Interior (Ici a) = Ioi a :=
  by 
    rw [â†compl_Iio, interior_compl, closure_Iio, compl_Iic]

@[simp]
theorem interior_Iic [NoTopOrder Î±] {a : Î±} : Interior (Iic a) = Iio a :=
  by 
    rw [â†compl_Ioi, interior_compl, closure_Ioi, compl_Ici]

@[simp]
theorem interior_Icc [NoBotOrder Î±] [NoTopOrder Î±] {a b : Î±} : Interior (Icc a b) = Ioo a b :=
  by 
    rw [â†Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]

@[simp]
theorem interior_Ico [NoBotOrder Î±] {a b : Î±} : Interior (Ico a b) = Ioo a b :=
  by 
    rw [â†Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]

@[simp]
theorem interior_Ioc [NoTopOrder Î±] {a b : Î±} : Interior (Ioc a b) = Ioo a b :=
  by 
    rw [â†Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]

@[simp]
theorem frontier_Ici [NoBotOrder Î±] {a : Î±} : Frontier (Ici a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Iic [NoTopOrder Î±] {a : Î±} : Frontier (Iic a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Ioi [NoTopOrder Î±] {a : Î±} : Frontier (Ioi a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Iio [NoBotOrder Î±] {a : Î±} : Frontier (Iio a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Icc [NoBotOrder Î±] [NoTopOrder Î±] {a b : Î±} (h : a < b) : Frontier (Icc a b) = {a, b} :=
  by 
    simp [Frontier, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ioo {a b : Î±} (h : a < b) : Frontier (Ioo a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ico [NoBotOrder Î±] {a b : Î±} (h : a < b) : Frontier (Ico a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ioc [NoTopOrder Î±] {a b : Î±} (h : a < b) : Frontier (Ioc a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_ltâ‚“ h, Icc_diff_Ioo_same]

theorem nhds_within_Ioi_ne_bot' {a b c : Î±} (Hâ‚ : a < c) (Hâ‚‚ : a â‰¤ b) : ne_bot (ğ“[Ioi a] b) :=
  mem_closure_iff_nhds_within_ne_bot.1$
    by 
      rw [closure_Ioi' Hâ‚]
      exact Hâ‚‚

theorem nhds_within_Ioi_ne_bot [NoTopOrder Î±] {a b : Î±} (H : a â‰¤ b) : ne_bot (ğ“[Ioi a] b) :=
  let âŸ¨c, hcâŸ© := no_top a 
  nhds_within_Ioi_ne_bot' hc H

theorem nhds_within_Ioi_self_ne_bot' {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioi a] a) :=
  nhds_within_Ioi_ne_bot' H (le_reflâ‚“ a)

@[instance]
theorem nhds_within_Ioi_self_ne_bot [NoTopOrder Î±] (a : Î±) : ne_bot (ğ“[Ioi a] a) :=
  nhds_within_Ioi_ne_bot (le_reflâ‚“ a)

theorem Filter.Eventually.exists_gt [NoTopOrder Î±] {a : Î±} {p : Î± â†’ Prop} (h : âˆ€á¶ x in ğ“ a, p x) :
  âˆƒ (b : _)(_ : b > a), p b :=
  by 
    simpa only [exists_prop, gt_iff_lt, and_comm] using
      ((h.filter_mono (@nhds_within_le_nhds _ _ a (Ioi a))).And self_mem_nhds_within).exists

theorem nhds_within_Iio_ne_bot' {a b c : Î±} (Hâ‚ : a < c) (Hâ‚‚ : b â‰¤ c) : ne_bot (ğ“[Iio c] b) :=
  mem_closure_iff_nhds_within_ne_bot.1$
    by 
      rw [closure_Iio' Hâ‚]
      exact Hâ‚‚

theorem nhds_within_Iio_ne_bot [NoBotOrder Î±] {a b : Î±} (H : a â‰¤ b) : ne_bot (ğ“[Iio b] a) :=
  let âŸ¨c, hcâŸ© := no_bot b 
  nhds_within_Iio_ne_bot' hc H

theorem nhds_within_Iio_self_ne_bot' {a b : Î±} (H : a < b) : ne_bot (ğ“[Iio b] b) :=
  nhds_within_Iio_ne_bot' H (le_reflâ‚“ b)

@[instance]
theorem nhds_within_Iio_self_ne_bot [NoBotOrder Î±] (a : Î±) : ne_bot (ğ“[Iio a] a) :=
  nhds_within_Iio_ne_bot (le_reflâ‚“ a)

theorem Filter.Eventually.exists_lt [NoBotOrder Î±] {a : Î±} {p : Î± â†’ Prop} (h : âˆ€á¶ x in ğ“ a, p x) :
  âˆƒ (b : _)(_ : b < a), p b :=
  @Filter.Eventually.exists_gt (OrderDual Î±) _ _ _ _ _ _ _ h

theorem right_nhds_within_Ico_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ico a b] b) :=
  (is_lub_Ico H).nhds_within_ne_bot (nonempty_Ico.2 H)

theorem left_nhds_within_Ioc_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioc a b] a) :=
  (is_glb_Ioc H).nhds_within_ne_bot (nonempty_Ioc.2 H)

theorem left_nhds_within_Ioo_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioo a b] a) :=
  (is_glb_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

theorem right_nhds_within_Ioo_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioo a b] b) :=
  (is_lub_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem comap_coe_nhds_within_Iio_of_Ioo_subset
(hb : Â«expr âŠ† Â»(s, Iio b))
(hs : s.nonempty â†’ Â«exprâˆƒ , Â»((a Â«expr < Â» b), Â«expr âŠ† Â»(Ioo a b, s))) : Â«expr = Â»(comap (coe : s â†’ Î±) Â«exprğ“[ ] Â»(Iio b, b), at_top) :=
begin
  nontriviality [] [],
  haveI [] [":", expr nonempty s] [":=", expr nontrivial_iff_nonempty.1 Â«exprâ€¹ â€ºÂ»(_)],
  rcases [expr hs (nonempty_subtype.1 Â«exprâ€¹ â€ºÂ»(_)), "with", "âŸ¨", ident a, ",", ident h, ",", ident hs, "âŸ©"],
  ext [] [ident u] [],
  split,
  { rintros ["âŸ¨", ident t, ",", ident ht, ",", ident hts, "âŸ©"],
    obtain ["âŸ¨", ident x, ",", "âŸ¨", ident hxa, ":", expr Â«expr â‰¤ Â»(a, x), ",", ident hxb, ":", expr Â«expr < Â»(x, b), "âŸ©", ",", ident hxt, ":", expr Â«expr âŠ† Â»(Ioo x b, t), "âŸ©", ":=", expr (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht],
    obtain ["âŸ¨", ident y, ",", ident hxy, ",", ident hyb, "âŸ©", ":=", expr exists_between hxb],
    refine [expr mem_of_superset (mem_at_top âŸ¨y, hs âŸ¨hxa.trans_lt hxy, hybâŸ©âŸ©) _],
    rintros ["âŸ¨", ident z, ",", ident hzs, "âŸ©", "(", ident hyz, ":", expr Â«expr â‰¤ Â»(y, z), ")"],
    refine [expr hts (hxt âŸ¨hxy.trans_le _, hb _âŸ©)]; assumption },
  { intros [ident hu],
    obtain ["âŸ¨", ident x, ":", expr s, ",", ident hx, ":", expr âˆ€
     z, Â«expr â‰¤ Â»(x, z) â†’ Â«expr âˆˆ Â»(z, u), "âŸ©", ":=", expr mem_at_top_sets.1 hu],
    exact [expr âŸ¨Ioo x b, Ioo_mem_nhds_within_Iio Â«expr $ Â»(right_mem_Ioc.2, hb x.2), Î» z hz, hx _ hz.1.leâŸ©] }
end

theorem comap_coe_nhds_within_Ioi_of_Ioo_subset (ha : s âŠ† Ioi a) (hs : s.nonempty â†’ âˆƒ (b : _)(_ : b > a), Ioo a b âŠ† s) :
  comap (coeâ‚“ : s â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Iio_of_Ioo_subset (show of_dual â»Â¹' s âŠ† Iio (to_dual a) from ha)
    fun h =>
      by 
        simpa only [OrderDual.exists, dual_Ioo] using hs h

theorem map_coe_at_top_of_Ioo_subset (hb : s âŠ† Iio b) (hs : âˆ€ a' _ : a' < b, âˆƒ (a : _)(_ : a < b), Ioo a b âŠ† s) :
  map (coeâ‚“ : s â†’ Î±) at_top = ğ“[Iio b] b :=
  by 
    rcases eq_empty_or_nonempty (Iio b) with (hb' | âŸ¨a, haâŸ©)
    Â·
      rw [filter_eq_bot_of_is_empty at_top, map_bot, hb', nhds_within_empty]
      exact âŸ¨fun x => hb'.subset (hb x.2)âŸ©
    Â·
      rw [â†comap_coe_nhds_within_Iio_of_Ioo_subset hb fun _ => hs a ha, map_comap_of_mem]
      rw [Subtype.range_coe]
      exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)

theorem map_coe_at_bot_of_Ioo_subset (ha : s âŠ† Ioi a) (hs : âˆ€ b' _ : b' > a, âˆƒ (b : _)(_ : b > a), Ioo a b âŠ† s) :
  map (coeâ‚“ : s â†’ Î±) at_bot = ğ“[Ioi a] a :=
  by 
    refine' (map_coe_at_top_of_Ioo_subset (show of_dual â»Â¹' s âŠ† Iio (to_dual a) from ha) fun b' hb' => _ : _)
    simpa only [OrderDual.exists, dual_Ioo] using hs b' hb'

/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Iio (a b : Î±) : comap (coeâ‚“ : Ioo a b â†’ Î±) (ğ“[Iio b] b) = at_top :=
  comap_coe_nhds_within_Iio_of_Ioo_subset Ioo_subset_Iio_self$ fun h => âŸ¨a, nonempty_Ioo.1 h, subset.refl _âŸ©

/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Ioi (a b : Î±) : comap (coeâ‚“ : Ioo a b â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Ioi_of_Ioo_subset Ioo_subset_Ioi_self$ fun h => âŸ¨b, nonempty_Ioo.1 h, subset.refl _âŸ©

theorem comap_coe_Ioi_nhds_within_Ioi (a : Î±) : comap (coeâ‚“ : Ioi a â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Ioi_of_Ioo_subset (subset.refl _)$ fun âŸ¨x, hxâŸ© => âŸ¨x, hx, Ioo_subset_Ioi_selfâŸ©

theorem comap_coe_Iio_nhds_within_Iio (a : Î±) : comap (coeâ‚“ : Iio a â†’ Î±) (ğ“[Iio a] a) = at_top :=
  @comap_coe_Ioi_nhds_within_Ioi (OrderDual Î±) _ _ _ _ a

@[simp]
theorem map_coe_Ioo_at_top {a b : Î±} (h : a < b) : map (coeâ‚“ : Ioo a b â†’ Î±) at_top = ğ“[Iio b] b :=
  map_coe_at_top_of_Ioo_subset Ioo_subset_Iio_self$ fun _ _ => âŸ¨_, h, subset.refl _âŸ©

@[simp]
theorem map_coe_Ioo_at_bot {a b : Î±} (h : a < b) : map (coeâ‚“ : Ioo a b â†’ Î±) at_bot = ğ“[Ioi a] a :=
  map_coe_at_bot_of_Ioo_subset Ioo_subset_Ioi_self$ fun _ _ => âŸ¨_, h, subset.refl _âŸ©

@[simp]
theorem map_coe_Ioi_at_bot (a : Î±) : map (coeâ‚“ : Ioi a â†’ Î±) at_bot = ğ“[Ioi a] a :=
  map_coe_at_bot_of_Ioo_subset (subset.refl _)$ fun b hb => âŸ¨b, hb, Ioo_subset_Ioi_selfâŸ©

@[simp]
theorem map_coe_Iio_at_top (a : Î±) : map (coeâ‚“ : Iio a â†’ Î±) at_top = ğ“[Iio a] a :=
  @map_coe_Ioi_at_bot (OrderDual Î±) _ _ _ _ _

variable {l : Filter Î²} {f : Î± â†’ Î²}

@[simp]
theorem tendsto_comp_coe_Ioo_at_top (h : a < b) :
  tendsto (fun x : Ioo a b => f x) at_top l â†” tendsto f (ğ“[Iio b] b) l :=
  by 
    rw [â†map_coe_Ioo_at_top h, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Ioo_at_bot (h : a < b) :
  tendsto (fun x : Ioo a b => f x) at_bot l â†” tendsto f (ğ“[Ioi a] a) l :=
  by 
    rw [â†map_coe_Ioo_at_bot h, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Ioi_at_bot : tendsto (fun x : Ioi a => f x) at_bot l â†” tendsto f (ğ“[Ioi a] a) l :=
  by 
    rw [â†map_coe_Ioi_at_bot, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Iio_at_top : tendsto (fun x : Iio a => f x) at_top l â†” tendsto f (ğ“[Iio a] a) l :=
  by 
    rw [â†map_coe_Iio_at_top, tendsto_map'_iff]

@[simp]
theorem tendsto_Ioo_at_top {f : Î² â†’ Ioo a b} : tendsto f l at_top â†” tendsto (fun x => (f x : Î±)) l (ğ“[Iio b] b) :=
  by 
    rw [â†comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]

@[simp]
theorem tendsto_Ioo_at_bot {f : Î² â†’ Ioo a b} : tendsto f l at_bot â†” tendsto (fun x => (f x : Î±)) l (ğ“[Ioi a] a) :=
  by 
    rw [â†comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]

@[simp]
theorem tendsto_Ioi_at_bot {f : Î² â†’ Ioi a} : tendsto f l at_bot â†” tendsto (fun x => (f x : Î±)) l (ğ“[Ioi a] a) :=
  by 
    rw [â†comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]

@[simp]
theorem tendsto_Iio_at_top {f : Î² â†’ Iio a} : tendsto f l at_top â†” tendsto (fun x => (f x : Î±)) l (ğ“[Iio a] a) :=
  by 
    rw [â†comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]

theorem dense_iff_forall_lt_exists_mem [Nontrivial Î±] {s : Set Î±} :
  Dense s â†” âˆ€ a b, a < b â†’ âˆƒ (c : _)(_ : c âˆˆ s), a < c âˆ§ c < b :=
  by 
    split 
    Â·
      intro h a b hab 
      obtain âŸ¨c, âŸ¨hc, csâŸ©âŸ© : (Ioo a b âˆ© s).Nonempty :=
        dense_iff_inter_open.1 h (Ioo a b) is_open_Ioo (nonempty_Ioo.2 hab)
      exact âŸ¨c, cs, hcâŸ©
    Â·
      intro h 
      apply dense_iff_inter_open.2 fun U U_open U_nonempty => _ 
      obtain âŸ¨a, b, hab, HâŸ© : âˆƒ a b : Î±, a < b âˆ§ Ioo a b âŠ† U := U_open.exists_Ioo_subset U_nonempty 
      obtain âŸ¨x, xs, hxâŸ© : âˆƒ (x : Î±)(H : x âˆˆ s), a < x âˆ§ x < b := h a b hab 
      exact âŸ¨x, âŸ¨H hx, xsâŸ©âŸ©

instance (x : Î±) [Nontrivial Î±] : ne_bot (ğ“[Â«expr á¶œÂ» {x}] x) :=
  by 
    apply forall_mem_nonempty_iff_ne_bot.1 fun s hs => _ 
    obtain âŸ¨u, u_open, xu, usâŸ© : âˆƒ u : Set Î±, IsOpen u âˆ§ x âˆˆ u âˆ§ u âˆ© Â«expr á¶œÂ» {x} âŠ† s := mem_nhds_within.1 hs 
    obtain âŸ¨a, b, a_lt_b, habâŸ© : âˆƒ a b : Î±, a < b âˆ§ Ioo a b âŠ† u := u_open.exists_Ioo_subset âŸ¨x, xuâŸ©
    obtain âŸ¨y, hyâŸ© : âˆƒ y, a < y âˆ§ y < b := exists_between a_lt_b 
    rcases ne_or_eq x y with (xy | rfl)
    Â·
      exact âŸ¨y, us âŸ¨hab hy, xy.symmâŸ©âŸ©
    obtain âŸ¨z, hzâŸ© : âˆƒ z, a < z âˆ§ z < x := exists_between hy.1 
    exact âŸ¨z, us âŸ¨hab âŸ¨hz.1, hz.2.trans hy.2âŸ©, hz.2.NeâŸ©âŸ©

/-- Let `s` be a dense set in a nontrivial dense linear order `Î±`. If `s` is a
separable space (e.g., if `Î±` has a second countable topology), then there exists a countable
dense subset `t âŠ† s` such that `t` does not contain bottom/top elements of `Î±`. -/
theorem Dense.exists_countable_dense_subset_no_bot_top [Nontrivial Î±] {s : Set Î±} [separable_space s] (hs : Dense s) :
  âˆƒ (t : _)(_ : t âŠ† s), countable t âˆ§ Dense t âˆ§ (âˆ€ x, IsBot x â†’ x âˆ‰ t) âˆ§ âˆ€ x, IsTop x â†’ x âˆ‰ t :=
  by 
    rcases hs.exists_countable_dense_subset with âŸ¨t, hts, htc, htdâŸ©
    refine' âŸ¨t \ ({ x | IsBot x } âˆª { x | IsTop x }), _, _, _, _, _âŸ©
    Â·
      exact (diff_subset _ _).trans hts
    Â·
      exact htc.mono (diff_subset _ _)
    Â·
      exact htd.diff_finite ((subsingleton_is_bot Î±).Finite.union (subsingleton_is_top Î±).Finite)
    Â·
      intro x hx 
      simp [hx]
    Â·
      intro x hx 
      simp [hx]

variable (Î±)

/-- If `Î±` is a nontrivial separable dense linear order, then there exists a
countable dense set `s : set Î±` that contains neither top nor bottom elements of `Î±`.
For a dense set containing both bot and top elements, see
`exists_countable_dense_bot_top`. -/
theorem exists_countable_dense_no_bot_top [separable_space Î±] [Nontrivial Î±] :
  âˆƒ s : Set Î±, countable s âˆ§ Dense s âˆ§ (âˆ€ x, IsBot x â†’ x âˆ‰ s) âˆ§ âˆ€ x, IsTop x â†’ x âˆ‰ s :=
  by 
    simpa using dense_univ.exists_countable_dense_subset_no_bot_top

end DenselyOrdered

section CompleteLinearOrder

variable [CompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [CompleteLinearOrder Î²] [TopologicalSpace Î²]
  [OrderTopology Î²] [Nonempty Î³]

theorem Sup_mem_closure {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) : Sup s âˆˆ Closure s :=
  (is_lub_Sup s).mem_closure hs

theorem Inf_mem_closure {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) : Inf s âˆˆ Closure s :=
  (is_glb_Inf s).mem_closure hs

theorem IsClosed.Sup_mem {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) (hc : IsClosed s) : Sup s âˆˆ s :=
  (is_lub_Sup s).mem_of_is_closed hs hc

theorem IsClosed.Inf_mem {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±] {s : Set Î±}
  (hs : s.nonempty) (hc : IsClosed s) : Inf s âˆˆ s :=
  (is_glb_Inf s).mem_of_is_closed hs hc

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone' {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (hs : s.nonempty) : f (Sup s) = Sup (f '' s) :=
  ((is_lub_Sup _).is_lub_of_tendsto (fun x hx y hy xy => Mf xy) hs$ Cf.mono_left inf_le_left).Sup_eq.symm

/-- A monotone function `s` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (fbot : f âŠ¥ = âŠ¥) : f (Sup s) = Sup (f '' s) :=
  by 
    cases' s.eq_empty_or_nonempty with h h
    Â·
      simp [h, fbot]
    Â·
      exact map_Sup_of_continuous_at_of_monotone' Cf Mf h

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone' {Î¹ : Sort _} [Nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : ContinuousAt f (supr g)) (Mf : Monotone f) : f (â¨†i, g i) = â¨†i, f (g i) :=
  by 
    rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), â†range_comp, supr]

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone {Î¹ : Sort _} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (supr g))
  (Mf : Monotone f) (fbot : f âŠ¥ = âŠ¥) : f (â¨†i, g i) = â¨†i, f (g i) :=
  by 
    rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, â†range_comp, supr]

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone' {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (hs : s.nonempty) : f (Inf s) = Inf (f '' s) :=
  @map_Sup_of_continuous_at_of_monotone' (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ f s Cf Mf.dual hs

/-- A monotone function `s` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (ftop : f âŠ¤ = âŠ¤) : f (Inf s) = Inf (f '' s) :=
  @map_Sup_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ f s Cf Mf.dual ftop

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone' {Î¹ : Sort _} [Nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : ContinuousAt f (infi g)) (Mf : Monotone f) : f (â¨…i, g i) = â¨…i, f (g i) :=
  @map_supr_of_continuous_at_of_monotone' (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ Î¹ _ f g Cf Mf.dual

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone {Î¹ : Sort _} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (infi g))
  (Mf : Monotone f) (ftop : f âŠ¤ = âŠ¤) : f (infi g) = infi (f âˆ˜ g) :=
  @map_supr_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ Î¹ f g Cf Mf.dual ftop

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  [ConditionallyCompleteLinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] [Nonempty Î³]

theorem cSup_mem_closure {s : Set Î±} (hs : s.nonempty) (B : BddAbove s) : Sup s âˆˆ Closure s :=
  (is_lub_cSup hs B).mem_closure hs

theorem cInf_mem_closure {s : Set Î±} (hs : s.nonempty) (B : BddBelow s) : Inf s âˆˆ Closure s :=
  (is_glb_cInf hs B).mem_closure hs

theorem IsClosed.cSup_mem {s : Set Î±} (hc : IsClosed s) (hs : s.nonempty) (B : BddAbove s) : Sup s âˆˆ s :=
  (is_lub_cSup hs B).mem_of_is_closed hs hc

theorem IsClosed.cInf_mem {s : Set Î±} (hc : IsClosed s) (hs : s.nonempty) (B : BddBelow s) : Inf s âˆˆ s :=
  (is_glb_cInf hs B).mem_of_is_closed hs hc

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
theorem map_cSup_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (ne : s.nonempty) (H : BddAbove s) : f (Sup s) = Sup (f '' s) :=
  by 
    refine' ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm 
    refine' (is_lub_cSup Ne H).is_lub_of_tendsto (fun x hx y hy xy => Mf xy) Ne _ 
    exact Cf.mono_left inf_le_left

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
theorem map_csupr_of_continuous_at_of_monotone {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : ContinuousAt f (â¨†i, g i)) (Mf : Monotone f)
  (H : BddAbove (range g)) : f (â¨†i, g i) = â¨†i, f (g i) :=
  by 
    rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, â†range_comp, supr]

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
theorem map_cInf_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : Set Î±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (ne : s.nonempty) (H : BddBelow s) : f (Inf s) = Inf (f '' s) :=
  @map_cSup_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ f s Cf Mf.dual Ne H

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
theorem map_cinfi_of_continuous_at_of_monotone {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : ContinuousAt f (â¨…i, g i)) (Mf : Monotone f)
  (H : BddBelow (range g)) : f (â¨…i, g i) = â¨…i, f (g i) :=
  @map_csupr_of_continuous_at_of_monotone (OrderDual Î±) (OrderDual Î²) _ _ _ _ _ _ _ _ _ _ Cf Mf.dual H

/-- A monotone map has a limit to the left of any point `x`, equal to `Sup (f '' (Iio x))`. -/
theorem Monotone.tendsto_nhds_within_Iio {Î± : Type _} [LinearOrderâ‚“ Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  {f : Î± â†’ Î²} (Mf : Monotone f) (x : Î±) : tendsto f (ğ“[Iio x] x) (ğ“ (Sup (f '' Iio x))) :=
  by 
    rcases eq_empty_or_nonempty (Iio x) with (h | h)
    Â·
      simp [h]
    refine' tendsto_order.2 âŸ¨fun l hl => _, fun m hm => _âŸ©
    Â·
      obtain âŸ¨z, zx, lzâŸ© : âˆƒ a : Î±, a < x âˆ§ l < f a
      Â·
        simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using
          exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl 
      exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 âŸ¨z, zx, fun y hy => lz.trans_le (Mf hy.1.le)âŸ©
    Â·
      filterUpwards [self_mem_nhds_within]
      intro y hy 
      apply lt_of_le_of_ltâ‚“ _ hm 
      exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy)

/-- A monotone map has a limit to the right of any point `x`, equal to `Inf (f '' (Ioi x))`. -/
theorem Monotone.tendsto_nhds_within_Ioi {Î± : Type _} [LinearOrderâ‚“ Î±] [TopologicalSpace Î±] [OrderTopology Î±]
  {f : Î± â†’ Î²} (Mf : Monotone f) (x : Î±) : tendsto f (ğ“[Ioi x] x) (ğ“ (Inf (f '' Ioi x))) :=
  @Monotone.tendsto_nhds_within_Iio (OrderDual Î²) _ _ _ (OrderDual Î±) _ _ _ f Mf.dual x

end ConditionallyCompleteLinearOrder

end OrderTopology

