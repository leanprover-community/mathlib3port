/-
Copyright (c) 2020 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker

! This file was ported from Lean 3 source module topology.algebra.order.floor
! leanprover-community/mathlib commit ee05e9ce1322178f0c12004eb93c00d2c8c00ed2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Floor
import Mathbin.Topology.Algebra.Order.Group

/-!
# Topological facts about `int.floor`, `int.ceil` and `int.fract`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file proves statements about limits and continuity of functions involving `floor`, `ceil` and
`fract`.

## Main declarations

* `tendsto_floor_at_top`, `tendsto_floor_at_bot`, `tendsto_ceil_at_top`, `tendsto_ceil_at_bot`:
  `int.floor` and `int.ceil` tend to +-âˆ in +-âˆ.
* `continuous_on_floor`: `int.floor` is continuous on `Ico n (n + 1)`, because constant.
* `continuous_on_ceil`: `int.ceil` is continuous on `Ioc n (n + 1)`, because constant.
* `continuous_on_fract`: `int.fract` is continuous on `Ico n (n + 1)`.
* `continuous_on.comp_fract`: Precomposing a continuous function satisfying `f 0 = f 1` with
  `int.fract` yields another continuous function.
-/


open Filter Function Int Set

open Topology

variable {Î± Î² Î³ : Type _} [LinearOrderedRing Î±] [FloorRing Î±]

#print tendsto_floor_atTop /-
theorem tendsto_floor_atTop : Tendsto (floor : Î± â†’ â„¤) atTop atTop :=
  floor_mono.tendsto_atTop_atTop fun b =>
    âŸ¨(b + 1 : â„¤), by
      rw [floor_int_cast]
      exact (lt_add_one _).leâŸ©
#align tendsto_floor_at_top tendsto_floor_atTop
-/

#print tendsto_floor_atBot /-
theorem tendsto_floor_atBot : Tendsto (floor : Î± â†’ â„¤) atBot atBot :=
  floor_mono.tendsto_atBot_atBot fun b => âŸ¨b, (floor_intCast _).leâŸ©
#align tendsto_floor_at_bot tendsto_floor_atBot
-/

#print tendsto_ceil_atTop /-
theorem tendsto_ceil_atTop : Tendsto (ceil : Î± â†’ â„¤) atTop atTop :=
  ceil_mono.tendsto_atTop_atTop fun b => âŸ¨b, (ceil_intCast _).geâŸ©
#align tendsto_ceil_at_top tendsto_ceil_atTop
-/

#print tendsto_ceil_atBot /-
theorem tendsto_ceil_atBot : Tendsto (ceil : Î± â†’ â„¤) atBot atBot :=
  ceil_mono.tendsto_atBot_atBot fun b =>
    âŸ¨(b - 1 : â„¤), by
      rw [ceil_int_cast]
      exact (sub_one_lt _).leâŸ©
#align tendsto_ceil_at_bot tendsto_ceil_atBot
-/

variable [TopologicalSpace Î±]

/- warning: continuous_on_floor -> continuousOn_floor is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] (n : Int), ContinuousOn.{u1, u1} Î± Î± _inst_3 _inst_3 (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (Set.Ico.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toHasAdd.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] (n : Int), ContinuousOn.{u1, u1} Î± Î± _inst_3 _inst_3 (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (Set.Ico.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align continuous_on_floor continuousOn_floorâ‚“'. -/
theorem continuousOn_floor (n : â„¤) :
    ContinuousOn (fun x => floor x : Î± â†’ Î±) (Ico n (n + 1) : Set Î±) :=
  (continuousOn_congr <| floor_eq_on_Ico' n).mpr continuousOn_const
#align continuous_on_floor continuousOn_floor

/- warning: continuous_on_ceil -> continuousOn_ceil is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] (n : Int), ContinuousOn.{u1, u1} Î± Î± _inst_3 _inst_3 (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (Set.Ioc.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (SubNegMonoid.toHasSub.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] (n : Int), ContinuousOn.{u1, u1} Î± Î± _inst_3 _inst_3 (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (Set.Ioc.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (Ring.toSub.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))
Case conversion may be inaccurate. Consider using '#align continuous_on_ceil continuousOn_ceilâ‚“'. -/
theorem continuousOn_ceil (n : â„¤) :
    ContinuousOn (fun x => ceil x : Î± â†’ Î±) (Ioc (n - 1) n : Set Î±) :=
  (continuousOn_congr <| ceil_eq_on_Ioc' n).mpr continuousOn_const
#align continuous_on_ceil continuousOn_ceil

/- warning: tendsto_floor_right' -> tendsto_floor_right' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhds.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhds.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))
Case conversion may be inaccurate. Consider using '#align tendsto_floor_right' tendsto_floor_right'â‚“'. -/
theorem tendsto_floor_right' [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => floor x : Î± â†’ Î±) (ğ“[â‰¥] n) (ğ“ n) :=
  by
  rw [â† nhdsWithin_Ico_eq_nhdsWithin_Ici (lt_add_one (n : Î±))]
  simpa only [floor_int_cast] using
    (continuousOn_floor n _ (left_mem_Ico.mpr <| lt_add_one (_ : Î±))).Tendsto
#align tendsto_floor_right' tendsto_floor_right'

/- warning: tendsto_ceil_left' -> tendsto_ceil_left' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhds.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhds.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))
Case conversion may be inaccurate. Consider using '#align tendsto_ceil_left' tendsto_ceil_left'â‚“'. -/
theorem tendsto_ceil_left' [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => ceil x : Î± â†’ Î±) (ğ“[â‰¤] n) (ğ“ n) :=
  by
  rw [â† nhdsWithin_Ioc_eq_nhdsWithin_Iic (sub_one_lt (n : Î±))]
  simpa only [ceil_int_cast] using
    (continuousOn_ceil _ _ (right_mem_Ioc.mpr <| sub_one_lt (_ : Î±))).Tendsto
#align tendsto_ceil_left' tendsto_ceil_left'

/- warning: tendsto_floor_right -> tendsto_floor_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n)))
Case conversion may be inaccurate. Consider using '#align tendsto_floor_right tendsto_floor_rightâ‚“'. -/
theorem tendsto_floor_right [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => floor x : Î± â†’ Î±) (ğ“[â‰¥] n) (ğ“[â‰¥] n) :=
  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ (tendsto_floor_right' _)
    (by
      refine' eventually_nhdsWithin_of_forall fun x (hx : (n : Î±) â‰¤ x) => _
      change _ â‰¤ _
      norm_cast
      convertâ† floor_mono hx
      rw [floor_eq_iff]
      exact âŸ¨le_rfl, lt_add_one _âŸ©)
#align tendsto_floor_right tendsto_floor_right

/- warning: tendsto_ceil_left -> tendsto_ceil_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n)))
Case conversion may be inaccurate. Consider using '#align tendsto_ceil_left tendsto_ceil_leftâ‚“'. -/
theorem tendsto_ceil_left [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => ceil x : Î± â†’ Î±) (ğ“[â‰¤] n) (ğ“[â‰¤] n) :=
  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ (tendsto_ceil_left' _)
    (by
      refine' eventually_nhdsWithin_of_forall fun x (hx : x â‰¤ (n : Î±)) => _
      change _ â‰¤ _
      norm_cast
      convertâ† ceil_mono hx
      rw [ceil_eq_iff]
      exact âŸ¨sub_one_lt _, le_rflâŸ©)
#align tendsto_ceil_left tendsto_ceil_left

/- warning: tendsto_floor_left -> tendsto_floor_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhdsWithin.{u1} Î± _inst_3 (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (SubNegMonoid.toHasSub.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (SubNegMonoid.toHasSub.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhdsWithin.{u1} Î± _inst_3 (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (Ring.toSub.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) (Set.Iic.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (Ring.toSub.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_floor_left tendsto_floor_leftâ‚“'. -/
theorem tendsto_floor_left [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => floor x : Î± â†’ Î±) (ğ“[<] n) (ğ“[â‰¤] (n - 1)) :=
  by
  rw [â† nhdsWithin_Ico_eq_nhdsWithin_Iio (sub_one_lt (n : Î±))]
  convert(tendsto_nhdsWithin_congr fun x hx => (floor_eq_on_Ico' (n - 1) x hx).symm)
        (tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ tendsto_const_nhds
          (eventually_of_forall fun _ => mem_Iic.mpr <| le_rfl)) <;>
    first |norm_cast|infer_instance
  ring
#align tendsto_floor_left tendsto_floor_left

/- warning: tendsto_ceil_right -> tendsto_ceil_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhdsWithin.{u1} Î± _inst_3 (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toHasAdd.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toHasAdd.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhdsWithin.{u1} Î± _inst_3 (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_ceil_right tendsto_ceil_rightâ‚“'. -/
theorem tendsto_ceil_right [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => ceil x : Î± â†’ Î±) (ğ“[>] n) (ğ“[â‰¥] (n + 1)) :=
  by
  rw [â† nhdsWithin_Ioc_eq_nhdsWithin_Ioi (lt_add_one (n : Î±))]
  convert(tendsto_nhdsWithin_congr fun x hx => (ceil_eq_on_Ioc' (n + 1) x hx).symm)
        (tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ tendsto_const_nhds
          (eventually_of_forall fun _ => mem_Ici.mpr <| le_rfl)) <;>
    first |norm_cast|infer_instance
  ring
#align tendsto_ceil_right tendsto_ceil_right

/- warning: tendsto_floor_left' -> tendsto_floor_left' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhds.{u1} Î± _inst_3 (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (SubNegMonoid.toHasSub.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.floor.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhds.{u1} Î± _inst_3 (HSub.hSub.{u1, u1, u1} Î± Î± Î± (instHSub.{u1} Î± (Ring.toSub.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_floor_left' tendsto_floor_left'â‚“'. -/
theorem tendsto_floor_left' [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => floor x : Î± â†’ Î±) (ğ“[<] n) (ğ“ (n - 1)) :=
  by
  rw [â† nhdsWithin_univ]
  exact tendsto_nhdsWithin_mono_right (subset_univ _) (tendsto_floor_left n)
#align tendsto_floor_left' tendsto_floor_left'

/- warning: tendsto_ceil_right' -> tendsto_ceil_right' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => (fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhds.{u1} Î± _inst_3 (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toHasAdd.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (fun (x : Î±) => Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.ceil.{u1} Î± _inst_1 _inst_2 x)) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Ioi.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhds.{u1} Î± _inst_3 (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_ceil_right' tendsto_ceil_right'â‚“'. -/
theorem tendsto_ceil_right' [OrderClosedTopology Î±] (n : â„¤) :
    Tendsto (fun x => ceil x : Î± â†’ Î±) (ğ“[>] n) (ğ“ (n + 1)) :=
  by
  rw [â† nhdsWithin_univ]
  exact tendsto_nhdsWithin_mono_right (subset_univ _) (tendsto_ceil_right n)
#align tendsto_ceil_right' tendsto_ceil_right'

/- warning: continuous_on_fract -> continuousOn_fract is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))] (n : Int), ContinuousOn.{u1, u1} Î± Î± _inst_3 _inst_3 (Int.fract.{u1} Î± _inst_1 _inst_2) (Set.Ico.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toHasAdd.{u1} Î± (Ring.toDistrib.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (Ring.toAddGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), ContinuousOn.{u1, u1} Î± Î± _inst_3 _inst_3 (Int.fract.{u1} Î± _inst_1 _inst_2) (Set.Ico.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align continuous_on_fract continuousOn_fractâ‚“'. -/
theorem continuousOn_fract [TopologicalAddGroup Î±] (n : â„¤) :
    ContinuousOn (fract : Î± â†’ Î±) (Ico n (n + 1) : Set Î±) :=
  continuousOn_id.sub (continuousOn_floor n)
#align continuous_on_fract continuousOn_fract

/- warning: tendsto_fract_left' -> tendsto_fract_left' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhds.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (Ring.toAddGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhds.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align tendsto_fract_left' tendsto_fract_left'â‚“'. -/
theorem tendsto_fract_left' [OrderClosedTopology Î±] [TopologicalAddGroup Î±] (n : â„¤) :
    Tendsto (fract : Î± â†’ Î±) (ğ“[<] n) (ğ“ 1) := by
  convert(tendsto_nhdsWithin_of_tendsto_nhds tendsto_id).sub (tendsto_floor_left' n) <;>
    [Â·
      norm_cast
      ring, infer_instance, infer_instance]
#align tendsto_fract_left' tendsto_fract_left'

/- warning: tendsto_fract_left -> tendsto_fract_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhdsWithin.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (Ring.toAddGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhdsWithin.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1)))))) (Set.Iio.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_fract_left tendsto_fract_leftâ‚“'. -/
theorem tendsto_fract_left [OrderClosedTopology Î±] [TopologicalAddGroup Î±] (n : â„¤) :
    Tendsto (fract : Î± â†’ Î±) (ğ“[<] n) (ğ“[<] 1) :=
  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ (tendsto_fract_left' _)
    (eventually_of_forall fract_lt_one)
#align tendsto_fract_left tendsto_fract_left

/- warning: tendsto_fract_right' -> tendsto_fract_right' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhds.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (Ring.toAddGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhds.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_fract_right' tendsto_fract_right'â‚“'. -/
theorem tendsto_fract_right' [OrderClosedTopology Î±] [TopologicalAddGroup Î±] (n : â„¤) :
    Tendsto (fract : Î± â†’ Î±) (ğ“[â‰¥] n) (ğ“ 0) := by
  convert(tendsto_nhdsWithin_of_tendsto_nhds tendsto_id).sub (tendsto_floor_right' n) <;>
    [exact (sub_self _).symm, infer_instance, infer_instance]
#align tendsto_fract_right' tendsto_fract_right'

/- warning: tendsto_fract_right -> tendsto_fract_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int Î± (HasLiftT.mk.{1, succ u1} Int Î± (CoeTCâ‚“.coe.{1, succ u1} Int Î± (Int.castCoe.{u1} Î± (AddGroupWithOne.toHasIntCast.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))) n))) (nhdsWithin.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderClosedTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))] [_inst_5 : TopologicalAddGroup.{u1} Î± _inst_3 (AddGroupWithOne.toAddGroup.{u1} Î± (Ring.toAddGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] (n : Int), Filter.Tendsto.{u1, u1} Î± Î± (Int.fract.{u1} Î± _inst_1 _inst_2) (nhdsWithin.{u1} Î± _inst_3 (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (Int.cast.{u1} Î± (Ring.toIntCast.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) n))) (nhdsWithin.{u1} Î± _inst_3 (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) (Set.Ici.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_fract_right tendsto_fract_rightâ‚“'. -/
theorem tendsto_fract_right [OrderClosedTopology Î±] [TopologicalAddGroup Î±] (n : â„¤) :
    Tendsto (fract : Î± â†’ Î±) (ğ“[â‰¥] n) (ğ“[â‰¥] 0) :=
  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ (tendsto_fract_right' _)
    (eventually_of_forall fract_nonneg)
#align tendsto_fract_right tendsto_fract_right

-- mathport name: exprI
local notation "I" => (Icc 0 1 : Set Î±)

variable [OrderTopology Î±] [TopologicalSpace Î²] [TopologicalSpace Î³]

/- warning: continuous_on.comp_fract' -> ContinuousOn.comp_fract' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] [_inst_5 : TopologicalSpace.{u2} Î²] [_inst_6 : TopologicalSpace.{u3} Î³] {f : Î² -> Î± -> Î³}, (ContinuousOn.{max u2 u1, u3} (Prod.{u2, u1} Î² Î±) Î³ (Prod.topologicalSpace.{u2, u1} Î² Î± _inst_5 _inst_3) _inst_6 (Function.uncurry.{u2, u1, u3} Î² Î± Î³ f) (Set.prod.{u2, u1} Î² Î± (Set.univ.{u2} Î²) (Set.Icc.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))) -> (forall (s : Î²), Eq.{succ u3} Î³ (f s (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))) (f s (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))) -> (Continuous.{max u2 u1, u3} (Prod.{u2, u1} Î² Î±) Î³ (Prod.topologicalSpace.{u2, u1} Î² Î± _inst_5 _inst_3) _inst_6 (fun (st : Prod.{u2, u1} Î² Î±) => f (Prod.fst.{u2, u1} Î² Î± st) (Int.fract.{u1} Î± _inst_1 _inst_2 (Prod.snd.{u2, u1} Î² Î± st))))
but is expected to have type
  forall {Î± : Type.{u3}} {Î² : Type.{u2}} {Î³ : Type.{u1}} [_inst_1 : LinearOrderedRing.{u3} Î±] [_inst_2 : FloorRing.{u3} Î± _inst_1] [_inst_3 : TopologicalSpace.{u3} Î±] [_inst_4 : OrderTopology.{u3} Î± _inst_3 (PartialOrder.toPreorder.{u3} Î± (StrictOrderedRing.toPartialOrder.{u3} Î± (LinearOrderedRing.toStrictOrderedRing.{u3} Î± _inst_1)))] [_inst_5 : TopologicalSpace.{u2} Î²] [_inst_6 : TopologicalSpace.{u1} Î³] {f : Î² -> Î± -> Î³}, (ContinuousOn.{max u3 u2, u1} (Prod.{u2, u3} Î² Î±) Î³ (instTopologicalSpaceProd.{u2, u3} Î² Î± _inst_5 _inst_3) _inst_6 (Function.uncurry.{u2, u3, u1} Î² Î± Î³ f) (Set.prod.{u2, u3} Î² Î± (Set.univ.{u2} Î²) (Set.Icc.{u3} Î± (PartialOrder.toPreorder.{u3} Î± (StrictOrderedRing.toPartialOrder.{u3} Î± (LinearOrderedRing.toStrictOrderedRing.{u3} Î± _inst_1))) (OfNat.ofNat.{u3} Î± 0 (Zero.toOfNat0.{u3} Î± (MonoidWithZero.toZero.{u3} Î± (Semiring.toMonoidWithZero.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1))))))) (OfNat.ofNat.{u3} Î± 1 (One.toOfNat1.{u3} Î± (Semiring.toOne.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1))))))))) -> (forall (s : Î²), Eq.{succ u1} Î³ (f s (OfNat.ofNat.{u3} Î± 0 (Zero.toOfNat0.{u3} Î± (MonoidWithZero.toZero.{u3} Î± (Semiring.toMonoidWithZero.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1)))))))) (f s (OfNat.ofNat.{u3} Î± 1 (One.toOfNat1.{u3} Î± (Semiring.toOne.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1)))))))) -> (Continuous.{max u3 u2, u1} (Prod.{u2, u3} Î² Î±) Î³ (instTopologicalSpaceProd.{u2, u3} Î² Î± _inst_5 _inst_3) _inst_6 (fun (st : Prod.{u2, u3} Î² Î±) => f (Prod.fst.{u2, u3} Î² Î± st) (Int.fract.{u3} Î± _inst_1 _inst_2 (Prod.snd.{u2, u3} Î² Î± st))))
Case conversion may be inaccurate. Consider using '#align continuous_on.comp_fract' ContinuousOn.comp_fract'â‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Do not use this, use `continuous_on.comp_fract` instead. -/
theorem ContinuousOn.comp_fract' {f : Î² â†’ Î± â†’ Î³} (h : ContinuousOn (uncurry f) <| univ Ã—Ë¢ I)
    (hf : âˆ€ s, f s 0 = f s 1) : Continuous fun st : Î² Ã— Î± => f st.1 <| fract st.2 :=
  by
  change Continuous (uncurry f âˆ˜ Prod.map id fract)
  rw [continuous_iff_continuousAt]
  rintro âŸ¨s, tâŸ©
  by_cases ht : t = floor t
  Â· rw [ht]
    rw [â† continuousWithinAt_univ]
    have : (univ : Set (Î² Ã— Î±)) âŠ† univ Ã—Ë¢ Iio â†‘âŒŠtâŒ‹ âˆª univ Ã—Ë¢ Ici â†‘âŒŠtâŒ‹ :=
      by
      rintro p -
      rw [â† prod_union]
      exact âŸ¨trivial, lt_or_le p.2 _âŸ©
    refine' ContinuousWithinAt.mono _ this
    refine' ContinuousWithinAt.union _ _
    Â· simp only [ContinuousWithinAt, fract_int_cast, nhdsWithin_prod_eq, nhdsWithin_univ, id.def,
        comp_app, Prod.map_mk]
      have : (uncurry f) (s, 0) = (uncurry f) (s, (1 : Î±)) := by simp [uncurry, hf]
      rw [this]
      refine' (h _ âŸ¨âŸ¨âŸ©, by exact_mod_cast right_mem_Icc.2 (zero_le_one' Î±)âŸ©).Tendsto.comp _
      rw [nhdsWithin_prod_eq, nhdsWithin_univ]
      rw [nhdsWithin_Icc_eq_nhdsWithin_Iic (zero_lt_one' Î±)]
      exact
        tendsto_id.prod_map
          (tendsto_nhdsWithin_mono_right Iio_subset_Iic_self <| tendsto_fract_left _)
    Â· simp only [ContinuousWithinAt, fract_int_cast, nhdsWithin_prod_eq, nhdsWithin_univ, id.def,
        comp_app, Prod.map_mk]
      refine' (h _ âŸ¨âŸ¨âŸ©, by exact_mod_cast left_mem_Icc.2 (zero_le_one' Î±)âŸ©).Tendsto.comp _
      rw [nhdsWithin_prod_eq, nhdsWithin_univ, nhdsWithin_Icc_eq_nhdsWithin_Ici (zero_lt_one' Î±)]
      exact tendsto_id.prod_map (tendsto_fract_right _)
  Â· have : t âˆˆ Ioo (floor t : Î±) ((floor t : Î±) + 1) :=
      âŸ¨lt_of_le_of_ne (floor_le t) (Ne.symm ht), lt_floor_add_one _âŸ©
    apply (h ((Prod.map _ fract) _) âŸ¨trivial, âŸ¨fract_nonneg _, (fract_lt_one _).leâŸ©âŸ©).Tendsto.comp
    simp only [nhds_prod_eq, nhdsWithin_prod_eq, nhdsWithin_univ, id.def, Prod.map_mk]
    exact
      continuous_at_id.tendsto.prod_map
        (tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
          (((continuousOn_fract _ _ (Ioo_subset_Ico_self this)).mono
                Ioo_subset_Ico_self).ContinuousAt
            (Ioo_mem_nhds this.1 this.2))
          (eventually_of_forall fun x => âŸ¨fract_nonneg _, (fract_lt_one _).leâŸ©))
#align continuous_on.comp_fract' ContinuousOn.comp_fract'

/- warning: continuous_on.comp_fract -> ContinuousOn.comp_fract is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {Î³ : Type.{u3}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] [_inst_5 : TopologicalSpace.{u2} Î²] [_inst_6 : TopologicalSpace.{u3} Î³] {s : Î² -> Î±} {f : Î² -> Î± -> Î³}, (ContinuousOn.{max u2 u1, u3} (Prod.{u2, u1} Î² Î±) Î³ (Prod.topologicalSpace.{u2, u1} Î² Î± _inst_5 _inst_3) _inst_6 (Function.uncurry.{u2, u1, u3} Î² Î± Î³ f) (Set.prod.{u2, u1} Î² Î± (Set.univ.{u2} Î²) (Set.Icc.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))))) -> (Continuous.{u2, u1} Î² Î± _inst_5 _inst_3 s) -> (forall (s : Î²), Eq.{succ u3} Î³ (f s (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))) (f s (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))) -> (Continuous.{u2, u3} Î² Î³ _inst_5 _inst_6 (fun (x : Î²) => f x (Int.fract.{u1} Î± _inst_1 _inst_2 (s x))))
but is expected to have type
  forall {Î± : Type.{u3}} {Î² : Type.{u2}} {Î³ : Type.{u1}} [_inst_1 : LinearOrderedRing.{u3} Î±] [_inst_2 : FloorRing.{u3} Î± _inst_1] [_inst_3 : TopologicalSpace.{u3} Î±] [_inst_4 : OrderTopology.{u3} Î± _inst_3 (PartialOrder.toPreorder.{u3} Î± (StrictOrderedRing.toPartialOrder.{u3} Î± (LinearOrderedRing.toStrictOrderedRing.{u3} Î± _inst_1)))] [_inst_5 : TopologicalSpace.{u2} Î²] [_inst_6 : TopologicalSpace.{u1} Î³] {s : Î² -> Î±} {f : Î² -> Î± -> Î³}, (ContinuousOn.{max u3 u2, u1} (Prod.{u2, u3} Î² Î±) Î³ (instTopologicalSpaceProd.{u2, u3} Î² Î± _inst_5 _inst_3) _inst_6 (Function.uncurry.{u2, u3, u1} Î² Î± Î³ f) (Set.prod.{u2, u3} Î² Î± (Set.univ.{u2} Î²) (Set.Icc.{u3} Î± (PartialOrder.toPreorder.{u3} Î± (StrictOrderedRing.toPartialOrder.{u3} Î± (LinearOrderedRing.toStrictOrderedRing.{u3} Î± _inst_1))) (OfNat.ofNat.{u3} Î± 0 (Zero.toOfNat0.{u3} Î± (MonoidWithZero.toZero.{u3} Î± (Semiring.toMonoidWithZero.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1))))))) (OfNat.ofNat.{u3} Î± 1 (One.toOfNat1.{u3} Î± (Semiring.toOne.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1))))))))) -> (Continuous.{u2, u3} Î² Î± _inst_5 _inst_3 s) -> (forall (s : Î²), Eq.{succ u1} Î³ (f s (OfNat.ofNat.{u3} Î± 0 (Zero.toOfNat0.{u3} Î± (MonoidWithZero.toZero.{u3} Î± (Semiring.toMonoidWithZero.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1)))))))) (f s (OfNat.ofNat.{u3} Î± 1 (One.toOfNat1.{u3} Î± (Semiring.toOne.{u3} Î± (StrictOrderedSemiring.toSemiring.{u3} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u3} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u3} Î± _inst_1)))))))) -> (Continuous.{u2, u1} Î² Î³ _inst_5 _inst_6 (fun (x : Î²) => f x (Int.fract.{u3} Î± _inst_1 _inst_2 (s x))))
Case conversion may be inaccurate. Consider using '#align continuous_on.comp_fract ContinuousOn.comp_fractâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem ContinuousOn.comp_fract {s : Î² â†’ Î±} {f : Î² â†’ Î± â†’ Î³}
    (h : ContinuousOn (uncurry f) <| univ Ã—Ë¢ Icc 0 1) (hs : Continuous s)
    (hf : âˆ€ s, f s 0 = f s 1) : Continuous fun x : Î² => f x <| Int.fract (s x) :=
  (h.comp_fract' hf).comp (continuous_id.prod_mk hs)
#align continuous_on.comp_fract ContinuousOn.comp_fract

/- warning: continuous_on.comp_fract'' -> ContinuousOn.comp_fract'' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : FloorRing.{u1} Î± _inst_1] [_inst_3 : TopologicalSpace.{u1} Î±] [_inst_4 : OrderTopology.{u1} Î± _inst_3 (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] [_inst_5 : TopologicalSpace.{u2} Î²] {f : Î± -> Î²}, (ContinuousOn.{u1, u2} Î± Î² _inst_3 _inst_5 f (Set.Icc.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))))))) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))) -> (Eq.{succ u2} Î² (f (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} Î± (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î± (Ring.toNonAssocRing.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))) (f (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))))) -> (Continuous.{u1, u2} Î± Î² _inst_3 _inst_5 (Function.comp.{succ u1, succ u1, succ u2} Î± Î± Î² f (Int.fract.{u1} Î± _inst_1 _inst_2)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} Î±] [_inst_2 : FloorRing.{u2} Î± _inst_1] [_inst_3 : TopologicalSpace.{u2} Î±] [_inst_4 : OrderTopology.{u2} Î± _inst_3 (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± _inst_1)))] [_inst_5 : TopologicalSpace.{u1} Î²] {f : Î± -> Î²}, (ContinuousOn.{u2, u1} Î± Î² _inst_3 _inst_5 f (Set.Icc.{u2} Î± (PartialOrder.toPreorder.{u2} Î± (StrictOrderedRing.toPartialOrder.{u2} Î± (LinearOrderedRing.toStrictOrderedRing.{u2} Î± _inst_1))) (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (MonoidWithZero.toZero.{u2} Î± (Semiring.toMonoidWithZero.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u2} Î± _inst_1))))))) (OfNat.ofNat.{u2} Î± 1 (One.toOfNat1.{u2} Î± (Semiring.toOne.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u2} Î± _inst_1)))))))) -> (Eq.{succ u1} Î² (f (OfNat.ofNat.{u2} Î± 0 (Zero.toOfNat0.{u2} Î± (MonoidWithZero.toZero.{u2} Î± (Semiring.toMonoidWithZero.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u2} Î± _inst_1)))))))) (f (OfNat.ofNat.{u2} Î± 1 (One.toOfNat1.{u2} Î± (Semiring.toOne.{u2} Î± (StrictOrderedSemiring.toSemiring.{u2} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u2} Î± _inst_1)))))))) -> (Continuous.{u2, u1} Î± Î² _inst_3 _inst_5 (Function.comp.{succ u2, succ u2, succ u1} Î± Î± Î² f (Int.fract.{u2} Î± _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align continuous_on.comp_fract'' ContinuousOn.comp_fract''â‚“'. -/
/-- A special case of `continuous_on.comp_fract`. -/
theorem ContinuousOn.comp_fract'' {f : Î± â†’ Î²} (h : ContinuousOn f I) (hf : f 0 = f 1) :
    Continuous (f âˆ˜ fract) :=
  ContinuousOn.comp_fract (h.comp continuousOn_snd fun x hx => (mem_prod.mp hx).2) continuous_id
    fun _ => hf
#align continuous_on.comp_fract'' ContinuousOn.comp_fract''

