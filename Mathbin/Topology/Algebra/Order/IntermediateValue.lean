/-
Copyright (c) 2021 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov, Alistair Tucker

! This file was ported from Lean 3 source module topology.algebra.order.intermediate_value
! leanprover-community/mathlib commit 50832daea47b195a48b5b33b1c8b2162c48c3afc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Order.CompleteLatticeIntervals
import Mathbin.Topology.Order.Basic

/-!
# Intermediate Value Theorem

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we prove the Intermediate Value Theorem: if `f : Œ± ‚Üí Œ≤` is a function defined on a
connected set `s` that takes both values `‚â§ a` and values `‚â• a` on `s`, then it is equal to `a` at
some point of `s`. We also prove that intervals in a dense conditionally complete order are
preconnected and any preconnected set is an interval. Then we specialize IVT to functions continuous
on intervals.

## Main results

* `is_preconnected_I??` : all intervals `I??` are preconnected,
* `is_preconnected.intermediate_value`, `intermediate_value_univ` : Intermediate Value Theorem for
  connected sets and connected spaces, respectively;
* `intermediate_value_Icc`, `intermediate_value_Icc'`: Intermediate Value Theorem for functions
  on closed intervals.

### Miscellaneous facts

* `is_closed.Icc_subset_of_forall_mem_nhds_within` : ‚ÄúContinuous induction‚Äù principle;
  if `s ‚à© [a, b]` is closed, `a ‚àà s`, and for each `x ‚àà [a, b) ‚à© s` some of its right neighborhoods
  is included `s`, then `[a, b] ‚äÜ s`.
* `is_closed.Icc_subset_of_forall_exists_gt`, `is_closed.mem_of_ge_of_forall_exists_gt` : two
  other versions of the ‚Äúcontinuous induction‚Äù principle.

## Tags

intermediate value theorem, connected space, connected set
-/


open Filter OrderDual TopologicalSpace Function Set

open Topology Filter

universe u v w

/-!
### Intermediate value theorem on a (pre)connected space

In this section we prove the following theorem (see `is_preconnected.intermediate_value‚ÇÇ`): if `f`
and `g` are two functions continuous on a preconnected set `s`, `f a ‚â§ g a` at some `a ‚àà s` and
`g b ‚â§ f b` at some `b ‚àà s`, then `f c = g c` at some `c ‚àà s`. We prove several versions of this
statement, including the classical IVT that corresponds to a constant function `g`.
-/


section

variable {X : Type u} {Œ± : Type v} [TopologicalSpace X] [LinearOrder Œ±] [TopologicalSpace Œ±]
  [OrderClosedTopology Œ±]

/- warning: intermediate_value_univ‚ÇÇ -> intermediate_value_univ‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {a : X} {b : X} {f : X -> Œ±} {g : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 g) -> (LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) (f a) (g a)) -> (LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) (g b) (f b)) -> (Exists.{succ u1} X (fun (x : X) => Eq.{succ u2} Œ± (f x) (g x)))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {a : X} {b : X} {f : X -> Œ±} {g : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 g) -> (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (f a) (g a)) -> (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (g b) (f b)) -> (Exists.{succ u1} X (fun (x : X) => Eq.{succ u2} Œ± (f x) (g x)))
Case conversion may be inaccurate. Consider using '#align intermediate_value_univ‚ÇÇ intermediate_value_univ‚ÇÇ‚Çì'. -/
/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions
on a preconnected space and `f a ‚â§ g a` and `g b ‚â§ f b`, then for some `x` we have `f x = g x`. -/
theorem intermediate_value_univ‚ÇÇ [PreconnectedSpace X] {a b : X} {f g : X ‚Üí Œ±} (hf : Continuous f)
    (hg : Continuous g) (ha : f a ‚â§ g a) (hb : g b ‚â§ f b) : ‚àÉ x, f x = g x :=
  by
  obtain ‚ü®x, h, hfg, hgf‚ü© : (univ ‚à© { x | f x ‚â§ g x ‚àß g x ‚â§ f x }).Nonempty
  exact
    isPreconnected_closed_iff.1 PreconnectedSpace.isPreconnected_univ _ _ (isClosed_le hf hg)
      (isClosed_le hg hf) (fun x hx => le_total _ _) ‚ü®a, trivial, ha‚ü© ‚ü®b, trivial, hb‚ü©
  exact ‚ü®x, le_antisymm hfg hgf‚ü©
#align intermediate_value_univ‚ÇÇ intermediate_value_univ‚ÇÇ

/- warning: intermediate_value_univ‚ÇÇ_eventually‚ÇÅ -> intermediate_value_univ‚ÇÇ_eventually‚ÇÅ is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {a : X} {l : Filter.{u1} X} [_inst_6 : Filter.NeBot.{u1} X l] {f : X -> Œ±} {g : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 g) -> (LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) (f a) (g a)) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) l g f) -> (Exists.{succ u1} X (fun (x : X) => Eq.{succ u2} Œ± (f x) (g x)))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {a : X} {l : Filter.{u1} X} [_inst_6 : Filter.NeBot.{u1} X l] {f : X -> Œ±} {g : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 g) -> (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (f a) (g a)) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) l g f) -> (Exists.{succ u1} X (fun (x : X) => Eq.{succ u2} Œ± (f x) (g x)))
Case conversion may be inaccurate. Consider using '#align intermediate_value_univ‚ÇÇ_eventually‚ÇÅ intermediate_value_univ‚ÇÇ_eventually‚ÇÅ‚Çì'. -/
theorem intermediate_value_univ‚ÇÇ_eventually‚ÇÅ [PreconnectedSpace X] {a : X} {l : Filter X} [NeBot l]
    {f g : X ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) (ha : f a ‚â§ g a) (he : g ‚â§·∂†[l] f) :
    ‚àÉ x, f x = g x :=
  let ‚ü®c, hc‚ü© := he.Frequently.exists
  intermediate_value_univ‚ÇÇ hf hg ha hc
#align intermediate_value_univ‚ÇÇ_eventually‚ÇÅ intermediate_value_univ‚ÇÇ_eventually‚ÇÅ

/- warning: intermediate_value_univ‚ÇÇ_eventually‚ÇÇ -> intermediate_value_univ‚ÇÇ_eventually‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_6 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_7 : Filter.NeBot.{u1} X l‚ÇÇ] {f : X -> Œ±} {g : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 g) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) l‚ÇÅ f g) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) l‚ÇÇ g f) -> (Exists.{succ u1} X (fun (x : X) => Eq.{succ u2} Œ± (f x) (g x)))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_6 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_7 : Filter.NeBot.{u1} X l‚ÇÇ] {f : X -> Œ±} {g : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 g) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) l‚ÇÅ f g) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) l‚ÇÇ g f) -> (Exists.{succ u1} X (fun (x : X) => Eq.{succ u2} Œ± (f x) (g x)))
Case conversion may be inaccurate. Consider using '#align intermediate_value_univ‚ÇÇ_eventually‚ÇÇ intermediate_value_univ‚ÇÇ_eventually‚ÇÇ‚Çì'. -/
theorem intermediate_value_univ‚ÇÇ_eventually‚ÇÇ [PreconnectedSpace X] {l‚ÇÅ l‚ÇÇ : Filter X} [NeBot l‚ÇÅ]
    [NeBot l‚ÇÇ] {f g : X ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) (he‚ÇÅ : f ‚â§·∂†[l‚ÇÅ] g)
    (he‚ÇÇ : g ‚â§·∂†[l‚ÇÇ] f) : ‚àÉ x, f x = g x :=
  let ‚ü®c‚ÇÅ, hc‚ÇÅ‚ü© := he‚ÇÅ.Frequently.exists
  let ‚ü®c‚ÇÇ, hc‚ÇÇ‚ü© := he‚ÇÇ.Frequently.exists
  intermediate_value_univ‚ÇÇ hf hg hc‚ÇÅ hc‚ÇÇ
#align intermediate_value_univ‚ÇÇ_eventually‚ÇÇ intermediate_value_univ‚ÇÇ_eventually‚ÇÇ

/- warning: is_preconnected.intermediate_value‚ÇÇ -> IsPreconnected.intermediate_value‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {b : X}, (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) a s) -> (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) b s) -> (forall {f : X -> Œ±} {g : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 g s) -> (LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) (f a) (g a)) -> (LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) (g b) (f b)) -> (Exists.{succ u1} X (fun (x : X) => Exists.{0} (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) (fun (H : Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) => Eq.{succ u2} Œ± (f x) (g x))))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {b : X}, (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) a s) -> (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) b s) -> (forall {f : X -> Œ±} {g : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 g s) -> (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (f a) (g a)) -> (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (g b) (f b)) -> (Exists.{succ u1} X (fun (x : X) => And (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) x s) (Eq.{succ u2} Œ± (f x) (g x))))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value‚ÇÇ IsPreconnected.intermediate_value‚ÇÇ‚Çì'. -/
/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous
on a preconnected set `s` and for some `a b ‚àà s` we have `f a ‚â§ g a` and `g b ‚â§ f b`,
then for some `x ‚àà s` we have `f x = g x`. -/
theorem IsPreconnected.intermediate_value‚ÇÇ {s : Set X} (hs : IsPreconnected s) {a b : X}
    (ha : a ‚àà s) (hb : b ‚àà s) {f g : X ‚Üí Œ±} (hf : ContinuousOn f s) (hg : ContinuousOn g s)
    (ha' : f a ‚â§ g a) (hb' : g b ‚â§ f b) : ‚àÉ x ‚àà s, f x = g x :=
  let ‚ü®x, hx‚ü© :=
    @intermediate_value_univ‚ÇÇ s Œ± _ _ _ _ (Subtype.preconnectedSpace hs) ‚ü®a, ha‚ü© ‚ü®b, hb‚ü© _ _
      (continuousOn_iff_continuous_restrict.1 hf) (continuousOn_iff_continuous_restrict.1 hg) ha'
      hb'
  ‚ü®x, x.2, hx‚ü©
#align is_preconnected.intermediate_value‚ÇÇ IsPreconnected.intermediate_value‚ÇÇ

/- warning: is_preconnected.intermediate_value‚ÇÇ_eventually‚ÇÅ -> IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÅ is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±} {g : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 g s) -> (LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) (f a) (g a)) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) l g f) -> (Exists.{succ u1} X (fun (x : X) => Exists.{0} (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) (fun (H : Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) => Eq.{succ u2} Œ± (f x) (g x)))))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±} {g : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 g s) -> (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (f a) (g a)) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) l g f) -> (Exists.{succ u1} X (fun (x : X) => And (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) x s) (Eq.{succ u2} Œ± (f x) (g x)))))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value‚ÇÇ_eventually‚ÇÅ IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÅ‚Çì'. -/
theorem IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÅ {s : Set X} (hs : IsPreconnected s) {a : X}
    {l : Filter X} (ha : a ‚àà s) [NeBot l] (hl : l ‚â§ ùìü s) {f g : X ‚Üí Œ±} (hf : ContinuousOn f s)
    (hg : ContinuousOn g s) (ha' : f a ‚â§ g a) (he : g ‚â§·∂†[l] f) : ‚àÉ x ‚àà s, f x = g x :=
  by
  rw [continuousOn_iff_continuous_restrict] at hf hg
  obtain ‚ü®b, h‚ü© :=
    @intermediate_value_univ‚ÇÇ_eventually‚ÇÅ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) ‚ü®a, ha‚ü© _
      (comap_coe_ne_bot_of_le_principal hl) _ _ hf hg ha' (he.comap _)
  exact ‚ü®b, b.prop, h‚ü©
#align is_preconnected.intermediate_value‚ÇÇ_eventually‚ÇÅ IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÅ

/- warning: is_preconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ -> IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±} {g : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 g s) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) l‚ÇÅ f g) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) l‚ÇÇ g f) -> (Exists.{succ u1} X (fun (x : X) => Exists.{0} (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) (fun (H : Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) x s) => Eq.{succ u2} Œ± (f x) (g x))))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±} {g : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 g s) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) l‚ÇÅ f g) -> (Filter.EventuallyLE.{u1, u2} X Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) l‚ÇÇ g f) -> (Exists.{succ u1} X (fun (x : X) => And (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) x s) (Eq.{succ u2} Œ± (f x) (g x))))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ‚Çì'. -/
theorem IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ {s : Set X} (hs : IsPreconnected s)
    {l‚ÇÅ l‚ÇÇ : Filter X} [NeBot l‚ÇÅ] [NeBot l‚ÇÇ] (hl‚ÇÅ : l‚ÇÅ ‚â§ ùìü s) (hl‚ÇÇ : l‚ÇÇ ‚â§ ùìü s) {f g : X ‚Üí Œ±}
    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (he‚ÇÅ : f ‚â§·∂†[l‚ÇÅ] g) (he‚ÇÇ : g ‚â§·∂†[l‚ÇÇ] f) :
    ‚àÉ x ‚àà s, f x = g x :=
  by
  rw [continuousOn_iff_continuous_restrict] at hf hg
  obtain ‚ü®b, h‚ü© :=
    @intermediate_value_univ‚ÇÇ_eventually‚ÇÇ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) _ _
      (comap_coe_ne_bot_of_le_principal hl‚ÇÅ) (comap_coe_ne_bot_of_le_principal hl‚ÇÇ) _ _ hf hg
      (he‚ÇÅ.comap _) (he‚ÇÇ.comap _)
  exact ‚ü®b, b.prop, h‚ü©
#align is_preconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ

#print IsPreconnected.intermediate_value /-
/-- **Intermediate Value Theorem** for continuous functions on connected sets. -/
theorem IsPreconnected.intermediate_value {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a ‚àà s)
    (hb : b ‚àà s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s) : Icc (f a) (f b) ‚äÜ f '' s := fun x hx =>
  mem_image_iff_bex.2 <| hs.intermediate_value‚ÇÇ ha hb hf continuousOn_const hx.1 hx.2
#align is_preconnected.intermediate_value IsPreconnected.intermediate_value
-/

/- warning: is_preconnected.intermediate_value_Ico -> IsPreconnected.intermediate_value_Ico is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l (nhds.{u2} Œ± _inst_3 v)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.Ico.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))) (f a) v) (Set.image.{u1, u2} X Œ± f s))))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l (nhds.{u2} Œ± _inst_3 v)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.Ico.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))) (f a) v) (Set.image.{u1, u2} X Œ± f s))))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Ico IsPreconnected.intermediate_value_Ico‚Çì'. -/
theorem IsPreconnected.intermediate_value_Ico {s : Set X} (hs : IsPreconnected s) {a : X}
    {l : Filter X} (ha : a ‚àà s) [NeBot l] (hl : l ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s) {v : Œ±}
    (ht : Tendsto f l (ùìù v)) : Ico (f a) v ‚äÜ f '' s := fun y h =>
  bex_def.1 <|
    hs.intermediate_value‚ÇÇ_eventually‚ÇÅ ha hl hf continuousOn_const h.1
      (eventually_ge_of_tendsto_gt h.2 ht)
#align is_preconnected.intermediate_value_Ico IsPreconnected.intermediate_value_Ico

/- warning: is_preconnected.intermediate_value_Ioc -> IsPreconnected.intermediate_value_Ioc is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l (nhds.{u2} Œ± _inst_3 v)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.Ioc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))) v (f a)) (Set.image.{u1, u2} X Œ± f s))))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l (nhds.{u2} Œ± _inst_3 v)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.Ioc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))) v (f a)) (Set.image.{u1, u2} X Œ± f s))))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Ioc IsPreconnected.intermediate_value_Ioc‚Çì'. -/
theorem IsPreconnected.intermediate_value_Ioc {s : Set X} (hs : IsPreconnected s) {a : X}
    {l : Filter X} (ha : a ‚àà s) [NeBot l] (hl : l ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s) {v : Œ±}
    (ht : Tendsto f l (ùìù v)) : Ioc v (f a) ‚äÜ f '' s := fun y h =>
  bex_def.1 <|
    (BEx.imp_right fun x _ => Eq.symm) <|
      hs.intermediate_value‚ÇÇ_eventually‚ÇÅ ha hl continuousOn_const hf h.2
        (eventually_le_of_tendsto_lt h.1 ht)
#align is_preconnected.intermediate_value_Ioc IsPreconnected.intermediate_value_Ioc

/- warning: is_preconnected.intermediate_value_Ioo -> IsPreconnected.intermediate_value_Ioo is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v‚ÇÅ : Œ±} {v‚ÇÇ : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (nhds.{u2} Œ± _inst_3 v‚ÇÅ)) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (nhds.{u2} Œ± _inst_3 v‚ÇÇ)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.Ioo.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))) v‚ÇÅ v‚ÇÇ) (Set.image.{u1, u2} X Œ± f s)))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v‚ÇÅ : Œ±} {v‚ÇÇ : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (nhds.{u2} Œ± _inst_3 v‚ÇÅ)) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (nhds.{u2} Œ± _inst_3 v‚ÇÇ)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.Ioo.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))) v‚ÇÅ v‚ÇÇ) (Set.image.{u1, u2} X Œ± f s)))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Ioo IsPreconnected.intermediate_value_Ioo‚Çì'. -/
theorem IsPreconnected.intermediate_value_Ioo {s : Set X} (hs : IsPreconnected s) {l‚ÇÅ l‚ÇÇ : Filter X}
    [NeBot l‚ÇÅ] [NeBot l‚ÇÇ] (hl‚ÇÅ : l‚ÇÅ ‚â§ ùìü s) (hl‚ÇÇ : l‚ÇÇ ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s)
    {v‚ÇÅ v‚ÇÇ : Œ±} (ht‚ÇÅ : Tendsto f l‚ÇÅ (ùìù v‚ÇÅ)) (ht‚ÇÇ : Tendsto f l‚ÇÇ (ùìù v‚ÇÇ)) : Ioo v‚ÇÅ v‚ÇÇ ‚äÜ f '' s :=
  fun y h =>
  bex_def.1 <|
    hs.intermediate_value‚ÇÇ_eventually‚ÇÇ hl‚ÇÅ hl‚ÇÇ hf continuousOn_const
      (eventually_le_of_tendsto_lt h.1 ht‚ÇÅ) (eventually_ge_of_tendsto_gt h.2 ht‚ÇÇ)
#align is_preconnected.intermediate_value_Ioo IsPreconnected.intermediate_value_Ioo

/- warning: is_preconnected.intermediate_value_Ici -> IsPreconnected.intermediate_value_Ici is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (Filter.Tendsto.{u1, u2} X Œ± f l (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.Ici.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))) (f a)) (Set.image.{u1, u2} X Œ± f s)))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (Filter.Tendsto.{u1, u2} X Œ± f l (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.Ici.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))) (f a)) (Set.image.{u1, u2} X Œ± f s)))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Ici IsPreconnected.intermediate_value_Ici‚Çì'. -/
theorem IsPreconnected.intermediate_value_Ici {s : Set X} (hs : IsPreconnected s) {a : X}
    {l : Filter X} (ha : a ‚àà s) [NeBot l] (hl : l ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s)
    (ht : Tendsto f l atTop) : Ici (f a) ‚äÜ f '' s := fun y h =>
  bex_def.1 <|
    hs.intermediate_value‚ÇÇ_eventually‚ÇÅ ha hl hf continuousOn_const h (tendsto_atTop.1 ht y)
#align is_preconnected.intermediate_value_Ici IsPreconnected.intermediate_value_Ici

/- warning: is_preconnected.intermediate_value_Iic -> IsPreconnected.intermediate_value_Iic is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.Mem.{u1, u1} X (Set.{u1} X) (Set.hasMem.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (Filter.Tendsto.{u1, u2} X Œ± f l (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.Iic.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))) (f a)) (Set.image.{u1, u2} X Œ± f s)))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {a : X} {l : Filter.{u1} X}, (Membership.mem.{u1, u1} X (Set.{u1} X) (Set.instMembershipSet.{u1} X) a s) -> (forall [_inst_5 : Filter.NeBot.{u1} X l], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (Filter.Tendsto.{u1, u2} X Œ± f l (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.Iic.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))) (f a)) (Set.image.{u1, u2} X Œ± f s)))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Iic IsPreconnected.intermediate_value_Iic‚Çì'. -/
theorem IsPreconnected.intermediate_value_Iic {s : Set X} (hs : IsPreconnected s) {a : X}
    {l : Filter X} (ha : a ‚àà s) [NeBot l] (hl : l ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s)
    (ht : Tendsto f l atBot) : Iic (f a) ‚äÜ f '' s := fun y h =>
  bex_def.1 <|
    (BEx.imp_right fun x _ => Eq.symm) <|
      hs.intermediate_value‚ÇÇ_eventually‚ÇÅ ha hl continuousOn_const hf h (tendsto_atBot.1 ht y)
#align is_preconnected.intermediate_value_Iic IsPreconnected.intermediate_value_Iic

/- warning: is_preconnected.intermediate_value_Ioi -> IsPreconnected.intermediate_value_Ioi is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (nhds.{u2} Œ± _inst_3 v)) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))) v) (Set.image.{u1, u2} X Œ± f s)))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (nhds.{u2} Œ± _inst_3 v)) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))) v) (Set.image.{u1, u2} X Œ± f s)))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Ioi IsPreconnected.intermediate_value_Ioi‚Çì'. -/
theorem IsPreconnected.intermediate_value_Ioi {s : Set X} (hs : IsPreconnected s) {l‚ÇÅ l‚ÇÇ : Filter X}
    [NeBot l‚ÇÅ] [NeBot l‚ÇÇ] (hl‚ÇÅ : l‚ÇÅ ‚â§ ùìü s) (hl‚ÇÇ : l‚ÇÇ ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s)
    {v : Œ±} (ht‚ÇÅ : Tendsto f l‚ÇÅ (ùìù v)) (ht‚ÇÇ : Tendsto f l‚ÇÇ atTop) : Ioi v ‚äÜ f '' s := fun y h =>
  bex_def.1 <|
    hs.intermediate_value‚ÇÇ_eventually‚ÇÇ hl‚ÇÅ hl‚ÇÇ hf continuousOn_const
      (eventually_le_of_tendsto_lt h ht‚ÇÅ) (tendsto_atTop.1 ht‚ÇÇ y)
#align is_preconnected.intermediate_value_Ioi IsPreconnected.intermediate_value_Ioi

/- warning: is_preconnected.intermediate_value_Iio -> IsPreconnected.intermediate_value_Iio is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))))) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (nhds.{u2} Œ± _inst_3 v)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))) v) (Set.image.{u1, u2} X Œ± f s)))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (forall {v : Œ±}, (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))))) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (nhds.{u2} Œ± _inst_3 v)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))) v) (Set.image.{u1, u2} X Œ± f s)))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Iio IsPreconnected.intermediate_value_Iio‚Çì'. -/
theorem IsPreconnected.intermediate_value_Iio {s : Set X} (hs : IsPreconnected s) {l‚ÇÅ l‚ÇÇ : Filter X}
    [NeBot l‚ÇÅ] [NeBot l‚ÇÇ] (hl‚ÇÅ : l‚ÇÅ ‚â§ ùìü s) (hl‚ÇÇ : l‚ÇÇ ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s)
    {v : Œ±} (ht‚ÇÅ : Tendsto f l‚ÇÅ atBot) (ht‚ÇÇ : Tendsto f l‚ÇÇ (ùìù v)) : Iio v ‚äÜ f '' s := fun y h =>
  bex_def.1 <|
    hs.intermediate_value‚ÇÇ_eventually‚ÇÇ hl‚ÇÅ hl‚ÇÇ hf continuousOn_const (tendsto_atBot.1 ht‚ÇÅ y)
      (eventually_ge_of_tendsto_gt h ht‚ÇÇ)
#align is_preconnected.intermediate_value_Iio IsPreconnected.intermediate_value_Iio

/- warning: is_preconnected.intermediate_value_Iii -> IsPreconnected.intermediate_value_Iii is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toHasLe.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.partialOrder.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))))) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2)))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.hasSubset.{u2} Œ±) (Set.univ.{u2} Œ±) (Set.image.{u1, u2} X Œ± f s))))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {s : Set.{u1} X}, (IsPreconnected.{u1} X _inst_1 s) -> (forall {l‚ÇÅ : Filter.{u1} X} {l‚ÇÇ : Filter.{u1} X} [_inst_5 : Filter.NeBot.{u1} X l‚ÇÅ] [_inst_6 : Filter.NeBot.{u1} X l‚ÇÇ], (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÅ (Filter.principal.{u1} X s)) -> (LE.le.{u1} (Filter.{u1} X) (Preorder.toLE.{u1} (Filter.{u1} X) (PartialOrder.toPreorder.{u1} (Filter.{u1} X) (Filter.instPartialOrderFilter.{u1} X))) l‚ÇÇ (Filter.principal.{u1} X s)) -> (forall {f : X -> Œ±}, (ContinuousOn.{u1, u2} X Œ± _inst_1 _inst_3 f s) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÅ (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))))) -> (Filter.Tendsto.{u1, u2} X Œ± f l‚ÇÇ (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2))))))) -> (HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.univ.{u2} Œ±) (Set.image.{u1, u2} X Œ± f s))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.intermediate_value_Iii IsPreconnected.intermediate_value_Iii‚Çì'. -/
theorem IsPreconnected.intermediate_value_Iii {s : Set X} (hs : IsPreconnected s) {l‚ÇÅ l‚ÇÇ : Filter X}
    [NeBot l‚ÇÅ] [NeBot l‚ÇÇ] (hl‚ÇÅ : l‚ÇÅ ‚â§ ùìü s) (hl‚ÇÇ : l‚ÇÇ ‚â§ ùìü s) {f : X ‚Üí Œ±} (hf : ContinuousOn f s)
    (ht‚ÇÅ : Tendsto f l‚ÇÅ atBot) (ht‚ÇÇ : Tendsto f l‚ÇÇ atTop) : univ ‚äÜ f '' s := fun y h =>
  bex_def.1 <|
    hs.intermediate_value‚ÇÇ_eventually‚ÇÇ hl‚ÇÅ hl‚ÇÇ hf continuousOn_const (tendsto_atBot.1 ht‚ÇÅ y)
      (tendsto_atTop.1 ht‚ÇÇ y)
#align is_preconnected.intermediate_value_Iii IsPreconnected.intermediate_value_Iii

#print intermediate_value_univ /-
/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/
theorem intermediate_value_univ [PreconnectedSpace X] (a b : X) {f : X ‚Üí Œ±} (hf : Continuous f) :
    Icc (f a) (f b) ‚äÜ range f := fun x hx => intermediate_value_univ‚ÇÇ hf continuous_const hx.1 hx.2
#align intermediate_value_univ intermediate_value_univ
-/

/- warning: mem_range_of_exists_le_of_exists_ge -> mem_range_of_exists_le_of_exists_ge is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {c : Œ±} {f : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Exists.{succ u1} X (fun (a : X) => LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) (f a) c)) -> (Exists.{succ u1} X (fun (b : X) => LE.le.{u2} Œ± (Preorder.toHasLe.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (LinearOrder.toLattice.{u2} Œ± _inst_2))))) c (f b))) -> (Membership.Mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.hasMem.{u2} Œ±) c (Set.range.{u2, succ u1} Œ± X f))
but is expected to have type
  forall {X : Type.{u1}} {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : TopologicalSpace.{u2} Œ±] [_inst_4 : OrderClosedTopology.{u2} Œ± _inst_3 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] [_inst_5 : PreconnectedSpace.{u1} X _inst_1] {c : Œ±} {f : X -> Œ±}, (Continuous.{u1, u2} X Œ± _inst_1 _inst_3 f) -> (Exists.{succ u1} X (fun (a : X) => LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (f a) c)) -> (Exists.{succ u1} X (fun (b : X) => LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) c (f b))) -> (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) c (Set.range.{u2, succ u1} Œ± X f))
Case conversion may be inaccurate. Consider using '#align mem_range_of_exists_le_of_exists_ge mem_range_of_exists_le_of_exists_ge‚Çì'. -/
/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/
theorem mem_range_of_exists_le_of_exists_ge [PreconnectedSpace X] {c : Œ±} {f : X ‚Üí Œ±}
    (hf : Continuous f) (h‚ÇÅ : ‚àÉ a, f a ‚â§ c) (h‚ÇÇ : ‚àÉ b, c ‚â§ f b) : c ‚àà range f :=
  let ‚ü®a, ha‚ü© := h‚ÇÅ
  let ‚ü®b, hb‚ü© := h‚ÇÇ
  intermediate_value_univ a b hf ‚ü®ha, hb‚ü©
#align mem_range_of_exists_le_of_exists_ge mem_range_of_exists_le_of_exists_ge

/-!
### (Pre)connected sets in a linear order

In this section we prove the following results:

* `is_preconnected.ord_connected`: any preconnected set `s` in a linear order is `ord_connected`,
  i.e. `a ‚àà s` and `b ‚àà s` imply `Icc a b ‚äÜ s`;

* `is_preconnected.mem_intervals`: any preconnected set `s` in a conditionally complete linear order
  is one of the intervals `set.Icc`, `set.`Ico`, `set.Ioc`, `set.Ioo`, ``set.Ici`, `set.Iic`,
  `set.Ioi`, `set.Iio`; note that this is false for non-complete orders: e.g., in `‚Ñù \ {0}`, the set
  of positive numbers cannot be represented as `set.Ioi _`.

-/


#print IsPreconnected.Icc_subset /-
/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
theorem IsPreconnected.Icc_subset {s : Set Œ±} (hs : IsPreconnected s) {a b : Œ±} (ha : a ‚àà s)
    (hb : b ‚àà s) : Icc a b ‚äÜ s := by
  simpa only [image_id] using hs.intermediate_value ha hb continuousOn_id
#align is_preconnected.Icc_subset IsPreconnected.Icc_subset
-/

#print IsPreconnected.ordConnected /-
theorem IsPreconnected.ordConnected {s : Set Œ±} (h : IsPreconnected s) : OrdConnected s :=
  ‚ü®fun x hx y hy => h.Icc_subset hx hy‚ü©
#align is_preconnected.ord_connected IsPreconnected.ordConnected
-/

#print IsConnected.Icc_subset /-
/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
theorem IsConnected.Icc_subset {s : Set Œ±} (hs : IsConnected s) {a b : Œ±} (ha : a ‚àà s)
    (hb : b ‚àà s) : Icc a b ‚äÜ s :=
  hs.2.Icc_subset ha hb
#align is_connected.Icc_subset IsConnected.Icc_subset
-/

#print IsPreconnected.eq_univ_of_unbounded /-
/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole
space. -/
theorem IsPreconnected.eq_univ_of_unbounded {s : Set Œ±} (hs : IsPreconnected s) (hb : ¬¨BddBelow s)
    (ha : ¬¨BddAbove s) : s = univ :=
  by
  refine' eq_univ_of_forall fun x => _
  obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := not_bddBelow_iff.1 hb x
  obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bddAbove_iff.1 ha x
  exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
#align is_preconnected.eq_univ_of_unbounded IsPreconnected.eq_univ_of_unbounded
-/

end

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [ConditionallyCompleteLinearOrder Œ±]
  [TopologicalSpace Œ±] [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤]
  [OrderTopology Œ≤] [Nonempty Œ≥]

/- warning: is_connected.Ioo_cInf_cSup_subset -> IsConnected.Ioo_csInf_csSup_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsConnected.{u1} Œ± _inst_2 s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsConnected.{u1} Œ± _inst_2 s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) s)
Case conversion may be inaccurate. Consider using '#align is_connected.Ioo_cInf_cSup_subset IsConnected.Ioo_csInf_csSup_subset‚Çì'. -/
/-- A bounded connected subset of a conditionally complete linear order includes the open interval
`(Inf s, Sup s)`. -/
theorem IsConnected.Ioo_csInf_csSup_subset {s : Set Œ±} (hs : IsConnected s) (hb : BddBelow s)
    (ha : BddAbove s) : Ioo (sInf s) (sSup s) ‚äÜ s := fun x hx =>
  let ‚ü®y, ys, hy‚ü© := (isGLB_lt_iff (isGLB_csInf hs.Nonempty hb)).1 hx.1
  let ‚ü®z, zs, hz‚ü© := (lt_isLUB_iff (isLUB_csSup hs.Nonempty ha)).1 hx.2
  hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
#align is_connected.Ioo_cInf_cSup_subset IsConnected.Ioo_csInf_csSup_subset

/- warning: eq_Icc_cInf_cSup_of_connected_bdd_closed -> eq_Icc_csInf_csSup_of_connected_bdd_closed is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsConnected.{u1} Œ± _inst_2 s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (IsClosed.{u1} Œ± _inst_2 s) -> (Eq.{succ u1} (Set.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsConnected.{u1} Œ± _inst_2 s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (IsClosed.{u1} Œ± _inst_2 s) -> (Eq.{succ u1} (Set.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)))
Case conversion may be inaccurate. Consider using '#align eq_Icc_cInf_cSup_of_connected_bdd_closed eq_Icc_csInf_csSup_of_connected_bdd_closed‚Çì'. -/
theorem eq_Icc_csInf_csSup_of_connected_bdd_closed {s : Set Œ±} (hc : IsConnected s)
    (hb : BddBelow s) (ha : BddAbove s) (hcl : IsClosed s) : s = Icc (sInf s) (sSup s) :=
  Subset.antisymm (subset_Icc_csInf_csSup hb ha) <|
    hc.Icc_subset (hcl.csInf_mem hc.Nonempty hb) (hcl.csSup_mem hc.Nonempty ha)
#align eq_Icc_cInf_cSup_of_connected_bdd_closed eq_Icc_csInf_csSup_of_connected_bdd_closed

/- warning: is_preconnected.Ioi_cInf_subset -> IsPreconnected.Ioi_csInf_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsPreconnected.{u1} Œ± _inst_2 s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Not (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsPreconnected.{u1} Œ± _inst_2 s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Not (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) s)
Case conversion may be inaccurate. Consider using '#align is_preconnected.Ioi_cInf_subset IsPreconnected.Ioi_csInf_subset‚Çì'. -/
theorem IsPreconnected.Ioi_csInf_subset {s : Set Œ±} (hs : IsPreconnected s) (hb : BddBelow s)
    (ha : ¬¨BddAbove s) : Ioi (sInf s) ‚äÜ s :=
  by
  have sne : s.nonempty := @nonempty_of_not_bddAbove Œ± _ s ‚ü®Inf ‚àÖ‚ü© ha
  intro x hx
  obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := (isGLB_lt_iff (isGLB_csInf sne hb)).1 hx
  obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bddAbove_iff.1 ha x
  exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
#align is_preconnected.Ioi_cInf_subset IsPreconnected.Ioi_csInf_subset

/- warning: is_preconnected.Iio_cSup_subset -> IsPreconnected.Iio_csSup_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsPreconnected.{u1} Œ± _inst_2 s) -> (Not (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s)) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsPreconnected.{u1} Œ± _inst_2 s) -> (Not (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s)) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) s)
Case conversion may be inaccurate. Consider using '#align is_preconnected.Iio_cSup_subset IsPreconnected.Iio_csSup_subset‚Çì'. -/
theorem IsPreconnected.Iio_csSup_subset {s : Set Œ±} (hs : IsPreconnected s) (hb : ¬¨BddBelow s)
    (ha : BddAbove s) : Iio (sSup s) ‚äÜ s :=
  @IsPreconnected.Ioi_csInf_subset Œ±·µí·µà _ _ _ s hs ha hb
#align is_preconnected.Iio_cSup_subset IsPreconnected.Iio_csSup_subset

/- warning: is_preconnected.mem_intervals -> IsPreconnected.mem_intervals is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsPreconnected.{u1} Œ± _inst_2 s) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.univ.{u1} Œ±) (Singleton.singleton.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasSingleton.{u1} (Set.{u1} Œ±)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±)))))))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsPreconnected.{u1} Œ± _inst_2 s) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.univ.{u1} Œ±) (Singleton.singleton.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instSingletonSet.{u1} (Set.{u1} Œ±)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±)))))))))))))
Case conversion may be inaccurate. Consider using '#align is_preconnected.mem_intervals IsPreconnected.mem_intervals‚Çì'. -/
/-- A preconnected set in a conditionally complete linear order is either one of the intervals
`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +‚àû)`,
`(Inf s, +‚àû)`, `(-‚àû, Sup s]`, `(-‚àû, Sup s)`, `(-‚àû, +‚àû)`, or `‚àÖ`. The converse statement requires
`Œ±` to be densely ordererd. -/
theorem IsPreconnected.mem_intervals {s : Set Œ±} (hs : IsPreconnected s) :
    s ‚àà
      ({Icc (sInf s) (sSup s), Ico (sInf s) (sSup s), Ioc (sInf s) (sSup s), Ioo (sInf s) (sSup s),
          Ici (sInf s), Ioi (sInf s), Iic (sSup s), Iio (sSup s), univ, ‚àÖ} :
        Set (Set Œ±)) :=
  by
  rcases s.eq_empty_or_nonempty with (rfl | hne)
  ¬∑ apply_rules [Or.inr, mem_singleton]
  have hs' : IsConnected s := ‚ü®hne, hs‚ü©
  by_cases hb : BddBelow s <;> by_cases ha : BddAbove s
  ¬∑ rcases mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset (hs'.Ioo_cInf_cSup_subset hb ha)
        (subset_Icc_csInf_csSup hb ha) with (hs | hs | hs | hs)
    ¬∑ exact Or.inl hs
    ¬∑ exact Or.inr <| Or.inl hs
    ¬∑ exact Or.inr <| Or.inr <| Or.inl hs
    ¬∑ exact Or.inr <| Or.inr <| Or.inr <| Or.inl hs
  ¬∑ refine' Or.inr <| Or.inr <| Or.inr <| Or.inr _
    cases'
      mem_Ici_Ioi_of_subset_of_subset (hs.Ioi_cInf_subset hb ha) fun x hx => csInf_le hb hx with
      hs hs
    ¬∑ exact Or.inl hs
    ¬∑ exact Or.inr (Or.inl hs)
  ¬∑ iterate 6 apply Or.inr
    cases'
      mem_Iic_Iio_of_subset_of_subset (hs.Iio_cSup_subset hb ha) fun x hx => le_csSup ha hx with
      hs hs
    ¬∑ exact Or.inl hs
    ¬∑ exact Or.inr (Or.inl hs)
  ¬∑ iterate 8 apply Or.inr
    exact Or.inl (hs.eq_univ_of_unbounded hb ha)
#align is_preconnected.mem_intervals IsPreconnected.mem_intervals

/- warning: set_of_is_preconnected_subset_of_ordered -> setOf_isPreconnected_subset_of_ordered is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))], HasSubset.Subset.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasSubset.{u1} (Set.{u1} Œ±)) (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => IsPreconnected.{u1} Œ± _inst_2 s)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.univ.{u1} Œ±) (Singleton.singleton.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasSingleton.{u1} (Set.{u1} Œ±)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))], HasSubset.Subset.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instHasSubsetSet.{u1} (Set.{u1} Œ±)) (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => IsPreconnected.{u1} Œ± _inst_2 s)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.univ.{u1} Œ±) (Singleton.singleton.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instSingletonSet.{u1} (Set.{u1} Œ±)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±))))))
Case conversion may be inaccurate. Consider using '#align set_of_is_preconnected_subset_of_ordered setOf_isPreconnected_subset_of_ordered‚Çì'. -/
/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,
`Iic`, `Iio`, or `univ`, or `‚àÖ`. The converse statement requires `Œ±` to be densely ordered. Though
one can represent `‚àÖ` as `(Inf s, Inf s)`, we include it into the list of possible cases to improve
readability. -/
theorem setOf_isPreconnected_subset_of_ordered :
    { s : Set Œ± | IsPreconnected s } ‚äÜ-- bounded intervals
                range
                (uncurry Icc) ‚à™
              range (uncurry Ico) ‚à™
            range (uncurry Ioc) ‚à™
          range (uncurry Ioo) ‚à™
        (-- unbounded intervals and `univ`
                  range
                  Ici ‚à™
                range Ioi ‚à™
              range Iic ‚à™
            range Iio ‚à™
          {univ, ‚àÖ}) :=
  by
  intro s hs
  rcases hs.mem_intervals with (hs | hs | hs | hs | hs | hs | hs | hs | hs | hs)
  ¬∑ exact Or.inl <| Or.inl <| Or.inl <| Or.inl ‚ü®(Inf s, Sup s), hs.symm‚ü©
  ¬∑ exact Or.inl <| Or.inl <| Or.inl <| Or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©
  ¬∑ exact Or.inl <| Or.inl <| Or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©
  ¬∑ exact Or.inl <| Or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©
  ¬∑ exact Or.inr <| Or.inl <| Or.inl <| Or.inl <| Or.inl ‚ü®Inf s, hs.symm‚ü©
  ¬∑ exact Or.inr <| Or.inl <| Or.inl <| Or.inl <| Or.inr ‚ü®Inf s, hs.symm‚ü©
  ¬∑ exact Or.inr <| Or.inl <| Or.inl <| Or.inr ‚ü®Sup s, hs.symm‚ü©
  ¬∑ exact Or.inr <| Or.inl <| Or.inr ‚ü®Sup s, hs.symm‚ü©
  ¬∑ exact Or.inr <| Or.inr <| Or.inl hs
  ¬∑ exact Or.inr <| Or.inr <| Or.inr hs
#align set_of_is_preconnected_subset_of_ordered setOf_isPreconnected_subset_of_ordered

/-!
### Intervals are connected

In this section we prove that a closed interval (hence, any `ord_connected` set) in a dense
conditionally complete linear order is preconnected.
-/


/- warning: is_closed.mem_of_ge_of_forall_exists_gt -> IsClosed.mem_of_ge_of_forall_exists_gt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {a : Œ±} {b : Œ±} {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a s) -> (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x b)))) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) b s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {a : Œ±} {b : Œ±} {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) a s) -> (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x b)))) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) b s)
Case conversion may be inaccurate. Consider using '#align is_closed.mem_of_ge_of_forall_exists_gt IsClosed.mem_of_ge_of_forall_exists_gt‚Çì'. -/
/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and the set `s ‚à© [a, b)` has no maximal point, then `b ‚àà s`. -/
theorem IsClosed.mem_of_ge_of_forall_exists_gt {a b : Œ±} {s : Set Œ±} (hs : IsClosed (s ‚à© Icc a b))
    (ha : a ‚àà s) (hab : a ‚â§ b) (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, (s ‚à© Ioc x b).Nonempty) : b ‚àà s :=
  by
  let S := s ‚à© Icc a b
  replace ha : a ‚àà S
  exact ‚ü®ha, left_mem_Icc.2 hab‚ü©
  have Sbd : BddAbove S := ‚ü®b, fun z hz => hz.2.2‚ü©
  let c := Sup (s ‚à© Icc a b)
  have c_mem : c ‚àà S := hs.cSup_mem ‚ü®_, ha‚ü© Sbd
  have c_le : c ‚â§ b := csSup_le ‚ü®_, ha‚ü© fun x hx => hx.2.2
  cases' eq_or_lt_of_le c_le with hc hc
  exact hc ‚ñ∏ c_mem.1
  exfalso
  rcases hgt c ‚ü®c_mem.1, c_mem.2.1, hc‚ü© with ‚ü®x, xs, cx, xb‚ü©
  exact not_lt_of_le (le_csSup Sbd ‚ü®xs, le_trans (le_csSup Sbd ha) (le_of_lt cx), xb‚ü©) cx
#align is_closed.mem_of_ge_of_forall_exists_gt IsClosed.mem_of_ge_of_forall_exists_gt

/- warning: is_closed.Icc_subset_of_forall_exists_gt -> IsClosed.Icc_subset_of_forall_exists_gt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {a : Œ±} {b : Œ±} {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a s) -> (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (forall (y : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x)) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x y))))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {a : Œ±} {b : Œ±} {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) a s) -> (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (forall (y : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x)) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x y))))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) s)
Case conversion may be inaccurate. Consider using '#align is_closed.Icc_subset_of_forall_exists_gt IsClosed.Icc_subset_of_forall_exists_gt‚Çì'. -/
/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `a ‚â§ x < y ‚â§ b`, `x ‚àà s`, the set `s ‚à© (x, y]`
is not empty, then `[a, b] ‚äÜ s`. -/
theorem IsClosed.Icc_subset_of_forall_exists_gt {a b : Œ±} {s : Set Œ±} (hs : IsClosed (s ‚à© Icc a b))
    (ha : a ‚àà s) (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, ‚àÄ y ‚àà Ioi x, (s ‚à© Ioc x y).Nonempty) : Icc a b ‚äÜ s :=
  by
  intro y hy
  have : IsClosed (s ‚à© Icc a y) :=
    by
    suffices s ‚à© Icc a y = s ‚à© Icc a b ‚à© Icc a y
      by
      rw [this]
      exact IsClosed.inter hs isClosed_Icc
    rw [inter_assoc]
    congr
    exact (inter_eq_self_of_subset_right <| Icc_subset_Icc_right hy.2).symm
  exact
    IsClosed.mem_of_ge_of_forall_exists_gt this ha hy.1 fun x hx =>
      hgt x ‚ü®hx.1, Ico_subset_Ico_right hy.2 hx.2‚ü© y hx.2.2
#align is_closed.Icc_subset_of_forall_exists_gt IsClosed.Icc_subset_of_forall_exists_gt

variable [DenselyOrdered Œ±] {a b : Œ±}

/- warning: is_closed.Icc_subset_of_forall_mem_nhds_within -> IsClosed.Icc_subset_of_forall_mem_nhdsWithin is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±} {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a s) -> (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_2 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x)))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±} {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) a s) -> (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_2 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) x)))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) s)
Case conversion may be inaccurate. Consider using '#align is_closed.Icc_subset_of_forall_mem_nhds_within IsClosed.Icc_subset_of_forall_mem_nhdsWithin‚Çì'. -/
/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `x ‚àà s ‚à© [a, b)` the set `s` includes some open
neighborhood of `x` within `(x, +‚àû)`, then `[a, b] ‚äÜ s`. -/
theorem IsClosed.Icc_subset_of_forall_mem_nhdsWithin {a b : Œ±} {s : Set Œ±}
    (hs : IsClosed (s ‚à© Icc a b)) (ha : a ‚àà s) (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, s ‚àà ùìù[>] x) :
    Icc a b ‚äÜ s := by
  apply hs.Icc_subset_of_forall_exists_gt ha
  rintro x ‚ü®hxs, hxab‚ü© y hyxb
  have : s ‚à© Ioc x y ‚àà ùìù[>] x :=
    inter_mem (hgt x ‚ü®hxs, hxab‚ü©) (Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, hyxb‚ü©)
  exact (nhdsWithin_Ioi_self_neBot' ‚ü®b, hxab.2‚ü©).nonempty_of_mem this
#align is_closed.Icc_subset_of_forall_mem_nhds_within IsClosed.Icc_subset_of_forall_mem_nhdsWithin

/- warning: is_preconnected_Icc_aux -> isPreconnected_Icc_aux is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±} (x : Œ±) (y : Œ±) (s : Set.{u1} Œ±) (t : Set.{u1} Œ±), (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) x y) -> (IsClosed.{u1} Œ± _inst_2 s) -> (IsClosed.{u1} Œ± _inst_2 t) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t)) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) s)) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) t)) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±} (x : Œ±) (y : Œ±) (s : Set.{u1} Œ±) (t : Set.{u1} Œ±), (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) x y) -> (IsClosed.{u1} Œ± _inst_2 s) -> (IsClosed.{u1} Œ± _inst_2 t) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t)) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) s)) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) t)) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t)))
Case conversion may be inaccurate. Consider using '#align is_preconnected_Icc_aux isPreconnected_Icc_aux‚Çì'. -/
theorem isPreconnected_Icc_aux (x y : Œ±) (s t : Set Œ±) (hxy : x ‚â§ y) (hs : IsClosed s)
    (ht : IsClosed t) (hab : Icc a b ‚äÜ s ‚à™ t) (hx : x ‚àà Icc a b ‚à© s) (hy : y ‚àà Icc a b ‚à© t) :
    (Icc a b ‚à© (s ‚à© t)).Nonempty :=
  by
  have xyab : Icc x y ‚äÜ Icc a b := Icc_subset_Icc hx.1.1 hy.1.2
  by_contra hst
  suffices : Icc x y ‚äÜ s
  exact hst ‚ü®y, xyab <| right_mem_Icc.2 hxy, this <| right_mem_Icc.2 hxy, hy.2‚ü©
  apply (IsClosed.inter hs isClosed_Icc).Icc_subset_of_forall_mem_nhdsWithin hx.2
  rintro z ‚ü®zs, hz‚ü©
  have zt : z ‚àà t·∂ú := fun zt => hst ‚ü®z, xyab <| Ico_subset_Icc_self hz, zs, zt‚ü©
  have : t·∂ú ‚à© Ioc z y ‚àà ùìù[>] z :=
    by
    rw [‚Üê nhdsWithin_Ioc_eq_nhdsWithin_Ioi hz.2]
    exact mem_nhdsWithin.2 ‚ü®t·∂ú, ht.is_open_compl, zt, subset.refl _‚ü©
  apply mem_of_superset this
  have : Ioc z y ‚äÜ s ‚à™ t := fun w hw => hab (xyab ‚ü®le_trans hz.1 (le_of_lt hw.1), hw.2‚ü©)
  exact fun w ‚ü®wt, wzy‚ü© => (this wzy).elim id fun h => (wt h).elim
#align is_preconnected_Icc_aux isPreconnected_Icc_aux

/- warning: is_preconnected_Icc -> isPreconnected_Icc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Icc isPreconnected_Icc‚Çì'. -/
/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/
theorem isPreconnected_Icc : IsPreconnected (Icc a b) :=
  isPreconnected_closed_iff.2
    (by
      rintro s t hs ht hab ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©
      -- This used to use `wlog`, but it was causing timeouts.
      cases le_total x y
      ¬∑ exact isPreconnected_Icc_aux x y s t h hs ht hab hx hy
      ¬∑ rw [inter_comm s t]
        rw [union_comm s t] at hab
        exact isPreconnected_Icc_aux y x t s h ht hs hab hy hx)
#align is_preconnected_Icc isPreconnected_Icc

/- warning: is_preconnected_uIcc -> isPreconnected_uIcc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.uIcc.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) a b)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.uIcc.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) a b)
Case conversion may be inaccurate. Consider using '#align is_preconnected_uIcc isPreconnected_uIcc‚Çì'. -/
theorem isPreconnected_uIcc : IsPreconnected (uIcc a b) :=
  isPreconnected_Icc
#align is_preconnected_uIcc isPreconnected_uIcc

/- warning: set.ord_connected.is_preconnected -> Set.OrdConnected.isPreconnected is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {s : Set.{u1} Œ±}, (Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (IsPreconnected.{u1} Œ± _inst_2 s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {s : Set.{u1} Œ±}, (Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (IsPreconnected.{u1} Œ± _inst_2 s)
Case conversion may be inaccurate. Consider using '#align set.ord_connected.is_preconnected Set.OrdConnected.isPreconnected‚Çì'. -/
theorem Set.OrdConnected.isPreconnected {s : Set Œ±} (h : s.OrdConnected) : IsPreconnected s :=
  isPreconnected_of_forall_pair fun x hx y hy =>
    ‚ü®uIcc x y, h.uIcc_subset hx hy, left_mem_uIcc, right_mem_uIcc, isPreconnected_uIcc‚ü©
#align set.ord_connected.is_preconnected Set.OrdConnected.isPreconnected

/- warning: is_preconnected_iff_ord_connected -> isPreconnected_iff_ordConnected is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {s : Set.{u1} Œ±}, Iff (IsPreconnected.{u1} Œ± _inst_2 s) (Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {s : Set.{u1} Œ±}, Iff (IsPreconnected.{u1} Œ± _inst_2 s) (Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s)
Case conversion may be inaccurate. Consider using '#align is_preconnected_iff_ord_connected isPreconnected_iff_ordConnected‚Çì'. -/
theorem isPreconnected_iff_ordConnected {s : Set Œ±} : IsPreconnected s ‚Üî OrdConnected s :=
  ‚ü®IsPreconnected.ordConnected, Set.OrdConnected.isPreconnected‚ü©
#align is_preconnected_iff_ord_connected isPreconnected_iff_ordConnected

/- warning: is_preconnected_Ici -> isPreconnected_Ici is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Ici isPreconnected_Ici‚Çì'. -/
theorem isPreconnected_Ici : IsPreconnected (Ici a) :=
  ordConnected_Ici.IsPreconnected
#align is_preconnected_Ici isPreconnected_Ici

/- warning: is_preconnected_Iic -> isPreconnected_Iic is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Iic isPreconnected_Iic‚Çì'. -/
theorem isPreconnected_Iic : IsPreconnected (Iic a) :=
  ordConnected_Iic.IsPreconnected
#align is_preconnected_Iic isPreconnected_Iic

/- warning: is_preconnected_Iio -> isPreconnected_Iio is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Iio isPreconnected_Iio‚Çì'. -/
theorem isPreconnected_Iio : IsPreconnected (Iio a) :=
  ordConnected_Iio.IsPreconnected
#align is_preconnected_Iio isPreconnected_Iio

/- warning: is_preconnected_Ioi -> isPreconnected_Ioi is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Ioi isPreconnected_Ioi‚Çì'. -/
theorem isPreconnected_Ioi : IsPreconnected (Ioi a) :=
  ordConnected_Ioi.IsPreconnected
#align is_preconnected_Ioi isPreconnected_Ioi

/- warning: is_preconnected_Ioo -> isPreconnected_Ioo is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Ioo isPreconnected_Ioo‚Çì'. -/
theorem isPreconnected_Ioo : IsPreconnected (Ioo a b) :=
  ordConnected_Ioo.IsPreconnected
#align is_preconnected_Ioo isPreconnected_Ioo

/- warning: is_preconnected_Ioc -> isPreconnected_Ioc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Ioc isPreconnected_Ioc‚Çì'. -/
theorem isPreconnected_Ioc : IsPreconnected (Ioc a b) :=
  ordConnected_Ioc.IsPreconnected
#align is_preconnected_Ioc isPreconnected_Ioc

/- warning: is_preconnected_Ico -> isPreconnected_Ico is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, IsPreconnected.{u1} Œ± _inst_2 (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)
Case conversion may be inaccurate. Consider using '#align is_preconnected_Ico isPreconnected_Ico‚Çì'. -/
theorem isPreconnected_Ico : IsPreconnected (Ico a b) :=
  ordConnected_Ico.IsPreconnected
#align is_preconnected_Ico isPreconnected_Ico

/- warning: is_connected_Ici -> isConnected_Ici is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsConnected.{u1} Œ± _inst_2 (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsConnected.{u1} Œ± _inst_2 (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_connected_Ici isConnected_Ici‚Çì'. -/
theorem isConnected_Ici : IsConnected (Ici a) :=
  ‚ü®nonempty_Ici, isPreconnected_Ici‚ü©
#align is_connected_Ici isConnected_Ici

/- warning: is_connected_Iic -> isConnected_Iic is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsConnected.{u1} Œ± _inst_2 (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±}, IsConnected.{u1} Œ± _inst_2 (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_connected_Iic isConnected_Iic‚Çì'. -/
theorem isConnected_Iic : IsConnected (Iic a) :=
  ‚ü®nonempty_Iic, isPreconnected_Iic‚ü©
#align is_connected_Iic isConnected_Iic

/- warning: is_connected_Ioi -> isConnected_Ioi is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} [_inst_9 : NoMaxOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], IsConnected.{u1} Œ± _inst_2 (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} [_inst_9 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], IsConnected.{u1} Œ± _inst_2 (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_connected_Ioi isConnected_Ioi‚Çì'. -/
theorem isConnected_Ioi [NoMaxOrder Œ±] : IsConnected (Ioi a) :=
  ‚ü®nonempty_Ioi, isPreconnected_Ioi‚ü©
#align is_connected_Ioi isConnected_Ioi

/- warning: is_connected_Iio -> isConnected_Iio is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} [_inst_9 : NoMinOrder.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], IsConnected.{u1} Œ± _inst_2 (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} [_inst_9 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], IsConnected.{u1} Œ± _inst_2 (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a)
Case conversion may be inaccurate. Consider using '#align is_connected_Iio isConnected_Iio‚Çì'. -/
theorem isConnected_Iio [NoMinOrder Œ±] : IsConnected (Iio a) :=
  ‚ü®nonempty_Iio, isPreconnected_Iio‚ü©
#align is_connected_Iio isConnected_Iio

/- warning: is_connected_Icc -> isConnected_Icc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align is_connected_Icc isConnected_Icc‚Çì'. -/
theorem isConnected_Icc (h : a ‚â§ b) : IsConnected (Icc a b) :=
  ‚ü®nonempty_Icc.2 h, isPreconnected_Icc‚ü©
#align is_connected_Icc isConnected_Icc

/- warning: is_connected_Ioo -> isConnected_Ioo is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align is_connected_Ioo isConnected_Ioo‚Çì'. -/
theorem isConnected_Ioo (h : a < b) : IsConnected (Ioo a b) :=
  ‚ü®nonempty_Ioo.2 h, isPreconnected_Ioo‚ü©
#align is_connected_Ioo isConnected_Ioo

/- warning: is_connected_Ioc -> isConnected_Ioc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align is_connected_Ioc isConnected_Ioc‚Çì'. -/
theorem isConnected_Ioc (h : a < b) : IsConnected (Ioc a b) :=
  ‚ü®nonempty_Ioc.2 h, isPreconnected_Ioc‚ü©
#align is_connected_Ioc isConnected_Ioc

/- warning: is_connected_Ico -> isConnected_Ico is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (IsConnected.{u1} Œ± _inst_2 (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align is_connected_Ico isConnected_Ico‚Çì'. -/
theorem isConnected_Ico (h : a < b) : IsConnected (Ico a b) :=
  ‚ü®nonempty_Ico.2 h, isPreconnected_Ico‚ü©
#align is_connected_Ico isConnected_Ico

/- warning: ordered_connected_space -> ordered_connected_space is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], PreconnectedSpace.{u1} Œ± _inst_2
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], PreconnectedSpace.{u1} Œ± _inst_2
Case conversion may be inaccurate. Consider using '#align ordered_connected_space ordered_connected_space‚Çì'. -/
instance (priority := 100) ordered_connected_space : PreconnectedSpace Œ± :=
  ‚ü®ordConnected_univ.IsPreconnected‚ü©
#align ordered_connected_space ordered_connected_space

/- warning: set_of_is_preconnected_eq_of_ordered -> setOf_isPreconnected_eq_of_ordered is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], Eq.{succ u1} (Set.{u1} (Set.{u1} Œ±)) (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => IsPreconnected.{u1} Œ± _inst_2 s)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasUnion.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasInsert.{u1} (Set.{u1} Œ±)) (Set.univ.{u1} Œ±) (Singleton.singleton.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasSingleton.{u1} (Set.{u1} Œ±)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))], Eq.{succ u1} (Set.{u1} (Set.{u1} Œ±)) (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => IsPreconnected.{u1} Œ± _inst_2 s)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) (Prod.{u1, u1} Œ± Œ±) (Function.uncurry.{u1, u1, u1} Œ± Œ± (Set.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))))) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Union.union.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instUnionSet.{u1} (Set.{u1} Œ±)) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Set.range.{u1, succ u1} (Set.{u1} Œ±) Œ± (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))))) (Insert.insert.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instInsertSet.{u1} (Set.{u1} Œ±)) (Set.univ.{u1} Œ±) (Singleton.singleton.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instSingletonSet.{u1} (Set.{u1} Œ±)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±))))))
Case conversion may be inaccurate. Consider using '#align set_of_is_preconnected_eq_of_ordered setOf_isPreconnected_eq_of_ordered‚Çì'. -/
/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly
the set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-‚àû, +‚àû)`,
or `‚àÖ`. Though one can represent `‚àÖ` as `(Inf s, Inf s)`, we include it into the list of
possible cases to improve readability. -/
theorem setOf_isPreconnected_eq_of_ordered :
    { s : Set Œ± | IsPreconnected s } =-- bounded intervals
                range
                (uncurry Icc) ‚à™
              range (uncurry Ico) ‚à™
            range (uncurry Ioc) ‚à™
          range (uncurry Ioo) ‚à™
        (-- unbounded intervals and `univ`
                  range
                  Ici ‚à™
                range Ioi ‚à™
              range Iic ‚à™
            range Iio ‚à™
          {univ, ‚àÖ}) :=
  by
  refine' subset.antisymm setOf_isPreconnected_subset_of_ordered _
  simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp, forall_and, mem_union,
    mem_set_of_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true_iff,
    isPreconnected_Icc, isPreconnected_Ico, isPreconnected_Ioc, isPreconnected_Ioo,
    isPreconnected_Ioi, isPreconnected_Iio, isPreconnected_Ici, isPreconnected_Iic,
    is_preconnected_univ, isPreconnected_empty]
#align set_of_is_preconnected_eq_of_ordered setOf_isPreconnected_eq_of_ordered

/-!
### Intermediate Value Theorem on an interval

In this section we prove several versions of the Intermediate Value Theorem for a function
continuous on an interval.
-/


variable {Œ¥ : Type _} [LinearOrder Œ¥] [TopologicalSpace Œ¥] [OrderClosedTopology Œ¥]

/- warning: intermediate_value_Icc -> intermediate_value_Icc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Icc.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f a) (f b)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Icc.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f a) (f b)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Icc intermediate_value_Icc‚Çì'. -/
/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case
`f a ‚â§ t ‚â§ f b`.-/
theorem intermediate_value_Icc {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥} (hf : ContinuousOn f (Icc a b)) :
    Icc (f a) (f b) ‚äÜ f '' Icc a b :=
  isPreconnected_Icc.intermediate_value (left_mem_Icc.2 hab) (right_mem_Icc.2 hab) hf
#align intermediate_value_Icc intermediate_value_Icc

/- warning: intermediate_value_Icc' -> intermediate_value_Icc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Icc.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f b) (f a)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Icc.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f b) (f a)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Icc' intermediate_value_Icc'‚Çì'. -/
/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case
`f a ‚â• t ‚â• f b`.-/
theorem intermediate_value_Icc' {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥}
    (hf : ContinuousOn f (Icc a b)) : Icc (f b) (f a) ‚äÜ f '' Icc a b :=
  isPreconnected_Icc.intermediate_value (right_mem_Icc.2 hab) (left_mem_Icc.2 hab) hf
#align intermediate_value_Icc' intermediate_value_Icc'

/- warning: intermediate_value_uIcc -> intermediate_value_uIcc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±} {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.uIcc.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.uIcc.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9) (f a) (f b)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.uIcc.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) a b)))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±} {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.uIcc.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.uIcc.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)) (f a) (f b)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.uIcc.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)) a b)))
Case conversion may be inaccurate. Consider using '#align intermediate_value_uIcc intermediate_value_uIcc‚Çì'. -/
/-- **Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. -/
theorem intermediate_value_uIcc {a b : Œ±} {f : Œ± ‚Üí Œ¥} (hf : ContinuousOn f (uIcc a b)) :
    uIcc (f a) (f b) ‚äÜ f '' uIcc a b := by
  cases le_total (f a) (f b) <;> simp [*, is_preconnected_uIcc.intermediate_value]
#align intermediate_value_uIcc intermediate_value_uIcc

/- warning: intermediate_value_Ico -> intermediate_value_Ico is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Ico.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f a) (f b)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Ico.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f a) (f b)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Ico.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Ico intermediate_value_Ico‚Çì'. -/
theorem intermediate_value_Ico {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥} (hf : ContinuousOn f (Icc a b)) :
    Ico (f a) (f b) ‚äÜ f '' Ico a b :=
  Or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.2 (not_lt_of_le (he ‚ñ∏ h.1))) fun hlt =>
    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ico _ _ ‚ü®refl a, hlt‚ü©
      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _
      ((hf.ContinuousWithinAt ‚ü®hab, refl b‚ü©).mono Ico_subset_Icc_self)
#align intermediate_value_Ico intermediate_value_Ico

/- warning: intermediate_value_Ico' -> intermediate_value_Ico' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Ioc.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f b) (f a)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Ioc.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f b) (f a)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Ico.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Ico' intermediate_value_Ico'‚Çì'. -/
theorem intermediate_value_Ico' {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥}
    (hf : ContinuousOn f (Icc a b)) : Ioc (f b) (f a) ‚äÜ f '' Ico a b :=
  Or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.1 (not_lt_of_le (he ‚ñ∏ h.2))) fun hlt =>
    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ico _ _ ‚ü®refl a, hlt‚ü©
      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _
      ((hf.ContinuousWithinAt ‚ü®hab, refl b‚ü©).mono Ico_subset_Icc_self)
#align intermediate_value_Ico' intermediate_value_Ico'

/- warning: intermediate_value_Ioc -> intermediate_value_Ioc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Ioc.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f a) (f b)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Ioc.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f a) (f b)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Ioc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Ioc intermediate_value_Ioc‚Çì'. -/
theorem intermediate_value_Ioc {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥} (hf : ContinuousOn f (Icc a b)) :
    Ioc (f a) (f b) ‚äÜ f '' Ioc a b :=
  Or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.2 (not_le_of_lt (he ‚ñ∏ h.1))) fun hlt =>
    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ioc _ _ ‚ü®hlt, refl b‚ü©
      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _
      ((hf.ContinuousWithinAt ‚ü®refl a, hab‚ü©).mono Ioc_subset_Icc_self)
#align intermediate_value_Ioc intermediate_value_Ioc

/- warning: intermediate_value_Ioc' -> intermediate_value_Ioc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Ico.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f b) (f a)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Ico.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f b) (f a)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Ioc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Ioc' intermediate_value_Ioc'‚Çì'. -/
theorem intermediate_value_Ioc' {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥}
    (hf : ContinuousOn f (Icc a b)) : Ico (f b) (f a) ‚äÜ f '' Ioc a b :=
  Or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.1 (not_le_of_lt (he ‚ñ∏ h.2))) fun hlt =>
    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ioc _ _ ‚ü®hlt, refl b‚ü©
      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _
      ((hf.ContinuousWithinAt ‚ü®refl a, hab‚ü©).mono Ioc_subset_Icc_self)
#align intermediate_value_Ioc' intermediate_value_Ioc'

/- warning: intermediate_value_Ioo -> intermediate_value_Ioo is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Ioo.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f a) (f b)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Ioo.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f a) (f b)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Ioo.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Ioo intermediate_value_Ioo‚Çì'. -/
theorem intermediate_value_Ioo {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥} (hf : ContinuousOn f (Icc a b)) :
    Ioo (f a) (f b) ‚äÜ f '' Ioo a b :=
  Or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.2 (not_lt_of_lt (he ‚ñ∏ h.1))) fun hlt =>
    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _
      (left_nhdsWithin_Ioo_neBot hlt) (right_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _
      (hf.mono Ioo_subset_Icc_self) _ _
      ((hf.ContinuousWithinAt ‚ü®refl a, hab‚ü©).mono Ioo_subset_Icc_self)
      ((hf.ContinuousWithinAt ‚ü®hab, refl b‚ü©).mono Ioo_subset_Icc_self)
#align intermediate_value_Ioo intermediate_value_Ioo

/- warning: intermediate_value_Ioo' -> intermediate_value_Ioo' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {a : Œ±} {b : Œ±}, (LE.le.{u1} Œ± (Preorder.toHasLe.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u2} (Set.{u2} Œ¥) (Set.hasSubset.{u2} Œ¥) (Set.Ioo.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f b) (f a)) (Set.image.{u1, u2} Œ± Œ¥ f (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) a b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {a : Œ±} {b : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) a b) -> (forall {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f (Set.Icc.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ¥) (Set.instHasSubsetSet.{u1} Œ¥) (Set.Ioo.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f b) (f a)) (Set.image.{u2, u1} Œ± Œ¥ f (Set.Ioo.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) a b))))
Case conversion may be inaccurate. Consider using '#align intermediate_value_Ioo' intermediate_value_Ioo'‚Çì'. -/
theorem intermediate_value_Ioo' {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ¥}
    (hf : ContinuousOn f (Icc a b)) : Ioo (f b) (f a) ‚äÜ f '' Ioo a b :=
  Or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.1 (not_lt_of_lt (he ‚ñ∏ h.2))) fun hlt =>
    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _
      (right_nhdsWithin_Ioo_neBot hlt) (left_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _
      (hf.mono Ioo_subset_Icc_self) _ _
      ((hf.ContinuousWithinAt ‚ü®hab, refl b‚ü©).mono Ioo_subset_Icc_self)
      ((hf.ContinuousWithinAt ‚ü®refl a, hab‚ü©).mono Ioo_subset_Icc_self)
#align intermediate_value_Ioo' intermediate_value_Ioo'

/- warning: continuous_on.surj_on_Icc -> ContinuousOn.surjOn_Icc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {s : Set.{u1} Œ±} [hs : Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s] {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f s) -> (forall {a : Œ±} {b : Œ±}, (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) b s) -> (Set.SurjOn.{u1, u2} Œ± Œ¥ f s (Set.Icc.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))) (f a) (f b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {s : Set.{u2} Œ±} [hs : Set.OrdConnected.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) s] {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f s) -> (forall {a : Œ±} {b : Œ±}, (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) a s) -> (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) b s) -> (Set.SurjOn.{u2, u1} Œ± Œ¥ f s (Set.Icc.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))) (f a) (f b))))
Case conversion may be inaccurate. Consider using '#align continuous_on.surj_on_Icc ContinuousOn.surjOn_Icc‚Çì'. -/
/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,
`b` are two points of this set, then `f` sends `s` to a superset of `Icc (f x) (f y)`. -/
theorem ContinuousOn.surjOn_Icc {s : Set Œ±} [hs : OrdConnected s] {f : Œ± ‚Üí Œ¥}
    (hf : ContinuousOn f s) {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) : SurjOn f s (Icc (f a) (f b)) :=
  hs.IsPreconnected.intermediate_value ha hb hf
#align continuous_on.surj_on_Icc ContinuousOn.surjOn_Icc

/- warning: continuous_on.surj_on_uIcc -> ContinuousOn.surjOn_uIcc is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {s : Set.{u1} Œ±} [hs : Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s] {f : Œ± -> Œ¥}, (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f s) -> (forall {a : Œ±} {b : Œ±}, (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) b s) -> (Set.SurjOn.{u1, u2} Œ± Œ¥ f s (Set.uIcc.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9) (f a) (f b))))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {s : Set.{u2} Œ±} [hs : Set.OrdConnected.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) s] {f : Œ± -> Œ¥}, (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f s) -> (forall {a : Œ±} {b : Œ±}, (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) a s) -> (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) b s) -> (Set.SurjOn.{u2, u1} Œ± Œ¥ f s (Set.uIcc.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)) (f a) (f b))))
Case conversion may be inaccurate. Consider using '#align continuous_on.surj_on_uIcc ContinuousOn.surjOn_uIcc‚Çì'. -/
/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,
`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/
theorem ContinuousOn.surjOn_uIcc {s : Set Œ±} [hs : OrdConnected s] {f : Œ± ‚Üí Œ¥}
    (hf : ContinuousOn f s) {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) : SurjOn f s (uIcc (f a) (f b)) :=
  by cases' le_total (f a) (f b) with hab hab <;> simp [hf.surj_on_Icc, *]
#align continuous_on.surj_on_uIcc ContinuousOn.surjOn_uIcc

/- warning: continuous.surjective -> Continuous.surjective is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {f : Œ± -> Œ¥}, (Continuous.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f) -> (Filter.Tendsto.{u1, u2} Œ± Œ¥ f (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) (Filter.atTop.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Filter.Tendsto.{u1, u2} Œ± Œ¥ f (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) (Filter.atBot.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Function.Surjective.{succ u1, succ u2} Œ± Œ¥ f)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {f : Œ± -> Œ¥}, (Continuous.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f) -> (Filter.Tendsto.{u2, u1} Œ± Œ¥ f (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) (Filter.atTop.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Filter.Tendsto.{u2, u1} Œ± Œ¥ f (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) (Filter.atBot.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Function.Surjective.{succ u2, succ u1} Œ± Œ¥ f)
Case conversion may be inaccurate. Consider using '#align continuous.surjective Continuous.surjective‚Çì'. -/
/-- A continuous function which tendsto `at_top` `at_top` and to `at_bot` `at_bot` is surjective. -/
theorem Continuous.surjective {f : Œ± ‚Üí Œ¥} (hf : Continuous f) (h_top : Tendsto f atTop atTop)
    (h_bot : Tendsto f atBot atBot) : Function.Surjective f := fun p =>
  mem_range_of_exists_le_of_exists_ge hf (h_bot.Eventually (eventually_le_atBot p)).exists
    (h_top.Eventually (eventually_ge_atTop p)).exists
#align continuous.surjective Continuous.surjective

/- warning: continuous.surjective' -> Continuous.surjective' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {f : Œ± -> Œ¥}, (Continuous.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f) -> (Filter.Tendsto.{u1, u2} Œ± Œ¥ f (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) (Filter.atTop.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Filter.Tendsto.{u1, u2} Œ± Œ¥ f (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))) (Filter.atBot.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Function.Surjective.{succ u1, succ u2} Œ± Œ¥ f)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {f : Œ± -> Œ¥}, (Continuous.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f) -> (Filter.Tendsto.{u2, u1} Œ± Œ¥ f (Filter.atBot.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) (Filter.atTop.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Filter.Tendsto.{u2, u1} Œ± Œ¥ f (Filter.atTop.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))) (Filter.atBot.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Function.Surjective.{succ u2, succ u1} Œ± Œ¥ f)
Case conversion may be inaccurate. Consider using '#align continuous.surjective' Continuous.surjective'‚Çì'. -/
/-- A continuous function which tendsto `at_bot` `at_top` and to `at_top` `at_bot` is surjective. -/
theorem Continuous.surjective' {f : Œ± ‚Üí Œ¥} (hf : Continuous f) (h_top : Tendsto f atBot atTop)
    (h_bot : Tendsto f atTop atBot) : Function.Surjective f :=
  @Continuous.surjective Œ±·µí·µà _ _ _ _ _ _ _ _ _ hf h_top h_bot
#align continuous.surjective' Continuous.surjective'

/- warning: continuous_on.surj_on_of_tendsto -> ContinuousOn.surjOn_of_tendsto is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {f : Œ± -> Œ¥} {s : Set.{u1} Œ±} [_inst_12 : Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s], (Set.Nonempty.{u1} Œ± s) -> (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f s) -> (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ¥ (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))))) x)) (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) (Filter.atBot.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ¥ (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))))) x)) (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) (Filter.atTop.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Set.SurjOn.{u1, u2} Œ± Œ¥ f s (Set.univ.{u2} Œ¥))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {f : Œ± -> Œ¥} {s : Set.{u2} Œ±} [_inst_12 : Set.OrdConnected.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) s], (Set.Nonempty.{u2} Œ± s) -> (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f s) -> (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Œ± s) Œ¥ (fun (x : Set.Elem.{u2} Œ± s) => f (Subtype.val.{succ u2} Œ± (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s) x)) (Filter.atBot.{u2} (Set.Elem.{u2} Œ± s) (Subtype.preorder.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s))) (Filter.atBot.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Œ± s) Œ¥ (fun (x : Set.Elem.{u2} Œ± s) => f (Subtype.val.{succ u2} Œ± (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s) x)) (Filter.atTop.{u2} (Set.Elem.{u2} Œ± s) (Subtype.preorder.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s))) (Filter.atTop.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Set.SurjOn.{u2, u1} Œ± Œ¥ f s (Set.univ.{u1} Œ¥))
Case conversion may be inaccurate. Consider using '#align continuous_on.surj_on_of_tendsto ContinuousOn.surjOn_of_tendsto‚Çì'. -/
/-- If a function `f : Œ± ‚Üí Œ≤` is continuous on a nonempty interval `s`, its restriction to `s`
tends to `at_bot : filter Œ≤` along `at_bot : filter ‚Ü•s` and tends to `at_top : filter Œ≤` along
`at_top : filter ‚Ü•s`, then the restriction of `f` to `s` is surjective. We formulate the
conclusion as `surj_on f s univ`. -/
theorem ContinuousOn.surjOn_of_tendsto {f : Œ± ‚Üí Œ¥} {s : Set Œ±} [OrdConnected s] (hs : s.Nonempty)
    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atBot)
    (htop : Tendsto (fun x : s => f x) atTop atTop) : SurjOn f s univ :=
  haveI := Classical.inhabited_of_nonempty hs.to_subtype
  surj_on_iff_surjective.2 <| (continuousOn_iff_continuous_restrict.1 hf).Surjective htop hbot
#align continuous_on.surj_on_of_tendsto ContinuousOn.surjOn_of_tendsto

/- warning: continuous_on.surj_on_of_tendsto' -> ContinuousOn.surjOn_of_tendsto' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u1} Œ± (Preorder.toHasLt.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))))] {Œ¥ : Type.{u2}} [_inst_9 : LinearOrder.{u2} Œ¥] [_inst_10 : TopologicalSpace.{u2} Œ¥] [_inst_11 : OrderClosedTopology.{u2} Œ¥ _inst_10 (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9))))] {f : Œ± -> Œ¥} {s : Set.{u1} Œ±} [_inst_12 : Set.OrdConnected.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s], (Set.Nonempty.{u1} Œ± s) -> (ContinuousOn.{u1, u2} Œ± Œ¥ _inst_2 _inst_10 f s) -> (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ¥ (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))))) x)) (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) (Filter.atTop.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Filter.Tendsto.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ¥ (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) => f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))))) x)) (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) (Filter.atBot.{u2} Œ¥ (PartialOrder.toPreorder.{u2} Œ¥ (SemilatticeInf.toPartialOrder.{u2} Œ¥ (Lattice.toSemilatticeInf.{u2} Œ¥ (LinearOrder.toLattice.{u2} Œ¥ _inst_9)))))) -> (Set.SurjOn.{u1, u2} Œ± Œ¥ f s (Set.univ.{u2} Œ¥))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1)))))] [_inst_8 : DenselyOrdered.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))))] {Œ¥ : Type.{u1}} [_inst_9 : LinearOrder.{u1} Œ¥] [_inst_10 : TopologicalSpace.{u1} Œ¥] [_inst_11 : OrderClosedTopology.{u1} Œ¥ _inst_10 (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9)))))] {f : Œ± -> Œ¥} {s : Set.{u2} Œ±} [_inst_12 : Set.OrdConnected.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) s], (Set.Nonempty.{u2} Œ± s) -> (ContinuousOn.{u2, u1} Œ± Œ¥ _inst_2 _inst_10 f s) -> (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Œ± s) Œ¥ (fun (x : Set.Elem.{u2} Œ± s) => f (Subtype.val.{succ u2} Œ± (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s) x)) (Filter.atBot.{u2} (Set.Elem.{u2} Œ± s) (Subtype.preorder.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s))) (Filter.atTop.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Filter.Tendsto.{u2, u1} (Set.Elem.{u2} Œ± s) Œ¥ (fun (x : Set.Elem.{u2} Œ± s) => f (Subtype.val.{succ u2} Œ± (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s) x)) (Filter.atTop.{u2} (Set.Elem.{u2} Œ± s) (Subtype.preorder.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (ConditionallyCompleteLattice.toLattice.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± _inst_1))))) (fun (x : Œ±) => Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s))) (Filter.atBot.{u1} Œ¥ (PartialOrder.toPreorder.{u1} Œ¥ (SemilatticeInf.toPartialOrder.{u1} Œ¥ (Lattice.toSemilatticeInf.{u1} Œ¥ (DistribLattice.toLattice.{u1} Œ¥ (instDistribLattice.{u1} Œ¥ _inst_9))))))) -> (Set.SurjOn.{u2, u1} Œ± Œ¥ f s (Set.univ.{u1} Œ¥))
Case conversion may be inaccurate. Consider using '#align continuous_on.surj_on_of_tendsto' ContinuousOn.surjOn_of_tendsto'‚Çì'. -/
/-- If a function `f : Œ± ‚Üí Œ≤` is continuous on a nonempty interval `s`, its restriction to `s`
tends to `at_top : filter Œ≤` along `at_bot : filter ‚Ü•s` and tends to `at_bot : filter Œ≤` along
`at_top : filter ‚Ü•s`, then the restriction of `f` to `s` is surjective. We formulate the
conclusion as `surj_on f s univ`. -/
theorem ContinuousOn.surjOn_of_tendsto' {f : Œ± ‚Üí Œ¥} {s : Set Œ±} [OrdConnected s] (hs : s.Nonempty)
    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atTop)
    (htop : Tendsto (fun x : s => f x) atTop atBot) : SurjOn f s univ :=
  @ContinuousOn.surjOn_of_tendsto Œ± _ _ _ _ Œ¥·µí·µà _ _ _ _ _ _ hs hf hbot htop
#align continuous_on.surj_on_of_tendsto' ContinuousOn.surjOn_of_tendsto'

