/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module topology.continuous_function.compact
! leanprover-community/mathlib commit 0b7c740e25651db0ba63648fbae9f9d6f941e31b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.ContinuousFunction.Bounded
import Mathbin.Topology.UniformSpace.Compact
import Mathbin.Topology.CompactOpen
import Mathbin.Topology.Sets.Compacts

/-!
# Continuous functions on a compact space

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Continuous functions `C(Î±, Î²)` from a compact space `Î±` to a metric space `Î²`
are automatically bounded, and so acquire various structures inherited from `Î± â†’áµ‡ Î²`.

This file transfers these structures, and restates some lemmas
characterising these structures.

If you need a lemma which is proved about `Î± â†’áµ‡ Î²` but not for `C(Î±, Î²)` when `Î±` is compact,
you should restate it here. You can also use
`bounded_continuous_function.equiv_continuous_map_of_compact` to move functions back and forth.

-/


noncomputable section

open Topology Classical NNReal BoundedContinuousFunction BigOperators

open Set Filter Metric

open BoundedContinuousFunction

namespace ContinuousMap

variable {Î± Î² E : Type _} [TopologicalSpace Î±] [CompactSpace Î±] [MetricSpace Î²]
  [NormedAddCommGroup E]

section

variable (Î± Î²)

#print ContinuousMap.equivBoundedOfCompact /-
/-- When `Î±` is compact, the bounded continuous maps `Î± â†’áµ‡ Î²` are
equivalent to `C(Î±, Î²)`.
-/
@[simps (config := { fullyApplied := false })]
def equivBoundedOfCompact : C(Î±, Î²) â‰ƒ (Î± â†’áµ‡ Î²) :=
  âŸ¨mkOfCompact, BoundedContinuousFunction.toContinuousMap, fun f => by ext; rfl, fun f => by ext;
    rflâŸ©
#align continuous_map.equiv_bounded_of_compact ContinuousMap.equivBoundedOfCompact
-/

/- warning: continuous_map.uniform_inducing_equiv_bounded_of_compact -> ContinuousMap.uniformInducing_equivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) (Î² : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²], UniformInducing.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u1, u2} Î± Î² _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) => (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) -> (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (Î± : Type.{u2}) (Î² : Type.{u1}) [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²], UniformInducing.{max u2 u1, max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u2, u1} Î± Î² _inst_1 (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u2 u1} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (fun (_x : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) => BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align continuous_map.uniform_inducing_equiv_bounded_of_compact ContinuousMap.uniformInducing_equivBoundedOfCompactâ‚“'. -/
theorem uniformInducing_equivBoundedOfCompact : UniformInducing (equivBoundedOfCompact Î± Î²) :=
  UniformInducing.mk'
    (by
      simp only [has_basis_compact_convergence_uniformity.mem_iff, uniformity_basis_dist_le.mem_iff]
      exact fun s =>
        âŸ¨fun âŸ¨âŸ¨a, bâŸ©, âŸ¨ha, âŸ¨Îµ, hÎµ, hbâŸ©âŸ©, hsâŸ© =>
          âŸ¨{ p | âˆ€ x, (p.1 x, p.2 x) âˆˆ b }, âŸ¨Îµ, hÎµ, fun _ h x => hb ((dist_le hÎµ.le).mp h x)âŸ©,
            fun f g h => hs fun x hx => h xâŸ©,
          fun âŸ¨t, âŸ¨Îµ, hÎµ, htâŸ©, hsâŸ© =>
          âŸ¨âŸ¨Set.univ, { p | dist p.1 p.2 â‰¤ Îµ }âŸ©, âŸ¨isCompact_univ, âŸ¨Îµ, hÎµ, fun _ h => hâŸ©âŸ©,
            fun âŸ¨f, gâŸ© h => hs _ _ (ht ((dist_le hÎµ.le).mpr fun x => h x (mem_univ x)))âŸ©âŸ©)
#align continuous_map.uniform_inducing_equiv_bounded_of_compact ContinuousMap.uniformInducing_equivBoundedOfCompact

/- warning: continuous_map.uniform_embedding_equiv_bounded_of_compact -> ContinuousMap.uniformEmbedding_equivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) (Î² : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²], UniformEmbedding.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u1, u2} Î± Î² _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) => (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) -> (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (Î± : Type.{u2}) (Î² : Type.{u1}) [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²], UniformEmbedding.{max u2 u1, max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u2, u1} Î± Î² _inst_1 (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u2 u1} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (fun (_x : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) => BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align continuous_map.uniform_embedding_equiv_bounded_of_compact ContinuousMap.uniformEmbedding_equivBoundedOfCompactâ‚“'. -/
theorem uniformEmbedding_equivBoundedOfCompact : UniformEmbedding (equivBoundedOfCompact Î± Î²) :=
  { uniformInducing_equivBoundedOfCompact Î± Î² with inj := (equivBoundedOfCompact Î± Î²).Injective }
#align continuous_map.uniform_embedding_equiv_bounded_of_compact ContinuousMap.uniformEmbedding_equivBoundedOfCompact

/- warning: continuous_map.add_equiv_bounded_of_compact -> ContinuousMap.addEquivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) (Î² : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] [_inst_5 : AddMonoid.{u2} Î²] [_inst_6 : LipschitzAdd.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) _inst_5], AddEquiv.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (ContinuousMap.instAdd.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (AddZeroClass.toHasAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² _inst_5)) (ContinuousMap.addEquivBoundedOfCompact._proof_1.{u2} Î² _inst_3 _inst_5 _inst_6)) (BoundedContinuousFunction.hasAdd.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) _inst_5 _inst_6)
but is expected to have type
  forall (Î± : Type.{u1}) (Î² : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] [_inst_5 : AddMonoid.{u2} Î²] [_inst_6 : LipschitzAdd.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) _inst_5], AddEquiv.{max u2 u1, max u2 u1} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (ContinuousMap.instAdd.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (AddZeroClass.toAdd.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² _inst_5)) (LipschitzAdd.continuousAdd.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) _inst_5 _inst_6)) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align continuous_map.add_equiv_bounded_of_compact ContinuousMap.addEquivBoundedOfCompactâ‚“'. -/
/-- When `Î±` is compact, the bounded continuous maps `Î± â†’áµ‡ ð•œ` are
additively equivalent to `C(Î±, ð•œ)`.
-/
@[simps (config := { fullyApplied := false }) apply symm_apply]
def addEquivBoundedOfCompact [AddMonoid Î²] [LipschitzAdd Î²] : C(Î±, Î²) â‰ƒ+ (Î± â†’áµ‡ Î²) :=
  ({ toContinuousMapAddHom Î± Î², (equivBoundedOfCompact Î± Î²).symm with } : (Î± â†’áµ‡ Î²) â‰ƒ+ C(Î±, Î²)).symm
#align continuous_map.add_equiv_bounded_of_compact ContinuousMap.addEquivBoundedOfCompact

instance : MetricSpace C(Î±, Î²) :=
  (uniformEmbedding_equivBoundedOfCompact Î± Î²).comapMetricSpace _

/- warning: continuous_map.isometry_equiv_bounded_of_compact -> ContinuousMap.isometryEquivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) (Î² : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²], IsometryEquiv.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))
but is expected to have type
  forall (Î± : Type.{u1}) (Î² : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²], IsometryEquiv.{max u2 u1, max u2 u1} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (EMetricSpace.toPseudoEMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toEMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) (EMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (MetricSpace.toEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (BoundedContinuousFunction.instMetricSpaceBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} Î± Î² _inst_1 _inst_3)))
Case conversion may be inaccurate. Consider using '#align continuous_map.isometry_equiv_bounded_of_compact ContinuousMap.isometryEquivBoundedOfCompactâ‚“'. -/
/-- When `Î±` is compact, and `Î²` is a metric space, the bounded continuous maps `Î± â†’áµ‡ Î²` are
isometric to `C(Î±, Î²)`.
-/
@[simps (config := { fullyApplied := false }) toEquiv apply symm_apply]
def isometryEquivBoundedOfCompact : C(Î±, Î²) â‰ƒáµ¢ (Î± â†’áµ‡ Î²)
    where
  isometry_toFun x y := rfl
  toEquiv := equivBoundedOfCompact Î± Î²
#align continuous_map.isometry_equiv_bounded_of_compact ContinuousMap.isometryEquivBoundedOfCompact

end

/- warning: bounded_continuous_function.dist_mk_of_compact -> BoundedContinuousFunction.dist_mkOfCompact is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] (f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))), Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (BoundedContinuousFunction.hasDist.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) _inst_2 f) (BoundedContinuousFunction.mkOfCompact.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) _inst_2 g)) (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] (f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (g : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))), Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (BoundedContinuousFunction.mkOfCompact.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3) _inst_2 f) (BoundedContinuousFunction.mkOfCompact.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3) _inst_2 g)) (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_mk_of_compact BoundedContinuousFunction.dist_mkOfCompactâ‚“'. -/
@[simp]
theorem BoundedContinuousFunction.dist_mkOfCompact (f g : C(Î±, Î²)) :
    dist (mkOfCompact f) (mkOfCompact g) = dist f g :=
  rfl
#align bounded_continuous_function.dist_mk_of_compact BoundedContinuousFunction.dist_mkOfCompact

/- warning: bounded_continuous_function.dist_to_continuous_map -> BoundedContinuousFunction.dist_toContinuousMap is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] (f : BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (g : BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)), Eq.{1} Real (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) (BoundedContinuousFunction.toContinuousMap.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) f) (BoundedContinuousFunction.toContinuousMap.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3) g)) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (BoundedContinuousFunction.hasDist.{u1, u2} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) f g)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] (f : BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (g : BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)), Eq.{1} Real (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))) (BoundedContinuousFunction.toContinuousMap.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3) f) (BoundedContinuousFunction.toContinuousMap.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3) g)) (Dist.dist.{max u2 u1} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_to_continuous_map BoundedContinuousFunction.dist_toContinuousMapâ‚“'. -/
@[simp]
theorem BoundedContinuousFunction.dist_toContinuousMap (f g : Î± â†’áµ‡ Î²) :
    dist f.toContinuousMap g.toContinuousMap = dist f g :=
  rfl
#align bounded_continuous_function.dist_to_continuous_map BoundedContinuousFunction.dist_toContinuousMap

open BoundedContinuousFunction

section

variable {Î± Î²} {f g : C(Î±, Î²)} {C : â„}

/- warning: continuous_map.dist_apply_le_dist -> ContinuousMap.dist_apply_le_dist is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] {f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} (x : Î±), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} Î² (PseudoMetricSpace.toHasDist.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) g x)) (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] {f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} (x : Î±), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (PseudoMetricSpace.toDist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (MetricSpace.toPseudoMetricSpace.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))))) g x)) (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_apply_le_dist ContinuousMap.dist_apply_le_distâ‚“'. -/
/-- The pointwise distance is controlled by the distance between functions, by definition. -/
theorem dist_apply_le_dist (x : Î±) : dist (f x) (g x) â‰¤ dist f g := by
  simp only [â† dist_mk_of_compact, dist_coe_le_dist, â† mk_of_compact_apply]
#align continuous_map.dist_apply_le_dist ContinuousMap.dist_apply_le_dist

/- warning: continuous_map.dist_le -> ContinuousMap.dist_le is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] {f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LE.le.{0} Real Real.hasLe (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} Î² (PseudoMetricSpace.toHasDist.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) g x)) C))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] {f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {g : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LE.le.{0} Real Real.instLEReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) g x)) C))
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_le ContinuousMap.dist_leâ‚“'. -/
/-- The distance between two functions is controlled by the supremum of the pointwise distances -/
theorem dist_le (C0 : (0 : â„) â‰¤ C) : dist f g â‰¤ C â†” âˆ€ x : Î±, dist (f x) (g x) â‰¤ C := by
  simp only [â† dist_mk_of_compact, dist_le C0, mk_of_compact_apply]
#align continuous_map.dist_le ContinuousMap.dist_le

/- warning: continuous_map.dist_le_iff_of_nonempty -> ContinuousMap.dist_le_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] {f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u1} Î±], Iff (LE.le.{0} Real Real.hasLe (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} Î² (PseudoMetricSpace.toHasDist.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) g x)) C)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] {f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {g : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u2} Î±], Iff (LE.le.{0} Real Real.instLEReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) g x)) C)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_le_iff_of_nonempty ContinuousMap.dist_le_iff_of_nonemptyâ‚“'. -/
theorem dist_le_iff_of_nonempty [Nonempty Î±] : dist f g â‰¤ C â†” âˆ€ x, dist (f x) (g x) â‰¤ C := by
  simp only [â† dist_mk_of_compact, dist_le_iff_of_nonempty, mk_of_compact_apply]
#align continuous_map.dist_le_iff_of_nonempty ContinuousMap.dist_le_iff_of_nonempty

/- warning: continuous_map.dist_lt_iff_of_nonempty -> ContinuousMap.dist_lt_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] {f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u1} Î±], Iff (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} Î² (PseudoMetricSpace.toHasDist.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) g x)) C)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] {f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {g : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u2} Î±], Iff (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) g x)) C)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_iff_of_nonempty ContinuousMap.dist_lt_iff_of_nonemptyâ‚“'. -/
theorem dist_lt_iff_of_nonempty [Nonempty Î±] : dist f g < C â†” âˆ€ x : Î±, dist (f x) (g x) < C := by
  simp only [â† dist_mk_of_compact, dist_lt_iff_of_nonempty_compact, mk_of_compact_apply]
#align continuous_map.dist_lt_iff_of_nonempty ContinuousMap.dist_lt_iff_of_nonempty

/- warning: continuous_map.dist_lt_of_nonempty -> ContinuousMap.dist_lt_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] {f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u1} Î±], (forall (x : Î±), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} Î² (PseudoMetricSpace.toHasDist.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) g x)) C) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] {f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {g : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u2} Î±], (forall (x : Î±), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) g x)) C) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_of_nonempty ContinuousMap.dist_lt_of_nonemptyâ‚“'. -/
theorem dist_lt_of_nonempty [Nonempty Î±] (w : âˆ€ x : Î±, dist (f x) (g x) < C) : dist f g < C :=
  dist_lt_iff_of_nonempty.2 w
#align continuous_map.dist_lt_of_nonempty ContinuousMap.dist_lt_of_nonempty

/- warning: continuous_map.dist_lt_iff -> ContinuousMap.dist_lt_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] {f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {g : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))} {C : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} Î² (PseudoMetricSpace.toHasDist.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) g x)) C))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] {f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {g : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))} {C : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : Î±), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) g x)) C))
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_iff ContinuousMap.dist_lt_iffâ‚“'. -/
theorem dist_lt_iff (C0 : (0 : â„) < C) : dist f g < C â†” âˆ€ x : Î±, dist (f x) (g x) < C := by
  simp only [â† dist_mk_of_compact, dist_lt_iff_of_compact C0, mk_of_compact_apply]
#align continuous_map.dist_lt_iff ContinuousMap.dist_lt_iff

end

instance [CompleteSpace Î²] : CompleteSpace C(Î±, Î²) :=
  (isometryEquivBoundedOfCompact Î± Î²).CompleteSpace

/- warning: continuous_map.continuous_eval -> ContinuousMap.continuous_eval is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²], Continuous.{max u1 u2, u2} (Prod.{max u1 u2, u1} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î±) Î² (Prod.topologicalSpace.{max u1 u2, u1} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± (ContinuousMap.compactOpen.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) _inst_1) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (fun (p : Prod.{max u1 u2, u1} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î±) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (Prod.fst.{max u1 u2, u1} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± p) (Prod.snd.{max u1 u2, u1} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± p))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²], Continuous.{max u2 u1, u1} (Prod.{max u1 u2, u2} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î±) Î² (instTopologicalSpaceProd.{max u2 u1, u2} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (ContinuousMap.compactOpen.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) _inst_1) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (fun (p : Prod.{max u1 u2, u2} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î±) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) (Prod.fst.{max u2 u1, u2} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± p) (Prod.snd.{max u2 u1, u2} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± p))
Case conversion may be inaccurate. Consider using '#align continuous_map.continuous_eval ContinuousMap.continuous_evalâ‚“'. -/
/-- See also `continuous_map.continuous_eval'` -/
@[continuity]
theorem continuous_eval : Continuous fun p : C(Î±, Î²) Ã— Î± => p.1 p.2 :=
  continuous_eval.comp ((isometryEquivBoundedOfCompact Î± Î²).Continuous.Prod_map continuous_id)
#align continuous_map.continuous_eval ContinuousMap.continuous_eval

/- warning: continuous_map.continuous_eval_const -> ContinuousMap.continuous_eval_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²] (x : Î±), Continuous.{max u1 u2, u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î² (ContinuousMap.compactOpen.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (fun (f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f x)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_3 : MetricSpace.{u1} Î²] (x : Î±), Continuous.{max u2 u1, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (ContinuousMap.compactOpen.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (PseudoMetricSpace.toUniformSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) x) _inst_3))) (fun (f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f x)
Case conversion may be inaccurate. Consider using '#align continuous_map.continuous_eval_const ContinuousMap.continuous_eval_constâ‚“'. -/
/-- See also `continuous_map.continuous_eval_const` -/
@[continuity]
theorem continuous_eval_const (x : Î±) : Continuous fun f : C(Î±, Î²) => f x :=
  continuous_eval.comp (continuous_id.prod_mk continuous_const)
#align continuous_map.continuous_eval_const ContinuousMap.continuous_eval_const

/- warning: continuous_map.continuous_coe -> ContinuousMap.continuous_coe is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²], Continuous.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (Î± -> Î²) (ContinuousMap.compactOpen.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (Pi.topologicalSpace.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (a : Î±) => UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (á¾° : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_3 : MetricSpace.{u2} Î²], Continuous.{max u2 u1, max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (Î± -> Î²) (ContinuousMap.compactOpen.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (Pi.topologicalSpace.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (a : Î±) => UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± (fun (á¾° : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) á¾°) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3))))))
Case conversion may be inaccurate. Consider using '#align continuous_map.continuous_coe ContinuousMap.continuous_coeâ‚“'. -/
/-- See also `continuous_map.continuous_coe'` -/
theorem continuous_coe : @Continuous C(Î±, Î²) (Î± â†’ Î²) _ _ coeFn :=
  continuous_pi continuous_eval_const
#align continuous_map.continuous_coe ContinuousMap.continuous_coe

-- TODO at some point we will need lemmas characterising this norm!
-- At the moment the only way to reason about it is to transfer `f : C(Î±,E)` back to `Î± â†’áµ‡ E`.
instance : Norm C(Î±, E) where norm x := dist x 0

/- warning: bounded_continuous_function.norm_mk_of_compact -> BoundedContinuousFunction.norm_mkOfCompact is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (BoundedContinuousFunction.hasNorm.{u1, u2} Î± E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) _inst_2 f)) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f)
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u2, u1} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} Î± E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) (BoundedContinuousFunction.mkOfCompact.{u2, u1} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) _inst_2 f)) (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_mk_of_compact BoundedContinuousFunction.norm_mkOfCompactâ‚“'. -/
@[simp]
theorem BoundedContinuousFunction.norm_mkOfCompact (f : C(Î±, E)) : â€–mkOfCompact fâ€– = â€–fâ€– :=
  rfl
#align bounded_continuous_function.norm_mk_of_compact BoundedContinuousFunction.norm_mkOfCompact

/- warning: bounded_continuous_function.norm_to_continuous_map_eq -> BoundedContinuousFunction.norm_toContinuousMap_eq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : BoundedContinuousFunction.{u1, u2} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))), Eq.{1} Real (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) (BoundedContinuousFunction.toContinuousMap.{u1, u2} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) f)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (BoundedContinuousFunction.hasNorm.{u1, u2} Î± E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) f)
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : BoundedContinuousFunction.{u2, u1} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))), Eq.{1} Real (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4) (BoundedContinuousFunction.toContinuousMap.{u2, u1} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) f)) (Norm.norm.{max u2 u1} (BoundedContinuousFunction.{u2, u1} Î± E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} Î± E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_to_continuous_map_eq BoundedContinuousFunction.norm_toContinuousMap_eqâ‚“'. -/
@[simp]
theorem BoundedContinuousFunction.norm_toContinuousMap_eq (f : Î± â†’áµ‡ E) :
    â€–f.toContinuousMapâ€– = â€–fâ€– :=
  rfl
#align bounded_continuous_function.norm_to_continuous_map_eq BoundedContinuousFunction.norm_toContinuousMap_eq

open BoundedContinuousFunction

instance : NormedAddCommGroup C(Î±, E) :=
  { ContinuousMap.metricSpace _ _,
    ContinuousMap.addCommGroup with
    dist_eq := fun x y => by
      rw [â† norm_mk_of_compact, â† dist_mk_of_compact, dist_eq_norm, mk_of_compact_sub]
    dist := dist
    norm := norm }

instance [Nonempty Î±] [One E] [NormOneClass E] : NormOneClass C(Î±, E)
    where norm_one := by simp only [â† norm_mk_of_compact, mk_of_compact_one, norm_one]

section

variable (f : C(Î±, E))

/- warning: continuous_map.norm_coe_le_norm -> ContinuousMap.norm_coe_le_norm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : Î±), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f)
but is expected to have type
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : Î±), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toNorm.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))))) f x)) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f)
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_coe_le_norm ContinuousMap.norm_coe_le_normâ‚“'. -/
-- The corresponding lemmas for `bounded_continuous_function` are stated with `{f}`,
-- and so can not be used in dot notation.
theorem norm_coe_le_norm (x : Î±) : â€–f xâ€– â‰¤ â€–fâ€– :=
  (mkOfCompact f).norm_coe_le_norm x
#align continuous_map.norm_coe_le_norm ContinuousMap.norm_coe_le_norm

/- warning: continuous_map.dist_le_two_norm -> ContinuousMap.dist_le_two_norm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : Î±) (y : Î±), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} E (PseudoMetricSpace.toHasDist.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f))
but is expected to have type
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : Î±) (y : Î±), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (PseudoMetricSpace.toDist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))))) f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_le_two_norm ContinuousMap.dist_le_two_normâ‚“'. -/
/-- Distance between the images of any two points is at most twice the norm of the function. -/
theorem dist_le_two_norm (x y : Î±) : dist (f x) (f y) â‰¤ 2 * â€–fâ€– :=
  (mkOfCompact f).dist_le_two_norm x y
#align continuous_map.dist_le_two_norm ContinuousMap.dist_le_two_norm

/- warning: continuous_map.norm_le -> ContinuousMap.norm_le is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f) C) (forall (x : Î±), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) C))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4) f) C) (forall (x : Î±), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) C))
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_le ContinuousMap.norm_leâ‚“'. -/
/-- The norm of a function is controlled by the supremum of the pointwise norms -/
theorem norm_le {C : â„} (C0 : (0 : â„) â‰¤ C) : â€–fâ€– â‰¤ C â†” âˆ€ x : Î±, â€–f xâ€– â‰¤ C :=
  @BoundedContinuousFunction.norm_le _ _ _ _ (mkOfCompact f) _ C0
#align continuous_map.norm_le ContinuousMap.norm_le

/- warning: continuous_map.norm_le_of_nonempty -> ContinuousMap.norm_le_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) [_inst_5 : Nonempty.{succ u1} Î±] {M : Real}, Iff (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f) M) (forall (x : Î±), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M)
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) [_inst_5 : Nonempty.{succ u2} Î±] {M : Real}, Iff (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4) f) M) (forall (x : Î±), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M)
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_le_of_nonempty ContinuousMap.norm_le_of_nonemptyâ‚“'. -/
theorem norm_le_of_nonempty [Nonempty Î±] {M : â„} : â€–fâ€– â‰¤ M â†” âˆ€ x, â€–f xâ€– â‰¤ M :=
  @BoundedContinuousFunction.norm_le_of_nonempty _ _ _ _ _ (mkOfCompact f) _
#align continuous_map.norm_le_of_nonempty ContinuousMap.norm_le_of_nonempty

/- warning: continuous_map.norm_lt_iff -> ContinuousMap.norm_lt_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) {M : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) M) -> (Iff (LT.lt.{0} Real Real.hasLt (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f) M) (forall (x : Î±), LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) {M : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) M) -> (Iff (LT.lt.{0} Real Real.instLTReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4) f) M) (forall (x : Î±), LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M))
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_lt_iff ContinuousMap.norm_lt_iffâ‚“'. -/
theorem norm_lt_iff {M : â„} (M0 : 0 < M) : â€–fâ€– < M â†” âˆ€ x, â€–f xâ€– < M :=
  @BoundedContinuousFunction.norm_lt_iff_of_compact _ _ _ _ _ (mkOfCompact f) _ M0
#align continuous_map.norm_lt_iff ContinuousMap.norm_lt_iff

/- warning: continuous_map.nnnorm_lt_iff -> ContinuousMap.nnnorm_lt_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) {M : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) M) -> (Iff (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.normedAddCommGroup.{u1, u2} Î± E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : Î±), LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} E (SeminormedAddGroup.toNNNorm.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) {M : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)) M) -> (Iff (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormedAddCommGroupContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : Î±), LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (SeminormedAddGroup.toNNNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M))
Case conversion may be inaccurate. Consider using '#align continuous_map.nnnorm_lt_iff ContinuousMap.nnnorm_lt_iffâ‚“'. -/
theorem nnnorm_lt_iff {M : â„â‰¥0} (M0 : 0 < M) : â€–fâ€–â‚Š < M â†” âˆ€ x : Î±, â€–f xâ€–â‚Š < M :=
  f.norm_lt_iff M0
#align continuous_map.nnnorm_lt_iff ContinuousMap.nnnorm_lt_iff

/- warning: continuous_map.norm_lt_iff_of_nonempty -> ContinuousMap.norm_lt_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) [_inst_5 : Nonempty.{succ u1} Î±] {M : Real}, Iff (LT.lt.{0} Real Real.hasLt (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f) M) (forall (x : Î±), LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M)
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) [_inst_5 : Nonempty.{succ u2} Î±] {M : Real}, Iff (LT.lt.{0} Real Real.instLTReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4) f) M) (forall (x : Î±), LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M)
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_lt_iff_of_nonempty ContinuousMap.norm_lt_iff_of_nonemptyâ‚“'. -/
theorem norm_lt_iff_of_nonempty [Nonempty Î±] {M : â„} : â€–fâ€– < M â†” âˆ€ x, â€–f xâ€– < M :=
  @BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact _ _ _ _ _ _ (mkOfCompact f) _
#align continuous_map.norm_lt_iff_of_nonempty ContinuousMap.norm_lt_iff_of_nonempty

/- warning: continuous_map.nnnorm_lt_iff_of_nonempty -> ContinuousMap.nnnorm_lt_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) [_inst_5 : Nonempty.{succ u1} Î±] {M : NNReal}, Iff (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.normedAddCommGroup.{u1, u2} Î± E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : Î±), LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} E (SeminormedAddGroup.toNNNorm.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M)
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) [_inst_5 : Nonempty.{succ u2} Î±] {M : NNReal}, Iff (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormedAddCommGroupContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : Î±), LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (SeminormedAddGroup.toNNNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M)
Case conversion may be inaccurate. Consider using '#align continuous_map.nnnorm_lt_iff_of_nonempty ContinuousMap.nnnorm_lt_iff_of_nonemptyâ‚“'. -/
theorem nnnorm_lt_iff_of_nonempty [Nonempty Î±] {M : â„â‰¥0} : â€–fâ€–â‚Š < M â†” âˆ€ x, â€–f xâ€–â‚Š < M :=
  f.norm_lt_iff_of_nonempty
#align continuous_map.nnnorm_lt_iff_of_nonempty ContinuousMap.nnnorm_lt_iff_of_nonempty

/- warning: continuous_map.apply_le_norm -> ContinuousMap.apply_le_norm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] (f : ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : Î±), LE.le.{0} Real Real.hasLe (coeFn.{succ u1, succ u1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => Î± -> Real) (ContinuousMap.hasCoeToFun.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f x) (Norm.norm.{u1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.hasNorm.{u1, 0} Î± Real _inst_1 _inst_2 Real.normedAddCommGroup) f)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] (f : ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : Î±), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Real) x) Real.instLEReal (FunLike.coe.{succ u1, succ u1, 1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f x) (Norm.norm.{u1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, 0} Î± Real _inst_1 _inst_2 Real.normedAddCommGroup) f)
Case conversion may be inaccurate. Consider using '#align continuous_map.apply_le_norm ContinuousMap.apply_le_normâ‚“'. -/
theorem apply_le_norm (f : C(Î±, â„)) (x : Î±) : f x â‰¤ â€–fâ€– :=
  le_trans (le_abs.mpr (Or.inl (le_refl (f x)))) (f.norm_coe_le_norm x)
#align continuous_map.apply_le_norm ContinuousMap.apply_le_norm

/- warning: continuous_map.neg_norm_le_apply -> ContinuousMap.neg_norm_le_apply is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] (f : ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : Î±), LE.le.{0} Real Real.hasLe (Neg.neg.{0} Real Real.hasNeg (Norm.norm.{u1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.hasNorm.{u1, 0} Î± Real _inst_1 _inst_2 Real.normedAddCommGroup) f)) (coeFn.{succ u1, succ u1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => Î± -> Real) (ContinuousMap.hasCoeToFun.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f x)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] (f : ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : Î±), LE.le.{0} Real Real.instLEReal (Neg.neg.{0} Real Real.instNegReal (Norm.norm.{u1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, 0} Î± Real _inst_1 _inst_2 Real.normedAddCommGroup) f)) (FunLike.coe.{succ u1, succ u1, 1} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (ContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, 0} Î± Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f x)
Case conversion may be inaccurate. Consider using '#align continuous_map.neg_norm_le_apply ContinuousMap.neg_norm_le_applyâ‚“'. -/
theorem neg_norm_le_apply (f : C(Î±, â„)) (x : Î±) : -â€–fâ€– â‰¤ f x :=
  le_trans (neg_le_neg (f.norm_coe_le_norm x)) (neg_le.mp (neg_le_abs_self (f x)))
#align continuous_map.neg_norm_le_apply ContinuousMap.neg_norm_le_apply

/- warning: continuous_map.norm_eq_supr_norm -> ContinuousMap.norm_eq_iSup_norm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} Î± E _inst_1 _inst_2 _inst_4) f) (iSup.{0, succ u1} Real Real.hasSup Î± (fun (x : Î±) => Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => Î± -> E) (ContinuousMap.hasCoeToFun.{u1, u2} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} Î± E _inst_1 _inst_2 _inst_4) f) (iSup.{0, succ u2} Real Real.instSupSetReal Î± (fun (x : Î±) => Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)))
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_eq_supr_norm ContinuousMap.norm_eq_iSup_normâ‚“'. -/
theorem norm_eq_iSup_norm : â€–fâ€– = â¨† x : Î±, â€–f xâ€– :=
  (mkOfCompact f).norm_eq_iSup_norm
#align continuous_map.norm_eq_supr_norm ContinuousMap.norm_eq_iSup_norm

/- warning: continuous_map.norm_restrict_mono_set -> ContinuousMap.norm_restrict_mono_set is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_restrict_mono_set ContinuousMap.norm_restrict_mono_setâ‚“'. -/
theorem norm_restrict_mono_set {X : Type _} [TopologicalSpace X] (f : C(X, E))
    {K L : TopologicalSpace.Compacts X} (hKL : K â‰¤ L) : â€–f.restrict Kâ€– â‰¤ â€–f.restrict Lâ€– :=
  (norm_le _ (norm_nonneg _)).mpr fun x => norm_coe_le_norm (f.restrict L) <| Set.inclusion hKL x
#align continuous_map.norm_restrict_mono_set ContinuousMap.norm_restrict_mono_set

end

section

variable {R : Type _} [NormedRing R]

instance : NormedRing C(Î±, R) :=
  { (inferInstance : NormedAddCommGroup C(Î±, R)), ContinuousMap.ring with
    norm_mul := fun f g => norm_mul_le (mkOfCompact f) (mkOfCompact g) }

end

section

variable {ð•œ : Type _} [NormedField ð•œ] [NormedSpace ð•œ E]

instance : NormedSpace ð•œ C(Î±, E) where norm_smul_le c f := (norm_smul_le c (mkOfCompact f) : _)

section

variable (Î± ð•œ E)

/- warning: continuous_map.linear_isometry_bounded_of_compact -> ContinuousMap.linearIsometryBoundedOfCompact is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact ContinuousMap.linearIsometryBoundedOfCompactâ‚“'. -/
/-- When `Î±` is compact and `ð•œ` is a normed field,
the `ð•œ`-algebra of bounded continuous maps `Î± â†’áµ‡ Î²` is
`ð•œ`-linearly isometric to `C(Î±, Î²)`.
-/
def linearIsometryBoundedOfCompact : C(Î±, E) â‰ƒâ‚—áµ¢[ð•œ] Î± â†’áµ‡ E :=
  {
    addEquivBoundedOfCompact Î±
      E with
    map_smul' := fun c f => by ext; simp
    norm_map' := fun f => rfl }
#align continuous_map.linear_isometry_bounded_of_compact ContinuousMap.linearIsometryBoundedOfCompact

variable {Î± E}

/- warning: continuous_map.eval_clm -> ContinuousMap.evalClm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.eval_clm ContinuousMap.evalClmâ‚“'. -/
-- to match bounded_continuous_function.eval_clm
/-- The evaluation at a point, as a continuous linear map from `C(Î±, ð•œ)` to `ð•œ`. -/
def evalClm (x : Î±) : C(Î±, E) â†’L[ð•œ] E :=
  (evalClm ð•œ x).comp (linearIsometryBoundedOfCompact Î± E ð•œ).toLinearIsometry.toContinuousLinearMap
#align continuous_map.eval_clm ContinuousMap.evalClm

end

/- warning: continuous_map.linear_isometry_bounded_of_compact_symm_apply -> ContinuousMap.linearIsometryBoundedOfCompact_symm_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_symm_apply ContinuousMap.linearIsometryBoundedOfCompact_symm_applyâ‚“'. -/
-- this lemma and the next are the analogues of those autogenerated by `@[simps]` for
-- `equiv_bounded_of_compact`, `add_equiv_bounded_of_compact`
@[simp]
theorem linearIsometryBoundedOfCompact_symm_apply (f : Î± â†’áµ‡ E) :
    (linearIsometryBoundedOfCompact Î± E ð•œ).symm f = f.toContinuousMap :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_symm_apply ContinuousMap.linearIsometryBoundedOfCompact_symm_apply

/- warning: continuous_map.linear_isometry_bounded_of_compact_apply_apply -> ContinuousMap.linearIsometryBoundedOfCompact_apply_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_apply_apply ContinuousMap.linearIsometryBoundedOfCompact_apply_applyâ‚“'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_apply_apply (f : C(Î±, E)) (a : Î±) :
    (linearIsometryBoundedOfCompact Î± E ð•œ f) a = f a :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_apply_apply ContinuousMap.linearIsometryBoundedOfCompact_apply_apply

/- warning: continuous_map.linear_isometry_bounded_of_compact_to_isometry_equiv -> ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_to_isometry_equiv ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquivâ‚“'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_toIsometryEquiv :
    (linearIsometryBoundedOfCompact Î± E ð•œ).toIsometryEquiv = isometryEquivBoundedOfCompact Î± E :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_to_isometry_equiv ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquiv

/- warning: continuous_map.linear_isometry_bounded_of_compact_to_add_equiv -> ContinuousMap.linearIsometryBoundedOfCompact_toAddEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_to_add_equiv ContinuousMap.linearIsometryBoundedOfCompact_toAddEquivâ‚“'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_toAddEquiv :
    (linearIsometryBoundedOfCompact Î± E ð•œ).toLinearEquiv.toAddEquiv =
      addEquivBoundedOfCompact Î± E :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_to_add_equiv ContinuousMap.linearIsometryBoundedOfCompact_toAddEquiv

/- warning: continuous_map.linear_isometry_bounded_of_compact_of_compact_to_equiv -> ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_of_compact_to_equiv ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquivâ‚“'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_of_compact_toEquiv :
    (linearIsometryBoundedOfCompact Î± E ð•œ).toLinearEquiv.toEquiv = equivBoundedOfCompact Î± E :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_of_compact_to_equiv ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquiv

end

section

variable {ð•œ : Type _} {Î³ : Type _} [NormedField ð•œ] [NormedRing Î³] [NormedAlgebra ð•œ Î³]

instance : NormedAlgebra ð•œ C(Î±, Î³) :=
  { ContinuousMap.normedSpace with }

end

end ContinuousMap

namespace ContinuousMap

section UniformContinuity

variable {Î± Î² : Type _}

variable [MetricSpace Î±] [CompactSpace Î±] [MetricSpace Î²]

/-!
We now set up some declarations making it convenient to use uniform continuity.
-/


/- warning: continuous_map.uniform_continuity -> ContinuousMap.uniform_continuity is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.uniform_continuity ContinuousMap.uniform_continuityâ‚“'. -/
theorem uniform_continuity (f : C(Î±, Î²)) (Îµ : â„) (h : 0 < Îµ) :
    âˆƒ Î´ > 0, âˆ€ {x y}, dist x y < Î´ â†’ dist (f x) (f y) < Îµ :=
  Metric.uniformContinuous_iff.mp (CompactSpace.uniformContinuous_of_continuous f.Continuous) Îµ h
#align continuous_map.uniform_continuity ContinuousMap.uniform_continuity

/- warning: continuous_map.modulus -> ContinuousMap.modulus is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : MetricSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1)))] [_inst_3 : MetricSpace.{u2} Î²], (ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) -> (forall (Îµ : Real), (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> Real)
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : MetricSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1)))] [_inst_3 : MetricSpace.{u2} Î²], (ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) -> (forall (Îµ : Real), (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> Real)
Case conversion may be inaccurate. Consider using '#align continuous_map.modulus ContinuousMap.modulusâ‚“'. -/
-- This definition allows us to separate the choice of some `Î´`,
-- and the corresponding use of `dist a b < Î´ â†’ dist (f a) (f b) < Îµ`,
-- even across different declarations.
/-- An arbitrarily chosen modulus of uniform continuity for a given function `f` and `Îµ > 0`.
-/
def modulus (f : C(Î±, Î²)) (Îµ : â„) (h : 0 < Îµ) : â„ :=
  Classical.choose (uniform_continuity f Îµ h)
#align continuous_map.modulus ContinuousMap.modulus

/- warning: continuous_map.modulus_pos -> ContinuousMap.modulus_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : MetricSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1)))] [_inst_3 : MetricSpace.{u2} Î²] (f : ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) {Îµ : Real} {h : LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ}, LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (ContinuousMap.modulus.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3 f Îµ h)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : MetricSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1)))] [_inst_3 : MetricSpace.{u1} Î²] (f : ContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) {Îµ : Real} {h : LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ}, LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (ContinuousMap.modulus.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3 f Îµ h)
Case conversion may be inaccurate. Consider using '#align continuous_map.modulus_pos ContinuousMap.modulus_posâ‚“'. -/
theorem modulus_pos (f : C(Î±, Î²)) {Îµ : â„} {h : 0 < Îµ} : 0 < f.modulus Îµ h :=
  (Classical.choose_spec (uniform_continuity f Îµ h)).fst
#align continuous_map.modulus_pos ContinuousMap.modulus_pos

/- warning: continuous_map.dist_lt_of_dist_lt_modulus -> ContinuousMap.dist_lt_of_dist_lt_modulus is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : MetricSpace.{u1} Î±] [_inst_2 : CompactSpace.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1)))] [_inst_3 : MetricSpace.{u2} Î²] (f : ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (Îµ : Real) (h : LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) {a : Î±} {b : Î±}, (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1)) a b) (ContinuousMap.modulus.{u1, u2} Î± Î² _inst_1 _inst_2 _inst_3 f Îµ h)) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} Î² (PseudoMetricSpace.toHasDist.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) => Î± -> Î²) (ContinuousMap.hasCoeToFun.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± (MetricSpace.toPseudoMetricSpace.{u1} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (MetricSpace.toPseudoMetricSpace.{u2} Î² _inst_3)))) f b)) Îµ)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : MetricSpace.{u2} Î±] [_inst_2 : CompactSpace.{u2} Î± (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1)))] [_inst_3 : MetricSpace.{u1} Î²] (f : ContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) (Îµ : Real) (h : LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) {a : Î±} {b : Î±}, (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u2} Î± (PseudoMetricSpace.toDist.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1)) a b) (ContinuousMap.modulus.{u2, u1} Î± Î² _inst_1 _inst_2 _inst_3 f Îµ h)) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) a) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) a) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) a) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Î±) => Î²) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3)))) Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î± (PseudoMetricSpace.toUniformSpace.{u2} Î± (MetricSpace.toPseudoMetricSpace.{u2} Î± _inst_1))) (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (MetricSpace.toPseudoMetricSpace.{u1} Î² _inst_3))))) f b)) Îµ)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_of_dist_lt_modulus ContinuousMap.dist_lt_of_dist_lt_modulusâ‚“'. -/
theorem dist_lt_of_dist_lt_modulus (f : C(Î±, Î²)) (Îµ : â„) (h : 0 < Îµ) {a b : Î±}
    (w : dist a b < f.modulus Îµ h) : dist (f a) (f b) < Îµ :=
  (Classical.choose_spec (uniform_continuity f Îµ h)).snd w
#align continuous_map.dist_lt_of_dist_lt_modulus ContinuousMap.dist_lt_of_dist_lt_modulus

end UniformContinuity

end ContinuousMap

section CompLeft

variable (X : Type _) {ð•œ Î² Î³ : Type _} [TopologicalSpace X] [CompactSpace X]
  [NontriviallyNormedField ð•œ]

variable [NormedAddCommGroup Î²] [NormedSpace ð•œ Î²] [NormedAddCommGroup Î³] [NormedSpace ð•œ Î³]

open ContinuousMap

/- warning: continuous_linear_map.comp_left_continuous_compact -> ContinuousLinearMap.compLeftContinuousCompact is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.comp_left_continuous_compact ContinuousLinearMap.compLeftContinuousCompactâ‚“'. -/
/-- Postcomposition of continuous functions into a normed module by a continuous linear map is a
continuous linear map.
Transferred version of `continuous_linear_map.comp_left_continuous_bounded`,
upgraded version of `continuous_linear_map.comp_left_continuous`,
similar to `linear_map.comp_left`. -/
protected def ContinuousLinearMap.compLeftContinuousCompact (g : Î² â†’L[ð•œ] Î³) :
    C(X, Î²) â†’L[ð•œ] C(X, Î³) :=
  (linearIsometryBoundedOfCompact X Î³ ð•œ).symm.toLinearIsometry.toContinuousLinearMap.comp <|
    (g.compLeftContinuousBounded X).comp <|
      (linearIsometryBoundedOfCompact X Î² ð•œ).toLinearIsometry.toContinuousLinearMap
#align continuous_linear_map.comp_left_continuous_compact ContinuousLinearMap.compLeftContinuousCompact

/- warning: continuous_linear_map.to_linear_comp_left_continuous_compact -> ContinuousLinearMap.toLinear_compLeftContinuousCompact is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.to_linear_comp_left_continuous_compact ContinuousLinearMap.toLinear_compLeftContinuousCompactâ‚“'. -/
@[simp]
theorem ContinuousLinearMap.toLinear_compLeftContinuousCompact (g : Î² â†’L[ð•œ] Î³) :
    (g.compLeftContinuousCompact X : C(X, Î²) â†’â‚—[ð•œ] C(X, Î³)) = g.compLeftContinuous ð•œ X := by ext f;
  rfl
#align continuous_linear_map.to_linear_comp_left_continuous_compact ContinuousLinearMap.toLinear_compLeftContinuousCompact

/- warning: continuous_linear_map.comp_left_continuous_compact_apply -> ContinuousLinearMap.compLeftContinuousCompact_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.comp_left_continuous_compact_apply ContinuousLinearMap.compLeftContinuousCompact_applyâ‚“'. -/
@[simp]
theorem ContinuousLinearMap.compLeftContinuousCompact_apply (g : Î² â†’L[ð•œ] Î³) (f : C(X, Î²)) (x : X) :
    g.compLeftContinuousCompact X f x = g (f x) :=
  rfl
#align continuous_linear_map.comp_left_continuous_compact_apply ContinuousLinearMap.compLeftContinuousCompact_apply

end CompLeft

namespace ContinuousMap

/-!
We now setup variations on `comp_right_* f`, where `f : C(X, Y)`
(that is, precomposition by a continuous map),
as a morphism `C(Y, T) â†’ C(X, T)`, respecting various types of structure.

In particular:
* `comp_right_continuous_map`, the bundled continuous map (for this we need `X Y` compact).
* `comp_right_homeomorph`, when we precompose by a homeomorphism.
* `comp_right_alg_hom`, when `T = R` is a topological ring.
-/


section CompRight

#print ContinuousMap.compRightContinuousMap /-
/-- Precomposition by a continuous map is itself a continuous map between spaces of continuous maps.
-/
def compRightContinuousMap {X Y : Type _} (T : Type _) [TopologicalSpace X] [CompactSpace X]
    [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : C(X, Y)) : C(C(Y, T), C(X, T))
    where
  toFun g := g.comp f
  continuous_toFun := by
    refine' metric.continuous_iff.mpr _
    intro g Îµ Îµ_pos
    refine' âŸ¨Îµ, Îµ_pos, fun g' h => _âŸ©
    rw [ContinuousMap.dist_lt_iff Îµ_pos] at hâŠ¢
    Â· exact fun x => h (f x)
#align continuous_map.comp_right_continuous_map ContinuousMap.compRightContinuousMap
-/

/- warning: continuous_map.comp_right_continuous_map_apply -> ContinuousMap.compRightContinuousMap_apply is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} (T : Type.{u3}) [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : CompactSpace.{u1} X _inst_1] [_inst_3 : TopologicalSpace.{u2} Y] [_inst_4 : CompactSpace.{u2} Y _inst_3] [_inst_5 : MetricSpace.{u3} T] (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_3) (g : ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))), Eq.{max (succ u1) (succ u3)} (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (coeFn.{max (succ (max u2 u3)) (succ (max u1 u3)), max (succ (max u2 u3)) (succ (max u1 u3))} (ContinuousMap.{max u2 u3, max u1 u3} (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) (fun (_x : ContinuousMap.{max u2 u3, max u1 u3} (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) => (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) -> (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) (ContinuousMap.hasCoeToFun.{max u2 u3, max u1 u3} (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) (ContinuousMap.compRightContinuousMap.{u1, u2, u3} X Y T _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) g) (ContinuousMap.comp.{u1, u2, u3} X Y T _inst_1 _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))) g f)
but is expected to have type
  forall {X : Type.{u3}} {Y : Type.{u2}} (T : Type.{u1}) [_inst_1 : TopologicalSpace.{u3} X] [_inst_2 : CompactSpace.{u3} X _inst_1] [_inst_3 : TopologicalSpace.{u2} Y] [_inst_4 : CompactSpace.{u2} Y _inst_3] [_inst_5 : MetricSpace.{u1} T] (f : ContinuousMap.{u3, u2} X Y _inst_1 _inst_3) (g : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))), Eq.{max (succ u3) (succ u1)} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) => ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) g) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u2) (succ u1), max (succ u3) (succ u1)} (ContinuousMap.{max u1 u2, max u1 u3} (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5))))) (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (fun (_x : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) => ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) _x) (ContinuousMapClass.toFunLike.{max (max u3 u2) u1, max u2 u1, max u3 u1} (ContinuousMap.{max u1 u2, max u1 u3} (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5))))) (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.instContinuousMapClassContinuousMap.{max u2 u1, max u3 u1} (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))))) (ContinuousMap.compRightContinuousMap.{u3, u2, u1} X Y T _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) g) (ContinuousMap.comp.{u3, u2, u1} X Y T _inst_1 _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5))) g f)
Case conversion may be inaccurate. Consider using '#align continuous_map.comp_right_continuous_map_apply ContinuousMap.compRightContinuousMap_applyâ‚“'. -/
@[simp]
theorem compRightContinuousMap_apply {X Y : Type _} (T : Type _) [TopologicalSpace X]
    [CompactSpace X] [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : C(X, Y))
    (g : C(Y, T)) : (compRightContinuousMap T f) g = g.comp f :=
  rfl
#align continuous_map.comp_right_continuous_map_apply ContinuousMap.compRightContinuousMap_apply

#print ContinuousMap.compRightHomeomorph /-
/-- Precomposition by a homeomorphism is itself a homeomorphism between spaces of continuous maps.
-/
def compRightHomeomorph {X Y : Type _} (T : Type _) [TopologicalSpace X] [CompactSpace X]
    [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : X â‰ƒâ‚œ Y) : C(Y, T) â‰ƒâ‚œ C(X, T)
    where
  toFun := compRightContinuousMap T f.toContinuousMap
  invFun := compRightContinuousMap T f.symm.toContinuousMap
  left_inv g := ext fun _ => congr_arg g (f.apply_symm_apply _)
  right_inv g := ext fun _ => congr_arg g (f.symm_apply_apply _)
#align continuous_map.comp_right_homeomorph ContinuousMap.compRightHomeomorph
-/

/- warning: continuous_map.comp_right_alg_hom_continuous -> ContinuousMap.compRightAlgHom_continuous is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.comp_right_alg_hom_continuous ContinuousMap.compRightAlgHom_continuousâ‚“'. -/
theorem compRightAlgHom_continuous {X Y : Type _} (R A : Type _) [TopologicalSpace X]
    [CompactSpace X] [TopologicalSpace Y] [CompactSpace Y] [CommSemiring R] [Semiring A]
    [MetricSpace A] [TopologicalSemiring A] [Algebra R A] (f : C(X, Y)) :
    Continuous (compRightAlgHom R A f) :=
  map_continuous (compRightContinuousMap A f)
#align continuous_map.comp_right_alg_hom_continuous ContinuousMap.compRightAlgHom_continuous

end CompRight

section LocalNormalConvergence

/-! ### Local normal convergence

A sum of continuous functions (on a locally compact space) is "locally normally convergent" if the
sum of its sup-norms on any compact subset is summable. This implies convergence in the topology
of `C(X, E)` (i.e. locally uniform convergence). -/


open TopologicalSpace

variable {X : Type _} [TopologicalSpace X] [T2Space X] [LocallyCompactSpace X]

variable {E : Type _} [NormedAddCommGroup E] [CompleteSpace E]

/- warning: continuous_map.summable_of_locally_summable_norm -> ContinuousMap.summable_of_locally_summable_norm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.summable_of_locally_summable_norm ContinuousMap.summable_of_locally_summable_normâ‚“'. -/
theorem summable_of_locally_summable_norm {Î¹ : Type _} {F : Î¹ â†’ C(X, E)}
    (hF : âˆ€ K : Compacts X, Summable fun i => â€–(F i).restrict Kâ€–) : Summable F :=
  by
  refine' (ContinuousMap.exists_tendsto_compactOpen_iff_forall _).2 fun K hK => _
  lift K to compacts X using hK
  have A : âˆ€ s : Finset Î¹, restrict (â†‘K) (âˆ‘ i in s, F i) = âˆ‘ i in s, restrict K (F i) := by intro s;
    ext1 x; simp
  simpa only [HasSum, A] using summable_of_summable_norm (hF K)
#align continuous_map.summable_of_locally_summable_norm ContinuousMap.summable_of_locally_summable_norm

end LocalNormalConvergence

/-!
### Star structures

In this section, if `Î²` is a normed â‹†-group, then so is the space of
continuous functions from `Î±` to `Î²`, by using the star operation pointwise.

Furthermore, if `Î±` is compact and `Î²` is a Câ‹†-ring, then `C(Î±, Î²)` is a Câ‹†-ring.  -/


section NormedSpace

variable {Î± : Type _} {Î² : Type _}

variable [TopologicalSpace Î±] [NormedAddCommGroup Î²] [StarAddMonoid Î²] [NormedStarGroup Î²]

/- warning: bounded_continuous_function.mk_of_compact_star -> BoundedContinuousFunction.mkOfCompact_star is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Î±] [_inst_2 : NormedAddCommGroup.{u2} Î²] [_inst_3 : StarAddMonoid.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (NormedAddGroup.toAddGroup.{u2} Î² (NormedAddCommGroup.toNormedAddGroup.{u2} Î² _inst_2))))] [_inst_4 : NormedStarGroup.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2) _inst_3] [_inst_5 : CompactSpace.{u1} Î± _inst_1] (f : ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))))), Eq.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))) (BoundedContinuousFunction.mkOfCompact.{u1, u2} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2)) _inst_5 (Star.star.{max u1 u2} (ContinuousMap.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))))) (ContinuousMap.hasStar.{u1, u2} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2)))) (InvolutiveStar.toHasStar.{u2} Î² (StarAddMonoid.toHasInvolutiveStar.{u2} Î² (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (SeminormedAddGroup.toAddGroup.{u2} Î² (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))))) _inst_3)) (NormedStarGroup.to_continuousStar.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2) _inst_3 _inst_4)) f)) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))) (InvolutiveStar.toHasStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))) (StarAddMonoid.toHasInvolutiveStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))) (BoundedContinuousFunction.addMonoid.{u1, u2} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2)) (SubNegMonoid.toAddMonoid.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (SeminormedAddGroup.toAddGroup.{u2} Î² (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2))) (BoundedContinuousFunction.starAddMonoid.{u1, u2} Î± Î² _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2) _inst_3 _inst_4))) (BoundedContinuousFunction.mkOfCompact.{u1, u2} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} Î² _inst_2)) _inst_5 f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Î±] [_inst_2 : NormedAddCommGroup.{u1} Î²] [_inst_3 : StarAddMonoid.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (NormedAddGroup.toAddGroup.{u1} Î² (NormedAddCommGroup.toNormedAddGroup.{u1} Î² _inst_2))))] [_inst_4 : NormedStarGroup.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2) _inst_3] [_inst_5 : CompactSpace.{u2} Î± _inst_1] (f : ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2))))), Eq.{max (succ u2) (succ u1)} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2))) (BoundedContinuousFunction.mkOfCompact.{u2, u1} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2)) _inst_5 (Star.star.{max u1 u2} (ContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2))))) (ContinuousMap.instStarContinuousMap.{u2, u1} Î± Î² _inst_1 (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2)))) (InvolutiveStar.toStar.{u1} Î² (StarAddMonoid.toInvolutiveStar.{u1} Î² (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (NormedAddGroup.toAddGroup.{u1} Î² (NormedAddCommGroup.toNormedAddGroup.{u1} Î² _inst_2)))) _inst_3)) (NormedStarGroup.to_continuousStar.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2) _inst_3 _inst_4)) f)) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2))) (InvolutiveStar.toStar.{max u2 u1} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2))) (StarAddMonoid.toInvolutiveStar.{max u2 u1} (BoundedContinuousFunction.{u2, u1} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2))) (BoundedContinuousFunction.addMonoid.{u2, u1} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2)) (SubNegMonoid.toAddMonoid.{u1} Î² (AddGroup.toSubNegMonoid.{u1} Î² (NormedAddGroup.toAddGroup.{u1} Î² (NormedAddCommGroup.toNormedAddGroup.{u1} Î² _inst_2)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2))) (BoundedContinuousFunction.starAddMonoid.{u2, u1} Î± Î² _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2) _inst_3 _inst_4))) (BoundedContinuousFunction.mkOfCompact.{u2, u1} Î± Î² _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} Î² (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} Î² _inst_2)) _inst_5 f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_compact_star BoundedContinuousFunction.mkOfCompact_starâ‚“'. -/
theorem BoundedContinuousFunction.mkOfCompact_star [CompactSpace Î±] (f : C(Î±, Î²)) :
    mkOfCompact (star f) = star (mkOfCompact f) :=
  rfl
#align bounded_continuous_function.mk_of_compact_star BoundedContinuousFunction.mkOfCompact_star

instance [CompactSpace Î±] : NormedStarGroup C(Î±, Î²)
    where norm_star f := by
    rw [â† BoundedContinuousFunction.norm_mkOfCompact, BoundedContinuousFunction.mkOfCompact_star,
      norm_star, BoundedContinuousFunction.norm_mkOfCompact]

end NormedSpace

section CstarRing

variable {Î± : Type _} {Î² : Type _}

variable [TopologicalSpace Î±] [NormedRing Î²] [StarRing Î²]

instance [CompactSpace Î±] [CstarRing Î²] : CstarRing C(Î±, Î²)
    where norm_star_mul_self := by
    intro f
    refine' le_antisymm _ _
    Â· rw [â† sq, ContinuousMap.norm_le _ (sq_nonneg _)]
      intro x
      simp only [ContinuousMap.coe_mul, coe_star, Pi.mul_apply, Pi.star_apply,
        CstarRing.norm_star_mul_self, â† sq]
      refine' sq_le_sq' _ _
      Â· linarith [norm_nonneg (f x), norm_nonneg f]
      Â· exact ContinuousMap.norm_coe_le_norm f x
    Â· rw [â† sq, â† Real.le_sqrt (norm_nonneg _) (norm_nonneg _),
        ContinuousMap.norm_le _ (Real.sqrt_nonneg _)]
      intro x
      rw [Real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, â† CstarRing.norm_star_mul_self]
      exact ContinuousMap.norm_coe_le_norm (star f * f) x

end CstarRing

end ContinuousMap

