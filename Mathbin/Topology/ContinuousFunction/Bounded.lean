/-
Copyright (c) 2018 Sébastien Gouëzel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sébastien Gouëzel, Mario Carneiro, Yury Kudryashov, Heather Macbeth

! This file was ported from Lean 3 source module topology.continuous_function.bounded
! leanprover-community/mathlib commit 4280f5f32e16755ec7985ce11e189b6cd6ff6735
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Normed.Order.Lattice
import Mathbin.Analysis.NormedSpace.OperatorNorm
import Mathbin.Analysis.NormedSpace.Star.Basic
import Mathbin.Data.Real.Sqrt
import Mathbin.Topology.ContinuousFunction.Algebra
import Mathbin.Topology.MetricSpace.Equicontinuity

/-!
# Bounded continuous functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The type of bounded continuous functions taking values in a metric space, with
the uniform distance.

-/


noncomputable section

open Topology Classical NNReal uniformity UniformConvergence

open Set Filter Metric Function

universe u v w

variable {F : Type _} {α : Type u} {β : Type v} {γ : Type w}

#print BoundedContinuousFunction /-
/-- `α →ᵇ β` is the type of bounded continuous functions `α → β` from a topological space to a
metric space.

When possible, instead of parametrizing results over `(f : α →ᵇ β)`,
you should parametrize over `(F : Type*) [bounded_continuous_map_class F α β] (f : F)`.

When you extend this structure, make sure to extend `bounded_continuous_map_class`. -/
structure BoundedContinuousFunction (α : Type u) (β : Type v) [TopologicalSpace α]
  [PseudoMetricSpace β] extends ContinuousMap α β : Type max u v where
  map_bounded' : ∃ C, ∀ x y, dist (to_fun x) (to_fun y) ≤ C
#align bounded_continuous_function BoundedContinuousFunction
-/

-- mathport name: bounded_continuous_function
scoped[BoundedContinuousFunction] infixr:25 " →ᵇ " => BoundedContinuousFunction

section

#print BoundedContinuousMapClass /-
/-- `bounded_continuous_map_class F α β` states that `F` is a type of bounded continuous maps.

You should also extend this typeclass when you extend `bounded_continuous_function`. -/
class BoundedContinuousMapClass (F α β : Type _) [TopologicalSpace α] [PseudoMetricSpace β] extends
  ContinuousMapClass F α β where
  map_bounded (f : F) : ∃ C, ∀ x y, dist (f x) (f y) ≤ C
#align bounded_continuous_map_class BoundedContinuousMapClass
-/

end

export BoundedContinuousMapClass (map_bounded)

namespace BoundedContinuousFunction

section Basics

variable [TopologicalSpace α] [PseudoMetricSpace β] [PseudoMetricSpace γ]

variable {f g : α →ᵇ β} {x : α} {C : ℝ}

instance : BoundedContinuousMapClass (α →ᵇ β) α β
    where
  coe f := f.toFun
  coe_injective' f g h := by
    obtain ⟨⟨_, _⟩, _⟩ := f
    obtain ⟨⟨_, _⟩, _⟩ := g
    congr
  map_continuous f := f.continuous_toFun
  map_bounded f := f.map_bounded'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (α →ᵇ β) fun _ => α → β :=
  FunLike.hasCoeToFun

instance [BoundedContinuousMapClass F α β] : CoeTC F (α →ᵇ β) :=
  ⟨fun f =>
    { toFun := f
      continuous_toFun := map_continuous f
      map_bounded' := map_bounded f }⟩

/- warning: bounded_continuous_function.coe_to_continuous_fun -> BoundedContinuousFunction.coe_to_continuous_fun is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (BoundedContinuousFunction.toContinuousMap.{u1, u2} α β _inst_1 _inst_2 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (BoundedContinuousFunction.toContinuousMap.{u1, u2} α β _inst_1 _inst_2 f)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)))) (BoundedContinuousFunction.toContinuousMap.{u1, u2} α β _inst_1 _inst_2 f)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_to_continuous_fun BoundedContinuousFunction.coe_to_continuous_funₓ'. -/
@[simp]
theorem coe_to_continuous_fun (f : α →ᵇ β) : (f.toContinuousMap : α → β) = f :=
  rfl
#align bounded_continuous_function.coe_to_continuous_fun BoundedContinuousFunction.coe_to_continuous_fun

#print BoundedContinuousFunction.Simps.apply /-
/-- See Note [custom simps projection]. We need to specify this projection explicitly in this case,
  because it is a composition of multiple projections. -/
def Simps.apply (h : α →ᵇ β) : α → β :=
  h
#align bounded_continuous_function.simps.apply BoundedContinuousFunction.Simps.apply
-/

initialize_simps_projections BoundedContinuousFunction (to_continuous_map_to_fun → apply)

/- warning: bounded_continuous_function.bounded -> BoundedContinuousFunction.bounded is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Exists.{1} Real (fun (C : Real) => forall (x : α) (y : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f y)) C)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Exists.{1} Real (fun (C : Real) => forall (x : α) (y : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f y)) C)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.bounded BoundedContinuousFunction.boundedₓ'. -/
protected theorem bounded (f : α →ᵇ β) : ∃ C, ∀ x y : α, dist (f x) (f y) ≤ C :=
  f.map_bounded'
#align bounded_continuous_function.bounded BoundedContinuousFunction.bounded

/- warning: bounded_continuous_function.continuous -> BoundedContinuousFunction.continuous is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Continuous.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Continuous.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.continuous BoundedContinuousFunction.continuousₓ'. -/
protected theorem continuous (f : α →ᵇ β) : Continuous f :=
  f.toContinuousMap.Continuous
#align bounded_continuous_function.continuous BoundedContinuousFunction.continuous

/- warning: bounded_continuous_function.ext -> BoundedContinuousFunction.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, (forall (x : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) -> (Eq.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, (forall (x : α), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) -> (Eq.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.ext BoundedContinuousFunction.extₓ'. -/
@[ext]
theorem ext (h : ∀ x, f x = g x) : f = g :=
  FunLike.ext _ _ h
#align bounded_continuous_function.ext BoundedContinuousFunction.ext

/- warning: bounded_continuous_function.bounded_range -> BoundedContinuousFunction.bounded_range is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Metric.Bounded.{u2} β _inst_2 (Set.range.{u2, succ u1} β α (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Metric.Bounded.{u2} β _inst_2 (Set.range.{u2, succ u1} β α (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.bounded_range BoundedContinuousFunction.bounded_rangeₓ'. -/
theorem bounded_range (f : α →ᵇ β) : Bounded (range f) :=
  bounded_range_iff.2 f.Bounded
#align bounded_continuous_function.bounded_range BoundedContinuousFunction.bounded_range

/- warning: bounded_continuous_function.bounded_image -> BoundedContinuousFunction.bounded_image is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (s : Set.{u1} α), Metric.Bounded.{u2} β _inst_2 (Set.image.{u1, u2} α β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) s)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (s : Set.{u1} α), Metric.Bounded.{u2} β _inst_2 (Set.image.{u1, u2} α β (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f) s)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.bounded_image BoundedContinuousFunction.bounded_imageₓ'. -/
theorem bounded_image (f : α →ᵇ β) (s : Set α) : Bounded (f '' s) :=
  f.bounded_range.mono <| image_subset_range _ _
#align bounded_continuous_function.bounded_image BoundedContinuousFunction.bounded_image

#print BoundedContinuousFunction.eq_of_empty /-
theorem eq_of_empty [IsEmpty α] (f g : α →ᵇ β) : f = g :=
  ext <| IsEmpty.elim ‹_›
#align bounded_continuous_function.eq_of_empty BoundedContinuousFunction.eq_of_empty
-/

/- warning: bounded_continuous_function.mk_of_bound -> BoundedContinuousFunction.mkOfBound is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (C : Real), (forall (x : α) (y : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) f y)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (C : Real), (forall (x : α) (y : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)))) f y)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_bound BoundedContinuousFunction.mkOfBoundₓ'. -/
/-- A continuous function with an explicit bound is a bounded continuous function. -/
def mkOfBound (f : C(α, β)) (C : ℝ) (h : ∀ x y : α, dist (f x) (f y) ≤ C) : α →ᵇ β :=
  ⟨f, ⟨C, h⟩⟩
#align bounded_continuous_function.mk_of_bound BoundedContinuousFunction.mkOfBound

/- warning: bounded_continuous_function.mk_of_bound_coe -> BoundedContinuousFunction.mkOfBound_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))} {C : Real} {h : forall (x : α) (y : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) f y)) C}, Eq.{max (succ u1) (succ u2)} ((fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.mkOfBound.{u1, u2} α β _inst_1 _inst_2 f C h)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.mkOfBound.{u1, u2} α β _inst_1 _inst_2 f C h)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))} {C : Real} {h : forall (x : α) (y : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)))) f y)) C}, Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (BoundedContinuousFunction.mkOfBound.{u1, u2} α β _inst_1 _inst_2 f C h)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)))) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_bound_coe BoundedContinuousFunction.mkOfBound_coeₓ'. -/
@[simp]
theorem mkOfBound_coe {f} {C} {h} : (mkOfBound f C h : α → β) = (f : α → β) :=
  rfl
#align bounded_continuous_function.mk_of_bound_coe BoundedContinuousFunction.mkOfBound_coe

#print BoundedContinuousFunction.mkOfCompact /-
/-- A continuous function on a compact space is automatically a bounded continuous function. -/
def mkOfCompact [CompactSpace α] (f : C(α, β)) : α →ᵇ β :=
  ⟨f, bounded_range_iff.1 (isCompact_range f.Continuous).Bounded⟩
#align bounded_continuous_function.mk_of_compact BoundedContinuousFunction.mkOfCompact
-/

/- warning: bounded_continuous_function.mk_of_compact_apply -> BoundedContinuousFunction.mkOfCompact_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_4 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (a : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_4 f) a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) f a)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_4 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (a : α), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_4 f) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)))) f a)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_compact_apply BoundedContinuousFunction.mkOfCompact_applyₓ'. -/
@[simp]
theorem mkOfCompact_apply [CompactSpace α] (f : C(α, β)) (a : α) : mkOfCompact f a = f a :=
  rfl
#align bounded_continuous_function.mk_of_compact_apply BoundedContinuousFunction.mkOfCompact_apply

/- warning: bounded_continuous_function.mk_of_discrete -> BoundedContinuousFunction.mkOfDiscrete is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_4 : DiscreteTopology.{u1} α _inst_1] (f : α -> β) (C : Real), (forall (x : α) (y : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (f x) (f y)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_4 : DiscreteTopology.{u1} α _inst_1] (f : α -> β) (C : Real), (forall (x : α) (y : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} β (PseudoMetricSpace.toDist.{u2} β _inst_2) (f x) (f y)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_discrete BoundedContinuousFunction.mkOfDiscreteₓ'. -/
/-- If a function is bounded on a discrete space, it is automatically continuous,
and therefore gives rise to an element of the type of bounded continuous functions -/
@[simps]
def mkOfDiscrete [DiscreteTopology α] (f : α → β) (C : ℝ) (h : ∀ x y : α, dist (f x) (f y) ≤ C) :
    α →ᵇ β :=
  ⟨⟨f, continuous_of_discreteTopology⟩, ⟨C, h⟩⟩
#align bounded_continuous_function.mk_of_discrete BoundedContinuousFunction.mkOfDiscrete

/-- The uniform distance between two bounded continuous functions -/
instance : Dist (α →ᵇ β) :=
  ⟨fun f g => sInf { C | 0 ≤ C ∧ ∀ x : α, dist (f x) (g x) ≤ C }⟩

/- warning: bounded_continuous_function.dist_eq -> BoundedContinuousFunction.dist_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) (InfSet.sInf.{0} Real Real.hasInf (setOf.{0} Real (fun (C : Real) => And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) (InfSet.sInf.{0} Real Real.instInfSetReal (setOf.{0} Real (fun (C : Real) => And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_eq BoundedContinuousFunction.dist_eqₓ'. -/
theorem dist_eq : dist f g = sInf { C | 0 ≤ C ∧ ∀ x : α, dist (f x) (g x) ≤ C } :=
  rfl
#align bounded_continuous_function.dist_eq BoundedContinuousFunction.dist_eq

/- warning: bounded_continuous_function.dist_set_exists -> BoundedContinuousFunction.dist_set_exists is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Exists.{1} Real (fun (C : Real) => And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Exists.{1} Real (fun (C : Real) => And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_set_exists BoundedContinuousFunction.dist_set_existsₓ'. -/
theorem dist_set_exists : ∃ C, 0 ≤ C ∧ ∀ x : α, dist (f x) (g x) ≤ C :=
  by
  rcases f.bounded_range.union g.bounded_range with ⟨C, hC⟩
  refine' ⟨max 0 C, le_max_left _ _, fun x => (hC _ _ _ _).trans (le_max_right _ _)⟩ <;>
      [left;right] <;>
    apply mem_range_self
#align bounded_continuous_function.dist_set_exists BoundedContinuousFunction.dist_set_exists

/- warning: bounded_continuous_function.dist_coe_le_dist -> BoundedContinuousFunction.dist_coe_le_dist is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_coe_le_dist BoundedContinuousFunction.dist_coe_le_distₓ'. -/
/-- The pointwise distance is controlled by the distance between functions, by definition. -/
theorem dist_coe_le_dist (x : α) : dist (f x) (g x) ≤ dist f g :=
  le_csInf dist_set_exists fun b hb => hb.2 x
#align bounded_continuous_function.dist_coe_le_dist BoundedContinuousFunction.dist_coe_le_dist

/- This lemma will be needed in the proof of the metric space instance, but it will become
useless afterwards as it will be superseded by the general result that the distance is nonnegative
in metric spaces. -/
private theorem dist_nonneg' : 0 ≤ dist f g :=
  le_csInf dist_set_exists fun C => And.left
#align bounded_continuous_function.dist_nonneg' bounded_continuous_function.dist_nonneg'

/- warning: bounded_continuous_function.dist_le -> BoundedContinuousFunction.dist_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LE.le.{0} Real Real.hasLe (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LE.le.{0} Real Real.instLEReal (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_le BoundedContinuousFunction.dist_leₓ'. -/
/-- The distance between two functions is controlled by the supremum of the pointwise distances -/
theorem dist_le (C0 : (0 : ℝ) ≤ C) : dist f g ≤ C ↔ ∀ x : α, dist (f x) (g x) ≤ C :=
  ⟨fun h x => le_trans (dist_coe_le_dist x) h, fun H => csInf_le ⟨0, fun C => And.left⟩ ⟨C0, H⟩⟩
#align bounded_continuous_function.dist_le BoundedContinuousFunction.dist_le

/- warning: bounded_continuous_function.dist_le_iff_of_nonempty -> BoundedContinuousFunction.dist_le_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : Nonempty.{succ u1} α], Iff (LE.le.{0} Real Real.hasLe (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : Nonempty.{succ u1} α], Iff (LE.le.{0} Real Real.instLEReal (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_le_iff_of_nonempty BoundedContinuousFunction.dist_le_iff_of_nonemptyₓ'. -/
theorem dist_le_iff_of_nonempty [Nonempty α] : dist f g ≤ C ↔ ∀ x, dist (f x) (g x) ≤ C :=
  ⟨fun h x => le_trans (dist_coe_le_dist x) h, fun w =>
    (dist_le (le_trans dist_nonneg (w (Nonempty.some ‹_›)))).mpr w⟩
#align bounded_continuous_function.dist_le_iff_of_nonempty BoundedContinuousFunction.dist_le_iff_of_nonempty

/- warning: bounded_continuous_function.dist_lt_of_nonempty_compact -> BoundedContinuousFunction.dist_lt_of_nonempty_compact is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : Nonempty.{succ u1} α] [_inst_5 : CompactSpace.{u1} α _inst_1], (forall (x : α), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) C)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : Nonempty.{succ u1} α] [_inst_5 : CompactSpace.{u1} α _inst_1], (forall (x : α), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) C)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_lt_of_nonempty_compact BoundedContinuousFunction.dist_lt_of_nonempty_compactₓ'. -/
theorem dist_lt_of_nonempty_compact [Nonempty α] [CompactSpace α]
    (w : ∀ x : α, dist (f x) (g x) < C) : dist f g < C :=
  by
  have c : Continuous fun x => dist (f x) (g x) := by continuity
  obtain ⟨x, -, le⟩ :=
    IsCompact.exists_forall_ge isCompact_univ Set.univ_nonempty (Continuous.continuousOn c)
  exact lt_of_le_of_lt (dist_le_iff_of_nonempty.mpr fun y => le y trivial) (w x)
#align bounded_continuous_function.dist_lt_of_nonempty_compact BoundedContinuousFunction.dist_lt_of_nonempty_compact

/- warning: bounded_continuous_function.dist_lt_iff_of_compact -> BoundedContinuousFunction.dist_lt_iff_of_compact is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : CompactSpace.{u1} α _inst_1], (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : CompactSpace.{u1} α _inst_1], (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_lt_iff_of_compact BoundedContinuousFunction.dist_lt_iff_of_compactₓ'. -/
theorem dist_lt_iff_of_compact [CompactSpace α] (C0 : (0 : ℝ) < C) :
    dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C :=
  by
  fconstructor
  · intro w x
    exact lt_of_le_of_lt (dist_coe_le_dist x) w
  · by_cases h : Nonempty α
    · skip
      exact dist_lt_of_nonempty_compact
    · rintro -
      convert C0
      apply le_antisymm _ dist_nonneg'
      rw [dist_eq]
      exact csInf_le ⟨0, fun C => And.left⟩ ⟨le_rfl, fun x => False.elim (h (Nonempty.intro x))⟩
#align bounded_continuous_function.dist_lt_iff_of_compact BoundedContinuousFunction.dist_lt_iff_of_compact

/- warning: bounded_continuous_function.dist_lt_iff_of_nonempty_compact -> BoundedContinuousFunction.dist_lt_iff_of_nonempty_compact is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : Nonempty.{succ u1} α] [_inst_5 : CompactSpace.{u1} α _inst_1], Iff (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {C : Real} [_inst_4 : Nonempty.{succ u1} α] [_inst_5 : CompactSpace.{u1} α _inst_1], Iff (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) C) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_lt_iff_of_nonempty_compact BoundedContinuousFunction.dist_lt_iff_of_nonempty_compactₓ'. -/
theorem dist_lt_iff_of_nonempty_compact [Nonempty α] [CompactSpace α] :
    dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C :=
  ⟨fun w x => lt_of_le_of_lt (dist_coe_le_dist x) w, dist_lt_of_nonempty_compact⟩
#align bounded_continuous_function.dist_lt_iff_of_nonempty_compact BoundedContinuousFunction.dist_lt_iff_of_nonempty_compact

/-- The type of bounded continuous functions, with the uniform distance, is a pseudometric space. -/
instance : PseudoMetricSpace (α →ᵇ β)
    where
  dist_self f := le_antisymm ((dist_le le_rfl).2 fun x => by simp) dist_nonneg'
  dist_comm f g := by simp [dist_eq, dist_comm]
  dist_triangle f g h :=
    (dist_le (add_nonneg dist_nonneg' dist_nonneg')).2 fun x =>
      le_trans (dist_triangle _ _ _) (add_le_add (dist_coe_le_dist _) (dist_coe_le_dist _))

/-- The type of bounded continuous functions, with the uniform distance, is a metric space. -/
instance {α β} [TopologicalSpace α] [MetricSpace β] : MetricSpace (α →ᵇ β)
    where eq_of_dist_eq_zero f g hfg := by
    ext x <;> exact eq_of_dist_eq_zero (le_antisymm (hfg ▸ dist_coe_le_dist _) dist_nonneg)

/- warning: bounded_continuous_function.nndist_eq -> BoundedContinuousFunction.nndist_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) f g) (InfSet.sInf.{0} NNReal (ConditionallyCompleteLattice.toHasInf.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.conditionallyCompleteLinearOrderBot))) (setOf.{0} NNReal (fun (C : NNReal) => forall (x : α), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) f g) (InfSet.sInf.{0} NNReal (ConditionallyCompleteLattice.toInfSet.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.instConditionallyCompleteLinearOrderBotNNReal))) (setOf.{0} NNReal (fun (C : NNReal) => forall (x : α), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNDist.nndist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toNNDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nndist_eq BoundedContinuousFunction.nndist_eqₓ'. -/
theorem nndist_eq : nndist f g = sInf { C | ∀ x : α, nndist (f x) (g x) ≤ C } :=
  Subtype.ext <|
    dist_eq.trans <| by
      rw [NNReal.coe_sInf, NNReal.coe_image]
      simp_rw [mem_set_of_eq, ← NNReal.coe_le_coe, Subtype.coe_mk, exists_prop, coe_nndist]
#align bounded_continuous_function.nndist_eq BoundedContinuousFunction.nndist_eq

/- warning: bounded_continuous_function.nndist_set_exists -> BoundedContinuousFunction.nndist_set_exists is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Exists.{1} NNReal (fun (C : NNReal) => forall (x : α), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) C)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Exists.{1} NNReal (fun (C : NNReal) => forall (x : α), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNDist.nndist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toNNDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) C)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nndist_set_exists BoundedContinuousFunction.nndist_set_existsₓ'. -/
theorem nndist_set_exists : ∃ C, ∀ x : α, nndist (f x) (g x) ≤ C :=
  Subtype.exists.mpr <| dist_set_exists.imp fun a ⟨ha, h⟩ => ⟨ha, h⟩
#align bounded_continuous_function.nndist_set_exists BoundedContinuousFunction.nndist_set_exists

/- warning: bounded_continuous_function.nndist_coe_le_nndist -> BoundedContinuousFunction.nndist_coe_le_nndist is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} (x : α), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)) (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) f g)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} (x : α), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNDist.nndist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toNNDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)) (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nndist_coe_le_nndist BoundedContinuousFunction.nndist_coe_le_nndistₓ'. -/
theorem nndist_coe_le_nndist (x : α) : nndist (f x) (g x) ≤ nndist f g :=
  dist_coe_le_dist x
#align bounded_continuous_function.nndist_coe_le_nndist BoundedContinuousFunction.nndist_coe_le_nndist

/- warning: bounded_continuous_function.dist_zero_of_empty -> BoundedContinuousFunction.dist_zero_of_empty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} [_inst_4 : IsEmpty.{succ u1} α], Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} [_inst_4 : IsEmpty.{succ u1} α], Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_zero_of_empty BoundedContinuousFunction.dist_zero_of_emptyₓ'. -/
/-- On an empty space, bounded continuous functions are at distance 0 -/
theorem dist_zero_of_empty [IsEmpty α] : dist f g = 0 := by
  rw [(ext isEmptyElim : f = g), dist_self]
#align bounded_continuous_function.dist_zero_of_empty BoundedContinuousFunction.dist_zero_of_empty

/- warning: bounded_continuous_function.dist_eq_supr -> BoundedContinuousFunction.dist_eq_iSup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) f g) (iSup.{0, succ u1} Real Real.hasSup α (fun (x : α) => Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f g) (iSup.{0, succ u1} Real Real.instSupSetReal α (fun (x : α) => Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_eq_supr BoundedContinuousFunction.dist_eq_iSupₓ'. -/
theorem dist_eq_iSup : dist f g = ⨆ x : α, dist (f x) (g x) :=
  by
  cases isEmpty_or_nonempty α; · rw [iSup_of_empty', Real.sSup_empty, dist_zero_of_empty]
  refine' (dist_le_iff_of_nonempty.mpr <| le_ciSup _).antisymm (ciSup_le dist_coe_le_dist)
  exact dist_set_exists.imp fun C hC => forall_range_iff.2 hC.2
#align bounded_continuous_function.dist_eq_supr BoundedContinuousFunction.dist_eq_iSup

/- warning: bounded_continuous_function.nndist_eq_supr -> BoundedContinuousFunction.nndist_eq_iSup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) f g) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toHasSup.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.conditionallyCompleteLinearOrderBot))) α (fun (x : α) => NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2}, Eq.{1} NNReal (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) f g) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toSupSet.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.instConditionallyCompleteLinearOrderBotNNReal))) α (fun (x : α) => NNDist.nndist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toNNDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nndist_eq_supr BoundedContinuousFunction.nndist_eq_iSupₓ'. -/
theorem nndist_eq_iSup : nndist f g = ⨆ x : α, nndist (f x) (g x) :=
  Subtype.ext <| dist_eq_iSup.trans <| by simp_rw [NNReal.coe_iSup, coe_nndist]
#align bounded_continuous_function.nndist_eq_supr BoundedContinuousFunction.nndist_eq_iSup

/- warning: bounded_continuous_function.tendsto_iff_tendsto_uniformly -> BoundedContinuousFunction.tendsto_iff_tendstoUniformly is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {ι : Type.{u3}} {F : ι -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)} {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2} {l : Filter.{u3} ι}, Iff (Filter.Tendsto.{u3, max u1 u2} ι (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) F l (nhds.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) f)) (TendstoUniformly.{u1, u2, u3} α β ι (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2) (fun (i : ι) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (F i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) l)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {ι : Type.{u1}} {F : ι -> (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2)} {f : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2} {l : Filter.{u1} ι}, Iff (Filter.Tendsto.{u1, max u2 u3} ι (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) F l (nhds.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) f)) (TendstoUniformly.{u2, u3, u1} α β ι (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2) (fun (i : ι) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) (F i)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) f) l)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.tendsto_iff_tendsto_uniformly BoundedContinuousFunction.tendsto_iff_tendstoUniformlyₓ'. -/
theorem tendsto_iff_tendstoUniformly {ι : Type _} {F : ι → α →ᵇ β} {f : α →ᵇ β} {l : Filter ι} :
    Tendsto F l (𝓝 f) ↔ TendstoUniformly (fun i => F i) f l :=
  Iff.intro
    (fun h =>
      tendstoUniformly_iff.2 fun ε ε0 =>
        (Metric.tendsto_nhds.mp h ε ε0).mp
          (eventually_of_forall fun n hn x =>
            lt_of_le_of_lt (dist_coe_le_dist x) (dist_comm (F n) f ▸ hn)))
    fun h =>
    Metric.tendsto_nhds.mpr fun ε ε_pos =>
      (h _ (dist_mem_uniformity <| half_pos ε_pos)).mp
        (eventually_of_forall fun n hn =>
          lt_of_le_of_lt
            ((dist_le (half_pos ε_pos).le).mpr fun x => dist_comm (f x) (F n x) ▸ le_of_lt (hn x))
            (half_lt_self ε_pos))
#align bounded_continuous_function.tendsto_iff_tendsto_uniformly BoundedContinuousFunction.tendsto_iff_tendstoUniformly

/- warning: bounded_continuous_function.inducing_coe_fn -> BoundedContinuousFunction.inducing_coeFn is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Inducing.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (UniformFun.{u1, u2} α β) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) (UniformFun.topologicalSpace.{u1, u2} α β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (Function.comp.{succ (max u1 u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (α -> β) (UniformFun.{u1, u2} α β) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (UniformFun.{u1, u2} α β)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (UniformFun.{u1, u2} α β)) => (α -> β) -> (UniformFun.{u1, u2} α β)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (UniformFun.{u1, u2} α β)) (UniformFun.ofFun.{u1, u2} α β)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (ᾰ : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Inducing.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (UniformFun.{u1, u2} α β) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (UniformFun.topologicalSpace.{u1, u2} α β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (Function.comp.{max (succ u1) (succ u2), max (succ u2) (succ u1), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (α -> β) (UniformFun.{u1, u2} α β) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (UniformFun.{u1, u2} α β)) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : α -> β) => UniformFun.{u1, u2} α β) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> β) (UniformFun.{u1, u2} α β)) (UniformFun.ofFun.{u1, u2} α β)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.inducing_coe_fn BoundedContinuousFunction.inducing_coeFnₓ'. -/
/-- The topology on `α →ᵇ β` is exactly the topology induced by the natural map to `α →ᵤ β`. -/
theorem inducing_coeFn : Inducing (UniformFun.ofFun ∘ coeFn : (α →ᵇ β) → α →ᵤ β) :=
  by
  rw [inducing_iff_nhds]
  refine' fun f => eq_of_forall_le_iff fun l => _
  rw [← tendsto_iff_comap, ← tendsto_id', tendsto_iff_tendsto_uniformly,
    UniformFun.tendsto_iff_tendstoUniformly]
  rfl
#align bounded_continuous_function.inducing_coe_fn BoundedContinuousFunction.inducing_coeFn

/- warning: bounded_continuous_function.embedding_coe_fn -> BoundedContinuousFunction.embedding_coeFn is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Embedding.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (UniformFun.{u1, u2} α β) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) (UniformFun.topologicalSpace.{u1, u2} α β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (Function.comp.{succ (max u1 u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (α -> β) (UniformFun.{u1, u2} α β) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (UniformFun.{u1, u2} α β)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (UniformFun.{u1, u2} α β)) => (α -> β) -> (UniformFun.{u1, u2} α β)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (UniformFun.{u1, u2} α β)) (UniformFun.ofFun.{u1, u2} α β)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (ᾰ : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Embedding.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (UniformFun.{u1, u2} α β) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (UniformFun.topologicalSpace.{u1, u2} α β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (Function.comp.{max (succ u1) (succ u2), max (succ u2) (succ u1), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (α -> β) (UniformFun.{u1, u2} α β) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (UniformFun.{u1, u2} α β)) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : α -> β) => UniformFun.{u1, u2} α β) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> β) (UniformFun.{u1, u2} α β)) (UniformFun.ofFun.{u1, u2} α β)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.embedding_coe_fn BoundedContinuousFunction.embedding_coeFnₓ'. -/
-- TODO: upgrade to a `uniform_embedding`
theorem embedding_coeFn : Embedding (UniformFun.ofFun ∘ coeFn : (α →ᵇ β) → α →ᵤ β) :=
  ⟨inducing_coeFn, fun f g h => ext fun x => congr_fun h x⟩
#align bounded_continuous_function.embedding_coe_fn BoundedContinuousFunction.embedding_coeFn

variable (α) {β}

#print BoundedContinuousFunction.const /-
/-- Constant as a continuous bounded function. -/
@[simps (config := { fullyApplied := false })]
def const (b : β) : α →ᵇ β :=
  ⟨ContinuousMap.const α b, 0, by simp [le_rfl]⟩
#align bounded_continuous_function.const BoundedContinuousFunction.const
-/

variable {α}

/- warning: bounded_continuous_function.const_apply' -> BoundedContinuousFunction.const_apply' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (a : α) (b : β), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 _inst_2 b) a) b
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (a : α) (b : β), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 _inst_2 b) a) b
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.const_apply' BoundedContinuousFunction.const_apply'ₓ'. -/
theorem const_apply' (a : α) (b : β) : (const α b : α → β) a = b :=
  rfl
#align bounded_continuous_function.const_apply' BoundedContinuousFunction.const_apply'

/-- If the target space is inhabited, so is the space of bounded continuous functions -/
instance [Inhabited β] : Inhabited (α →ᵇ β) :=
  ⟨const α default⟩

/- warning: bounded_continuous_function.lipschitz_evalx -> BoundedContinuousFunction.lipschitz_evalx is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (x : α), LipschitzWith.{max u1 u2, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) β (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β _inst_2) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (x : α), LipschitzWith.{max u1 u2, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.lipschitz_evalx BoundedContinuousFunction.lipschitz_evalxₓ'. -/
theorem lipschitz_evalx (x : α) : LipschitzWith 1 fun f : α →ᵇ β => f x :=
  LipschitzWith.mk_one fun f g => dist_coe_le_dist x
#align bounded_continuous_function.lipschitz_evalx BoundedContinuousFunction.lipschitz_evalx

/- warning: bounded_continuous_function.uniform_continuous_coe -> BoundedContinuousFunction.uniformContinuous_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], UniformContinuous.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (α -> β) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) (Pi.uniformSpace.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (ᾰ : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], UniformContinuous.{max u2 u1, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (α -> β) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) (Pi.uniformSpace.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.uniform_continuous_coe BoundedContinuousFunction.uniformContinuous_coeₓ'. -/
theorem uniformContinuous_coe : @UniformContinuous (α →ᵇ β) (α → β) _ _ coeFn :=
  uniformContinuous_pi.2 fun x => (lipschitz_evalx x).UniformContinuous
#align bounded_continuous_function.uniform_continuous_coe BoundedContinuousFunction.uniformContinuous_coe

/- warning: bounded_continuous_function.continuous_coe -> BoundedContinuousFunction.continuous_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Continuous.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (α -> β) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) (Pi.topologicalSpace.{u1, u2} α (fun (x : α) => β) (fun (a : α) => UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (x : α) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Continuous.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (forall (x : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (Pi.topologicalSpace.{u1, u2} α (fun (x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (fun (a : α) => UniformSpace.toTopologicalSpace.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (PseudoMetricSpace.toUniformSpace.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) _inst_2))) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (x : α) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.continuous_coe BoundedContinuousFunction.continuous_coeₓ'. -/
theorem continuous_coe : Continuous fun (f : α →ᵇ β) x => f x :=
  UniformContinuous.continuous uniformContinuous_coe
#align bounded_continuous_function.continuous_coe BoundedContinuousFunction.continuous_coe

/- warning: bounded_continuous_function.continuous_eval_const -> BoundedContinuousFunction.continuous_eval_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {x : α}, Continuous.{max u1 u2, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) β (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {x : α}, Continuous.{max u1 u2, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (UniformSpace.toTopologicalSpace.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toUniformSpace.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2)) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.continuous_eval_const BoundedContinuousFunction.continuous_eval_constₓ'. -/
/-- When `x` is fixed, `(f : α →ᵇ β) ↦ f x` is continuous -/
@[continuity]
theorem continuous_eval_const {x : α} : Continuous fun f : α →ᵇ β => f x :=
  (continuous_apply x).comp continuous_coe
#align bounded_continuous_function.continuous_eval_const BoundedContinuousFunction.continuous_eval_const

/- warning: bounded_continuous_function.continuous_eval -> BoundedContinuousFunction.continuous_eval is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Continuous.{max u1 u2, u2} (Prod.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α) β (Prod.topologicalSpace.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) _inst_1) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (fun (p : Prod.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (Prod.fst.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α p) (Prod.snd.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α p))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β], Continuous.{max u1 u2, u2} (Prod.{max u2 u1, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α) β (instTopologicalSpaceProd.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) _inst_1) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (fun (p : Prod.{max u2 u1, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (Prod.fst.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α p) (Prod.snd.{max u1 u2, u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α p))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.continuous_eval BoundedContinuousFunction.continuous_evalₓ'. -/
/-- The evaluation map is continuous, as a joint function of `u` and `x` -/
@[continuity]
theorem continuous_eval : Continuous fun p : (α →ᵇ β) × α => p.1 p.2 :=
  (continuous_prod_of_continuous_lipschitz _ 1 fun f => f.Continuous) <| lipschitz_evalx
#align bounded_continuous_function.continuous_eval BoundedContinuousFunction.continuous_eval

/-- Bounded continuous functions taking values in a complete space form a complete space. -/
instance [CompleteSpace β] : CompleteSpace (α →ᵇ β) :=
  complete_of_cauchySeq_tendsto fun (f : ℕ → α →ᵇ β) (hf : CauchySeq f) =>
    by
    /- We have to show that `f n` converges to a bounded continuous function.
      For this, we prove pointwise convergence to define the limit, then check
      it is a continuous bounded function, and then check the norm convergence. -/
    rcases cauchySeq_iff_le_tendsto_0.1 hf with ⟨b, b0, b_bound, b_lim⟩
    have f_bdd := fun x n m N hn hm => le_trans (dist_coe_le_dist x) (b_bound n m N hn hm)
    have fx_cau : ∀ x, CauchySeq fun n => f n x := fun x =>
      cauchySeq_iff_le_tendsto_0.2 ⟨b, b0, f_bdd x, b_lim⟩
    choose F hF using fun x => cauchySeq_tendsto_of_complete (fx_cau x)
    /- F : α → β,  hF : ∀ (x : α), tendsto (λ (n : ℕ), f n x) at_top (𝓝 (F x))
      `F` is the desired limit function. Check that it is uniformly approximated by `f N` -/
    have fF_bdd : ∀ x N, dist (f N x) (F x) ≤ b N := fun x N =>
      le_of_tendsto (tendsto_const_nhds.dist (hF x))
        (Filter.eventually_atTop.2 ⟨N, fun n hn => f_bdd x N n N (le_refl N) hn⟩)
    refine' ⟨⟨⟨F, _⟩, _⟩, _⟩
    · -- Check that `F` is continuous, as a uniform limit of continuous functions
      have : TendstoUniformly (fun n x => f n x) F at_top :=
        by
        refine' Metric.tendstoUniformly_iff.2 fun ε ε0 => _
        refine' ((tendsto_order.1 b_lim).2 ε ε0).mono fun n hn x => _
        rw [dist_comm]
        exact lt_of_le_of_lt (fF_bdd x n) hn
      exact this.continuous (eventually_of_forall fun N => (f N).Continuous)
    · -- Check that `F` is bounded
      rcases(f 0).Bounded with ⟨C, hC⟩
      refine' ⟨C + (b 0 + b 0), fun x y => _⟩
      calc
        dist (F x) (F y) ≤ dist (f 0 x) (f 0 y) + (dist (f 0 x) (F x) + dist (f 0 y) (F y)) :=
          dist_triangle4_left _ _ _ _
        _ ≤ C + (b 0 + b 0) := by mono*
        
    · -- Check that `F` is close to `f N` in distance terms
      refine' tendsto_iff_dist_tendsto_zero.2 (squeeze_zero (fun _ => dist_nonneg) _ b_lim)
      exact fun N => (dist_le (b0 _)).2 fun x => fF_bdd x N

#print BoundedContinuousFunction.compContinuous /-
/-- Composition of a bounded continuous function and a continuous function. -/
def compContinuous {δ : Type _} [TopologicalSpace δ] (f : α →ᵇ β) (g : C(δ, α)) : δ →ᵇ β
    where
  toContinuousMap := f.1.comp g
  map_bounded' := f.map_bounded'.imp fun C hC x y => hC _ _
#align bounded_continuous_function.comp_continuous BoundedContinuousFunction.compContinuous
-/

/- warning: bounded_continuous_function.coe_comp_continuous -> BoundedContinuousFunction.coe_compContinuous is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u3, u1} δ α _inst_4 _inst_1), Eq.{max (succ u3) (succ u2)} (δ -> β) (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (fun (_x : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) => δ -> β) (BoundedContinuousFunction.hasCoeToFun.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 f g)) (Function.comp.{succ u3, succ u1, succ u2} δ α β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (ContinuousMap.{u3, u1} δ α _inst_4 _inst_1) (fun (_x : ContinuousMap.{u3, u1} δ α _inst_4 _inst_1) => δ -> α) (ContinuousMap.hasCoeToFun.{u3, u1} δ α _inst_4 _inst_1) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] (f : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} δ α _inst_4 _inst_1), Eq.{max (succ u3) (succ u1)} (forall (ᾰ : δ), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ (fun (_x : δ) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2))) (BoundedContinuousFunction.compContinuous.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 f g)) (Function.comp.{succ u1, succ u2, succ u3} δ α β (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (ContinuousMap.{u1, u2} δ α _inst_4 _inst_1) δ (fun (_x : δ) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : δ) => α) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u1, u2} (ContinuousMap.{u1, u2} δ α _inst_4 _inst_1) δ α _inst_4 _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} δ α _inst_4 _inst_1)) g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_comp_continuous BoundedContinuousFunction.coe_compContinuousₓ'. -/
@[simp]
theorem coe_compContinuous {δ : Type _} [TopologicalSpace δ] (f : α →ᵇ β) (g : C(δ, α)) :
    coeFn (f.comp_continuous g) = f ∘ g :=
  rfl
#align bounded_continuous_function.coe_comp_continuous BoundedContinuousFunction.coe_compContinuous

/- warning: bounded_continuous_function.comp_continuous_apply -> BoundedContinuousFunction.compContinuous_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u3, u1} δ α _inst_4 _inst_1) (x : δ), Eq.{succ u2} β (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (fun (_x : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) => δ -> β) (BoundedContinuousFunction.hasCoeToFun.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 f g) x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (ContinuousMap.{u3, u1} δ α _inst_4 _inst_1) (fun (_x : ContinuousMap.{u3, u1} δ α _inst_4 _inst_1) => δ -> α) (ContinuousMap.hasCoeToFun.{u3, u1} δ α _inst_4 _inst_1) g x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] (f : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} δ α _inst_4 _inst_1) (x : δ), Eq.{succ u3} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ (fun (_x : δ) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2))) (BoundedContinuousFunction.compContinuous.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 f g) x) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) f (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (ContinuousMap.{u1, u2} δ α _inst_4 _inst_1) δ (fun (_x : δ) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : δ) => α) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u1, u2} (ContinuousMap.{u1, u2} δ α _inst_4 _inst_1) δ α _inst_4 _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} δ α _inst_4 _inst_1)) g x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.comp_continuous_apply BoundedContinuousFunction.compContinuous_applyₓ'. -/
@[simp]
theorem compContinuous_apply {δ : Type _} [TopologicalSpace δ] (f : α →ᵇ β) (g : C(δ, α)) (x : δ) :
    f.comp_continuous g x = f (g x) :=
  rfl
#align bounded_continuous_function.comp_continuous_apply BoundedContinuousFunction.compContinuous_apply

/- warning: bounded_continuous_function.lipschitz_comp_continuous -> BoundedContinuousFunction.lipschitz_compContinuous is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] (g : ContinuousMap.{u3, u1} δ α _inst_4 _inst_1), LipschitzWith.{max u1 u2, max u3 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u3 u2} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u3, u2} δ β _inst_4 _inst_2)) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] (g : ContinuousMap.{u1, u2} δ α _inst_4 _inst_1), LipschitzWith.{max u2 u3, max u3 u1} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u3 u1} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2)) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) (fun (f : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) => BoundedContinuousFunction.compContinuous.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.lipschitz_comp_continuous BoundedContinuousFunction.lipschitz_compContinuousₓ'. -/
theorem lipschitz_compContinuous {δ : Type _} [TopologicalSpace δ] (g : C(δ, α)) :
    LipschitzWith 1 fun f : α →ᵇ β => f.comp_continuous g :=
  LipschitzWith.mk_one fun f₁ f₂ => (dist_le dist_nonneg).2 fun x => dist_coe_le_dist (g x)
#align bounded_continuous_function.lipschitz_comp_continuous BoundedContinuousFunction.lipschitz_compContinuous

/- warning: bounded_continuous_function.continuous_comp_continuous -> BoundedContinuousFunction.continuous_compContinuous is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] (g : ContinuousMap.{u3, u1} δ α _inst_4 _inst_1), Continuous.{max u1 u2, max u3 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) (UniformSpace.toTopologicalSpace.{max u3 u2} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u3 u2} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u3, u2} δ β _inst_4 _inst_2))) (fun (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] (g : ContinuousMap.{u1, u2} δ α _inst_4 _inst_1), Continuous.{max u2 u3, max u3 u1} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) (UniformSpace.toTopologicalSpace.{max u3 u1} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u3 u1} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2))) (fun (f : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) => BoundedContinuousFunction.compContinuous.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.continuous_comp_continuous BoundedContinuousFunction.continuous_compContinuousₓ'. -/
theorem continuous_compContinuous {δ : Type _} [TopologicalSpace δ] (g : C(δ, α)) :
    Continuous fun f : α →ᵇ β => f.comp_continuous g :=
  (lipschitz_compContinuous g).Continuous
#align bounded_continuous_function.continuous_comp_continuous BoundedContinuousFunction.continuous_compContinuous

#print BoundedContinuousFunction.restrict /-
/-- Restrict a bounded continuous function to a set. -/
def restrict (f : α →ᵇ β) (s : Set α) : s →ᵇ β :=
  f.comp_continuous <| (ContinuousMap.id _).restrict s
#align bounded_continuous_function.restrict BoundedContinuousFunction.restrict
-/

/- warning: bounded_continuous_function.coe_restrict -> BoundedContinuousFunction.coe_restrict is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (s : Set.{u1} α), Eq.{max (succ u1) (succ u2)} ((coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) -> β) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) _inst_1) _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) _inst_1) _inst_2) => (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) _inst_1) _inst_2) (BoundedContinuousFunction.restrict.{u1, u2} α β _inst_1 _inst_2 f s)) (Function.comp.{succ u1, succ u1, succ u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s)))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (s : Set.{u1} α), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : Set.Elem.{u1} α s), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : Set.Elem.{u1} α s) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2) (Set.Elem.{u1} α s) (fun (_x : Set.Elem.{u1} α s) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : Set.Elem.{u1} α s) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2) (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2) (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2))) (BoundedContinuousFunction.restrict.{u1, u2} α β _inst_1 _inst_2 f s)) (Function.comp.{succ u1, succ u1, succ u2} (Set.Elem.{u1} α s) α β (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f) (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_restrict BoundedContinuousFunction.coe_restrictₓ'. -/
@[simp]
theorem coe_restrict (f : α →ᵇ β) (s : Set α) : coeFn (f.restrict s) = f ∘ coe :=
  rfl
#align bounded_continuous_function.coe_restrict BoundedContinuousFunction.coe_restrict

/- warning: bounded_continuous_function.restrict_apply -> BoundedContinuousFunction.restrict_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (s : Set.{u1} α) (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) _inst_1) _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) _inst_1) _inst_2) => (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) _inst_1) _inst_2) (BoundedContinuousFunction.restrict.{u1, u2} α β _inst_1 _inst_2 f s) x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))))) x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (s : Set.{u1} α) (x : Set.Elem.{u1} α s), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : Set.Elem.{u1} α s) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2) (Set.Elem.{u1} α s) (fun (_x : Set.Elem.{u1} α s) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : Set.Elem.{u1} α s) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2) (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2) (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} (Set.Elem.{u1} α s) β (instTopologicalSpaceSubtype.{u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) _inst_1) _inst_2))) (BoundedContinuousFunction.restrict.{u1, u2} α β _inst_1 _inst_2 f s) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.restrict_apply BoundedContinuousFunction.restrict_applyₓ'. -/
@[simp]
theorem restrict_apply (f : α →ᵇ β) (s : Set α) (x : s) : f.restrict s x = f x :=
  rfl
#align bounded_continuous_function.restrict_apply BoundedContinuousFunction.restrict_apply

#print BoundedContinuousFunction.comp /-
/-- Composition (in the target) of a bounded continuous function with a Lipschitz map again
gives a bounded continuous function -/
def comp (G : β → γ) {C : ℝ≥0} (H : LipschitzWith C G) (f : α →ᵇ β) : α →ᵇ γ :=
  ⟨⟨fun x => G (f x), H.Continuous.comp f.Continuous⟩,
    let ⟨D, hD⟩ := f.Bounded
    ⟨max C 0 * D, fun x y =>
      calc
        dist (G (f x)) (G (f y)) ≤ C * dist (f x) (f y) := H.dist_le_mul _ _
        _ ≤ max C 0 * dist (f x) (f y) := (mul_le_mul_of_nonneg_right (le_max_left C 0) dist_nonneg)
        _ ≤ max C 0 * D := mul_le_mul_of_nonneg_left (hD _ _) (le_max_right C 0)
        ⟩⟩
#align bounded_continuous_function.comp BoundedContinuousFunction.comp
-/

/- warning: bounded_continuous_function.lipschitz_comp -> BoundedContinuousFunction.lipschitz_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : PseudoMetricSpace.{u3} γ] {G : β -> γ} {C : NNReal} (H : LipschitzWith.{u2, u3} β γ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} γ _inst_3) C G), LipschitzWith.{max u1 u2, max u1 u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u3} α γ _inst_1 _inst_3)) C (BoundedContinuousFunction.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 G C H)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : PseudoMetricSpace.{u3} γ] {G : β -> γ} {C : NNReal} (H : LipschitzWith.{u2, u3} β γ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} γ _inst_3) C G), LipschitzWith.{max u1 u2, max u1 u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3)) C (BoundedContinuousFunction.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 G C H)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.lipschitz_comp BoundedContinuousFunction.lipschitz_compₓ'. -/
/-- The composition operator (in the target) with a Lipschitz map is Lipschitz -/
theorem lipschitz_comp {G : β → γ} {C : ℝ≥0} (H : LipschitzWith C G) :
    LipschitzWith C (comp G H : (α →ᵇ β) → α →ᵇ γ) :=
  LipschitzWith.of_dist_le_mul fun f g =>
    (dist_le (mul_nonneg C.2 dist_nonneg)).2 fun x =>
      calc
        dist (G (f x)) (G (g x)) ≤ C * dist (f x) (g x) := H.dist_le_mul _ _
        _ ≤ C * dist f g := mul_le_mul_of_nonneg_left (dist_coe_le_dist _) C.2
        
#align bounded_continuous_function.lipschitz_comp BoundedContinuousFunction.lipschitz_comp

/- warning: bounded_continuous_function.uniform_continuous_comp -> BoundedContinuousFunction.uniformContinuous_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : PseudoMetricSpace.{u3} γ] {G : β -> γ} {C : NNReal} (H : LipschitzWith.{u2, u3} β γ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} γ _inst_3) C G), UniformContinuous.{max u1 u2, max u1 u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u3} α γ _inst_1 _inst_3)) (BoundedContinuousFunction.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 G C H)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : PseudoMetricSpace.{u3} γ] {G : β -> γ} {C : NNReal} (H : LipschitzWith.{u2, u3} β γ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} γ _inst_3) C G), UniformContinuous.{max u1 u2, max u1 u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3)) (BoundedContinuousFunction.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 G C H)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.uniform_continuous_comp BoundedContinuousFunction.uniformContinuous_compₓ'. -/
/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/
theorem uniformContinuous_comp {G : β → γ} {C : ℝ≥0} (H : LipschitzWith C G) :
    UniformContinuous (comp G H : (α →ᵇ β) → α →ᵇ γ) :=
  (lipschitz_comp H).UniformContinuous
#align bounded_continuous_function.uniform_continuous_comp BoundedContinuousFunction.uniformContinuous_comp

/- warning: bounded_continuous_function.continuous_comp -> BoundedContinuousFunction.continuous_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : PseudoMetricSpace.{u3} γ] {G : β -> γ} {C : NNReal} (H : LipschitzWith.{u2, u3} β γ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} γ _inst_3) C G), Continuous.{max u1 u2, max u1 u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2))) (UniformSpace.toTopologicalSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u3} α γ _inst_1 _inst_3))) (BoundedContinuousFunction.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 G C H)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : PseudoMetricSpace.{u3} γ] {G : β -> γ} {C : NNReal} (H : LipschitzWith.{u2, u3} β γ (PseudoMetricSpace.toPseudoEMetricSpace.{u2} β _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{u3} γ _inst_3) C G), Continuous.{max u1 u2, max u1 u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (UniformSpace.toTopologicalSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u3} α γ _inst_1 _inst_3))) (BoundedContinuousFunction.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 G C H)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.continuous_comp BoundedContinuousFunction.continuous_compₓ'. -/
/-- The composition operator (in the target) with a Lipschitz map is continuous -/
theorem continuous_comp {G : β → γ} {C : ℝ≥0} (H : LipschitzWith C G) :
    Continuous (comp G H : (α →ᵇ β) → α →ᵇ γ) :=
  (lipschitz_comp H).Continuous
#align bounded_continuous_function.continuous_comp BoundedContinuousFunction.continuous_comp

/- warning: bounded_continuous_function.cod_restrict -> BoundedContinuousFunction.codRestrict is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (s : Set.{u2} β) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), (forall (x : α), Membership.Mem.{u2, u2} β (Set.{u2} β) (Set.hasMem.{u2} β) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) s) -> (BoundedContinuousFunction.{u1, u2} α (coeSort.{succ u2, succ (succ u2)} (Set.{u2} β) Type.{u2} (Set.hasCoeToSort.{u2} β) s) _inst_1 (Subtype.pseudoMetricSpace.{u2} β _inst_2 (fun (x : β) => Membership.Mem.{u2, u2} β (Set.{u2} β) (Set.hasMem.{u2} β) x s)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] (s : Set.{u2} β) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), (forall (x : α), Membership.mem.{u2, u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (Set.{u2} β) (Set.instMembershipSet.{u2} β) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) s) -> (BoundedContinuousFunction.{u1, u2} α (Set.Elem.{u2} β s) _inst_1 (Subtype.pseudoMetricSpace.{u2} β _inst_2 (fun (x : β) => Membership.mem.{u2, u2} β (Set.{u2} β) (Set.instMembershipSet.{u2} β) x s)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.cod_restrict BoundedContinuousFunction.codRestrictₓ'. -/
/-- Restriction (in the target) of a bounded continuous function taking values in a subset -/
def codRestrict (s : Set β) (f : α →ᵇ β) (H : ∀ x, f x ∈ s) : α →ᵇ s :=
  ⟨⟨s.codRestrict f H, f.Continuous.subtype_mk _⟩, f.Bounded⟩
#align bounded_continuous_function.cod_restrict BoundedContinuousFunction.codRestrict

section Extend

variable {δ : Type _} [TopologicalSpace δ] [DiscreteTopology δ]

#print BoundedContinuousFunction.extend /-
/-- A version of `function.extend` for bounded continuous maps. We assume that the domain has
discrete topology, so we only need to verify boundedness. -/
def extend (f : α ↪ δ) (g : α →ᵇ β) (h : δ →ᵇ β) : δ →ᵇ β
    where
  toFun := extend f g h
  continuous_toFun := continuous_of_discreteTopology
  map_bounded' :=
    by
    rw [← bounded_range_iff, range_extend f.injective, Metric.bounded_union]
    exact ⟨g.bounded_range, h.bounded_image _⟩
#align bounded_continuous_function.extend BoundedContinuousFunction.extend
-/

/- warning: bounded_continuous_function.extend_apply -> BoundedContinuousFunction.extend_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] [_inst_5 : DiscreteTopology.{u3} δ _inst_4] (f : Function.Embedding.{succ u1, succ u3} α δ) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (x : α), Eq.{succ u2} β (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (fun (_x : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) => δ -> β) (BoundedContinuousFunction.hasCoeToFun.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.extend.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f x)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] [_inst_5 : DiscreteTopology.{u1} δ _inst_4] (f : Function.Embedding.{succ u2, succ u1} α δ) (g : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (x : α), Eq.{succ u3} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (a : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f x)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ (fun (_x : δ) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2))) (BoundedContinuousFunction.extend.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f x)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) g x)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.extend_apply BoundedContinuousFunction.extend_applyₓ'. -/
@[simp]
theorem extend_apply (f : α ↪ δ) (g : α →ᵇ β) (h : δ →ᵇ β) (x : α) : extend f g h (f x) = g x :=
  f.Injective.extend_apply _ _ _
#align bounded_continuous_function.extend_apply BoundedContinuousFunction.extend_apply

/- warning: bounded_continuous_function.extend_comp -> BoundedContinuousFunction.extend_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] [_inst_5 : DiscreteTopology.{u3} δ _inst_4] (f : Function.Embedding.{succ u1, succ u3} α δ) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2), Eq.{max (succ u1) (succ u2)} (α -> β) (Function.comp.{succ u1, succ u3, succ u2} α δ β (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (fun (_x : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) => δ -> β) (BoundedContinuousFunction.hasCoeToFun.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.extend.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] [_inst_5 : DiscreteTopology.{u1} δ _inst_4] (f : Function.Embedding.{succ u2, succ u1} α δ) (g : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2), Eq.{max (succ u2) (succ u3)} (α -> β) (Function.comp.{succ u2, succ u1, succ u3} α δ β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ (fun (_x : δ) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2))) (BoundedContinuousFunction.extend.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.extend_comp BoundedContinuousFunction.extend_compₓ'. -/
@[simp]
theorem extend_comp (f : α ↪ δ) (g : α →ᵇ β) (h : δ →ᵇ β) : extend f g h ∘ f = g :=
  extend_comp f.Injective _ _
#align bounded_continuous_function.extend_comp BoundedContinuousFunction.extend_comp

/- warning: bounded_continuous_function.extend_apply' -> BoundedContinuousFunction.extend_apply' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] [_inst_5 : DiscreteTopology.{u3} δ _inst_4] {f : Function.Embedding.{succ u1, succ u3} α δ} {x : δ}, (Not (Membership.Mem.{u3, u3} δ (Set.{u3} δ) (Set.hasMem.{u3} δ) x (Set.range.{u3, succ u1} δ α (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f)))) -> (forall (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2), Eq.{succ u2} β (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (fun (_x : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) => δ -> β) (BoundedContinuousFunction.hasCoeToFun.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.extend.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h) x) (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (fun (_x : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) => δ -> β) (BoundedContinuousFunction.hasCoeToFun.{u3, u2} δ β _inst_4 _inst_2) h x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] [_inst_5 : DiscreteTopology.{u1} δ _inst_4] {f : Function.Embedding.{succ u2, succ u1} α δ} {x : δ}, (Not (Membership.mem.{u1, u1} δ (Set.{u1} δ) (Set.instMembershipSet.{u1} δ) x (Set.range.{u1, succ u2} δ α (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f)))) -> (forall (g : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2), Eq.{succ u3} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ (fun (_x : δ) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2))) (BoundedContinuousFunction.extend.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ (fun (_x : δ) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : δ) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u3, u1, u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) δ β _inst_4 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2))) h x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.extend_apply' BoundedContinuousFunction.extend_apply'ₓ'. -/
theorem extend_apply' {f : α ↪ δ} {x : δ} (hx : x ∉ range f) (g : α →ᵇ β) (h : δ →ᵇ β) :
    extend f g h x = h x :=
  extend_apply' _ _ _ hx
#align bounded_continuous_function.extend_apply' BoundedContinuousFunction.extend_apply'

/- warning: bounded_continuous_function.extend_of_empty -> BoundedContinuousFunction.extend_of_empty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] [_inst_5 : DiscreteTopology.{u3} δ _inst_4] [_inst_6 : IsEmpty.{succ u1} α] (f : Function.Embedding.{succ u1, succ u3} α δ) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2), Eq.{succ (max u3 u2)} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.extend.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h) h
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] [_inst_5 : DiscreteTopology.{u1} δ _inst_4] [_inst_6 : IsEmpty.{succ u2} α] (f : Function.Embedding.{succ u2, succ u1} α δ) (g : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (h : BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2), Eq.{max (succ u3) (succ u1)} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (BoundedContinuousFunction.extend.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h) h
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.extend_of_empty BoundedContinuousFunction.extend_of_emptyₓ'. -/
theorem extend_of_empty [IsEmpty α] (f : α ↪ δ) (g : α →ᵇ β) (h : δ →ᵇ β) : extend f g h = h :=
  FunLike.coe_injective <| Function.extend_of_isEmpty f g h
#align bounded_continuous_function.extend_of_empty BoundedContinuousFunction.extend_of_empty

/- warning: bounded_continuous_function.dist_extend_extend -> BoundedContinuousFunction.dist_extend_extend is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] [_inst_5 : DiscreteTopology.{u3} δ _inst_4] (f : Function.Embedding.{succ u1, succ u3} α δ) (g₁ : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g₂ : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (h₁ : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (h₂ : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2), Eq.{1} Real (Dist.dist.{max u3 u2} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.hasDist.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.extend.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g₁ h₁) (BoundedContinuousFunction.extend.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g₂ h₂)) (LinearOrder.max.{0} Real Real.linearOrder (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 _inst_2) g₁ g₂) (Dist.dist.{max u3 u2} (BoundedContinuousFunction.{u3, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} δ) Type.{u3} (Set.hasCoeToSort.{u3} δ) (HasCompl.compl.{u3} (Set.{u3} δ) (BooleanAlgebra.toHasCompl.{u3} (Set.{u3} δ) (Set.booleanAlgebra.{u3} δ)) (Set.range.{u3, succ u1} δ α (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f)))) β (Subtype.topologicalSpace.{u3} δ (fun (x : δ) => Membership.Mem.{u3, u3} δ (Set.{u3} δ) (Set.hasMem.{u3} δ) x (HasCompl.compl.{u3} (Set.{u3} δ) (BooleanAlgebra.toHasCompl.{u3} (Set.{u3} δ) (Set.booleanAlgebra.{u3} δ)) (Set.range.{u3, succ u1} δ α (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f)))) _inst_4) _inst_2) (BoundedContinuousFunction.hasDist.{u3, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} δ) Type.{u3} (Set.hasCoeToSort.{u3} δ) (HasCompl.compl.{u3} (Set.{u3} δ) (BooleanAlgebra.toHasCompl.{u3} (Set.{u3} δ) (Set.booleanAlgebra.{u3} δ)) (Set.range.{u3, succ u1} δ α (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f)))) β (Subtype.topologicalSpace.{u3} δ (fun (x : δ) => Membership.Mem.{u3, u3} δ (Set.{u3} δ) (Set.hasMem.{u3} δ) x (HasCompl.compl.{u3} (Set.{u3} δ) (BooleanAlgebra.toHasCompl.{u3} (Set.{u3} δ) (Set.booleanAlgebra.{u3} δ)) (Set.range.{u3, succ u1} δ α (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f)))) _inst_4) _inst_2) (BoundedContinuousFunction.restrict.{u3, u2} δ β _inst_4 _inst_2 h₁ (HasCompl.compl.{u3} (Set.{u3} δ) (BooleanAlgebra.toHasCompl.{u3} (Set.{u3} δ) (Set.booleanAlgebra.{u3} δ)) (Set.range.{u3, succ u1} δ α (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f)))) (BoundedContinuousFunction.restrict.{u3, u2} δ β _inst_4 _inst_2 h₂ (HasCompl.compl.{u3} (Set.{u3} δ) (BooleanAlgebra.toHasCompl.{u3} (Set.{u3} δ) (Set.booleanAlgebra.{u3} δ)) (Set.range.{u3, succ u1} δ α (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α δ) (fun (_x : Function.Embedding.{succ u1, succ u3} α δ) => α -> δ) (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α δ) f))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] [_inst_5 : DiscreteTopology.{u1} δ _inst_4] (f : Function.Embedding.{succ u2, succ u1} α δ) (g₁ : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (g₂ : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (h₁ : BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (h₂ : BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2), Eq.{1} Real (Dist.dist.{max u1 u3} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (BoundedContinuousFunction.extend.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g₁ h₁) (BoundedContinuousFunction.extend.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g₂ h₂)) (Max.max.{0} Real (LinearOrderedRing.toMax.{0} Real Real.instLinearOrderedRingReal) (Dist.dist.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) g₁ g₂) (Dist.dist.{max u3 u1} (BoundedContinuousFunction.{u1, u3} (Set.Elem.{u1} δ (HasCompl.compl.{u1} (Set.{u1} δ) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} δ) (Set.instBooleanAlgebraSet.{u1} δ)) (Set.range.{u1, succ u2} δ α (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f)))) β (instTopologicalSpaceSubtype.{u1} δ (fun (x : δ) => Membership.mem.{u1, u1} δ (Set.{u1} δ) (Set.instMembershipSet.{u1} δ) x (HasCompl.compl.{u1} (Set.{u1} δ) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} δ) (Set.instBooleanAlgebraSet.{u1} δ)) (Set.range.{u1, succ u2} δ α (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f)))) _inst_4) _inst_2) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u3} (Set.Elem.{u1} δ (HasCompl.compl.{u1} (Set.{u1} δ) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} δ) (Set.instBooleanAlgebraSet.{u1} δ)) (Set.range.{u1, succ u2} δ α (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f)))) β (instTopologicalSpaceSubtype.{u1} δ (fun (x : δ) => Membership.mem.{u1, u1} δ (Set.{u1} δ) (Set.instMembershipSet.{u1} δ) x (HasCompl.compl.{u1} (Set.{u1} δ) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} δ) (Set.instBooleanAlgebraSet.{u1} δ)) (Set.range.{u1, succ u2} δ α (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f)))) _inst_4) _inst_2) (BoundedContinuousFunction.restrict.{u1, u3} δ β _inst_4 _inst_2 h₁ (HasCompl.compl.{u1} (Set.{u1} δ) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} δ) (Set.instBooleanAlgebraSet.{u1} δ)) (Set.range.{u1, succ u2} δ α (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f)))) (BoundedContinuousFunction.restrict.{u1, u3} δ β _inst_4 _inst_2 h₂ (HasCompl.compl.{u1} (Set.{u1} δ) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} δ) (Set.instBooleanAlgebraSet.{u1} δ)) (Set.range.{u1, succ u2} δ α (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => δ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α δ) α δ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α δ)) f))))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_extend_extend BoundedContinuousFunction.dist_extend_extendₓ'. -/
@[simp]
theorem dist_extend_extend (f : α ↪ δ) (g₁ g₂ : α →ᵇ β) (h₁ h₂ : δ →ᵇ β) :
    dist (g₁.extend f h₁) (g₂.extend f h₂) =
      max (dist g₁ g₂) (dist (h₁.restrict (range fᶜ)) (h₂.restrict (range fᶜ))) :=
  by
  refine' le_antisymm ((dist_le <| le_max_iff.2 <| Or.inl dist_nonneg).2 fun x => _) (max_le _ _)
  · rcases em (∃ y, f y = x) with (⟨x, rfl⟩ | hx)
    · simp only [extend_apply]
      exact (dist_coe_le_dist x).trans (le_max_left _ _)
    · simp only [extend_apply' hx]
      lift x to (range fᶜ : Set δ) using hx
      calc
        dist (h₁ x) (h₂ x) = dist (h₁.restrict (range fᶜ) x) (h₂.restrict (range fᶜ) x) := rfl
        _ ≤ dist (h₁.restrict (range fᶜ)) (h₂.restrict (range fᶜ)) := (dist_coe_le_dist x)
        _ ≤ _ := le_max_right _ _
        
  · refine' (dist_le dist_nonneg).2 fun x => _
    rw [← extend_apply f g₁ h₁, ← extend_apply f g₂ h₂]
    exact dist_coe_le_dist _
  · refine' (dist_le dist_nonneg).2 fun x => _
    calc
      dist (h₁ x) (h₂ x) = dist (extend f g₁ h₁ x) (extend f g₂ h₂ x) := by
        rw [extend_apply' x.coe_prop, extend_apply' x.coe_prop]
      _ ≤ _ := dist_coe_le_dist _
      
#align bounded_continuous_function.dist_extend_extend BoundedContinuousFunction.dist_extend_extend

/- warning: bounded_continuous_function.isometry_extend -> BoundedContinuousFunction.isometry_extend is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] {δ : Type.{u3}} [_inst_4 : TopologicalSpace.{u3} δ] [_inst_5 : DiscreteTopology.{u3} δ _inst_4] (f : Function.Embedding.{succ u1, succ u3} α δ) (h : BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2), Isometry.{max u1 u2, max u3 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u3 u2} (BoundedContinuousFunction.{u3, u2} δ β _inst_4 _inst_2) (BoundedContinuousFunction.pseudoMetricSpace.{u3, u2} δ β _inst_4 _inst_2)) (fun (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => BoundedContinuousFunction.extend.{u1, u2, u3} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] {δ : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} δ] [_inst_5 : DiscreteTopology.{u1} δ _inst_4] (f : Function.Embedding.{succ u2, succ u1} α δ) (h : BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2), Isometry.{max u2 u3, max u1 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (PseudoMetricSpace.toPseudoEMetricSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u3 u1} (BoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u3} δ β _inst_4 _inst_2)) (fun (g : BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) => BoundedContinuousFunction.extend.{u2, u3, u1} α β _inst_1 _inst_2 δ _inst_4 _inst_5 f g h)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.isometry_extend BoundedContinuousFunction.isometry_extendₓ'. -/
theorem isometry_extend (f : α ↪ δ) (h : δ →ᵇ β) : Isometry fun g : α →ᵇ β => extend f g h :=
  Isometry.of_dist_eq fun g₁ g₂ => by simp [dist_nonneg]
#align bounded_continuous_function.isometry_extend BoundedContinuousFunction.isometry_extend

end Extend

end Basics

section ArzelaAscoli

variable [TopologicalSpace α] [CompactSpace α] [PseudoMetricSpace β]

variable {f g : α →ᵇ β} {x : α} {C : ℝ}

/- warning: bounded_continuous_function.arzela_ascoli₁ -> BoundedContinuousFunction.arzela_ascoli₁ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : CompactSpace.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3))] (A : Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)), (IsClosed.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_3))) A) -> (Equicontinuous.{max u1 u2, u1, u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (fun (ᾰ : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) => α -> β) (coeFnTrans.{max (succ u1) (succ u2), succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_3) (coeBaseAux.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (coeSubtype.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => Membership.Mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.hasMem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) x A)))))) -> (IsCompact.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_3))) A)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : CompactSpace.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3))] (A : Set.{max u2 u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)), (IsClosed.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) A) -> (Equicontinuous.{max u1 u2, u1, u2} (Set.Elem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) A) α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3) (fun (x : Set.Elem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) A) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) (Subtype.val.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => Membership.mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.instMembershipSet.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) x A) x))) -> (IsCompact.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) A)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.arzela_ascoli₁ BoundedContinuousFunction.arzela_ascoli₁ₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y z «expr ∈ » U) -/
/- Arzela-Ascoli theorem asserts that, on a compact space, a set of functions sharing
a common modulus of continuity and taking values in a compact set forms a compact
subset for the topology of uniform convergence. In this section, we prove this theorem
and several useful variations around it. -/
/-- First version, with pointwise equicontinuity and range in a compact space -/
theorem arzela_ascoli₁ [CompactSpace β] (A : Set (α →ᵇ β)) (closed : IsClosed A)
    (H : Equicontinuous (coeFn : A → α → β)) : IsCompact A :=
  by
  simp_rw [Equicontinuous, Metric.equicontinuousAt_iff_pair] at H
  refine' isCompact_of_totallyBounded_isClosed _ closed
  refine' totally_bounded_of_finite_discretization fun ε ε0 => _
  rcases exists_between ε0 with ⟨ε₁, ε₁0, εε₁⟩
  let ε₂ := ε₁ / 2 / 2
  /- We have to find a finite discretization of `u`, i.e., finite information
    that is sufficient to reconstruct `u` up to ε. This information will be
    provided by the values of `u` on a sufficiently dense set tα,
    slightly translated to fit in a finite ε₂-dense set tβ in the image. Such
    sets exist by compactness of the source and range. Then, to check that these
    data determine the function up to ε, one uses the control on the modulus of
    continuity to extend the closeness on tα to closeness everywhere. -/
  have ε₂0 : ε₂ > 0 := half_pos (half_pos ε₁0)
  have :
    ∀ x : α,
      ∃ U,
        x ∈ U ∧
          IsOpen U ∧
            ∀ (y) (_ : y ∈ U) (z) (_ : z ∈ U) {f : α →ᵇ β}, f ∈ A → dist (f y) (f z) < ε₂ :=
    fun x =>
    let ⟨U, nhdsU, hU⟩ := H x _ ε₂0
    let ⟨V, VU, openV, xV⟩ := _root_.mem_nhds_iff.1 nhdsU
    ⟨V, xV, openV, fun y hy z hz f hf => hU y (VU hy) z (VU hz) ⟨f, hf⟩⟩
  choose U hU using this
  /- For all x, the set hU x is an open set containing x on which the elements of A
    fluctuate by at most ε₂.
    We extract finitely many of these sets that cover the whole space, by compactness -/
  rcases is_compact_univ.elim_finite_subcover_image (fun x _ => (hU x).2.1) fun x hx =>
      mem_bUnion (mem_univ _) (hU x).1 with
    ⟨tα, _, ⟨_⟩, htα⟩
  -- tα : set α, htα : univ ⊆ ⋃x ∈ tα, U x
  rcases@finite_cover_balls_of_compact β _ _ isCompact_univ _ ε₂0 with ⟨tβ, _, ⟨_⟩, htβ⟩
  skip
  -- tβ : set β, htβ : univ ⊆ ⋃y ∈ tβ, ball y ε₂ 
  -- Associate to every point `y` in the space a nearby point `F y` in tβ
  choose F hF using fun y => show ∃ z ∈ tβ, dist y z < ε₂ by simpa using htβ (mem_univ y)
  -- F : β → β, hF : ∀ (y : β), F y ∈ tβ ∧ dist y (F y) < ε₂ 
  /- Associate to every function a discrete approximation, mapping each point in `tα`
    to a point in `tβ` close to its true image by the function. -/
  refine' ⟨tα → tβ, by infer_instance, fun f a => ⟨F (f a), (hF (f a)).1⟩, _⟩
  rintro ⟨f, hf⟩ ⟨g, hg⟩ f_eq_g
  -- If two functions have the same approximation, then they are within distance ε
  refine' lt_of_le_of_lt ((dist_le <| le_of_lt ε₁0).2 fun x => _) εε₁
  obtain ⟨x', x'tα, hx'⟩ : ∃ x' ∈ tα, x ∈ U x' := mem_Union₂.1 (htα (mem_univ x))
  calc
    dist (f x) (g x) ≤ dist (f x) (f x') + dist (g x) (g x') + dist (f x') (g x') :=
      dist_triangle4_right _ _ _ _
    _ ≤ ε₂ + ε₂ + ε₁ / 2 := (le_of_lt (add_lt_add (add_lt_add _ _) _))
    _ = ε₁ := by rw [add_halves, add_halves]
    
  · exact (hU x').2.2 _ hx' _ (hU x').1 hf
  · exact (hU x').2.2 _ hx' _ (hU x').1 hg
  · have F_f_g : F (f x') = F (g x') :=
      (congr_arg (fun f : tα → tβ => (f ⟨x', x'tα⟩ : β)) f_eq_g : _)
    calc
      dist (f x') (g x') ≤ dist (f x') (F (f x')) + dist (g x') (F (f x')) :=
        dist_triangle_right _ _ _
      _ = dist (f x') (F (f x')) + dist (g x') (F (g x')) := by rw [F_f_g]
      _ < ε₂ + ε₂ := (add_lt_add (hF (f x')).2 (hF (g x')).2)
      _ = ε₁ / 2 := add_halves _
      
#align bounded_continuous_function.arzela_ascoli₁ BoundedContinuousFunction.arzela_ascoli₁

/- warning: bounded_continuous_function.arzela_ascoli₂ -> BoundedContinuousFunction.arzela_ascoli₂ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : PseudoMetricSpace.{u2} β] (s : Set.{u2} β), (IsCompact.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) s) -> (forall (A : Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)), (IsClosed.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_3))) A) -> (forall (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (x : α), (Membership.Mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.hasMem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) f A) -> (Membership.Mem.{u2, u2} β (Set.{u2} β) (Set.hasMem.{u2} β) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_3) f x) s)) -> (Equicontinuous.{max u1 u2, u1, u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (fun (ᾰ : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) => α -> β) (coeFnTrans.{max (succ u1) (succ u2), succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_3) (coeBaseAux.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (coeSubtype.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => Membership.Mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.hasMem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) x A)))))) -> (IsCompact.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_3))) A))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : PseudoMetricSpace.{u2} β] (s : Set.{u2} β), (IsCompact.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) s) -> (forall (A : Set.{max u2 u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)), (IsClosed.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) A) -> (forall (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (x : α), (Membership.mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u2 u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.instMembershipSet.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) f A) -> (Membership.mem.{u2, u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (Set.{u2} β) (Set.instMembershipSet.{u2} β) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) f x) s)) -> (Equicontinuous.{max u1 u2, u1, u2} (Set.Elem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) A) α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3) (fun (x : Set.Elem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) A) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) (Subtype.val.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => Membership.mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.instMembershipSet.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) x A) x))) -> (IsCompact.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) A))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.arzela_ascoli₂ BoundedContinuousFunction.arzela_ascoli₂ₓ'. -/
/-- Second version, with pointwise equicontinuity and range in a compact subset -/
theorem arzela_ascoli₂ (s : Set β) (hs : IsCompact s) (A : Set (α →ᵇ β)) (closed : IsClosed A)
    (in_s : ∀ (f : α →ᵇ β) (x : α), f ∈ A → f x ∈ s) (H : Equicontinuous (coeFn : A → α → β)) :
    IsCompact A :=
  by
  /- This version is deduced from the previous one by restricting to the compact type in the target,
  using compactness there and then lifting everything to the original space. -/
  have M : LipschitzWith 1 coe := LipschitzWith.subtype_val s
  let F : (α →ᵇ s) → α →ᵇ β := comp coe M
  refine'
    isCompact_of_isClosed_subset ((_ : IsCompact (F ⁻¹' A)).image (continuous_comp M)) closed
      fun f hf => _
  · haveI : CompactSpace s := isCompact_iff_compactSpace.1 hs
    refine' arzela_ascoli₁ _ (continuous_iff_isClosed.1 (continuous_comp M) _ closed) _
    rw [uniform_embedding_subtype_coe.to_uniform_inducing.equicontinuous_iff]
    exact H.comp (A.restrict_preimage F)
  · let g := cod_restrict s f fun x => in_s f x hf
    rw [show f = F g by ext <;> rfl] at hf⊢
    exact ⟨g, hf, rfl⟩
#align bounded_continuous_function.arzela_ascoli₂ BoundedContinuousFunction.arzela_ascoli₂

/- warning: bounded_continuous_function.arzela_ascoli -> BoundedContinuousFunction.arzela_ascoli is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : T2Space.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3))] (s : Set.{u2} β), (IsCompact.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) s) -> (forall (A : Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)), (forall (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (x : α), (Membership.Mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.hasMem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) f A) -> (Membership.Mem.{u2, u2} β (Set.{u2} β) (Set.hasMem.{u2} β) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_3) f x) s)) -> (Equicontinuous.{max u1 u2, u1, u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (fun (ᾰ : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) => α -> β) (coeFnTrans.{max (succ u1) (succ u2), succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_3) (coeBaseAux.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) A) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (coeSubtype.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => Membership.Mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.hasMem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) x A)))))) -> (IsCompact.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_3))) (closure.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 _inst_3))) A)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : T2Space.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3))] (s : Set.{u2} β), (IsCompact.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) s) -> (forall (A : Set.{max u2 u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)), (forall (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (x : α), (Membership.mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u2 u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.instMembershipSet.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) f A) -> (Membership.mem.{u2, u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (Set.{u2} β) (Set.instMembershipSet.{u2} β) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) f x) s)) -> (Equicontinuous.{max u1 u2, u1, u2} (Set.Elem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) A) α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3) (fun (x : Set.Elem.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) A) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) α β _inst_1 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) (Subtype.val.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (fun (x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) => Membership.mem.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (Set.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) (Set.instMembershipSet.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3)) x A) x))) -> (IsCompact.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) (closure.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_3))) A)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.arzela_ascoli BoundedContinuousFunction.arzela_ascoliₓ'. -/
/-- Third (main) version, with pointwise equicontinuity and range in a compact subset, but
without closedness. The closure is then compact -/
theorem arzela_ascoli [T2Space β] (s : Set β) (hs : IsCompact s) (A : Set (α →ᵇ β))
    (in_s : ∀ (f : α →ᵇ β) (x : α), f ∈ A → f x ∈ s) (H : Equicontinuous (coeFn : A → α → β)) :
    IsCompact (closure A) :=
  /- This version is deduced from the previous one by checking that the closure of A, in
    addition to being closed, still satisfies the properties of compact range and equicontinuity -/
    arzela_ascoli₂
    s hs (closure A) isClosed_closure
    (fun f x hf =>
      (mem_of_closed' hs.IsClosed).2 fun ε ε0 =>
        let ⟨g, gA, dist_fg⟩ := Metric.mem_closure_iff.1 hf ε ε0
        ⟨g x, in_s g x gA, lt_of_le_of_lt (dist_coe_le_dist _) dist_fg⟩)
    (H.closure' continuous_coe)
#align bounded_continuous_function.arzela_ascoli BoundedContinuousFunction.arzela_ascoli

end ArzelaAscoli

section One

variable [TopologicalSpace α] [PseudoMetricSpace β] [One β]

@[to_additive]
instance : One (α →ᵇ β) :=
  ⟨const α 1⟩

/- warning: bounded_continuous_function.coe_one -> BoundedContinuousFunction.coe_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : One.{u2} β], Eq.{max (succ u1) (succ u2)} ((fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (OfNat.mk.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (One.one.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasOne.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (OfNat.mk.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (One.one.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasOne.{u1, u2} α β _inst_1 _inst_2 _inst_3))))) (OfNat.ofNat.{max u1 u2} ((fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (One.one.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasOne.{u1, u2} α β _inst_1 _inst_2 _inst_3))) 1 (OfNat.mk.{max u1 u2} ((fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (One.one.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasOne.{u1, u2} α β _inst_1 _inst_2 _inst_3))) 1 (One.one.{max u1 u2} ((fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (One.one.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasOne.{u1, u2} α β _inst_1 _inst_2 _inst_3))) (Pi.instOne.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_3)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : One.{u2} β], Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (One.toOfNat1.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instOneBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 _inst_3)))) (OfNat.ofNat.{max u1 u2} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) 1 (One.toOfNat1.{max u1 u2} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (Pi.instOne.{u1, u2} α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (fun (i : α) => _inst_3))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_one BoundedContinuousFunction.coe_oneₓ'. -/
@[simp, to_additive]
theorem coe_one : ((1 : α →ᵇ β) : α → β) = 1 :=
  rfl
#align bounded_continuous_function.coe_one BoundedContinuousFunction.coe_one
#align bounded_continuous_function.coe_zero BoundedContinuousFunction.coe_zero

#print BoundedContinuousFunction.mkOfCompact_one /-
@[simp, to_additive]
theorem mkOfCompact_one [CompactSpace α] : mkOfCompact (1 : C(α, β)) = 1 :=
  rfl
#align bounded_continuous_function.mk_of_compact_one BoundedContinuousFunction.mkOfCompact_one
#align bounded_continuous_function.mk_of_compact_zero BoundedContinuousFunction.mkOfCompact_zero
-/

/- warning: bounded_continuous_function.forall_coe_one_iff_one -> BoundedContinuousFunction.forall_coe_one_iff_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : One.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Iff (forall (x : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (Eq.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (OfNat.mk.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (One.one.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasOne.{u1, u2} α β _inst_1 _inst_2 _inst_3)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : One.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Iff (forall (x : α), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (OfNat.ofNat.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) 1 (One.toOfNat1.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_3))) (Eq.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) f (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) 1 (One.toOfNat1.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instOneBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 _inst_3))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.forall_coe_one_iff_one BoundedContinuousFunction.forall_coe_one_iff_oneₓ'. -/
@[to_additive]
theorem forall_coe_one_iff_one (f : α →ᵇ β) : (∀ x, f x = 1) ↔ f = 1 :=
  (@FunLike.ext_iff _ _ _ _ f 1).symm
#align bounded_continuous_function.forall_coe_one_iff_one BoundedContinuousFunction.forall_coe_one_iff_one
#align bounded_continuous_function.forall_coe_zero_iff_zero BoundedContinuousFunction.forall_coe_zero_iff_zero

#print BoundedContinuousFunction.one_compContinuous /-
@[simp, to_additive]
theorem one_compContinuous [TopologicalSpace γ] (f : C(γ, α)) :
    (1 : α →ᵇ β).comp_continuous f = 1 :=
  rfl
#align bounded_continuous_function.one_comp_continuous BoundedContinuousFunction.one_compContinuous
#align bounded_continuous_function.zero_comp_continuous BoundedContinuousFunction.zero_compContinuous
-/

end One

section LipschitzAdd

/- In this section, if `β` is an `add_monoid` whose addition operation is Lipschitz, then we show
that the space of bounded continuous functions from `α` to `β` inherits a topological `add_monoid`
structure, by using pointwise operations and checking that they are compatible with the uniform
distance.

Implementation note: The material in this section could have been written for `has_lipschitz_mul`
and transported by `@[to_additive]`.  We choose not to do this because this causes a few lemma
names (for example, `coe_mul`) to conflict with later lemma names for normed rings; this is only a
trivial inconvenience, but in any case there are no obvious applications of the multiplicative
version. -/
variable [TopologicalSpace α] [PseudoMetricSpace β] [AddMonoid β]

variable [LipschitzAdd β]

variable (f g : α →ᵇ β) {x : α} {C : ℝ}

/-- The pointwise sum of two bounded continuous functions is again bounded continuous. -/
instance : Add (α →ᵇ β)
    where add f g :=
    BoundedContinuousFunction.mkOfBound (f.toContinuousMap + g.toContinuousMap)
      (↑(LipschitzAdd.C β) * max (Classical.choose f.Bounded) (Classical.choose g.Bounded))
      (by
        intro x y
        refine' le_trans (lipschitz_with_lipschitz_const_add ⟨f x, g x⟩ ⟨f y, g y⟩) _
        rw [Prod.dist_eq]
        refine' mul_le_mul_of_nonneg_left _ (LipschitzAdd.C β).coe_nonneg
        apply max_le_max
        exact Classical.choose_spec f.bounded x y
        exact Classical.choose_spec g.bounded x y)

/- warning: bounded_continuous_function.coe_add -> BoundedContinuousFunction.coe_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasAdd.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHAdd.{max u1 u2} (α -> β) (Pi.instAdd.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β _inst_3)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (instHAdd.{max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (Pi.instAdd.{u1, u2} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => AddZeroClass.toAdd.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_add BoundedContinuousFunction.coe_addₓ'. -/
@[simp]
theorem coe_add : ⇑(f + g) = f + g :=
  rfl
#align bounded_continuous_function.coe_add BoundedContinuousFunction.coe_add

/- warning: bounded_continuous_function.add_apply -> BoundedContinuousFunction.add_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) {x : α}, Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasAdd.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f g) x) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β _inst_3))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) {x : α}, Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f g) x) (HAdd.hAdd.{u2, u2, u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (instHAdd.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (AddZeroClass.toAdd.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (AddMonoid.toAddZeroClass.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_3))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) g x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.add_apply BoundedContinuousFunction.add_applyₓ'. -/
theorem add_apply : (f + g) x = f x + g x :=
  rfl
#align bounded_continuous_function.add_apply BoundedContinuousFunction.add_apply

/- warning: bounded_continuous_function.mk_of_compact_add -> BoundedContinuousFunction.mkOfCompact_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] [_inst_5 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))), Eq.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (instHAdd.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (ContinuousMap.instAdd.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β _inst_3)) (LipschitzAdd.continuousAdd.{u2} β _inst_2 _inst_3 _inst_4))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasAdd.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_5 f) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_5 g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] [_inst_5 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))), Eq.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (instHAdd.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (ContinuousMap.instAdd.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β _inst_3)) (LipschitzAdd.continuousAdd.{u2} β _inst_2 _inst_3 _inst_4))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_5 f) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_5 g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_compact_add BoundedContinuousFunction.mkOfCompact_addₓ'. -/
@[simp]
theorem mkOfCompact_add [CompactSpace α] (f g : C(α, β)) :
    mkOfCompact (f + g) = mkOfCompact f + mkOfCompact g :=
  rfl
#align bounded_continuous_function.mk_of_compact_add BoundedContinuousFunction.mkOfCompact_add

/- warning: bounded_continuous_function.add_comp_continuous -> BoundedContinuousFunction.add_compContinuous is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) [_inst_5 : TopologicalSpace.{u3} γ] (h : ContinuousMap.{u3, u1} γ α _inst_5 _inst_1), Eq.{succ (max u3 u2)} (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 γ _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasAdd.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) g f) h) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (instHAdd.{max u3 u2} (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.hasAdd.{u3, u2} γ β _inst_5 _inst_2 _inst_3 _inst_4)) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 γ _inst_5 g h) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 γ _inst_5 f h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) [_inst_5 : TopologicalSpace.{u3} γ] (h : ContinuousMap.{u3, u1} γ α _inst_5 _inst_1), Eq.{max (succ u2) (succ u3)} (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 γ _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHAdd.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) g f) h) (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (instHAdd.{max u2 u3} (BoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u3, u2} γ β _inst_5 _inst_2 _inst_3 _inst_4)) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 γ _inst_5 g h) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 _inst_2 γ _inst_5 f h))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.add_comp_continuous BoundedContinuousFunction.add_compContinuousₓ'. -/
theorem add_compContinuous [TopologicalSpace γ] (h : C(γ, α)) :
    (g + f).comp_continuous h = g.comp_continuous h + f.comp_continuous h :=
  rfl
#align bounded_continuous_function.add_comp_continuous BoundedContinuousFunction.add_compContinuous

/- warning: bounded_continuous_function.coe_nsmul_rec -> BoundedContinuousFunction.coe_nsmulRec is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (n : Nat), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (nsmulRec.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasZero.{u1, u2} α β _inst_1 _inst_2 (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β _inst_3))) (BoundedContinuousFunction.hasAdd.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) n f)) (SMul.smul.{0, max u1 u2} Nat (α -> β) (Function.hasSMul.{u1, 0, u2} α Nat β (AddMonoid.SMul.{u2} β _inst_3)) n (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (n : Nat), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (nsmulRec.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.instZeroBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 (AddMonoid.toZero.{u2} β _inst_3)) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) n f)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Nat (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (instHSMul.{0, max u1 u2} Nat (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (AddMonoid.SMul.{max u1 u2} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (Pi.addMonoid.{u1, u2} α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (fun (i : α) => _inst_3)))) n (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_nsmul_rec BoundedContinuousFunction.coe_nsmulRecₓ'. -/
@[simp]
theorem coe_nsmulRec : ∀ n, ⇑(nsmulRec n f) = n • f
  | 0 => by rw [nsmulRec, zero_smul, coe_zero]
  | n + 1 => by rw [nsmulRec, succ_nsmul, coe_add, coe_nsmul_rec]
#align bounded_continuous_function.coe_nsmul_rec BoundedContinuousFunction.coe_nsmulRec

#print BoundedContinuousFunction.hasNatScalar /-
instance hasNatScalar : SMul ℕ (α →ᵇ β)
    where smul n f :=
    { toContinuousMap := n • f.toContinuousMap
      map_bounded' := by simpa [coe_nsmul_rec] using (nsmulRec n f).map_bounded' }
#align bounded_continuous_function.has_nat_scalar BoundedContinuousFunction.hasNatScalar
-/

/- warning: bounded_continuous_function.coe_nsmul -> BoundedContinuousFunction.coe_nsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (r : Nat) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (SMul.smul.{0, max u1 u2} Nat (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasNatScalar.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) r f)) (SMul.smul.{0, max u1 u2} Nat (α -> β) (Function.hasSMul.{u1, 0, u2} α Nat β (AddMonoid.SMul.{u2} β _inst_3)) r (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (r : Nat) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Nat (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHSMul.{0, max u1 u2} Nat (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasNatScalar.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) r f)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Nat (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (instHSMul.{0, max u1 u2} Nat (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (AddMonoid.SMul.{max u1 u2} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (Pi.addMonoid.{u1, u2} α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (fun (i : α) => _inst_3)))) r (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_nsmul BoundedContinuousFunction.coe_nsmulₓ'. -/
@[simp]
theorem coe_nsmul (r : ℕ) (f : α →ᵇ β) : ⇑(r • f) = r • f :=
  rfl
#align bounded_continuous_function.coe_nsmul BoundedContinuousFunction.coe_nsmul

/- warning: bounded_continuous_function.nsmul_apply -> BoundedContinuousFunction.nsmul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (r : Nat) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (v : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (SMul.smul.{0, max u1 u2} Nat (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasNatScalar.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) r f) v) (SMul.smul.{0, u2} Nat β (AddMonoid.SMul.{u2} β _inst_3) r (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f v))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3] (r : Nat) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (v : α), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Nat (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (instHSMul.{0, max u1 u2} Nat (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.hasNatScalar.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) r f) v) (HSMul.hSMul.{0, u2, u2} Nat ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (instHSMul.{0, u2} Nat ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (AddMonoid.SMul.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) _inst_3)) r (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2))) f v))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nsmul_apply BoundedContinuousFunction.nsmul_applyₓ'. -/
@[simp]
theorem nsmul_apply (r : ℕ) (f : α →ᵇ β) (v : α) : (r • f) v = r • f v :=
  rfl
#align bounded_continuous_function.nsmul_apply BoundedContinuousFunction.nsmul_apply

instance : AddMonoid (α →ᵇ β) :=
  FunLike.coe_injective.AddMonoid _ coe_zero coe_add fun _ _ => coe_nsmul _ _

instance : LipschitzAdd (α →ᵇ β)
    where lipschitz_add :=
    ⟨LipschitzAdd.C β, by
      have C_nonneg := (LipschitzAdd.C β).coe_nonneg
      rw [lipschitzWith_iff_dist_le_mul]
      rintro ⟨f₁, g₁⟩ ⟨f₂, g₂⟩
      rw [dist_le (mul_nonneg C_nonneg dist_nonneg)]
      intro x
      refine' le_trans (lipschitz_with_lipschitz_const_add ⟨f₁ x, g₁ x⟩ ⟨f₂ x, g₂ x⟩) _
      refine' mul_le_mul_of_nonneg_left _ C_nonneg
      apply max_le_max <;> exact dist_coe_le_dist x⟩

#print BoundedContinuousFunction.coeFnAddHom /-
/-- Coercion of a `normed_add_group_hom` is an `add_monoid_hom`. Similar to
`add_monoid_hom.coe_fn`. -/
@[simps]
def coeFnAddHom : (α →ᵇ β) →+ α → β where
  toFun := coeFn
  map_zero' := coe_zero
  map_add' := coe_add
#align bounded_continuous_function.coe_fn_add_hom BoundedContinuousFunction.coeFnAddHom
-/

variable (α β)

/- warning: bounded_continuous_function.to_continuous_map_add_hom -> BoundedContinuousFunction.toContinuousMapAddHom is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3], AddMonoidHom.{max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (AddMonoid.toAddZeroClass.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.addMonoid.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) (ContinuousMap.addZeroClass.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (AddMonoid.toAddZeroClass.{u2} β _inst_3) (LipschitzAdd.continuousAdd.{u2} β _inst_2 _inst_3 _inst_4))
but is expected to have type
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 _inst_3], AddMonoidHom.{max u2 u1, max u2 u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2))) (AddMonoid.toAddZeroClass.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.addMonoid.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) (ContinuousMap.instAddZeroClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_2)) (AddMonoid.toAddZeroClass.{u2} β _inst_3) (LipschitzAdd.continuousAdd.{u2} β _inst_2 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.to_continuous_map_add_hom BoundedContinuousFunction.toContinuousMapAddHomₓ'. -/
/-- The additive map forgetting that a bounded continuous function is bounded.
-/
@[simps]
def toContinuousMapAddHom : (α →ᵇ β) →+ C(α, β)
    where
  toFun := toContinuousMap
  map_zero' := by
    ext
    simp
  map_add' := by
    intros
    ext
    simp
#align bounded_continuous_function.to_continuous_map_add_hom BoundedContinuousFunction.toContinuousMapAddHom

end LipschitzAdd

section CommHasLipschitzAdd

variable [TopologicalSpace α] [PseudoMetricSpace β] [AddCommMonoid β] [LipschitzAdd β]

@[to_additive]
instance : AddCommMonoid (α →ᵇ β) :=
  { BoundedContinuousFunction.addMonoid with add_comm := fun f g => by ext <;> simp [add_comm] }

open BigOperators

/- warning: bounded_continuous_function.coe_sum -> BoundedContinuousFunction.coe_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddCommMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 (AddCommMonoid.toAddMonoid.{u2} β _inst_3)] {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (Finset.sum.{max u1 u2, u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) ι (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) s (fun (i : ι) => f i))) (Finset.sum.{max u1 u2, u3} (α -> β) ι (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_3)) s (fun (i : ι) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (f i)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] [_inst_3 : AddCommMonoid.{u3} β] [_inst_4 : LipschitzAdd.{u3} β _inst_2 (AddCommMonoid.toAddMonoid.{u3} β _inst_3)] {ι : Type.{u1}} (s : Finset.{u1} ι) (f : ι -> (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2)), Eq.{max (succ u2) (succ u3)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) (Finset.sum.{max u2 u3, u1} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) ι (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) s (fun (i : ι) => f i))) (Finset.sum.{max u2 u3, u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) ι (Pi.addCommMonoid.{u2, u3} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => _inst_3)) s (fun (i : ι) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) (f i)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_sum BoundedContinuousFunction.coe_sumₓ'. -/
@[simp]
theorem coe_sum {ι : Type _} (s : Finset ι) (f : ι → α →ᵇ β) :
    ⇑(∑ i in s, f i) = ∑ i in s, (f i : α → β) :=
  (@coeFnAddHom α β _ _ _ _).map_sum f s
#align bounded_continuous_function.coe_sum BoundedContinuousFunction.coe_sum

/- warning: bounded_continuous_function.sum_apply -> BoundedContinuousFunction.sum_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : PseudoMetricSpace.{u2} β] [_inst_3 : AddCommMonoid.{u2} β] [_inst_4 : LipschitzAdd.{u2} β _inst_2 (AddCommMonoid.toAddMonoid.{u2} β _inst_3)] {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2)) (a : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (Finset.sum.{max u1 u2, u3} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) ι (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) s (fun (i : ι) => f i)) a) (Finset.sum.{u2, u3} β ι _inst_3 s (fun (i : ι) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (f i) a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : PseudoMetricSpace.{u3} β] [_inst_3 : AddCommMonoid.{u3} β] [_inst_4 : LipschitzAdd.{u3} β _inst_2 (AddCommMonoid.toAddMonoid.{u3} β _inst_3)] {ι : Type.{u1}} (s : Finset.{u1} ι) (f : ι -> (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2)) (a : α), Eq.{succ u3} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) (Finset.sum.{max u2 u3, u1} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) ι (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) s (fun (i : ι) => f i)) a) (Finset.sum.{u3, u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) ι _inst_3 s (fun (i : ι) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_2)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 _inst_2))) (f i) a))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.sum_apply BoundedContinuousFunction.sum_applyₓ'. -/
theorem sum_apply {ι : Type _} (s : Finset ι) (f : ι → α →ᵇ β) (a : α) :
    (∑ i in s, f i) a = ∑ i in s, f i a := by simp
#align bounded_continuous_function.sum_apply BoundedContinuousFunction.sum_apply

end CommHasLipschitzAdd

section NormedAddCommGroup

/- In this section, if β is a normed group, then we show that the space of bounded
continuous functions from α to β inherits a normed group structure, by using
pointwise operations and checking that they are compatible with the uniform distance. -/
variable [TopologicalSpace α] [SeminormedAddCommGroup β]

variable (f g : α →ᵇ β) {x : α} {C : ℝ}

instance : Norm (α →ᵇ β) :=
  ⟨fun u => dist u 0⟩

/- warning: bounded_continuous_function.norm_def -> BoundedContinuousFunction.norm_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) 0 (OfNat.mk.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) 0 (Zero.zero.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasZero.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) 0 (Zero.toOfNat0.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instZeroBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (NegZeroClass.toZero.{u2} β (SubNegZeroMonoid.toNegZeroClass.{u2} β (SubtractionMonoid.toSubNegZeroMonoid.{u2} β (SubtractionCommMonoid.toSubtractionMonoid.{u2} β (AddCommGroup.toDivisionAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))))))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_def BoundedContinuousFunction.norm_defₓ'. -/
theorem norm_def : ‖f‖ = dist f 0 :=
  rfl
#align bounded_continuous_function.norm_def BoundedContinuousFunction.norm_def

/- warning: bounded_continuous_function.norm_eq -> BoundedContinuousFunction.norm_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) (InfSet.sInf.{0} Real Real.hasInf (setOf.{0} Real (fun (C : Real) => And (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) C))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) (InfSet.sInf.{0} Real Real.instInfSetReal (setOf.{0} Real (fun (C : Real) => And (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) C))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_eq BoundedContinuousFunction.norm_eqₓ'. -/
/-- The norm of a bounded continuous function is the supremum of `‖f x‖`.
We use `Inf` to ensure that the definition works if `α` has no elements. -/
theorem norm_eq (f : α →ᵇ β) : ‖f‖ = sInf { C : ℝ | 0 ≤ C ∧ ∀ x : α, ‖f x‖ ≤ C } := by
  simp [norm_def, BoundedContinuousFunction.dist_eq]
#align bounded_continuous_function.norm_eq BoundedContinuousFunction.norm_eq

/- warning: bounded_continuous_function.norm_eq_of_nonempty -> BoundedContinuousFunction.norm_eq_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) [h : Nonempty.{succ u1} α], Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) (InfSet.sInf.{0} Real Real.hasInf (setOf.{0} Real (fun (C : Real) => forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) C)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) [h : Nonempty.{succ u1} α], Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) (InfSet.sInf.{0} Real Real.instInfSetReal (setOf.{0} Real (fun (C : Real) => forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) C)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_eq_of_nonempty BoundedContinuousFunction.norm_eq_of_nonemptyₓ'. -/
/-- When the domain is non-empty, we do not need the `0 ≤ C` condition in the formula for ‖f‖ as an
`Inf`. -/
theorem norm_eq_of_nonempty [h : Nonempty α] : ‖f‖ = sInf { C : ℝ | ∀ x : α, ‖f x‖ ≤ C } :=
  by
  obtain ⟨a⟩ := h
  rw [norm_eq]
  congr
  ext
  simp only [and_iff_right_iff_imp]
  exact fun h' => le_trans (norm_nonneg (f a)) (h' a)
#align bounded_continuous_function.norm_eq_of_nonempty BoundedContinuousFunction.norm_eq_of_nonempty

/- warning: bounded_continuous_function.norm_eq_zero_of_empty -> BoundedContinuousFunction.norm_eq_zero_of_empty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) [h : IsEmpty.{succ u1} α], Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) [h : IsEmpty.{succ u1} α], Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_eq_zero_of_empty BoundedContinuousFunction.norm_eq_zero_of_emptyₓ'. -/
@[simp]
theorem norm_eq_zero_of_empty [h : IsEmpty α] : ‖f‖ = 0 :=
  dist_zero_of_empty
#align bounded_continuous_function.norm_eq_zero_of_empty BoundedContinuousFunction.norm_eq_zero_of_empty

/- warning: bounded_continuous_function.norm_coe_le_norm -> BoundedContinuousFunction.norm_coe_le_norm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_coe_le_norm BoundedContinuousFunction.norm_coe_le_normₓ'. -/
theorem norm_coe_le_norm (x : α) : ‖f x‖ ≤ ‖f‖ :=
  calc
    ‖f x‖ = dist (f x) ((0 : α →ᵇ β) x) := by simp [dist_zero_right]
    _ ≤ ‖f‖ := dist_coe_le_dist _
    
#align bounded_continuous_function.norm_coe_le_norm BoundedContinuousFunction.norm_coe_le_norm

/- warning: bounded_continuous_function.dist_le_two_norm' -> BoundedContinuousFunction.dist_le_two_norm' is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} {γ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} β] {f : γ -> β} {C : Real}, (forall (x : γ), LE.le.{0} Real Real.hasLe (Norm.norm.{u1} β (SeminormedAddCommGroup.toHasNorm.{u1} β _inst_2) (f x)) C) -> (forall (x : γ) (y : γ), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} β (PseudoMetricSpace.toHasDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (f x) (f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) C))
but is expected to have type
  forall {β : Type.{u1}} {γ : Type.{u2}} [_inst_2 : SeminormedAddCommGroup.{u1} β] {f : γ -> β} {C : Real}, (forall (x : γ), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} β (SeminormedAddCommGroup.toNorm.{u1} β _inst_2) (f x)) C) -> (forall (x : γ) (y : γ), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} β (PseudoMetricSpace.toDist.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β _inst_2)) (f x) (f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) C))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_le_two_norm' BoundedContinuousFunction.dist_le_two_norm'ₓ'. -/
theorem dist_le_two_norm' {f : γ → β} {C : ℝ} (hC : ∀ x, ‖f x‖ ≤ C) (x y : γ) :
    dist (f x) (f y) ≤ 2 * C :=
  calc
    dist (f x) (f y) ≤ ‖f x‖ + ‖f y‖ := dist_le_norm_add_norm _ _
    _ ≤ C + C := (add_le_add (hC x) (hC y))
    _ = 2 * C := (two_mul _).symm
    
#align bounded_continuous_function.dist_le_two_norm' BoundedContinuousFunction.dist_le_two_norm'

/- warning: bounded_continuous_function.dist_le_two_norm -> BoundedContinuousFunction.dist_le_two_norm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α) (y : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α) (y : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_le_two_norm BoundedContinuousFunction.dist_le_two_normₓ'. -/
/-- Distance between the images of any two points is at most twice the norm of the function. -/
theorem dist_le_two_norm (x y : α) : dist (f x) (f y) ≤ 2 * ‖f‖ :=
  dist_le_two_norm' f.norm_coe_le_norm x y
#align bounded_continuous_function.dist_le_two_norm BoundedContinuousFunction.dist_le_two_norm

variable {f}

/- warning: bounded_continuous_function.norm_le -> BoundedContinuousFunction.norm_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) C))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) C))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_le BoundedContinuousFunction.norm_leₓ'. -/
/-- The norm of a function is controlled by the supremum of the pointwise norms -/
theorem norm_le (C0 : (0 : ℝ) ≤ C) : ‖f‖ ≤ C ↔ ∀ x : α, ‖f x‖ ≤ C := by
  simpa using @dist_le _ _ _ _ f 0 _ C0
#align bounded_continuous_function.norm_le BoundedContinuousFunction.norm_le

/- warning: bounded_continuous_function.norm_le_of_nonempty -> BoundedContinuousFunction.norm_le_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : Nonempty.{succ u1} α] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {M : Real}, Iff (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) M) (forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) M)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : Nonempty.{succ u1} α] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {M : Real}, Iff (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) M) (forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) M)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_le_of_nonempty BoundedContinuousFunction.norm_le_of_nonemptyₓ'. -/
theorem norm_le_of_nonempty [Nonempty α] {f : α →ᵇ β} {M : ℝ} : ‖f‖ ≤ M ↔ ∀ x, ‖f x‖ ≤ M :=
  by
  simp_rw [norm_def, ← dist_zero_right]
  exact dist_le_iff_of_nonempty
#align bounded_continuous_function.norm_le_of_nonempty BoundedContinuousFunction.norm_le_of_nonempty

/- warning: bounded_continuous_function.norm_lt_iff_of_compact -> BoundedContinuousFunction.norm_lt_iff_of_compact is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : CompactSpace.{u1} α _inst_1] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {M : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) M) -> (Iff (LT.lt.{0} Real Real.hasLt (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) M) (forall (x : α), LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) M))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : CompactSpace.{u1} α _inst_1] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {M : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) M) -> (Iff (LT.lt.{0} Real Real.instLTReal (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) M) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) M))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_lt_iff_of_compact BoundedContinuousFunction.norm_lt_iff_of_compactₓ'. -/
theorem norm_lt_iff_of_compact [CompactSpace α] {f : α →ᵇ β} {M : ℝ} (M0 : 0 < M) :
    ‖f‖ < M ↔ ∀ x, ‖f x‖ < M :=
  by
  simp_rw [norm_def, ← dist_zero_right]
  exact dist_lt_iff_of_compact M0
#align bounded_continuous_function.norm_lt_iff_of_compact BoundedContinuousFunction.norm_lt_iff_of_compact

/- warning: bounded_continuous_function.norm_lt_iff_of_nonempty_compact -> BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : Nonempty.{succ u1} α] [_inst_4 : CompactSpace.{u1} α _inst_1] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {M : Real}, Iff (LT.lt.{0} Real Real.hasLt (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) M) (forall (x : α), LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) M)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : Nonempty.{succ u1} α] [_inst_4 : CompactSpace.{u1} α _inst_1] {f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)} {M : Real}, Iff (LT.lt.{0} Real Real.instLTReal (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) M) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) M)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_lt_iff_of_nonempty_compact BoundedContinuousFunction.norm_lt_iff_of_nonempty_compactₓ'. -/
theorem norm_lt_iff_of_nonempty_compact [Nonempty α] [CompactSpace α] {f : α →ᵇ β} {M : ℝ} :
    ‖f‖ < M ↔ ∀ x, ‖f x‖ < M :=
  by
  simp_rw [norm_def, ← dist_zero_right]
  exact dist_lt_iff_of_nonempty_compact
#align bounded_continuous_function.norm_lt_iff_of_nonempty_compact BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact

variable (f)

/- warning: bounded_continuous_function.norm_const_le -> BoundedContinuousFunction.norm_const_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (b : β), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) b)) (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) b)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (b : β), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) b)) (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_2) b)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_const_le BoundedContinuousFunction.norm_const_leₓ'. -/
/-- Norm of `const α b` is less than or equal to `‖b‖`. If `α` is nonempty,
then it is equal to `‖b‖`. -/
theorem norm_const_le (b : β) : ‖const α b‖ ≤ ‖b‖ :=
  (norm_le (norm_nonneg b)).2 fun x => le_rfl
#align bounded_continuous_function.norm_const_le BoundedContinuousFunction.norm_const_le

/- warning: bounded_continuous_function.norm_const_eq -> BoundedContinuousFunction.norm_const_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [h : Nonempty.{succ u1} α] (b : β), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) b)) (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) b)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [h : Nonempty.{succ u1} α] (b : β), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) b)) (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_2) b)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_const_eq BoundedContinuousFunction.norm_const_eqₓ'. -/
@[simp]
theorem norm_const_eq [h : Nonempty α] (b : β) : ‖const α b‖ = ‖b‖ :=
  le_antisymm (norm_const_le b) <| h.elim fun x => (const α b).norm_coe_le_norm x
#align bounded_continuous_function.norm_const_eq BoundedContinuousFunction.norm_const_eq

/- warning: bounded_continuous_function.of_normed_add_comm_group -> BoundedContinuousFunction.ofNormedAddCommGroup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] (f : α -> β), (Continuous.{u1, u2} α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) f) -> (forall (C : Real), (forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_4) (f x)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] (f : α -> β), (Continuous.{u1, u2} α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) f) -> (forall (C : Real), (forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_4) (f x)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.of_normed_add_comm_group BoundedContinuousFunction.ofNormedAddCommGroupₓ'. -/
/-- Constructing a bounded continuous function from a uniformly bounded continuous
function taking values in a normed group. -/
def ofNormedAddCommGroup {α : Type u} {β : Type v} [TopologicalSpace α] [SeminormedAddCommGroup β]
    (f : α → β) (Hf : Continuous f) (C : ℝ) (H : ∀ x, ‖f x‖ ≤ C) : α →ᵇ β :=
  ⟨⟨fun n => f n, Hf⟩, ⟨_, dist_le_two_norm' H⟩⟩
#align bounded_continuous_function.of_normed_add_comm_group BoundedContinuousFunction.ofNormedAddCommGroup

/- warning: bounded_continuous_function.coe_of_normed_add_comm_group -> BoundedContinuousFunction.coe_ofNormedAddCommGroup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] (f : α -> β) (Hf : Continuous.{u1, u2} α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) f) (C : Real) (H : forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_4) (f x)) C), Eq.{max (succ u1) (succ u2)} ((fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) => α -> β) (BoundedContinuousFunction.ofNormedAddCommGroup.{u1, u2} α β _inst_3 _inst_4 f Hf C H)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (BoundedContinuousFunction.ofNormedAddCommGroup.{u1, u2} α β _inst_3 _inst_4 f Hf C H)) f
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] (f : α -> β) (Hf : Continuous.{u1, u2} α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) f) (C : Real) (H : forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_4) (f x)) C), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)))) (BoundedContinuousFunction.ofNormedAddCommGroup.{u1, u2} α β _inst_3 _inst_4 f Hf C H)) f
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_of_normed_add_comm_group BoundedContinuousFunction.coe_ofNormedAddCommGroupₓ'. -/
@[simp]
theorem coe_ofNormedAddCommGroup {α : Type u} {β : Type v} [TopologicalSpace α]
    [SeminormedAddCommGroup β] (f : α → β) (Hf : Continuous f) (C : ℝ) (H : ∀ x, ‖f x‖ ≤ C) :
    (ofNormedAddCommGroup f Hf C H : α → β) = f :=
  rfl
#align bounded_continuous_function.coe_of_normed_add_comm_group BoundedContinuousFunction.coe_ofNormedAddCommGroup

/- warning: bounded_continuous_function.norm_of_normed_add_comm_group_le -> BoundedContinuousFunction.norm_ofNormedAddCommGroup_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] {f : α -> β} (hfc : Continuous.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) f) {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (forall (hfC : forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (f x)) C), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.ofNormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2 f hfc C hfC)) C)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] {f : α -> β} (hfc : Continuous.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) f) {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (forall (hfC : forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_2) (f x)) C), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.ofNormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2 f hfc C hfC)) C)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_of_normed_add_comm_group_le BoundedContinuousFunction.norm_ofNormedAddCommGroup_leₓ'. -/
theorem norm_ofNormedAddCommGroup_le {f : α → β} (hfc : Continuous f) {C : ℝ} (hC : 0 ≤ C)
    (hfC : ∀ x, ‖f x‖ ≤ C) : ‖ofNormedAddCommGroup f hfc C hfC‖ ≤ C :=
  (norm_le hC).2 hfC
#align bounded_continuous_function.norm_of_normed_add_comm_group_le BoundedContinuousFunction.norm_ofNormedAddCommGroup_le

/- warning: bounded_continuous_function.of_normed_add_comm_group_discrete -> BoundedContinuousFunction.ofNormedAddCommGroupDiscrete is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : DiscreteTopology.{u1} α _inst_3] [_inst_5 : SeminormedAddCommGroup.{u2} β] (f : α -> β) (C : Real), (forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_5) (f x)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : DiscreteTopology.{u1} α _inst_3] [_inst_5 : SeminormedAddCommGroup.{u2} β] (f : α -> β) (C : Real), (forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_5) (f x)) C) -> (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.of_normed_add_comm_group_discrete BoundedContinuousFunction.ofNormedAddCommGroupDiscreteₓ'. -/
/-- Constructing a bounded continuous function from a uniformly bounded
function on a discrete space, taking values in a normed group -/
def ofNormedAddCommGroupDiscrete {α : Type u} {β : Type v} [TopologicalSpace α] [DiscreteTopology α]
    [SeminormedAddCommGroup β] (f : α → β) (C : ℝ) (H : ∀ x, norm (f x) ≤ C) : α →ᵇ β :=
  ofNormedAddCommGroup f continuous_of_discreteTopology C H
#align bounded_continuous_function.of_normed_add_comm_group_discrete BoundedContinuousFunction.ofNormedAddCommGroupDiscrete

/- warning: bounded_continuous_function.coe_of_normed_add_comm_group_discrete -> BoundedContinuousFunction.coe_ofNormedAddCommGroupDiscrete is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : DiscreteTopology.{u1} α _inst_3] [_inst_5 : SeminormedAddCommGroup.{u2} β] (f : α -> β) (C : Real) (H : forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_5) (f x)) C), Eq.{max (succ u1) (succ u2)} ((fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)) => α -> β) (BoundedContinuousFunction.ofNormedAddCommGroupDiscrete.{u1, u2} α β _inst_3 _inst_4 _inst_5 f C H)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)) (BoundedContinuousFunction.ofNormedAddCommGroupDiscrete.{u1, u2} α β _inst_3 _inst_4 _inst_5 f C H)) f
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : DiscreteTopology.{u1} α _inst_3] [_inst_5 : SeminormedAddCommGroup.{u2} β] (f : α -> β) (C : Real) (H : forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_5) (f x)) C), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)) α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)) α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_5)))) (BoundedContinuousFunction.ofNormedAddCommGroupDiscrete.{u1, u2} α β _inst_3 _inst_4 _inst_5 f C H)) f
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_of_normed_add_comm_group_discrete BoundedContinuousFunction.coe_ofNormedAddCommGroupDiscreteₓ'. -/
@[simp]
theorem coe_ofNormedAddCommGroupDiscrete {α : Type u} {β : Type v} [TopologicalSpace α]
    [DiscreteTopology α] [SeminormedAddCommGroup β] (f : α → β) (C : ℝ) (H : ∀ x, ‖f x‖ ≤ C) :
    (ofNormedAddCommGroupDiscrete f C H : α → β) = f :=
  rfl
#align bounded_continuous_function.coe_of_normed_add_comm_group_discrete BoundedContinuousFunction.coe_ofNormedAddCommGroupDiscrete

#print BoundedContinuousFunction.normComp /-
/-- Taking the pointwise norm of a bounded continuous function with values in a
`seminormed_add_comm_group` yields a bounded continuous function with values in ℝ. -/
def normComp : α →ᵇ ℝ :=
  f.comp norm lipschitzWith_one_norm
#align bounded_continuous_function.norm_comp BoundedContinuousFunction.normComp
-/

/- warning: bounded_continuous_function.coe_norm_comp -> BoundedContinuousFunction.coe_normComp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{succ u1} ((fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.normComp.{u1, u2} α β _inst_1 _inst_2 f)) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.normComp.{u1, u2} α β _inst_1 _inst_2 f)) (Function.comp.{succ u1, succ u2, 1} α β Real (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{succ u1} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) a) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 Real.pseudoMetricSpace (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace))) (BoundedContinuousFunction.normComp.{u1, u2} α β _inst_1 _inst_2 f)) (Function.comp.{succ u1, succ u2, 1} α β Real (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_norm_comp BoundedContinuousFunction.coe_normCompₓ'. -/
@[simp]
theorem coe_normComp : (f.normComp : α → ℝ) = norm ∘ f :=
  rfl
#align bounded_continuous_function.coe_norm_comp BoundedContinuousFunction.coe_normComp

/- warning: bounded_continuous_function.norm_norm_comp -> BoundedContinuousFunction.norm_normComp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.hasNorm.{u1, 0} α Real _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))) (BoundedContinuousFunction.normComp.{u1, u2} α β _inst_1 _inst_2 f)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, 0} α Real _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))) (BoundedContinuousFunction.normComp.{u1, u2} α β _inst_1 _inst_2 f)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_norm_comp BoundedContinuousFunction.norm_normCompₓ'. -/
@[simp]
theorem norm_normComp : ‖f.normComp‖ = ‖f‖ := by simp only [norm_eq, coe_norm_comp, norm_norm]
#align bounded_continuous_function.norm_norm_comp BoundedContinuousFunction.norm_normComp

/- warning: bounded_continuous_function.bdd_above_range_norm_comp -> BoundedContinuousFunction.bddAbove_range_norm_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), BddAbove.{0} Real Real.preorder (Set.range.{0, succ u1} Real α (Function.comp.{succ u1, succ u2, 1} α β Real (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), BddAbove.{0} Real Real.instPreorderReal (Set.range.{0, succ u1} Real α (Function.comp.{succ u1, succ u2, 1} α β Real (Norm.norm.{u2} β (SeminormedAddCommGroup.toNorm.{u2} β _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.bdd_above_range_norm_comp BoundedContinuousFunction.bddAbove_range_norm_compₓ'. -/
theorem bddAbove_range_norm_comp : BddAbove <| Set.range <| norm ∘ f :=
  (Real.bounded_iff_bddBelow_bddAbove.mp <| @bounded_range _ _ _ _ f.normComp).2
#align bounded_continuous_function.bdd_above_range_norm_comp BoundedContinuousFunction.bddAbove_range_norm_comp

/- warning: bounded_continuous_function.norm_eq_supr_norm -> BoundedContinuousFunction.norm_eq_iSup_norm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f) (iSup.{0, succ u1} Real Real.hasSup α (fun (x : α) => Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) (iSup.{0, succ u1} Real Real.instSupSetReal α (fun (x : α) => Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_eq_supr_norm BoundedContinuousFunction.norm_eq_iSup_normₓ'. -/
theorem norm_eq_iSup_norm : ‖f‖ = ⨆ x : α, ‖f x‖ := by
  simp_rw [norm_def, dist_eq_supr, coe_zero, Pi.zero_apply, dist_zero_right]
#align bounded_continuous_function.norm_eq_supr_norm BoundedContinuousFunction.norm_eq_iSup_norm

/-- If `‖(1 : β)‖ = 1`, then `‖(1 : α →ᵇ β)‖ = 1` if `α` is nonempty. -/
instance [Nonempty α] [One β] [NormOneClass β] : NormOneClass (α →ᵇ β)
    where norm_one := by simp only [norm_eq_supr_norm, coe_one, Pi.one_apply, norm_one, ciSup_const]

/-- The pointwise opposite of a bounded continuous function is again bounded continuous. -/
instance : Neg (α →ᵇ β) :=
  ⟨fun f =>
    ofNormedAddCommGroup (-f) f.Continuous.neg ‖f‖ fun x =>
      trans_rel_right _ (norm_neg _) (f.norm_coe_le_norm x)⟩

/-- The pointwise difference of two bounded continuous functions is again bounded continuous. -/
instance : Sub (α →ᵇ β) :=
  ⟨fun f g =>
    ofNormedAddCommGroup (f - g) (f.Continuous.sub g.Continuous) (‖f‖ + ‖g‖) fun x =>
      by
      simp only [sub_eq_add_neg]
      exact
        le_trans (norm_add_le _ _)
          (add_le_add (f.norm_coe_le_norm x) <|
            trans_rel_right _ (norm_neg _) (g.norm_coe_le_norm x))⟩

/- warning: bounded_continuous_function.coe_neg -> BoundedContinuousFunction.coe_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (Neg.neg.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNeg.{u1, u2} α β _inst_1 _inst_2) f)) (Neg.neg.{max u1 u2} (α -> β) (Pi.instNeg.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (Neg.neg.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNegBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f)) (Neg.neg.{max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (Pi.instNeg.{u1, u2} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => NegZeroClass.toNeg.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddCommGroup.toAddCommGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_2))))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_neg BoundedContinuousFunction.coe_negₓ'. -/
@[simp]
theorem coe_neg : ⇑(-f) = -f :=
  rfl
#align bounded_continuous_function.coe_neg BoundedContinuousFunction.coe_neg

/- warning: bounded_continuous_function.neg_apply -> BoundedContinuousFunction.neg_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) {x : α}, Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (Neg.neg.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNeg.{u1, u2} α β _inst_1 _inst_2) f) x) (Neg.neg.{u2} β (SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) {x : α}, Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (Neg.neg.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNegBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f) x) (Neg.neg.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (NegZeroClass.toNeg.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toAddCommGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.neg_apply BoundedContinuousFunction.neg_applyₓ'. -/
theorem neg_apply : (-f) x = -f x :=
  rfl
#align bounded_continuous_function.neg_apply BoundedContinuousFunction.neg_apply

/- warning: bounded_continuous_function.coe_sub -> BoundedContinuousFunction.coe_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSub.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasSub.{u1, u2} α β _inst_1 _inst_2)) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHSub.{max u1 u2} (α -> β) (Pi.instSub.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SubNegMonoid.toHasSub.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSub.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instSubBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (instHSub.{max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (Pi.instSub.{u1, u2} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => SubNegMonoid.toSub.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_sub BoundedContinuousFunction.coe_subₓ'. -/
@[simp]
theorem coe_sub : ⇑(f - g) = f - g :=
  rfl
#align bounded_continuous_function.coe_sub BoundedContinuousFunction.coe_sub

/- warning: bounded_continuous_function.sub_apply -> BoundedContinuousFunction.sub_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) {x : α}, Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSub.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasSub.{u1, u2} α β _inst_1 _inst_2)) f g) x) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β (SubNegMonoid.toHasSub.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) g x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) {x : α}, Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSub.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instSubBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) f g) x) (HSub.hSub.{u2, u2, u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (instHSub.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SubNegMonoid.toSub.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) g x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.sub_apply BoundedContinuousFunction.sub_applyₓ'. -/
theorem sub_apply : (f - g) x = f x - g x :=
  rfl
#align bounded_continuous_function.sub_apply BoundedContinuousFunction.sub_apply

/- warning: bounded_continuous_function.mk_of_compact_neg -> BoundedContinuousFunction.mkOfCompact_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))), Eq.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 (Neg.neg.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.hasNeg.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_topologicalAddGroup.{u2} β _inst_2)) f)) (Neg.neg.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNeg.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))), Eq.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 (Neg.neg.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.instNegContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_topologicalAddGroup.{u2} β _inst_2)) f)) (Neg.neg.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNegBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_compact_neg BoundedContinuousFunction.mkOfCompact_negₓ'. -/
@[simp]
theorem mkOfCompact_neg [CompactSpace α] (f : C(α, β)) : mkOfCompact (-f) = -mkOfCompact f :=
  rfl
#align bounded_continuous_function.mk_of_compact_neg BoundedContinuousFunction.mkOfCompact_neg

/- warning: bounded_continuous_function.mk_of_compact_sub -> BoundedContinuousFunction.mkOfCompact_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))), Eq.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (instHSub.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.hasSub.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (SubNegMonoid.toHasSub.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))) (TopologicalAddGroup.to_continuousSub.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_topologicalAddGroup.{u2} β _inst_2)))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSub.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasSub.{u1, u2} α β _inst_1 _inst_2)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 f) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))), Eq.{max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (instHSub.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (ContinuousMap.instSubContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (SubNegMonoid.toSub.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))) (TopologicalAddGroup.to_continuousSub.{u2} β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_topologicalAddGroup.{u2} β _inst_2)))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSub.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instSubBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 f) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) _inst_3 g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_compact_sub BoundedContinuousFunction.mkOfCompact_subₓ'. -/
@[simp]
theorem mkOfCompact_sub [CompactSpace α] (f g : C(α, β)) :
    mkOfCompact (f - g) = mkOfCompact f - mkOfCompact g :=
  rfl
#align bounded_continuous_function.mk_of_compact_sub BoundedContinuousFunction.mkOfCompact_sub

/- warning: bounded_continuous_function.coe_zsmul_rec -> BoundedContinuousFunction.coe_zsmulRec is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (z : Int), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (zsmulRec.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasZero.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2))))))) (BoundedContinuousFunction.hasAdd.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.hasNeg.{u1, u2} α β _inst_1 _inst_2) z f)) (SMul.smul.{0, max u1 u2} Int (α -> β) (Function.hasSMul.{u1, 0, u2} α Int β (SubNegMonoid.SMulInt.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2))))) z (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (z : Int), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (zsmulRec.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instZeroBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (NegZeroClass.toZero.{u2} β (SubNegZeroMonoid.toNegZeroClass.{u2} β (SubtractionMonoid.toSubNegZeroMonoid.{u2} β (SubtractionCommMonoid.toSubtractionMonoid.{u2} β (AddCommGroup.toDivisionAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))))) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.instNegBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) z f)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Int (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (instHSMul.{0, max u1 u2} Int (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (SubNegMonoid.SMulInt.{max u1 u2} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (Pi.subNegMonoid.{u1, u2} α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (fun (i : α) => AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_2)))))) z (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_zsmul_rec BoundedContinuousFunction.coe_zsmulRecₓ'. -/
@[simp]
theorem coe_zsmulRec : ∀ z, ⇑(zsmulRec z f) = z • f
  | Int.ofNat n => by rw [zsmulRec, Int.ofNat_eq_coe, coe_nsmul_rec, coe_nat_zsmul]
  | -[n+1] => by rw [zsmulRec, negSucc_zsmul, coe_neg, coe_nsmul_rec]
#align bounded_continuous_function.coe_zsmul_rec BoundedContinuousFunction.coe_zsmulRec

#print BoundedContinuousFunction.hasIntScalar /-
instance hasIntScalar : SMul ℤ (α →ᵇ β)
    where smul n f :=
    { toContinuousMap := n • f.toContinuousMap
      map_bounded' := by simpa using (zsmulRec n f).map_bounded' }
#align bounded_continuous_function.has_int_scalar BoundedContinuousFunction.hasIntScalar
-/

/- warning: bounded_continuous_function.coe_zsmul -> BoundedContinuousFunction.coe_zsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (r : Int) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SMul.smul.{0, max u1 u2} Int (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasIntScalar.{u1, u2} α β _inst_1 _inst_2) r f)) (SMul.smul.{0, max u1 u2} Int (α -> β) (Function.hasSMul.{u1, 0, u2} α Int β (SubNegMonoid.SMulInt.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2))))) r (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (r : Int) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Int (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSMul.{0, max u1 u2} Int (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasIntScalar.{u1, u2} α β _inst_1 _inst_2)) r f)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Int (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (instHSMul.{0, max u1 u2} Int (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (SubNegMonoid.SMulInt.{max u1 u2} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (Pi.subNegMonoid.{u1, u2} α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) a) (fun (i : α) => AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_2)))))) r (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_zsmul BoundedContinuousFunction.coe_zsmulₓ'. -/
@[simp]
theorem coe_zsmul (r : ℤ) (f : α →ᵇ β) : ⇑(r • f) = r • f :=
  rfl
#align bounded_continuous_function.coe_zsmul BoundedContinuousFunction.coe_zsmul

/- warning: bounded_continuous_function.zsmul_apply -> BoundedContinuousFunction.zsmul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (r : Int) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (v : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SMul.smul.{0, max u1 u2} Int (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasIntScalar.{u1, u2} α β _inst_1 _inst_2) r f) v) (SMul.smul.{0, u2} Int β (SubNegMonoid.SMulInt.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))) r (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f v))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (r : Int) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (v : α), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Int (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (instHSMul.{0, max u1 u2} Int (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasIntScalar.{u1, u2} α β _inst_1 _inst_2)) r f) v) (HSMul.hSMul.{0, u2, u2} Int ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (instHSMul.{0, u2} Int ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (SubNegMonoid.SMulInt.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) v) _inst_2))))) r (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f v))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.zsmul_apply BoundedContinuousFunction.zsmul_applyₓ'. -/
@[simp]
theorem zsmul_apply (r : ℤ) (f : α →ᵇ β) (v : α) : (r • f) v = r • f v :=
  rfl
#align bounded_continuous_function.zsmul_apply BoundedContinuousFunction.zsmul_apply

instance : AddCommGroup (α →ᵇ β) :=
  FunLike.coe_injective.AddCommGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => coe_nsmul _ _)
    fun _ _ => coe_zsmul _ _

instance : SeminormedAddCommGroup (α →ᵇ β)
    where dist_eq f g := by simp only [norm_eq, dist_eq, dist_eq_norm, sub_apply]

instance {α β} [TopologicalSpace α] [NormedAddCommGroup β] : NormedAddCommGroup (α →ᵇ β) :=
  { BoundedContinuousFunction.seminormedAddCommGroup with }

/- warning: bounded_continuous_function.nnnorm_def -> BoundedContinuousFunction.nnnorm_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f) (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) f (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) 0 (OfNat.mk.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) 0 (Zero.zero.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasZero.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)))))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f) (NNDist.nndist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toNNDist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) f (OfNat.ofNat.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) 0 (Zero.toOfNat0.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instZeroBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (NegZeroClass.toZero.{u2} β (SubNegZeroMonoid.toNegZeroClass.{u2} β (SubtractionMonoid.toSubNegZeroMonoid.{u2} β (SubtractionCommMonoid.toSubtractionMonoid.{u2} β (AddCommGroup.toDivisionAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2))))))))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnnorm_def BoundedContinuousFunction.nnnorm_defₓ'. -/
theorem nnnorm_def : ‖f‖₊ = nndist f 0 :=
  rfl
#align bounded_continuous_function.nnnorm_def BoundedContinuousFunction.nnnorm_def

/- warning: bounded_continuous_function.nnnorm_coe_le_nnnorm -> BoundedContinuousFunction.nnnorm_coe_le_nnnorm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddGroup.toNNNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnnorm_coe_le_nnnorm BoundedContinuousFunction.nnnorm_coe_le_nnnormₓ'. -/
theorem nnnorm_coe_le_nnnorm (x : α) : ‖f x‖₊ ≤ ‖f‖₊ :=
  norm_coe_le_norm _ _
#align bounded_continuous_function.nnnorm_coe_le_nnnorm BoundedContinuousFunction.nnnorm_coe_le_nnnorm

/- warning: bounded_continuous_function.nndist_le_two_nnnorm -> BoundedContinuousFunction.nndist_le_two_nnnorm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α) (y : α), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNDist.nndist.{u2} β (PseudoMetricSpace.toNNDist.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f y)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (Distrib.toHasMul.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (OfNat.ofNat.{0} NNReal 2 (OfNat.mk.{0} NNReal 2 (bit0.{0} NNReal (Distrib.toHasAdd.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))) (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α) (y : α), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNDist.nndist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (PseudoMetricSpace.toNNDist.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f y)) (HMul.hMul.{0, 0, 0} NNReal NNReal NNReal (instHMul.{0} NNReal (CanonicallyOrderedCommSemiring.toMul.{0} NNReal instNNRealCanonicallyOrderedCommSemiring)) (OfNat.ofNat.{0} NNReal 2 (instOfNat.{0} NNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nndist_le_two_nnnorm BoundedContinuousFunction.nndist_le_two_nnnormₓ'. -/
theorem nndist_le_two_nnnorm (x y : α) : nndist (f x) (f y) ≤ 2 * ‖f‖₊ :=
  dist_le_two_norm _ _ _
#align bounded_continuous_function.nndist_le_two_nnnorm BoundedContinuousFunction.nndist_le_two_nnnorm

/- warning: bounded_continuous_function.nnnorm_le -> BoundedContinuousFunction.nnnorm_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (C : NNReal), Iff (LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f) C) (forall (x : α), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)) C)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (C : NNReal), Iff (LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f) C) (forall (x : α), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddGroup.toNNNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)) C)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnnorm_le BoundedContinuousFunction.nnnorm_leₓ'. -/
/-- The nnnorm of a function is controlled by the supremum of the pointwise nnnorms -/
theorem nnnorm_le (C : ℝ≥0) : ‖f‖₊ ≤ C ↔ ∀ x : α, ‖f x‖₊ ≤ C :=
  norm_le C.Prop
#align bounded_continuous_function.nnnorm_le BoundedContinuousFunction.nnnorm_le

/- warning: bounded_continuous_function.nnnorm_const_le -> BoundedContinuousFunction.nnnorm_const_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (b : β), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) b)) (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) b)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (b : β), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) (BoundedContinuousFunction.const.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) b)) (NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) b)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnnorm_const_le BoundedContinuousFunction.nnnorm_const_leₓ'. -/
theorem nnnorm_const_le (b : β) : ‖const α b‖₊ ≤ ‖b‖₊ :=
  norm_const_le _
#align bounded_continuous_function.nnnorm_const_le BoundedContinuousFunction.nnnorm_const_le

#print BoundedContinuousFunction.nnnorm_const_eq /-
@[simp]
theorem nnnorm_const_eq [h : Nonempty α] (b : β) : ‖const α b‖₊ = ‖b‖₊ :=
  Subtype.ext <| norm_const_eq _
#align bounded_continuous_function.nnnorm_const_eq BoundedContinuousFunction.nnnorm_const_eq
-/

/- warning: bounded_continuous_function.nnnorm_eq_supr_nnnorm -> BoundedContinuousFunction.nnnorm_eq_iSup_nnnorm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toHasSup.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.conditionallyCompleteLinearOrderBot))) α (fun (x : α) => NNNorm.nnnorm.{u2} β (SeminormedAddGroup.toNNNorm.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)), Eq.{1} NNReal (NNNorm.nnnorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddGroup.toNNNorm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.seminormedAddCommGroup.{u1, u2} α β _inst_1 _inst_2))) f) (iSup.{0, succ u1} NNReal (ConditionallyCompleteLattice.toSupSet.{0} NNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} NNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} NNReal NNReal.instConditionallyCompleteLinearOrderBotNNReal))) α (fun (x : α) => NNNorm.nnnorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddGroup.toNNNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnnorm_eq_supr_nnnorm BoundedContinuousFunction.nnnorm_eq_iSup_nnnormₓ'. -/
theorem nnnorm_eq_iSup_nnnorm : ‖f‖₊ = ⨆ x : α, ‖f x‖₊ :=
  Subtype.ext <| (norm_eq_iSup_norm f).trans <| by simp_rw [NNReal.coe_iSup, coe_nnnorm]
#align bounded_continuous_function.nnnorm_eq_supr_nnnorm BoundedContinuousFunction.nnnorm_eq_iSup_nnnorm

/- warning: bounded_continuous_function.abs_diff_coe_le_dist -> BoundedContinuousFunction.abs_diff_coe_le_dist is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) {x : α}, LE.le.{0} Real Real.hasLe (Norm.norm.{u2} β (SeminormedAddCommGroup.toHasNorm.{u2} β _inst_2) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β (SubNegMonoid.toHasSub.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_2))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) g x))) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f g)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) {x : α}, LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toNorm.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2) (HSub.hSub.{u2, u2, u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (instHSub.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SubNegMonoid.toSub.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) g x))) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.abs_diff_coe_le_dist BoundedContinuousFunction.abs_diff_coe_le_distₓ'. -/
theorem abs_diff_coe_le_dist : ‖f x - g x‖ ≤ dist f g :=
  by
  rw [dist_eq_norm]
  exact (f - g).norm_coe_le_norm x
#align bounded_continuous_function.abs_diff_coe_le_dist BoundedContinuousFunction.abs_diff_coe_le_dist

/- warning: bounded_continuous_function.coe_le_coe_add_dist -> BoundedContinuousFunction.coe_le_coe_add_dist is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {x : α} {f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace} {g : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace}, LE.le.{0} Real Real.hasLe (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) g x) (Dist.dist.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.hasDist.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) f g))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {x : α} {f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace} {g : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace}, LE.le.{0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) x) Real.instLEReal (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 Real.pseudoMetricSpace (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace))) f x) (HAdd.hAdd.{0, 0, 0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) x) Real ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) x) (instHAdd.{0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) x) Real.instAddReal) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 Real.pseudoMetricSpace (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace))) g x) (Dist.dist.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) f g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_le_coe_add_dist BoundedContinuousFunction.coe_le_coe_add_distₓ'. -/
theorem coe_le_coe_add_dist {f g : α →ᵇ ℝ} : f x ≤ g x + dist f g :=
  sub_le_iff_le_add'.1 <| (abs_le.1 <| @dist_coe_le_dist _ _ _ _ f g x).2
#align bounded_continuous_function.coe_le_coe_add_dist BoundedContinuousFunction.coe_le_coe_add_dist

/- warning: bounded_continuous_function.norm_comp_continuous_le -> BoundedContinuousFunction.norm_compContinuous_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : TopologicalSpace.{u3} γ] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : ContinuousMap.{u3, u1} γ α _inst_3 _inst_1), LE.le.{0} Real Real.hasLe (Norm.norm.{max u3 u2} (BoundedContinuousFunction.{u3, u2} γ β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u3, u2} γ β _inst_3 _inst_2) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) γ _inst_3 f g)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : TopologicalSpace.{u3} γ] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (g : ContinuousMap.{u3, u1} γ α _inst_3 _inst_1), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u3} (BoundedContinuousFunction.{u3, u2} γ β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u3, u2} γ β _inst_3 _inst_2) (BoundedContinuousFunction.compContinuous.{u1, u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) γ _inst_3 f g)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_comp_continuous_le BoundedContinuousFunction.norm_compContinuous_leₓ'. -/
theorem norm_compContinuous_le [TopologicalSpace γ] (f : α →ᵇ β) (g : C(γ, α)) :
    ‖f.comp_continuous g‖ ≤ ‖f‖ :=
  ((lipschitz_compContinuous g).dist_le_mul f 0).trans <| by
    rw [NNReal.coe_one, one_mul, dist_zero_right]
#align bounded_continuous_function.norm_comp_continuous_le BoundedContinuousFunction.norm_compContinuous_le

end NormedAddCommGroup

section BoundedSMul

/-!
### `has_bounded_smul` (in particular, topological module) structure

In this section, if `β` is a metric space and a `𝕜`-module whose addition and scalar multiplication
are compatible with the metric structure, then we show that the space of bounded continuous
functions from `α` to `β` inherits a so-called `has_bounded_smul` structure (in particular, a
`has_continuous_mul` structure, which is the mathlib formulation of being a topological module), by
using pointwise operations and checking that they are compatible with the uniform distance. -/


variable {𝕜 : Type _} [PseudoMetricSpace 𝕜] [TopologicalSpace α] [PseudoMetricSpace β]

section SMul

variable [Zero 𝕜] [Zero β] [SMul 𝕜 β] [BoundedSMul 𝕜 β]

instance : SMul 𝕜 (α →ᵇ β)
    where smul c f :=
    { toContinuousMap := c • f.toContinuousMap
      map_bounded' :=
        let ⟨b, hb⟩ := f.Bounded
        ⟨dist c 0 * b, fun x y =>
          by
          refine' (dist_smul_pair c (f x) (f y)).trans _
          refine' mul_le_mul_of_nonneg_left _ dist_nonneg
          exact hb x y⟩ }

/- warning: bounded_continuous_function.coe_smul -> BoundedContinuousFunction.coe_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {𝕜 : Type.{u3}} [_inst_1 : PseudoMetricSpace.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : Zero.{u3} 𝕜] [_inst_5 : Zero.{u2} β] [_inst_6 : SMul.{u3, u2} 𝕜 β] [_inst_7 : BoundedSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 _inst_4 _inst_5 _inst_6] (c : 𝕜) (f : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_2 _inst_3) (SMul.smul.{u3, max u1 u2} 𝕜 (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (BoundedContinuousFunction.hasSmul.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) c f)) (fun (x : α) => SMul.smul.{u3, u2} 𝕜 β _inst_6 c (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_2 _inst_3) f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {𝕜 : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} 𝕜] [_inst_2 : TopologicalSpace.{u2} α] [_inst_3 : PseudoMetricSpace.{u3} β] [_inst_4 : Zero.{u1} 𝕜] [_inst_5 : Zero.{u3} β] [_inst_6 : SMul.{u1, u3} 𝕜 β] [_inst_7 : BoundedSMul.{u1, u3} 𝕜 β _inst_1 _inst_3 _inst_4 _inst_5 _inst_6] (c : 𝕜) (f : BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3), Eq.{max (succ u2) (succ u3)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} 𝕜 (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (instHSMul.{u1, max u2 u3} 𝕜 (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instSMulBoundedContinuousFunction.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) c f)) (fun (x : α) => HSMul.hSMul.{u1, u3, u3} 𝕜 ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (instHSMul.{u1, u3} 𝕜 ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_6) c (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) f x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_smul BoundedContinuousFunction.coe_smulₓ'. -/
@[simp]
theorem coe_smul (c : 𝕜) (f : α →ᵇ β) : ⇑(c • f) = fun x => c • f x :=
  rfl
#align bounded_continuous_function.coe_smul BoundedContinuousFunction.coe_smul

/- warning: bounded_continuous_function.smul_apply -> BoundedContinuousFunction.smul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {𝕜 : Type.{u3}} [_inst_1 : PseudoMetricSpace.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : Zero.{u3} 𝕜] [_inst_5 : Zero.{u2} β] [_inst_6 : SMul.{u3, u2} 𝕜 β] [_inst_7 : BoundedSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 _inst_4 _inst_5 _inst_6] (c : 𝕜) (f : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (x : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_2 _inst_3) (SMul.smul.{u3, max u1 u2} 𝕜 (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (BoundedContinuousFunction.hasSmul.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) c f) x) (SMul.smul.{u3, u2} 𝕜 β _inst_6 c (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_2 _inst_3) f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {𝕜 : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} 𝕜] [_inst_2 : TopologicalSpace.{u2} α] [_inst_3 : PseudoMetricSpace.{u3} β] [_inst_4 : Zero.{u1} 𝕜] [_inst_5 : Zero.{u3} β] [_inst_6 : SMul.{u1, u3} 𝕜 β] [_inst_7 : BoundedSMul.{u1, u3} 𝕜 β _inst_1 _inst_3 _inst_4 _inst_5 _inst_6] (c : 𝕜) (f : BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (x : α), Eq.{succ u3} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} 𝕜 (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (instHSMul.{u1, max u2 u3} 𝕜 (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instSMulBoundedContinuousFunction.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) c f) x) (HSMul.hSMul.{u1, u3, u3} 𝕜 ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (instHSMul.{u1, u3} 𝕜 ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_6) c (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) f x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.smul_apply BoundedContinuousFunction.smul_applyₓ'. -/
theorem smul_apply (c : 𝕜) (f : α →ᵇ β) (x : α) : (c • f) x = c • f x :=
  rfl
#align bounded_continuous_function.smul_apply BoundedContinuousFunction.smul_apply

instance [SMul 𝕜ᵐᵒᵖ β] [IsCentralScalar 𝕜 β] : IsCentralScalar 𝕜 (α →ᵇ β)
    where op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _

instance : BoundedSMul 𝕜 (α →ᵇ β)
    where
  dist_smul_pair' c f₁ f₂ :=
    by
    rw [dist_le (mul_nonneg dist_nonneg dist_nonneg)]
    intro x
    refine' (dist_smul_pair c (f₁ x) (f₂ x)).trans _
    exact mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
  dist_pair_smul' c₁ c₂ f :=
    by
    rw [dist_le (mul_nonneg dist_nonneg dist_nonneg)]
    intro x
    refine' (dist_pair_smul c₁ c₂ (f x)).trans _
    convert mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
    simp

end SMul

section MulAction

variable [MonoidWithZero 𝕜] [Zero β] [MulAction 𝕜 β] [BoundedSMul 𝕜 β]

instance : MulAction 𝕜 (α →ᵇ β) :=
  FunLike.coe_injective.MulAction _ coe_smul

end MulAction

section DistribMulAction

variable [MonoidWithZero 𝕜] [AddMonoid β] [DistribMulAction 𝕜 β] [BoundedSMul 𝕜 β]

variable [LipschitzAdd β]

instance : DistribMulAction 𝕜 (α →ᵇ β) :=
  Function.Injective.distribMulAction ⟨_, coe_zero, coe_add⟩ FunLike.coe_injective coe_smul

end DistribMulAction

section Module

variable [Semiring 𝕜] [AddCommMonoid β] [Module 𝕜 β] [BoundedSMul 𝕜 β]

variable {f g : α →ᵇ β} {x : α} {C : ℝ}

variable [LipschitzAdd β]

instance : Module 𝕜 (α →ᵇ β) :=
  Function.Injective.module _ ⟨_, coe_zero, coe_add⟩ FunLike.coe_injective coe_smul

variable (𝕜)

/- warning: bounded_continuous_function.eval_clm -> BoundedContinuousFunction.evalClm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (𝕜 : Type.{u3}) [_inst_1 : PseudoMetricSpace.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : Semiring.{u3} 𝕜] [_inst_5 : AddCommMonoid.{u2} β] [_inst_6 : Module.{u3, u2} 𝕜 β _inst_4 _inst_5] [_inst_7 : BoundedSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 (MulZeroClass.toHasZero.{u3} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (SMulZeroClass.toHasSmul.{u3, u2} 𝕜 β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (SMulWithZero.toSmulZeroClass.{u3, u2} 𝕜 β (MulZeroClass.toHasZero.{u3} 𝕜 (MulZeroOneClass.toMulZeroClass.{u3} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 β (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (Module.toMulActionWithZero.{u3, u2} 𝕜 β _inst_4 _inst_5 _inst_6))))] [_inst_8 : LipschitzAdd.{u2} β _inst_3 (AddCommMonoid.toAddMonoid.{u2} β _inst_5)], α -> (ContinuousLinearMap.{u3, u3, max u1 u2, u2} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)) (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_2 _inst_3))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} (𝕜 : Type.{u3}) [_inst_1 : PseudoMetricSpace.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : Semiring.{u3} 𝕜] [_inst_5 : AddCommMonoid.{u2} β] [_inst_6 : Module.{u3, u2} 𝕜 β _inst_4 _inst_5] [_inst_7 : BoundedSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (SMulZeroClass.toSMul.{u3, u2} 𝕜 β (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (SMulWithZero.toSMulZeroClass.{u3, u2} 𝕜 β (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 β (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (Module.toMulActionWithZero.{u3, u2} 𝕜 β _inst_4 _inst_5 _inst_6))))] [_inst_8 : LipschitzAdd.{u2} β _inst_3 (AddCommMonoid.toAddMonoid.{u2} β _inst_5)], α -> (ContinuousLinearMap.{u3, u3, max u2 u1, u2} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)) (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.eval_clm BoundedContinuousFunction.evalClmₓ'. -/
/-- The evaluation at a point, as a continuous linear map from `α →ᵇ β` to `β`. -/
def evalClm (x : α) : (α →ᵇ β) →L[𝕜] β where
  toFun f := f x
  map_add' f g := add_apply _ _
  map_smul' c f := smul_apply _ _ _
#align bounded_continuous_function.eval_clm BoundedContinuousFunction.evalClm

/- warning: bounded_continuous_function.eval_clm_apply -> BoundedContinuousFunction.evalClm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (𝕜 : Type.{u3}) [_inst_1 : PseudoMetricSpace.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : Semiring.{u3} 𝕜] [_inst_5 : AddCommMonoid.{u2} β] [_inst_6 : Module.{u3, u2} 𝕜 β _inst_4 _inst_5] [_inst_7 : BoundedSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 (MulZeroClass.toHasZero.{u3} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (SMulZeroClass.toHasSmul.{u3, u2} 𝕜 β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (SMulWithZero.toSmulZeroClass.{u3, u2} 𝕜 β (MulZeroClass.toHasZero.{u3} 𝕜 (MulZeroOneClass.toMulZeroClass.{u3} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 β (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (Module.toMulActionWithZero.{u3, u2} 𝕜 β _inst_4 _inst_5 _inst_6))))] [_inst_8 : LipschitzAdd.{u2} β _inst_3 (AddCommMonoid.toAddMonoid.{u2} β _inst_5)] (x : α) (f : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3), Eq.{succ u2} β (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ (max u1 u2)) (succ u2)} (ContinuousLinearMap.{u3, u3, max u1 u2, u2} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)) (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_2 _inst_3))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6) (fun (_x : ContinuousLinearMap.{u3, u3, max u1 u2, u2} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)) (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_2 _inst_3))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6) => (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) -> β) (ContinuousLinearMap.toFun.{u3, u3, max u1 u2, u2} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)) (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_2 _inst_3))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6) (BoundedContinuousFunction.evalClm.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 x) f) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_2 _inst_3) f x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} (𝕜 : Type.{u1}) [_inst_1 : PseudoMetricSpace.{u1} 𝕜] [_inst_2 : TopologicalSpace.{u2} α] [_inst_3 : PseudoMetricSpace.{u3} β] [_inst_4 : Semiring.{u1} 𝕜] [_inst_5 : AddCommMonoid.{u3} β] [_inst_6 : Module.{u1, u3} 𝕜 β _inst_4 _inst_5] [_inst_7 : BoundedSMul.{u1, u3} 𝕜 β _inst_1 _inst_3 (MonoidWithZero.toZero.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 _inst_4)) (AddMonoid.toZero.{u3} β (AddCommMonoid.toAddMonoid.{u3} β _inst_5)) (SMulZeroClass.toSMul.{u1, u3} 𝕜 β (AddMonoid.toZero.{u3} β (AddCommMonoid.toAddMonoid.{u3} β _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u3} 𝕜 β (MonoidWithZero.toZero.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 _inst_4)) (AddMonoid.toZero.{u3} β (AddCommMonoid.toAddMonoid.{u3} β _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u3} 𝕜 β (Semiring.toMonoidWithZero.{u1} 𝕜 _inst_4) (AddMonoid.toZero.{u3} β (AddCommMonoid.toAddMonoid.{u3} β _inst_5)) (Module.toMulActionWithZero.{u1, u3} 𝕜 β _inst_4 _inst_5 _inst_6))))] [_inst_8 : LipschitzAdd.{u3} β _inst_3 (AddCommMonoid.toAddMonoid.{u3} β _inst_5)] (x : α) (f : BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3), Eq.{succ u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) => β) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (ContinuousLinearMap.{u1, u1, max u3 u2, u3} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 _inst_4)) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (fun (_x : BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, max u2 u3, u3} (ContinuousLinearMap.{u1, u1, max u3 u2, u3} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 _inst_4)) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) β (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) (ContinuousSemilinearMapClass.toContinuousMapClass.{max u2 u3, u1, u1, max u2 u3, u3} (ContinuousLinearMap.{u1, u1, max u3 u2, u3} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 _inst_4)) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6) 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 _inst_4)) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6 (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, max u2 u3, u3} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 _inst_4)) (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3 _inst_5 _inst_8) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) _inst_5 (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) _inst_6))) (BoundedContinuousFunction.evalClm.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 x) f) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β _inst_3)) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3) α β _inst_2 _inst_3 (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_2 _inst_3))) f x)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.eval_clm_apply BoundedContinuousFunction.evalClm_applyₓ'. -/
@[simp]
theorem evalClm_apply (x : α) (f : α →ᵇ β) : evalClm 𝕜 x f = f x :=
  rfl
#align bounded_continuous_function.eval_clm_apply BoundedContinuousFunction.evalClm_apply

variable (α β)

/- warning: bounded_continuous_function.to_continuous_map_linear_map -> BoundedContinuousFunction.toContinuousMapLinearMap is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) (𝕜 : Type.{u3}) [_inst_1 : PseudoMetricSpace.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : Semiring.{u3} 𝕜] [_inst_5 : AddCommMonoid.{u2} β] [_inst_6 : Module.{u3, u2} 𝕜 β _inst_4 _inst_5] [_inst_7 : BoundedSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 (MulZeroClass.toHasZero.{u3} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (SMulZeroClass.toHasSmul.{u3, u2} 𝕜 β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (SMulWithZero.toSmulZeroClass.{u3, u2} 𝕜 β (MulZeroClass.toHasZero.{u3} 𝕜 (MulZeroOneClass.toMulZeroClass.{u3} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)))) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 β (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4) (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5))) (Module.toMulActionWithZero.{u3, u2} 𝕜 β _inst_4 _inst_5 _inst_6))))] [_inst_8 : LipschitzAdd.{u2} β _inst_3 (AddCommMonoid.toAddMonoid.{u2} β _inst_5)], LinearMap.{u3, u3, max u1 u2, max u1 u2} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)) (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (ContinuousMap.{u1, u2} α β _inst_2 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_2 _inst_3 _inst_5 _inst_8) (ContinuousMap.addCommMonoid.{u1, u2} α β _inst_2 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_5 (BoundedContinuousFunction.toContinuousMapLinearMap._proof_1.{u2} β _inst_3 _inst_5 _inst_8)) (BoundedContinuousFunction.module.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) (ContinuousMap.module.{u1, u3, u2} α _inst_2 𝕜 β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_4 _inst_5 (BoundedContinuousFunction.toContinuousMapLinearMap._proof_2.{u2} β _inst_3 _inst_5 _inst_8) _inst_6 (BoundedContinuousFunction.toContinuousMapLinearMap._proof_3.{u3, u2} β 𝕜 _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))
but is expected to have type
  forall (α : Type.{u1}) (β : Type.{u2}) (𝕜 : Type.{u3}) [_inst_1 : PseudoMetricSpace.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : PseudoMetricSpace.{u2} β] [_inst_4 : Semiring.{u3} 𝕜] [_inst_5 : AddCommMonoid.{u2} β] [_inst_6 : Module.{u3, u2} 𝕜 β _inst_4 _inst_5] [_inst_7 : BoundedSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (SMulZeroClass.toSMul.{u3, u2} 𝕜 β (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (SMulWithZero.toSMulZeroClass.{u3, u2} 𝕜 β (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 β (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (Module.toMulActionWithZero.{u3, u2} 𝕜 β _inst_4 _inst_5 _inst_6))))] [_inst_8 : LipschitzAdd.{u2} β _inst_3 (AddCommMonoid.toAddMonoid.{u2} β _inst_5)], LinearMap.{u3, u3, max u2 u1, max u2 u1} 𝕜 𝕜 _inst_4 _inst_4 (RingHom.id.{u3} 𝕜 (Semiring.toNonAssocSemiring.{u3} 𝕜 _inst_4)) (BoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3) (ContinuousMap.{u1, u2} α β _inst_2 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, u2} α β _inst_2 _inst_3 _inst_5 _inst_8) (ContinuousMap.instAddCommMonoidContinuousMap.{u1, u2} α β _inst_2 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_5 (LipschitzAdd.continuousAdd.{u2} β _inst_3 (AddCommMonoid.toAddMonoid.{u2} β _inst_5) _inst_8)) (BoundedContinuousFunction.module.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8) (ContinuousMap.module.{u1, u3, u2} α _inst_2 𝕜 β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) _inst_4 _inst_5 (LipschitzAdd.continuousAdd.{u2} β _inst_3 (AddCommMonoid.toAddMonoid.{u2} β _inst_5) _inst_8) _inst_6 (ContinuousSMul.continuousConstSMul.{u3, u2} 𝕜 β (UniformSpace.toTopologicalSpace.{u3} 𝕜 (PseudoMetricSpace.toUniformSpace.{u3} 𝕜 _inst_1)) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β _inst_3)) (SMulZeroClass.toSMul.{u3, u2} 𝕜 β (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (SMulWithZero.toSMulZeroClass.{u3, u2} 𝕜 β (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 β (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (Module.toMulActionWithZero.{u3, u2} 𝕜 β _inst_4 _inst_5 _inst_6)))) (BoundedSMul.continuousSMul.{u3, u2} 𝕜 β _inst_1 _inst_3 (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (SMulZeroClass.toSMul.{u3, u2} 𝕜 β (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (SMulWithZero.toSMulZeroClass.{u3, u2} 𝕜 β (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4)) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 β (Semiring.toMonoidWithZero.{u3} 𝕜 _inst_4) (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_5)) (Module.toMulActionWithZero.{u3, u2} 𝕜 β _inst_4 _inst_5 _inst_6)))) _inst_7)))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.to_continuous_map_linear_map BoundedContinuousFunction.toContinuousMapLinearMapₓ'. -/
/-- The linear map forgetting that a bounded continuous function is bounded. -/
@[simps]
def toContinuousMapLinearMap : (α →ᵇ β) →ₗ[𝕜] C(α, β)
    where
  toFun := toContinuousMap
  map_smul' f g := rfl
  map_add' c f := rfl
#align bounded_continuous_function.to_continuous_map_linear_map BoundedContinuousFunction.toContinuousMapLinearMap

end Module

end BoundedSMul

section NormedSpace

/-!
### Normed space structure

In this section, if `β` is a normed space, then we show that the space of bounded
continuous functions from `α` to `β` inherits a normed space structure, by using
pointwise operations and checking that they are compatible with the uniform distance. -/


variable {𝕜 : Type _}

variable [TopologicalSpace α] [SeminormedAddCommGroup β]

variable {f g : α →ᵇ β} {x : α} {C : ℝ}

instance [NormedField 𝕜] [NormedSpace 𝕜 β] : NormedSpace 𝕜 (α →ᵇ β) :=
  ⟨fun c f =>
    by
    refine' norm_of_normed_add_comm_group_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _
    exact fun x =>
      trans_rel_right _ (norm_smul _ _)
        (mul_le_mul_of_nonneg_left (f.norm_coe_le_norm _) (norm_nonneg _))⟩

variable [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 β]

variable [SeminormedAddCommGroup γ] [NormedSpace 𝕜 γ]

variable (α)

/- warning: continuous_linear_map.comp_left_continuous_bounded -> ContinuousLinearMap.compLeftContinuousBounded is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) {β : Type.{u2}} {γ : Type.{u3}} {𝕜 : Type.{u4}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NontriviallyNormedField.{u4} 𝕜] [_inst_4 : NormedSpace.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2] [_inst_5 : SeminormedAddCommGroup.{u3} γ] [_inst_6 : NormedSpace.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5], (ContinuousLinearMap.{u4, u4, u2, u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u3} γ (PseudoMetricSpace.toUniformSpace.{u3} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6)) -> (ContinuousLinearMap.{u4, u4, max u1 u2, max u1 u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5)) (BoundedContinuousFunction.module.{u1, u2, u4} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (ContinuousLinearMap.compLeftContinuousBounded._proof_1.{u4, u2} β 𝕜 _inst_2 _inst_3 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.module.{u1, u3, u4} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6) (ContinuousLinearMap.compLeftContinuousBounded._proof_2.{u4, u3} γ 𝕜 _inst_3 _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5)))
but is expected to have type
  forall (α : Type.{u1}) {β : Type.{u2}} {γ : Type.{u3}} {𝕜 : Type.{u4}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NontriviallyNormedField.{u4} 𝕜] [_inst_4 : NormedSpace.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2] [_inst_5 : SeminormedAddCommGroup.{u3} γ] [_inst_6 : NormedSpace.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5], (ContinuousLinearMap.{u4, u4, u2, u3} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u3} γ (PseudoMetricSpace.toUniformSpace.{u3} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6)) -> (ContinuousLinearMap.{u4, u4, max u2 u1, max u3 u1} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5)) (BoundedContinuousFunction.module.{u1, u2, u4} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSeminormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.boundedSMul.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.module.{u1, u3, u4} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSeminormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (DivisionSemiring.toSemiring.{u4} 𝕜 (Semifield.toDivisionSemiring.{u4} 𝕜 (Field.toSemifield.{u4} 𝕜 (NormedField.toField.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6) (NormedSpace.boundedSMul.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5)))
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.comp_left_continuous_bounded ContinuousLinearMap.compLeftContinuousBoundedₓ'. -/
-- TODO does this work in the `has_bounded_smul` setting, too?
/--
Postcomposition of bounded continuous functions into a normed module by a continuous linear map is
a continuous linear map.
Upgraded version of `continuous_linear_map.comp_left_continuous`, similar to
`linear_map.comp_left`. -/
protected def ContinuousLinearMap.compLeftContinuousBounded (g : β →L[𝕜] γ) :
    (α →ᵇ β) →L[𝕜] α →ᵇ γ :=
  LinearMap.mkContinuous
    { toFun := fun f =>
        ofNormedAddCommGroup (g ∘ f) (g.Continuous.comp f.Continuous) (‖g‖ * ‖f‖) fun x =>
          g.le_op_norm_of_le (f.norm_coe_le_norm x)
      map_add' := fun f g => by ext <;> simp
      map_smul' := fun c f => by ext <;> simp } ‖g‖ fun f =>
    norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg g) (norm_nonneg f)) _
#align continuous_linear_map.comp_left_continuous_bounded ContinuousLinearMap.compLeftContinuousBounded

/- warning: continuous_linear_map.comp_left_continuous_bounded_apply -> ContinuousLinearMap.compLeftContinuousBounded_apply is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) {β : Type.{u2}} {γ : Type.{u3}} {𝕜 : Type.{u4}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : SeminormedAddCommGroup.{u2} β] [_inst_3 : NontriviallyNormedField.{u4} 𝕜] [_inst_4 : NormedSpace.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2] [_inst_5 : SeminormedAddCommGroup.{u3} γ] [_inst_6 : NormedSpace.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5] (g : ContinuousLinearMap.{u4, u4, u2, u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u3} γ (PseudoMetricSpace.toUniformSpace.{u3} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6)) (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (x : α), Eq.{succ u3} γ (coeFn.{succ (max u1 u3), max (succ u1) (succ u3)} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (fun (_x : BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) => α -> γ) (BoundedContinuousFunction.hasCoeToFun.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (ContinuousLinearMap.{u4, u4, max u1 u2, max u1 u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5)) (BoundedContinuousFunction.module.{u1, u2, u4} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (ContinuousLinearMap.compLeftContinuousBounded._proof_1.{u4, u2} β 𝕜 _inst_2 _inst_3 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.module.{u1, u3, u4} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6) (ContinuousLinearMap.compLeftContinuousBounded._proof_2.{u4, u3} γ 𝕜 _inst_3 _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5))) (fun (_x : ContinuousLinearMap.{u4, u4, max u1 u2, max u1 u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5)) (BoundedContinuousFunction.module.{u1, u2, u4} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (ContinuousLinearMap.compLeftContinuousBounded._proof_1.{u4, u2} β 𝕜 _inst_2 _inst_3 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.module.{u1, u3, u4} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6) (ContinuousLinearMap.compLeftContinuousBounded._proof_2.{u4, u3} γ 𝕜 _inst_3 _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5))) => (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) -> (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5))) (ContinuousLinearMap.toFun.{u4, u4, max u1 u2, max u1 u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5)))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u3} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5)) (BoundedContinuousFunction.module.{u1, u2, u4} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (ContinuousLinearMap.compLeftContinuousBounded._proof_1.{u4, u2} β 𝕜 _inst_2 _inst_3 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_2)) (BoundedContinuousFunction.module.{u1, u3, u4} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u4} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u4} 𝕜 (NormedCommRing.toSeminormedCommRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6) (ContinuousLinearMap.compLeftContinuousBounded._proof_2.{u4, u3} γ 𝕜 _inst_3 _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} γ _inst_5))) (ContinuousLinearMap.compLeftContinuousBounded.{u1, u2, u3, u4} α β γ 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g) f) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (ContinuousLinearMap.{u4, u4, u2, u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u3} γ (PseudoMetricSpace.toUniformSpace.{u3} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6)) (fun (_x : ContinuousLinearMap.{u4, u4, u2, u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u3} γ (PseudoMetricSpace.toUniformSpace.{u3} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6)) => β -> γ) (ContinuousLinearMap.toFun.{u4, u4, u2, u3} 𝕜 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))) (RingHom.id.{u4} 𝕜 (Semiring.toNonAssocSemiring.{u4} 𝕜 (Ring.toSemiring.{u4} 𝕜 (NormedRing.toRing.{u4} 𝕜 (NormedCommRing.toNormedRing.{u4} 𝕜 (NormedField.toNormedCommRing.{u4} 𝕜 (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u3} γ (PseudoMetricSpace.toUniformSpace.{u3} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u3} γ (SeminormedAddCommGroup.toAddCommGroup.{u3} γ _inst_5)) (NormedSpace.toModule.{u4, u2} 𝕜 β (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u4, u3} 𝕜 γ (NontriviallyNormedField.toNormedField.{u4} 𝕜 _inst_3) _inst_5 _inst_6)) g (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_2)) f x))
but is expected to have type
  forall (α : Type.{u2}) {β : Type.{u3}} {γ : Type.{u4}} {𝕜 : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : SeminormedAddCommGroup.{u3} β] [_inst_3 : NontriviallyNormedField.{u1} 𝕜] [_inst_4 : NormedSpace.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2] [_inst_5 : SeminormedAddCommGroup.{u4} γ] [_inst_6 : NormedSpace.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5] (g : ContinuousLinearMap.{u1, u1, u3, u4} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6)) (f : BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (x : α), Eq.{succ u4} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => γ) x) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u4, u2, u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) α γ _inst_1 (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u4, u2, u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), max (succ u2) (succ u4)} (ContinuousLinearMap.{u1, u1, max u3 u2, max u4 u2} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5)) (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.boundedSMul.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.module.{u2, u4, u1} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (NormedSpace.boundedSMul.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5))) (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (fun (_x : BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) => BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, max u2 u4} (ContinuousLinearMap.{u1, u1, max u3 u2, max u4 u2} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5)) (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.boundedSMul.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.module.{u2, u4, u1} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (NormedSpace.boundedSMul.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5))) (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)))) (UniformSpace.toTopologicalSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)))) (ContinuousSemilinearMapClass.toContinuousMapClass.{max (max u2 u3) u4, u1, u1, max u2 u3, max u2 u4} (ContinuousLinearMap.{u1, u1, max u3 u2, max u4 u2} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5)) (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.boundedSMul.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.module.{u2, u4, u1} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (NormedSpace.boundedSMul.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5))) 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5)) (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.boundedSMul.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.module.{u2, u4, u1} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (NormedSpace.boundedSMul.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5)) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, max u2 u3, max u2 u4} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (UniformSpace.toTopologicalSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (PseudoMetricSpace.toUniformSpace.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (UniformSpace.toTopologicalSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (PseudoMetricSpace.toUniformSpace.{max u2 u4} (BoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5)))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u2, u4} α γ _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5)) (BoundedContinuousFunction.module.{u2, u3, u1} α β 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.boundedSMul.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (SeminormedAddCommGroup.to_lipschitzAdd.{u3} β _inst_2)) (BoundedContinuousFunction.module.{u2, u4, u1} α γ 𝕜 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (NormedSpace.boundedSMul.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (SeminormedAddCommGroup.to_lipschitzAdd.{u4} γ _inst_5))))) (ContinuousLinearMap.compLeftContinuousBounded.{u2, u3, u4, u1} α β γ 𝕜 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g) f) x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (ContinuousLinearMap.{u1, u1, u3, u4} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6)) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u3 u4, u3, u4} (ContinuousLinearMap.{u1, u1, u3, u4} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6)) β γ (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (ContinuousSemilinearMapClass.toContinuousMapClass.{max u3 u4, u1, u1, u3, u4} (ContinuousLinearMap.{u1, u1, u3, u4} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6)) 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u3, u4} 𝕜 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))) (RingHom.id.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3))))))) β (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (AddCommGroup.toAddCommMonoid.{u3} β (SeminormedAddCommGroup.toAddCommGroup.{u3} β _inst_2)) γ (UniformSpace.toTopologicalSpace.{u4} γ (PseudoMetricSpace.toUniformSpace.{u4} γ (SeminormedAddCommGroup.toPseudoMetricSpace.{u4} γ _inst_5))) (AddCommGroup.toAddCommMonoid.{u4} γ (SeminormedAddCommGroup.toAddCommGroup.{u4} γ _inst_5)) (NormedSpace.toModule.{u1, u3} 𝕜 β (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_2 _inst_4) (NormedSpace.toModule.{u1, u4} 𝕜 γ (NontriviallyNormedField.toNormedField.{u1} 𝕜 _inst_3) _inst_5 _inst_6)))) g (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) α β _inst_1 (UniformSpace.toTopologicalSpace.{u3} β (PseudoMetricSpace.toUniformSpace.{u3} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_2)))) f x))
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.comp_left_continuous_bounded_apply ContinuousLinearMap.compLeftContinuousBounded_applyₓ'. -/
@[simp]
theorem ContinuousLinearMap.compLeftContinuousBounded_apply (g : β →L[𝕜] γ) (f : α →ᵇ β) (x : α) :
    (g.compLeftContinuousBounded α f) x = g (f x) :=
  rfl
#align continuous_linear_map.comp_left_continuous_bounded_apply ContinuousLinearMap.compLeftContinuousBounded_apply

end NormedSpace

section NormedRing

/-!
### Normed ring structure

In this section, if `R` is a normed ring, then we show that the space of bounded
continuous functions from `α` to `R` inherits a normed ring structure, by using
pointwise operations and checking that they are compatible with the uniform distance. -/


variable [TopologicalSpace α] {R : Type _}

section NonUnital

section SemiNormed

variable [NonUnitalSeminormedRing R]

instance : Mul (α →ᵇ R)
    where mul f g :=
    ofNormedAddCommGroup (f * g) (f.Continuous.mul g.Continuous) (‖f‖ * ‖g‖) fun x =>
      le_trans (norm_mul_le (f x) (g x)) <|
        mul_le_mul (f.norm_coe_le_norm x) (g.norm_coe_le_norm x) (norm_nonneg _) (norm_nonneg _)

/- warning: bounded_continuous_function.coe_mul -> BoundedContinuousFunction.coe_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {R : Type.{u2}} [_inst_2 : NonUnitalSeminormedRing.{u2} R] (f : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)), Eq.{succ (max u1 u2)} (α -> R) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (instHMul.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasMul.{u1, u2} α _inst_1 R _inst_2)) f g)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (α -> R) (α -> R) (α -> R) (instHMul.{max u1 u2} (α -> R) (Pi.instMul.{u1, u2} α (fun (ᾰ : α) => R) (fun (i : α) => Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (NonUnitalSeminormedRing.toNonUnitalRing.{u2} R _inst_2))))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) f) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) g))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} α] {R : Type.{u1}} [_inst_2 : NonUnitalSeminormedRing.{u1} R] (f : BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (g : BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (instHMul.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.instMulBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α _inst_1 R _inst_2)) f g)) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (instHMul.{max u2 u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (Pi.instMul.{u2, u1} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (fun (i : α) => NonUnitalNonAssocRing.toMul.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (NonUnitalRing.toNonUnitalNonAssocRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (NonUnitalSeminormedRing.toNonUnitalRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) _inst_2))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_mul BoundedContinuousFunction.coe_mulₓ'. -/
@[simp]
theorem coe_mul (f g : α →ᵇ R) : ⇑(f * g) = f * g :=
  rfl
#align bounded_continuous_function.coe_mul BoundedContinuousFunction.coe_mul

/- warning: bounded_continuous_function.mul_apply -> BoundedContinuousFunction.mul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {R : Type.{u2}} [_inst_2 : NonUnitalSeminormedRing.{u2} R] (f : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (g : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (x : α), Eq.{succ u2} R (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (instHMul.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasMul.{u1, u2} α _inst_1 R _inst_2)) f g) x) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (NonUnitalSeminormedRing.toNonUnitalRing.{u2} R _inst_2)))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) g x))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} α] {R : Type.{u1}} [_inst_2 : NonUnitalSeminormedRing.{u1} R] (f : BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (g : BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (x : α), Eq.{succ u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (instHMul.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.instMulBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α _inst_1 R _inst_2)) f g) x) (HMul.hMul.{u1, u1, u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) (instHMul.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) (NonUnitalNonAssocRing.toMul.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) (NonUnitalRing.toNonUnitalNonAssocRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) (NonUnitalSeminormedRing.toNonUnitalRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) x) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (NonUnitalSeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) g x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mul_apply BoundedContinuousFunction.mul_applyₓ'. -/
theorem mul_apply (f g : α →ᵇ R) (x : α) : (f * g) x = f x * g x :=
  rfl
#align bounded_continuous_function.mul_apply BoundedContinuousFunction.mul_apply

instance : NonUnitalRing (α →ᵇ R) :=
  FunLike.coe_injective.NonUnitalRing _ coe_zero coe_add coe_mul coe_neg coe_sub
    (fun _ _ => coe_nsmul _ _) fun _ _ => coe_zsmul _ _

instance : NonUnitalSeminormedRing (α →ᵇ R) :=
  { BoundedContinuousFunction.seminormedAddCommGroup with
    norm_mul := fun f g =>
      norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _ }

end SemiNormed

instance [NonUnitalNormedRing R] : NonUnitalNormedRing (α →ᵇ R) :=
  { BoundedContinuousFunction.nonUnitalSemiNormedRing,
    BoundedContinuousFunction.normedAddCommGroup with }

end NonUnital

section SemiNormed

variable [SeminormedRing R]

/- warning: bounded_continuous_function.coe_npow_rec -> BoundedContinuousFunction.coe_npowRec is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {R : Type.{u2}} [_inst_2 : SeminormedRing.{u2} R] (f : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (n : Nat), Eq.{succ (max u1 u2)} (α -> R) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (npowRec.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasOne.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2) (AddMonoidWithOne.toOne.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (SeminormedRing.toRing.{u2} R _inst_2)))))) (BoundedContinuousFunction.hasMul.{u1, u2} α _inst_1 R (SeminormedRing.toNonUnitalSeminormedRing.{u2} R _inst_2)) n f)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (α -> R) Nat (α -> R) (instHPow.{max u1 u2, 0} (α -> R) Nat (Pi.hasPow.{u1, u2, 0} α Nat (fun (ᾰ : α) => R) (fun (i : α) => Monoid.Pow.{u2} R (Ring.toMonoid.{u2} R (SeminormedRing.toRing.{u2} R _inst_2))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) f) n)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} α] {R : Type.{u1}} [_inst_2 : SeminormedRing.{u1} R] (f : BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (n : Nat), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) (npowRec.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.instOneBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R (SeminormedRing.toRing.{u1} R _inst_2)))) (BoundedContinuousFunction.instMulBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α _inst_1 R (SeminormedRing.toNonUnitalSeminormedRing.{u1} R _inst_2)) n f)) (HPow.hPow.{max u2 u1, 0, max u2 u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) Nat (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (instHPow.{max u2 u1, 0} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) Nat (Pi.instPow.{u2, u1, 0} α Nat (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (fun (i : α) => Monoid.Pow.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (MonoidWithZero.toMonoid.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (Semiring.toMonoidWithZero.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (Ring.toSemiring.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (SeminormedRing.toRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) _inst_2))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) f) n)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_npow_rec BoundedContinuousFunction.coe_npowRecₓ'. -/
@[simp]
theorem coe_npowRec (f : α →ᵇ R) : ∀ n, ⇑(npowRec n f) = f ^ n
  | 0 => by rw [npowRec, pow_zero, coe_one]
  | n + 1 => by rw [npowRec, pow_succ, coe_mul, coe_npow_rec]
#align bounded_continuous_function.coe_npow_rec BoundedContinuousFunction.coe_npowRec

#print BoundedContinuousFunction.hasNatPow /-
instance hasNatPow : Pow (α →ᵇ R) ℕ
    where pow f n :=
    { toContinuousMap := f.toContinuousMap ^ n
      map_bounded' := by simpa [coe_npow_rec] using (npowRec n f).map_bounded' }
#align bounded_continuous_function.has_nat_pow BoundedContinuousFunction.hasNatPow
-/

/- warning: bounded_continuous_function.coe_pow -> BoundedContinuousFunction.coe_pow is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {R : Type.{u2}} [_inst_2 : SeminormedRing.{u2} R] (n : Nat) (f : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)), Eq.{succ (max u1 u2)} (α -> R) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (instHPow.{max u1 u2, 0} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) Nat (BoundedContinuousFunction.hasNatPow.{u1, u2} α _inst_1 R _inst_2)) f n)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (α -> R) Nat (α -> R) (instHPow.{max u1 u2, 0} (α -> R) Nat (Pi.hasPow.{u1, u2, 0} α Nat (fun (ᾰ : α) => R) (fun (i : α) => Monoid.Pow.{u2} R (Ring.toMonoid.{u2} R (SeminormedRing.toRing.{u2} R _inst_2))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) f) n)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} α] {R : Type.{u1}} [_inst_2 : SeminormedRing.{u1} R] (n : Nat) (f : BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) (HPow.hPow.{max u2 u1, 0, max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) Nat (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (instHPow.{max u2 u1, 0} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) Nat (BoundedContinuousFunction.hasNatPow.{u2, u1} α _inst_1 R _inst_2)) f n)) (HPow.hPow.{max u2 u1, 0, max u2 u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) Nat (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (instHPow.{max u2 u1, 0} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) Nat (Pi.instPow.{u2, u1, 0} α Nat (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) ᾰ) (fun (i : α) => Monoid.Pow.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (MonoidWithZero.toMonoid.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (Semiring.toMonoidWithZero.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (Ring.toSemiring.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (SeminormedRing.toRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) _inst_2))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) f) n)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_pow BoundedContinuousFunction.coe_powₓ'. -/
@[simp]
theorem coe_pow (n : ℕ) (f : α →ᵇ R) : ⇑(f ^ n) = f ^ n :=
  rfl
#align bounded_continuous_function.coe_pow BoundedContinuousFunction.coe_pow

/- warning: bounded_continuous_function.pow_apply -> BoundedContinuousFunction.pow_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {R : Type.{u2}} [_inst_2 : SeminormedRing.{u2} R] (n : Nat) (f : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (v : α), Eq.{succ u2} R (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (instHPow.{max u1 u2, 0} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) Nat (BoundedContinuousFunction.hasNatPow.{u1, u2} α _inst_1 R _inst_2)) f n) v) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (Ring.toMonoid.{u2} R (SeminormedRing.toRing.{u2} R _inst_2)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) f v) n)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} α] {R : Type.{u1}} [_inst_2 : SeminormedRing.{u1} R] (n : Nat) (f : BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (v : α), Eq.{succ u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) (HPow.hPow.{max u2 u1, 0, max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) Nat (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (instHPow.{max u2 u1, 0} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) Nat (BoundedContinuousFunction.hasNatPow.{u2, u1} α _inst_1 R _inst_2)) f n) v) (HPow.hPow.{u1, 0, u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) Nat ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) (instHPow.{u1, 0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) Nat (Monoid.Pow.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) (MonoidWithZero.toMonoid.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) (Semiring.toMonoidWithZero.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) (Ring.toSemiring.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) (SeminormedRing.toRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) v) _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) f v) n)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.pow_apply BoundedContinuousFunction.pow_applyₓ'. -/
@[simp]
theorem pow_apply (n : ℕ) (f : α →ᵇ R) (v : α) : (f ^ n) v = f v ^ n :=
  rfl
#align bounded_continuous_function.pow_apply BoundedContinuousFunction.pow_apply

instance : NatCast (α →ᵇ R) :=
  ⟨fun n => BoundedContinuousFunction.const _ n⟩

/- warning: bounded_continuous_function.coe_nat_cast -> BoundedContinuousFunction.coe_natCast is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {R : Type.{u2}} [_inst_2 : SeminormedRing.{u2} R] (n : Nat), Eq.{max (succ u1) (succ u2)} ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Nat.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasNatCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Nat.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasNatCast.{u1, u2} α _inst_1 R _inst_2)))) n)) ((fun (a : Type) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{1, max (succ u1) (succ u2)} a b] => self.0) Nat ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Nat.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasNatCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (HasLiftT.mk.{1, max (succ u1) (succ u2)} Nat ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Nat.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasNatCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (CoeTCₓ.coe.{1, max (succ u1) (succ u2)} Nat ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Nat.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasNatCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (Nat.castCoe.{max u1 u2} ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Nat (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Nat.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasNatCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (Pi.hasNatCast.{u1, u2} α (fun (ᾰ : α) => R) (fun (a : α) => AddMonoidWithOne.toNatCast.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (SeminormedRing.toRing.{u2} R _inst_2))))))))) n)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} α] {R : Type.{u1}} [_inst_2 : SeminormedRing.{u1} R] (n : Nat), Eq.{max (succ u2) (succ u1)} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) (Nat.cast.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.instNatCastBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α _inst_1 R _inst_2) n)) (Nat.cast.{max u2 u1} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (Pi.natCast.{u2, u1} α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (fun (a : α) => Semiring.toNatCast.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (Ring.toSemiring.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (SeminormedRing.toRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) _inst_2)))) n)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_nat_cast BoundedContinuousFunction.coe_natCastₓ'. -/
@[simp, norm_cast]
theorem coe_natCast (n : ℕ) : ((n : α →ᵇ R) : α → R) = n :=
  rfl
#align bounded_continuous_function.coe_nat_cast BoundedContinuousFunction.coe_natCast

instance : IntCast (α →ᵇ R) :=
  ⟨fun n => BoundedContinuousFunction.const _ n⟩

/- warning: bounded_continuous_function.coe_int_cast -> BoundedContinuousFunction.coe_intCast is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] {R : Type.{u2}} [_inst_2 : SeminormedRing.{u2} R] (n : Int), Eq.{max (succ u1) (succ u2)} ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Int.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasIntCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Int.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasIntCast.{u1, u2} α _inst_1 R _inst_2)))) n)) ((fun (a : Type) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{1, max (succ u1) (succ u2)} a b] => self.0) Int ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Int.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasIntCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (HasLiftT.mk.{1, max (succ u1) (succ u2)} Int ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Int.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasIntCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (CoeTCₓ.coe.{1, max (succ u1) (succ u2)} Int ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Int.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasIntCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (Int.castCoe.{max u1 u2} ((fun (_x : BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) => α -> R) ((fun (a : Type) (b : Type.{max u1 u2}) [self : HasLiftT.{1, succ (max u1 u2)} a b] => self.0) Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (HasLiftT.mk.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (CoeTCₓ.coe.{1, succ (max u1 u2)} Int (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (Int.castCoe.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u2} R _inst_2)) (BoundedContinuousFunction.hasIntCast.{u1, u2} α _inst_1 R _inst_2)))) n)) (Pi.hasIntCast.{u1, u2} α (fun (ᾰ : α) => R) (fun (i : α) => AddGroupWithOne.toHasIntCast.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (SeminormedRing.toRing.{u2} R _inst_2)))))))) n)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} α] {R : Type.{u1}} [_inst_2 : SeminormedRing.{u1} R] (n : Int), Eq.{max (succ u2) (succ u1)} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (UniformSpace.toTopologicalSpace.{u1} R (PseudoMetricSpace.toUniformSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u1, u2, u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)))) (Int.cast.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α R _inst_1 (SeminormedRing.toPseudoMetricSpace.{u1} R _inst_2)) (BoundedContinuousFunction.instIntCastBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α _inst_1 R _inst_2) n)) (Int.cast.{max u2 u1} (forall (a : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (Pi.intCast.{u2, u1} α (fun (a : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) a) (fun (i : α) => Ring.toIntCast.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) (SeminormedRing.toRing.{u1} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => R) i) _inst_2))) n)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_int_cast BoundedContinuousFunction.coe_intCastₓ'. -/
@[simp, norm_cast]
theorem coe_intCast (n : ℤ) : ((n : α →ᵇ R) : α → R) = n :=
  rfl
#align bounded_continuous_function.coe_int_cast BoundedContinuousFunction.coe_intCast

instance : Ring (α →ᵇ R) :=
  FunLike.coe_injective.Ring _ coe_zero coe_one coe_add coe_mul coe_neg coe_sub
    (fun _ _ => coe_nsmul _ _) (fun _ _ => coe_zsmul _ _) (fun _ _ => coe_pow _ _) coe_natCast
    coe_intCast

instance : SeminormedRing (α →ᵇ R) :=
  { BoundedContinuousFunction.nonUnitalSemiNormedRing with }

end SemiNormed

instance [NormedRing R] : NormedRing (α →ᵇ R) :=
  { BoundedContinuousFunction.nonUnitalNormedRing with }

end NormedRing

section NormedCommRing

/-!
### Normed commutative ring structure

In this section, if `R` is a normed commutative ring, then we show that the space of bounded
continuous functions from `α` to `R` inherits a normed commutative ring structure, by using
pointwise operations and checking that they are compatible with the uniform distance. -/


variable [TopologicalSpace α] {R : Type _}

instance [SeminormedCommRing R] : CommRing (α →ᵇ R) :=
  { BoundedContinuousFunction.ring with mul_comm := fun f₁ f₂ => ext fun x => mul_comm _ _ }

instance [SeminormedCommRing R] : SeminormedCommRing (α →ᵇ R) :=
  { BoundedContinuousFunction.commRing, BoundedContinuousFunction.seminormedAddCommGroup with }

instance [NormedCommRing R] : NormedCommRing (α →ᵇ R) :=
  { BoundedContinuousFunction.commRing, BoundedContinuousFunction.normedAddCommGroup with }

end NormedCommRing

section NormedAlgebra

/-!
### Normed algebra structure

In this section, if `γ` is a normed algebra, then we show that the space of bounded
continuous functions from `α` to `γ` inherits a normed algebra structure, by using
pointwise operations and checking that they are compatible with the uniform distance. -/


variable {𝕜 : Type _} [NormedField 𝕜]

variable [TopologicalSpace α] [SeminormedAddCommGroup β] [NormedSpace 𝕜 β]

variable [NormedRing γ] [NormedAlgebra 𝕜 γ]

variable {f g : α →ᵇ γ} {x : α} {c : 𝕜}

#print BoundedContinuousFunction.C /-
/-- `bounded_continuous_function.const` as a `ring_hom`. -/
def C : 𝕜 →+* α →ᵇ γ where
  toFun := fun c : 𝕜 => const α ((algebraMap 𝕜 γ) c)
  map_one' := ext fun x => (algebraMap 𝕜 γ).map_one
  map_mul' c₁ c₂ := ext fun x => (algebraMap 𝕜 γ).map_mul _ _
  map_zero' := ext fun x => (algebraMap 𝕜 γ).map_zero
  map_add' c₁ c₂ := ext fun x => (algebraMap 𝕜 γ).map_add _ _
#align bounded_continuous_function.C BoundedContinuousFunction.C
-/

instance : Algebra 𝕜 (α →ᵇ γ) :=
  { BoundedContinuousFunction.module,
    BoundedContinuousFunction.ring with
    toRingHom := C
    commutes' := fun c f => ext fun x => Algebra.commutes' _ _
    smul_def' := fun c f => ext fun x => Algebra.smul_def' _ _ }

/- warning: bounded_continuous_function.algebra_map_apply -> BoundedContinuousFunction.algebraMap_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {γ : Type.{u2}} {𝕜 : Type.{u3}} [_inst_1 : NormedField.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_5 : NormedRing.{u2} γ] [_inst_6 : NormedAlgebra.{u3, u2} 𝕜 γ _inst_1 (NormedRing.toSeminormedRing.{u2} γ _inst_5)] (k : 𝕜) (a : α), Eq.{succ u2} γ (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (fun (_x : BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) => α -> γ) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (RingHom.{u3, max u1 u2} 𝕜 (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (Semiring.toNonAssocSemiring.{u3} 𝕜 (CommSemiring.toSemiring.{u3} 𝕜 (Semifield.toCommSemiring.{u3} 𝕜 (Field.toSemifield.{u3} 𝕜 (NormedField.toField.{u3} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (Ring.toSemiring.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (BoundedContinuousFunction.ring.{u1, u2} α _inst_2 γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))))) (fun (_x : RingHom.{u3, max u1 u2} 𝕜 (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (Semiring.toNonAssocSemiring.{u3} 𝕜 (CommSemiring.toSemiring.{u3} 𝕜 (Semifield.toCommSemiring.{u3} 𝕜 (Field.toSemifield.{u3} 𝕜 (NormedField.toField.{u3} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (Ring.toSemiring.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (BoundedContinuousFunction.ring.{u1, u2} α _inst_2 γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))))) => 𝕜 -> (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5)))) (RingHom.hasCoeToFun.{u3, max u1 u2} 𝕜 (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (Semiring.toNonAssocSemiring.{u3} 𝕜 (CommSemiring.toSemiring.{u3} 𝕜 (Semifield.toCommSemiring.{u3} 𝕜 (Field.toSemifield.{u3} 𝕜 (NormedField.toField.{u3} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (Ring.toSemiring.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (BoundedContinuousFunction.ring.{u1, u2} α _inst_2 γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))))) (algebraMap.{u3, max u1 u2} 𝕜 (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (Semifield.toCommSemiring.{u3} 𝕜 (Field.toSemifield.{u3} 𝕜 (NormedField.toField.{u3} 𝕜 _inst_1))) (Ring.toSemiring.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u2} γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (BoundedContinuousFunction.ring.{u1, u2} α _inst_2 γ (NormedRing.toSeminormedRing.{u2} γ _inst_5))) (BoundedContinuousFunction.algebra.{u1, u2, u3} α γ 𝕜 _inst_1 _inst_2 _inst_5 _inst_6)) k) a) (SMul.smul.{u3, u2} 𝕜 γ (SMulZeroClass.toHasSmul.{u3, u2} 𝕜 γ (AddZeroClass.toHasZero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ (SeminormedAddCommGroup.toAddCommGroup.{u2} γ (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} γ (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} γ (NormedRing.toNonUnitalNormedRing.{u2} γ _inst_5)))))))) (SMulWithZero.toSmulZeroClass.{u3, u2} 𝕜 γ (MulZeroClass.toHasZero.{u3} 𝕜 (MulZeroOneClass.toMulZeroClass.{u3} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 (NormedRing.toRing.{u3} 𝕜 (NormedCommRing.toNormedRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1)))))))) (AddZeroClass.toHasZero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ (SeminormedAddCommGroup.toAddCommGroup.{u2} γ (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} γ (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} γ (NormedRing.toNonUnitalNormedRing.{u2} γ _inst_5)))))))) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 γ (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 (NormedRing.toRing.{u3} 𝕜 (NormedCommRing.toNormedRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ (SeminormedAddCommGroup.toAddCommGroup.{u2} γ (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} γ (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} γ (NormedRing.toNonUnitalNormedRing.{u2} γ _inst_5)))))))) (Module.toMulActionWithZero.{u3, u2} 𝕜 γ (Ring.toSemiring.{u3} 𝕜 (NormedRing.toRing.{u3} 𝕜 (NormedCommRing.toNormedRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} γ (SeminormedAddCommGroup.toAddCommGroup.{u2} γ (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} γ (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} γ (NormedRing.toNonUnitalNormedRing.{u2} γ _inst_5))))) (NormedSpace.toModule.{u3, u2} 𝕜 γ _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u2} γ (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u2} γ (NormedRing.toNonUnitalNormedRing.{u2} γ _inst_5))) (NormedAlgebra.toNormedSpace'.{u3, u2} 𝕜 _inst_1 γ _inst_5 _inst_6)))))) k (OfNat.ofNat.{u2} γ 1 (OfNat.mk.{u2} γ 1 (One.one.{u2} γ (AddMonoidWithOne.toOne.{u2} γ (AddGroupWithOne.toAddMonoidWithOne.{u2} γ (AddCommGroupWithOne.toAddGroupWithOne.{u2} γ (Ring.toAddCommGroupWithOne.{u2} γ (NormedRing.toRing.{u2} γ _inst_5)))))))))
but is expected to have type
  forall {α : Type.{u2}} {γ : Type.{u3}} {𝕜 : Type.{u1}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : TopologicalSpace.{u2} α] [_inst_5 : NormedRing.{u3} γ] [_inst_6 : NormedAlgebra.{u1, u3} 𝕜 γ _inst_1 (NormedRing.toSeminormedRing.{u3} γ _inst_5)] (k : 𝕜) (a : α), Eq.{succ u3} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => γ) a) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) α γ _inst_2 (UniformSpace.toTopologicalSpace.{u3} γ (PseudoMetricSpace.toUniformSpace.{u3} γ (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5)))) (BoundedContinuousMapClass.toContinuousMapClass.{max u2 u3, u2, u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5)) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u1, max (succ u2) (succ u3)} (RingHom.{u1, max u3 u2} 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))))) 𝕜 (fun (_x : 𝕜) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : 𝕜) => BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) _x) (MulHomClass.toFunLike.{max (max u2 u3) u1, u1, max u2 u3} (RingHom.{u1, max u3 u2} 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))))) 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (NonUnitalNonAssocSemiring.toMul.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))))) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5)))))) (NonUnitalRingHomClass.toMulHomClass.{max (max u2 u3) u1, u1, max u2 u3} (RingHom.{u1, max u3 u2} 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))))) 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))))) (RingHomClass.toNonUnitalRingHomClass.{max (max u2 u3) u1, u1, max u2 u3} (RingHom.{u1, max u3 u2} 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))))) 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5)))) (RingHom.instRingHomClassRingHom.{u1, max u2 u3} 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semiring.toNonAssocSemiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))))) (Semiring.toNonAssocSemiring.{max u3 u2} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5)))))))) (algebraMap.{u1, max u3 u2} 𝕜 (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α γ _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.ring.{u2, u3} α _inst_2 γ (NormedRing.toSeminormedRing.{u3} γ _inst_5))) (BoundedContinuousFunction.algebra.{u2, u3, u1} α γ 𝕜 _inst_1 _inst_2 _inst_5 _inst_6)) k) a) (HSMul.hSMul.{u1, u3, u3} 𝕜 γ γ (instHSMul.{u1, u3} 𝕜 γ (Algebra.toSMul.{u1, u3} 𝕜 γ (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 (NormedField.toField.{u1} 𝕜 _inst_1))) (Ring.toSemiring.{u3} γ (NormedRing.toRing.{u3} γ _inst_5)) (NormedAlgebra.toAlgebra.{u1, u3} 𝕜 γ _inst_1 (NormedRing.toSeminormedRing.{u3} γ _inst_5) _inst_6))) k (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Semiring.toOne.{u3} γ (Ring.toSemiring.{u3} γ (NormedRing.toRing.{u3} γ _inst_5))))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.algebra_map_apply BoundedContinuousFunction.algebraMap_applyₓ'. -/
@[simp]
theorem algebraMap_apply (k : 𝕜) (a : α) : algebraMap 𝕜 (α →ᵇ γ) k a = k • 1 :=
  by
  rw [Algebra.algebraMap_eq_smul_one]
  rfl
#align bounded_continuous_function.algebra_map_apply BoundedContinuousFunction.algebraMap_apply

instance : NormedAlgebra 𝕜 (α →ᵇ γ) :=
  { BoundedContinuousFunction.normedSpace with }

/-!
### Structure as normed module over scalar functions

If `β` is a normed `𝕜`-space, then we show that the space of bounded continuous
functions from `α` to `β` is naturally a module over the algebra of bounded continuous
functions from `α` to `𝕜`. -/


#print BoundedContinuousFunction.hasSmul' /-
instance hasSmul' : SMul (α →ᵇ 𝕜) (α →ᵇ β) :=
  ⟨fun (f : α →ᵇ 𝕜) (g : α →ᵇ β) =>
    ofNormedAddCommGroup (fun x => f x • g x) (f.Continuous.smul g.Continuous) (‖f‖ * ‖g‖) fun x =>
      calc
        ‖f x • g x‖ ≤ ‖f x‖ * ‖g x‖ := norm_smul_le _ _
        _ ≤ ‖f‖ * ‖g‖ :=
          mul_le_mul (f.norm_coe_le_norm _) (g.norm_coe_le_norm _) (norm_nonneg _) (norm_nonneg _)
        ⟩
#align bounded_continuous_function.has_smul' BoundedContinuousFunction.hasSmul'
-/

/- warning: bounded_continuous_function.module' -> BoundedContinuousFunction.module' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {𝕜 : Type.{u3}} [_inst_1 : NormedField.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : SeminormedAddCommGroup.{u2} β] [_inst_4 : NormedSpace.{u3, u2} 𝕜 β _inst_1 _inst_3], Module.{max u1 u3, max u1 u2} (BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3)) (Ring.toSemiring.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.ring.{u1, u3} α _inst_2 𝕜 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.addAddCommMonoid.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_3)) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {𝕜 : Type.{u3}} [_inst_1 : NormedField.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : SeminormedAddCommGroup.{u2} β] [_inst_4 : NormedSpace.{u3, u2} 𝕜 β _inst_1 _inst_3], Module.{max u3 u1, max u2 u1} (BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSeminormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSeminormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (CommRing.toCommSemiring.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSeminormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.commRing.{u1, u3} α _inst_2 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3) (AddCommGroup.toAddCommMonoid.{u2} β (SeminormedAddCommGroup.toAddCommGroup.{u2} β _inst_3)) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_3))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.module' BoundedContinuousFunction.module'ₓ'. -/
instance module' : Module (α →ᵇ 𝕜) (α →ᵇ β) :=
  Module.ofCore <|
    { smul := (· • ·)
      smul_add := fun c f₁ f₂ => ext fun x => smul_add _ _ _
      add_smul := fun c₁ c₂ f => ext fun x => add_smul _ _ _
      mul_smul := fun c₁ c₂ f => ext fun x => mul_smul _ _ _
      one_smul := fun f => ext fun x => one_smul 𝕜 (f x) }
#align bounded_continuous_function.module' BoundedContinuousFunction.module'

/- warning: bounded_continuous_function.norm_smul_le -> BoundedContinuousFunction.norm_smul_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {𝕜 : Type.{u3}} [_inst_1 : NormedField.{u3} 𝕜] [_inst_2 : TopologicalSpace.{u1} α] [_inst_3 : SeminormedAddCommGroup.{u2} β] [_inst_4 : NormedSpace.{u3, u2} 𝕜 β _inst_1 _inst_3] (f : BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (g : BoundedContinuousFunction.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3)), LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_2 _inst_3) (SMul.smul.{max u1 u3, max u1 u2} (BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.hasSmul'.{u1, u2, u3} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4) f g)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{max u1 u3} (BoundedContinuousFunction.{u1, u3} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u3} 𝕜 (SeminormedCommRing.toSemiNormedRing.{u3} 𝕜 (NormedCommRing.toSeminormedCommRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1))))) (BoundedContinuousFunction.hasNorm.{u1, u3} α 𝕜 _inst_2 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u3} 𝕜 (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u3} 𝕜 (NormedRing.toNonUnitalNormedRing.{u3} 𝕜 (NormedCommRing.toNormedRing.{u3} 𝕜 (NormedField.toNormedCommRing.{u3} 𝕜 _inst_1)))))) f) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.hasNorm.{u1, u2} α β _inst_2 _inst_3) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {𝕜 : Type.{u1}} [_inst_1 : NormedField.{u1} 𝕜] [_inst_2 : TopologicalSpace.{u2} α] [_inst_3 : SeminormedAddCommGroup.{u3} β] [_inst_4 : NormedSpace.{u1, u3} 𝕜 β _inst_1 _inst_3] (f : BoundedContinuousFunction.{u2, u1} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (g : BoundedContinuousFunction.{u2, u3} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_3)), LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_3)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u2, u3} α β _inst_2 _inst_3) (HSMul.hSMul.{max u2 u1, max u2 u3, max u2 u3} (BoundedContinuousFunction.{u2, u1} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (BoundedContinuousFunction.{u2, u3} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_3)) (BoundedContinuousFunction.{u2, u3} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_3)) (instHSMul.{max u2 u1, max u2 u3} (BoundedContinuousFunction.{u2, u1} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (BoundedContinuousFunction.{u2, u3} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_3)) (BoundedContinuousFunction.hasSmul'.{u2, u3, u1} α β 𝕜 _inst_1 _inst_2 _inst_3 _inst_4)) f g)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α 𝕜 _inst_2 (SeminormedRing.toPseudoMetricSpace.{u1} 𝕜 (SeminormedCommRing.toSeminormedRing.{u1} 𝕜 (NormedCommRing.toSeminormedCommRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1))))) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α 𝕜 _inst_2 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{u1} 𝕜 (NonUnitalNormedRing.toNonUnitalSeminormedRing.{u1} 𝕜 (NormedRing.toNonUnitalNormedRing.{u1} 𝕜 (NormedCommRing.toNormedRing.{u1} 𝕜 (NormedField.toNormedCommRing.{u1} 𝕜 _inst_1)))))) f) (Norm.norm.{max u2 u3} (BoundedContinuousFunction.{u2, u3} α β _inst_2 (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} β _inst_3)) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u2, u3} α β _inst_2 _inst_3) g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_smul_le BoundedContinuousFunction.norm_smul_leₓ'. -/
theorem norm_smul_le (f : α →ᵇ 𝕜) (g : α →ᵇ β) : ‖f • g‖ ≤ ‖f‖ * ‖g‖ :=
  norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _
#align bounded_continuous_function.norm_smul_le BoundedContinuousFunction.norm_smul_le

/- TODO: When `normed_module` has been added to `normed_space.basic`, the above facts
show that the space of bounded continuous functions from `α` to `β` is naturally a normed
module over the algebra of bounded continuous functions from `α` to `𝕜`. -/
end NormedAlgebra

/- warning: bounded_continuous_function.nnreal.upper_bound -> BoundedContinuousFunction.Nnreal.upper_bound is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (x : α), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) => α -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) f x) (NNDist.nndist.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (PseudoMetricSpace.toNNDist.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.pseudoMetricSpace.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace)) f (OfNat.ofNat.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) 0 (OfNat.mk.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) 0 (Zero.zero.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.hasZero.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) (x : α), LE.le.{0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) x) (Preorder.toLE.{0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) x) (PartialOrder.toPreorder.{0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) x) (StrictOrderedSemiring.toPartialOrder.{0} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) x) instNNRealStrictOrderedSemiring))) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal))) f x) (NNDist.nndist.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) (PseudoMetricSpace.toNNDist.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal)) f (OfNat.ofNat.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) 0 (Zero.toOfNat0.{u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) (BoundedContinuousFunction.instZeroBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealZero))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnreal.upper_bound BoundedContinuousFunction.Nnreal.upper_boundₓ'. -/
theorem Nnreal.upper_bound {α : Type _} [TopologicalSpace α] (f : α →ᵇ ℝ≥0) (x : α) :
    f x ≤ nndist f 0 :=
  by
  have key : nndist (f x) ((0 : α →ᵇ ℝ≥0) x) ≤ nndist f 0 := @dist_coe_le_dist α ℝ≥0 _ _ f 0 x
  simp only [coe_zero, Pi.zero_apply] at key
  rwa [NNReal.nndist_zero_eq_val' (f x)] at key
#align bounded_continuous_function.nnreal.upper_bound BoundedContinuousFunction.Nnreal.upper_bound

/-!
### Star structures

In this section, if `β` is a normed ⋆-group, then so is the space of bounded
continuous functions from `α` to `β`, by using the star operation pointwise.

If `𝕜` is normed field and a ⋆-ring over which `β` is a normed algebra and a
star module, then the space of bounded continuous functions from `α` to `β`
is a star module.

If `β` is a ⋆-ring in addition to being a normed ⋆-group, then `α →ᵇ β`
inherits a ⋆-ring structure.

In summary, if `β` is a C⋆-algebra over `𝕜`, then so is  `α →ᵇ β`; note that
completeness is guaranteed when `β` is complete (see
`bounded_continuous_function.complete`). -/


section NormedAddCommGroup

variable {𝕜 : Type _} [NormedField 𝕜] [StarRing 𝕜] [TopologicalSpace α] [SeminormedAddCommGroup β]
  [StarAddMonoid β] [NormedStarGroup β]

variable [NormedSpace 𝕜 β] [StarModule 𝕜 β]

instance : StarAddMonoid (α →ᵇ β)
    where
  unit f := f.comp star starNormedAddGroupHom.lipschitz
  star_involutive f := ext fun x => star_star (f x)
  star_add f g := ext fun x => star_add (f x) (g x)

/- warning: bounded_continuous_function.coe_star -> BoundedContinuousFunction.coe_star is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] [_inst_5 : StarAddMonoid.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4))))] [_inst_6 : NormedStarGroup.{u2} β _inst_4 _inst_5] (f : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (InvolutiveStar.toHasStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (StarAddMonoid.toHasInvolutiveStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (BoundedContinuousFunction.addMonoid.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_4)) (BoundedContinuousFunction.starAddMonoid.{u1, u2} α β _inst_3 _inst_4 _inst_5 _inst_6))) f)) (Star.star.{max u1 u2} (α -> β) (Pi.hasStar.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => InvolutiveStar.toHasStar.{u2} β (StarAddMonoid.toHasInvolutiveStar.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4)))) _inst_5))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] [_inst_5 : StarAddMonoid.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4))))] [_inst_6 : NormedStarGroup.{u2} β _inst_4 _inst_5] (f : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)))) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (InvolutiveStar.toStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (StarAddMonoid.toInvolutiveStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (BoundedContinuousFunction.addMonoid.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_4)) (BoundedContinuousFunction.starAddMonoid.{u1, u2} α β _inst_3 _inst_4 _inst_5 _inst_6))) f)) (Star.star.{max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (Pi.instStarForAll.{u1, u2} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => InvolutiveStar.toStar.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (StarAddMonoid.toInvolutiveStar.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_4)))) _inst_5))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_star BoundedContinuousFunction.coe_starₓ'. -/
/-- The right-hand side of this equality can be parsed `star ∘ ⇑f` because of the
instance `pi.has_star`. Upon inspecting the goal, one sees `⊢ ⇑(star f) = star ⇑f`.-/
@[simp]
theorem coe_star (f : α →ᵇ β) : ⇑(star f) = star f :=
  rfl
#align bounded_continuous_function.coe_star BoundedContinuousFunction.coe_star

/- warning: bounded_continuous_function.star_apply -> BoundedContinuousFunction.star_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] [_inst_5 : StarAddMonoid.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4))))] [_inst_6 : NormedStarGroup.{u2} β _inst_4 _inst_5] (f : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (x : α), Eq.{succ u2} β (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (InvolutiveStar.toHasStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (StarAddMonoid.toHasInvolutiveStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (BoundedContinuousFunction.addMonoid.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_4)) (BoundedContinuousFunction.starAddMonoid.{u1, u2} α β _inst_3 _inst_4 _inst_5 _inst_6))) f) x) (Star.star.{u2} β (InvolutiveStar.toHasStar.{u2} β (StarAddMonoid.toHasInvolutiveStar.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4)))) _inst_5)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} α] [_inst_4 : SeminormedAddCommGroup.{u2} β] [_inst_5 : StarAddMonoid.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4))))] [_inst_6 : NormedStarGroup.{u2} β _inst_4 _inst_5] (f : BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (x : α), Eq.{succ u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)))) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (InvolutiveStar.toStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (StarAddMonoid.toInvolutiveStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) (BoundedContinuousFunction.addMonoid.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β _inst_4)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β _inst_4)) (BoundedContinuousFunction.starAddMonoid.{u1, u2} α β _inst_3 _inst_4 _inst_5 _inst_6))) f) x) (Star.star.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (InvolutiveStar.toStar.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (StarAddMonoid.toInvolutiveStar.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SubNegMonoid.toAddMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) x) _inst_4)))) _inst_5)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)) α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_3 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β _inst_4)))) f x))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.star_apply BoundedContinuousFunction.star_applyₓ'. -/
@[simp]
theorem star_apply (f : α →ᵇ β) (x : α) : star f x = star (f x) :=
  rfl
#align bounded_continuous_function.star_apply BoundedContinuousFunction.star_apply

instance : NormedStarGroup (α →ᵇ β)
    where norm_star f := by simp only [norm_eq, star_apply, norm_star]

instance : StarModule 𝕜 (α →ᵇ β) where star_smul k f := ext fun x => star_smul k (f x)

end NormedAddCommGroup

section CstarRing

variable [TopologicalSpace α]

variable [NonUnitalNormedRing β] [StarRing β]

instance [NormedStarGroup β] : StarRing (α →ᵇ β) :=
  { BoundedContinuousFunction.starAddMonoid with
    star_mul := fun f g => ext fun x => star_mul (f x) (g x) }

variable [CstarRing β]

instance : CstarRing (α →ᵇ β)
    where norm_star_mul_self := by
    intro f
    refine' le_antisymm _ _
    · rw [← sq, norm_le (sq_nonneg _)]
      dsimp [star_apply]
      intro x
      rw [CstarRing.norm_star_mul_self, ← sq]
      refine' sq_le_sq' _ _
      · linarith [norm_nonneg (f x), norm_nonneg f]
      · exact norm_coe_le_norm f x
    · rw [← sq, ← Real.le_sqrt (norm_nonneg _) (norm_nonneg _), norm_le (Real.sqrt_nonneg _)]
      intro x
      rw [Real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, ← CstarRing.norm_star_mul_self]
      exact norm_coe_le_norm (star f * f) x

end CstarRing

section NormedLatticeOrderedGroup

variable [TopologicalSpace α] [NormedLatticeAddCommGroup β]

instance : PartialOrder (α →ᵇ β) :=
  PartialOrder.lift (fun f => f.toFun) (by tidy)

/-- Continuous normed lattice group valued functions form a meet-semilattice
-/
instance : SemilatticeInf (α →ᵇ β) :=
  {
    BoundedContinuousFunction.partialOrder with
    inf := fun f g =>
      { toFun := fun t => f t ⊓ g t
        continuous_toFun := f.Continuous.inf g.Continuous
        map_bounded' := by
          obtain ⟨C₁, hf⟩ := f.bounded
          obtain ⟨C₂, hg⟩ := g.bounded
          refine' ⟨C₁ + C₂, fun x y => _⟩
          simp_rw [NormedAddCommGroup.dist_eq] at hf hg⊢
          exact (norm_inf_sub_inf_le_add_norm _ _ _ _).trans (add_le_add (hf _ _) (hg _ _)) }
    inf_le_left := fun f g => ContinuousMap.le_def.mpr fun _ => inf_le_left
    inf_le_right := fun f g => ContinuousMap.le_def.mpr fun _ => inf_le_right
    le_inf := fun f g₁ g₂ w₁ w₂ =>
      ContinuousMap.le_def.mpr fun _ =>
        le_inf (ContinuousMap.le_def.mp w₁ _) (ContinuousMap.le_def.mp w₂ _) }

instance : SemilatticeSup (α →ᵇ β) :=
  {
    BoundedContinuousFunction.partialOrder with
    sup := fun f g =>
      { toFun := fun t => f t ⊔ g t
        continuous_toFun := f.Continuous.sup g.Continuous
        map_bounded' := by
          obtain ⟨C₁, hf⟩ := f.bounded
          obtain ⟨C₂, hg⟩ := g.bounded
          refine' ⟨C₁ + C₂, fun x y => _⟩
          simp_rw [NormedAddCommGroup.dist_eq] at hf hg⊢
          exact (norm_sup_sub_sup_le_add_norm _ _ _ _).trans (add_le_add (hf _ _) (hg _ _)) }
    le_sup_left := fun f g => ContinuousMap.le_def.mpr fun _ => le_sup_left
    le_sup_right := fun f g => ContinuousMap.le_def.mpr fun _ => le_sup_right
    sup_le := fun f g₁ g₂ w₁ w₂ =>
      ContinuousMap.le_def.mpr fun _ =>
        sup_le (ContinuousMap.le_def.mp w₁ _) (ContinuousMap.le_def.mp w₂ _) }

instance : Lattice (α →ᵇ β) :=
  { BoundedContinuousFunction.semilatticeSup, BoundedContinuousFunction.semilatticeInf with }

/- warning: bounded_continuous_function.coe_fn_sup -> BoundedContinuousFunction.coeFn_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : NormedLatticeAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (Sup.sup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (SemilatticeSup.toHasSup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (BoundedContinuousFunction.semilatticeSup.{u1, u2} α β _inst_1 _inst_2)) f g)) (Sup.sup.{max u1 u2} (α -> β) (Pi.hasSup.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β (NormedLatticeAddCommGroup.toLattice.{u2} β _inst_2)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) f) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : NormedLatticeAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))))) (Sup.sup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (SemilatticeSup.toSup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (BoundedContinuousFunction.semilatticeSup.{u1, u2} α β _inst_1 _inst_2)) f g)) (Sup.sup.{max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (Pi.instSupForAll.{u1, u2} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => SemilatticeSup.toSup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (Lattice.toSemilatticeSup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (NormedLatticeAddCommGroup.toLattice.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_2)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))))) f) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))))) g))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_fn_sup BoundedContinuousFunction.coeFn_supₓ'. -/
@[simp]
theorem coeFn_sup (f g : α →ᵇ β) : ⇑(f ⊔ g) = f ⊔ g :=
  rfl
#align bounded_continuous_function.coe_fn_sup BoundedContinuousFunction.coeFn_sup

/- warning: bounded_continuous_function.coe_fn_abs -> BoundedContinuousFunction.coeFn_abs is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : NormedLatticeAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (Abs.abs.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (Neg.toHasAbs.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (BoundedContinuousFunction.hasNeg.{u1, u2} α β _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))) (SemilatticeSup.toHasSup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (BoundedContinuousFunction.semilatticeSup.{u1, u2} α β _inst_1 _inst_2))) f)) (Abs.abs.{max u1 u2} (α -> β) (Neg.toHasAbs.{max u1 u2} (α -> β) (Pi.instNeg.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (NormedAddGroup.toAddGroup.{u2} β (NormedAddCommGroup.toNormedAddGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))))) (Pi.hasSup.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β (NormedLatticeAddCommGroup.toLattice.{u2} β _inst_2))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (fun (_x : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) => α -> β) (BoundedContinuousFunction.hasCoeToFun.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : NormedLatticeAddCommGroup.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))))) (Abs.abs.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (Neg.toHasAbs.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (BoundedContinuousFunction.instNegBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))) (SemilatticeSup.toSup.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) (BoundedContinuousFunction.semilatticeSup.{u1, u2} α β _inst_1 _inst_2))) f)) (Abs.abs.{max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (Neg.toHasAbs.{max u1 u2} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (Pi.instNeg.{u1, u2} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => NegZeroClass.toNeg.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (NormedAddCommGroup.toAddCommGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_2)))))))) (Pi.instSupForAll.{u1, u2} α (fun (ᾰ : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) ᾰ) (fun (i : α) => SemilatticeSup.toSup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (Lattice.toSemilatticeSup.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) (NormedLatticeAddCommGroup.toLattice.{u2} ((fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) i) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))))) (BoundedContinuousMapClass.toContinuousMapClass.{max u1 u2, u1, u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))) α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β (NormedLatticeAddCommGroup.toNormedAddCommGroup.{u2} β _inst_2)))))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.coe_fn_abs BoundedContinuousFunction.coeFn_absₓ'. -/
@[simp]
theorem coeFn_abs (f : α →ᵇ β) : ⇑(|f|) = |f| :=
  rfl
#align bounded_continuous_function.coe_fn_abs BoundedContinuousFunction.coeFn_abs

instance : NormedLatticeAddCommGroup (α →ᵇ β) :=
  { BoundedContinuousFunction.lattice,
    BoundedContinuousFunction.seminormedAddCommGroup with
    add_le_add_left := by
      intro f g h₁ h t
      simp only [coe_to_continuous_fun, Pi.add_apply, add_le_add_iff_left, coe_add,
        ContinuousMap.toFun_eq_coe]
      exact h₁ _
    solid := by
      intro f g h
      have i1 : ∀ t, ‖f t‖ ≤ ‖g t‖ := fun t => HasSolidNorm.solid (h t)
      rw [norm_le (norm_nonneg _)]
      exact fun t => (i1 t).trans (norm_coe_le_norm g t) }

end NormedLatticeOrderedGroup

section NonnegativePart

variable [TopologicalSpace α]

/- warning: bounded_continuous_function.nnreal_part -> BoundedContinuousFunction.nnrealPart is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α], (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) -> (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α], (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) -> (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnreal_part BoundedContinuousFunction.nnrealPartₓ'. -/
/-- The nonnegative part of a bounded continuous `ℝ`-valued function as a bounded
continuous `ℝ≥0`-valued function. -/
def nnrealPart (f : α →ᵇ ℝ) : α →ᵇ ℝ≥0 :=
  BoundedContinuousFunction.comp _ (show LipschitzWith 1 Real.toNNReal from lipschitzWith_pos) f
#align bounded_continuous_function.nnreal_part BoundedContinuousFunction.nnrealPart

/- warning: bounded_continuous_function.nnreal_part_coe_fun_eq -> BoundedContinuousFunction.nnrealPart_coeFn_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (α -> NNReal) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) => α -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 f)) (Function.comp.{succ u1, 1, 1} α Real NNReal Real.toNNReal (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) ᾰ) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal))) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 f)) (Function.comp.{succ u1, 1, 1} α Real NNReal Real.toNNReal (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 Real.pseudoMetricSpace (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnreal_part_coe_fun_eq BoundedContinuousFunction.nnrealPart_coeFn_eqₓ'. -/
@[simp]
theorem nnrealPart_coeFn_eq (f : α →ᵇ ℝ) : ⇑f.nnrealPart = Real.toNNReal ∘ ⇑f :=
  rfl
#align bounded_continuous_function.nnreal_part_coe_fun_eq BoundedContinuousFunction.nnrealPart_coeFn_eq

/- warning: bounded_continuous_function.nnnorm -> BoundedContinuousFunction.nnnorm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α], (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) -> (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α], (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) -> (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnnorm BoundedContinuousFunction.nnnormₓ'. -/
/-- The absolute value of a bounded continuous `ℝ`-valued function as a bounded
continuous `ℝ≥0`-valued function. -/
def nnnorm (f : α →ᵇ ℝ) : α →ᵇ ℝ≥0 :=
  BoundedContinuousFunction.comp _
    (show LipschitzWith 1 fun x : ℝ => ‖x‖₊ from lipschitzWith_one_norm) f
#align bounded_continuous_function.nnnorm BoundedContinuousFunction.nnnorm

/- warning: bounded_continuous_function.nnnorm_coe_fun_eq -> BoundedContinuousFunction.nnnorm_coeFn_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (α -> NNReal) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) => α -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.nnnorm.{u1} α _inst_1 f)) (Function.comp.{succ u1, 1, 1} α Real NNReal (NNNorm.nnnorm.{0} Real (SeminormedAddGroup.toNNNorm.{0} Real (SeminormedAddCommGroup.toSeminormedAddGroup.{0} Real (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) ᾰ) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal))) (BoundedContinuousFunction.nnnorm.{u1} α _inst_1 f)) (Function.comp.{succ u1, 1, 1} α Real NNReal (NNNorm.nnnorm.{0} Real (SeminormedAddGroup.toNNNorm.{0} Real (SeminormedAddCommGroup.toSeminormedAddGroup.{0} Real (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))))) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 Real.pseudoMetricSpace (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace))) f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.nnnorm_coe_fun_eq BoundedContinuousFunction.nnnorm_coeFn_eqₓ'. -/
@[simp]
theorem nnnorm_coeFn_eq (f : α →ᵇ ℝ) : ⇑f.nnnorm = NNNorm.nnnorm ∘ ⇑f :=
  rfl
#align bounded_continuous_function.nnnorm_coe_fun_eq BoundedContinuousFunction.nnnorm_coeFn_eq

/- warning: bounded_continuous_function.self_eq_nnreal_part_sub_nnreal_part_neg -> BoundedContinuousFunction.self_eq_nnrealPart_sub_nnrealPart_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (α -> Real) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) f) (HSub.hSub.{u1, u1, u1} (α -> Real) (α -> Real) (α -> Real) (instHSub.{u1} (α -> Real) (Pi.instSub.{u1, 0} α (fun (ᾰ : α) => Real) (fun (i : α) => Real.hasSub))) (Function.comp.{succ u1, 1, 1} α NNReal Real ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTCₓ.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe)))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) => α -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 f))) (Function.comp.{succ u1, 1, 1} α NNReal Real ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTCₓ.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe)))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) => α -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 (Neg.neg.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.hasNeg.{u1, 0} α Real _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))) f)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) ᾰ) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 Real.pseudoMetricSpace (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace))) f) (HSub.hSub.{u1, u1, u1} (α -> Real) (α -> Real) (forall (ᾰ : α), (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) ᾰ) (instHSub.{u1} (α -> Real) (Pi.instSub.{u1, 0} α (fun (ᾰ : α) => Real) (fun (i : α) => Real.instSubReal))) (Function.comp.{succ u1, 1, 1} α NNReal Real NNReal.toReal (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal))) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 f))) (Function.comp.{succ u1, 1, 1} α NNReal Real NNReal.toReal (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal))) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 (Neg.neg.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.instNegBoundedContinuousFunctionToPseudoMetricSpace.{u1, 0} α Real _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))) f)))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.self_eq_nnreal_part_sub_nnreal_part_neg BoundedContinuousFunction.self_eq_nnrealPart_sub_nnrealPart_negₓ'. -/
/-- Decompose a bounded continuous function to its positive and negative parts. -/
theorem self_eq_nnrealPart_sub_nnrealPart_neg (f : α →ᵇ ℝ) :
    ⇑f = coe ∘ f.nnrealPart - coe ∘ (-f).nnrealPart :=
  by
  funext x
  dsimp
  simp only [max_zero_sub_max_neg_zero_eq_self]
#align bounded_continuous_function.self_eq_nnreal_part_sub_nnreal_part_neg BoundedContinuousFunction.self_eq_nnrealPart_sub_nnrealPart_neg

/- warning: bounded_continuous_function.abs_self_eq_nnreal_part_add_nnreal_part_neg -> BoundedContinuousFunction.abs_self_eq_nnrealPart_add_nnrealPart_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (α -> Real) (Function.comp.{succ u1, 1, 1} α Real Real (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) => α -> Real) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) f)) (HAdd.hAdd.{u1, u1, u1} (α -> Real) (α -> Real) (α -> Real) (instHAdd.{u1} (α -> Real) (Pi.instAdd.{u1, 0} α (fun (ᾰ : α) => Real) (fun (i : α) => Real.hasAdd))) (Function.comp.{succ u1, 1, 1} α NNReal Real ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTCₓ.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe)))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) => α -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 f))) (Function.comp.{succ u1, 1, 1} α NNReal Real ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal Real (HasLiftT.mk.{1, 1} NNReal Real (CoeTCₓ.coe.{1, 1} NNReal Real (coeBase.{1, 1} NNReal Real NNReal.Real.hasCoe)))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) => α -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} α NNReal _inst_1 NNReal.pseudoMetricSpace) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 (Neg.neg.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.hasNeg.{u1, 0} α Real _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))) f)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] (f : BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace), Eq.{succ u1} (α -> Real) (Function.comp.{succ u1, 1, 1} α Real Real (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) α Real _inst_1 Real.pseudoMetricSpace (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace))) f)) (HAdd.hAdd.{u1, u1, u1} (α -> Real) (α -> Real) (α -> Real) (instHAdd.{u1} (α -> Real) (Pi.instAdd.{u1, 0} α (fun (ᾰ : α) => Real) (fun (i : α) => Real.instAddReal))) (Function.comp.{succ u1, 1, 1} α NNReal Real NNReal.toReal (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal))) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 f))) (Function.comp.{succ u1, 1, 1} α NNReal Real NNReal.toReal (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α (fun (_x : α) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : α) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal) α NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} α NNReal _inst_1 instPseudoMetricSpaceNNReal))) (BoundedContinuousFunction.nnrealPart.{u1} α _inst_1 (Neg.neg.{u1} (BoundedContinuousFunction.{u1, 0} α Real _inst_1 Real.pseudoMetricSpace) (BoundedContinuousFunction.instNegBoundedContinuousFunctionToPseudoMetricSpace.{u1, 0} α Real _inst_1 (NonUnitalSeminormedRing.toSeminormedAddCommGroup.{0} Real (NonUnitalNormedRing.toNonUnitalSeminormedRing.{0} Real (NormedRing.toNonUnitalNormedRing.{0} Real (NormedCommRing.toNormedRing.{0} Real Real.normedCommRing))))) f)))))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.abs_self_eq_nnreal_part_add_nnreal_part_neg BoundedContinuousFunction.abs_self_eq_nnrealPart_add_nnrealPart_negₓ'. -/
/-- Express the absolute value of a bounded continuous function in terms of its
positive and negative parts. -/
theorem abs_self_eq_nnrealPart_add_nnrealPart_neg (f : α →ᵇ ℝ) :
    abs ∘ ⇑f = coe ∘ f.nnrealPart + coe ∘ (-f).nnrealPart :=
  by
  funext x
  dsimp
  simp only [max_zero_add_max_neg_zero_eq_abs_self]
#align bounded_continuous_function.abs_self_eq_nnreal_part_add_nnreal_part_neg BoundedContinuousFunction.abs_self_eq_nnrealPart_add_nnrealPart_neg

end NonnegativePart

end BoundedContinuousFunction

