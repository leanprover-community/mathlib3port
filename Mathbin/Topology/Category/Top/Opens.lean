/-
Copyright (c) 2019 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module topology.category.Top.opens
! leanprover-community/mathlib commit f2b757fc5c341d88741b9c4630b1e8ba973c5726
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Category.Preorder
import Mathbin.CategoryTheory.EqToHom
import Mathbin.Topology.Category.Top.EpiMono
import Mathbin.Topology.Sets.Opens

/-!
# The category of open sets in a topological space.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define `to_Top : opens X â¥¤ Top` and
`map (f : X âŸ¶ Y) : opens Y â¥¤ opens X`, given by taking preimages of open sets.

Unfortunately `opens` isn't (usefully) a functor `Top â¥¤ Cat`.
(One can in fact define such a functor,
but using it results in unresolvable `eq.rec` terms in goals.)

Really it's a 2-functor from (spaces, continuous functions, equalities)
to (categories, functors, natural isomorphisms).
We don't attempt to set up the full theory here, but do provide the natural isomorphisms
`map_id : map (ðŸ™ X) â‰… ðŸ­ (opens X)` and
`map_comp : map (f â‰« g) â‰… map g â‹™ map f`.

Beyond that, there's a collection of simp lemmas for working with these constructions.
-/


open CategoryTheory

open TopologicalSpace

open Opposite

universe u

namespace TopologicalSpace.Opens

variable {X Y Z : TopCat.{u}}

/-!
Since `opens X` has a partial order, it automatically receives a `category` instance.
Unfortunately, because we do not allow morphisms in `Prop`,
the morphisms `U âŸ¶ V` are not just proofs `U â‰¤ V`, but rather
`ulift (plift (U â‰¤ V))`.
-/


/- warning: topological_space.opens.opens_hom_has_coe_to_fun -> TopologicalSpace.Opens.opensHomHasCoeToFun is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {U : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)} {V : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)}, CoeFun.{succ u1, succ u1} (Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))) U V) (fun (f : Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))) U V) => (coeSort.{succ u1, succ (succ u1)} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))) U) -> (coeSort.{succ u1, succ (succ u1)} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))) V))
but is expected to have type
  forall {X : TopCat.{u1}} {U : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)} {V : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)}, CoeFun.{succ u1, succ u1} (Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) U V) (fun (f : Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) U V) => (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (SetLike.instMembership.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopologicalSpace.Opens.instSetLikeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))) x U)) -> (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (SetLike.instMembership.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopologicalSpace.Opens.instSetLikeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))) x V)))
Case conversion may be inaccurate. Consider using '#align topological_space.opens.opens_hom_has_coe_to_fun TopologicalSpace.Opens.opensHomHasCoeToFunâ‚“'. -/
instance opensHomHasCoeToFun {U V : Opens X} : CoeFun (U âŸ¶ V) fun f => U â†’ V :=
  âŸ¨fun f x => âŸ¨x, f.le x.2âŸ©âŸ©
#align topological_space.opens.opens_hom_has_coe_to_fun TopologicalSpace.Opens.opensHomHasCoeToFun

/-!
We now construct as morphisms various inclusions of open sets.
-/


/- warning: topological_space.opens.inf_le_left -> TopologicalSpace.Opens.infLELeft is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (V : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Lattice.toSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))))))) (Inf.inf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SemilatticeInf.toHasInf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Lattice.toSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))) U V) U
but is expected to have type
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (V : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (Inf.inf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Lattice.toInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))) U V) U
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inf_le_left TopologicalSpace.Opens.infLELeftâ‚“'. -/
-- This is tedious, but necessary because we decided not to allow Prop as morphisms in a category...
/-- The inclusion `U âŠ“ V âŸ¶ U` as a morphism in the category of open sets.
-/
def infLELeft (U V : Opens X) : U âŠ“ V âŸ¶ U :=
  inf_le_left.Hom
#align topological_space.opens.inf_le_left TopologicalSpace.Opens.infLELeft

/- warning: topological_space.opens.inf_le_right -> TopologicalSpace.Opens.infLERight is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (V : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Lattice.toSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))))))) (Inf.inf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SemilatticeInf.toHasInf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Lattice.toSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))) U V) V
but is expected to have type
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (V : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (Inf.inf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Lattice.toInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))) U V) V
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inf_le_right TopologicalSpace.Opens.infLERightâ‚“'. -/
/-- The inclusion `U âŠ“ V âŸ¶ V` as a morphism in the category of open sets.
-/
def infLERight (U V : Opens X) : U âŠ“ V âŸ¶ V :=
  inf_le_right.Hom
#align topological_space.opens.inf_le_right TopologicalSpace.Opens.infLERight

/- warning: topological_space.opens.le_supr -> TopologicalSpace.Opens.leSupr is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Î¹ : Type.{u2}} (U : Î¹ -> (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))) (i : Î¹), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))) (U i) (iSup.{u1, succ u2} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (ConditionallyCompleteLattice.toHasSup.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))) Î¹ U)
but is expected to have type
  forall {X : TopCat.{u1}} {Î¹ : Type.{u2}} (U : Î¹ -> (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))) (i : Î¹), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (U i) (iSup.{u1, succ u2} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (ConditionallyCompleteLattice.toSupSet.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))) Î¹ U)
Case conversion may be inaccurate. Consider using '#align topological_space.opens.le_supr TopologicalSpace.Opens.leSuprâ‚“'. -/
/-- The inclusion `U i âŸ¶ supr U` as a morphism in the category of open sets.
-/
def leSupr {Î¹ : Type _} (U : Î¹ â†’ Opens X) (i : Î¹) : U i âŸ¶ iSup U :=
  (le_iSup U i).Hom
#align topological_space.opens.le_supr TopologicalSpace.Opens.leSupr

/- warning: topological_space.opens.bot_le -> TopologicalSpace.Opens.botLE is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (OrderBot.toHasBot.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.toHasLe.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (BoundedOrder.toOrderBot.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.toHasLe.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (CompleteLattice.toBoundedOrder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))) U
but is expected to have type
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toBot.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))) U
Case conversion may be inaccurate. Consider using '#align topological_space.opens.bot_le TopologicalSpace.Opens.botLEâ‚“'. -/
/-- The inclusion `âŠ¥ âŸ¶ U` as a morphism in the category of open sets.
-/
def botLE (U : Opens X) : âŠ¥ âŸ¶ U :=
  bot_le.Hom
#align topological_space.opens.bot_le TopologicalSpace.Opens.botLE

/- warning: topological_space.opens.le_top -> TopologicalSpace.Opens.leTop is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))) U (Top.top.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CompleteLattice.toHasTop.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))
but is expected to have type
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)), Quiver.Hom.{succ u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) U (Top.top.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toTop.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))
Case conversion may be inaccurate. Consider using '#align topological_space.opens.le_top TopologicalSpace.Opens.leTopâ‚“'. -/
/-- The inclusion `U âŸ¶ âŠ¤` as a morphism in the category of open sets.
-/
def leTop (U : Opens X) : U âŸ¶ âŠ¤ :=
  le_top.Hom
#align topological_space.opens.le_top TopologicalSpace.Opens.leTop

/- warning: topological_space.opens.inf_le_left_apply -> TopologicalSpace.Opens.infLELeft_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inf_le_left_apply TopologicalSpace.Opens.infLELeft_applyâ‚“'. -/
-- We do not mark this as a simp lemma because it breaks open `x`.
-- Nevertheless, it is useful in `sheaf_of_functions`.
theorem infLELeft_apply (U V : Opens X) (x) :
    (infLELeft U V) x = âŸ¨x.1, (@inf_le_left _ _ U V : _ â‰¤ _) x.2âŸ© :=
  rfl
#align topological_space.opens.inf_le_left_apply TopologicalSpace.Opens.infLELeft_apply

/- warning: topological_space.opens.inf_le_left_apply_mk -> TopologicalSpace.Opens.infLELeft_apply_mk is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inf_le_left_apply_mk TopologicalSpace.Opens.infLELeft_apply_mkâ‚“'. -/
@[simp]
theorem infLELeft_apply_mk (U V : Opens X) (x) (m) :
    (infLELeft U V) âŸ¨x, mâŸ© = âŸ¨x, (@inf_le_left _ _ U V : _ â‰¤ _) mâŸ© :=
  rfl
#align topological_space.opens.inf_le_left_apply_mk TopologicalSpace.Opens.infLELeft_apply_mk

/- warning: topological_space.opens.le_supr_apply_mk -> TopologicalSpace.Opens.leSupr_apply_mk is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.le_supr_apply_mk TopologicalSpace.Opens.leSupr_apply_mkâ‚“'. -/
@[simp]
theorem leSupr_apply_mk {Î¹ : Type _} (U : Î¹ â†’ Opens X) (i : Î¹) (x) (m) :
    (leSupr U i) âŸ¨x, mâŸ© = âŸ¨x, (le_iSup U i : _) mâŸ© :=
  rfl
#align topological_space.opens.le_supr_apply_mk TopologicalSpace.Opens.leSupr_apply_mk

/- warning: topological_space.opens.to_Top -> TopologicalSpace.Opens.toTopCat is a dubious translation:
lean 3 declaration is
  forall (X : TopCat.{u1}), CategoryTheory.Functor.{u1, u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) TopCat.{u1} TopCat.largeCategory.{u1}
but is expected to have type
  forall (X : TopCat.{u1}), CategoryTheory.Functor.{u1, u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) TopCat.{u1} instTopCatLargeCategory.{u1}
Case conversion may be inaccurate. Consider using '#align topological_space.opens.to_Top TopologicalSpace.Opens.toTopCatâ‚“'. -/
/-- The functor from open sets in `X` to `Top`,
realising each open set as a topological space itself.
-/
def toTopCat (X : TopCat.{u}) : Opens X â¥¤ TopCat
    where
  obj U := âŸ¨U, inferInstanceâŸ©
  map U V i :=
    âŸ¨fun x => âŸ¨x.1, i.le x.2âŸ©,
      (Embedding.continuous_iff embedding_subtype_val).2 continuous_induced_domâŸ©
#align topological_space.opens.to_Top TopologicalSpace.Opens.toTopCat

/- warning: topological_space.opens.to_Top_map -> TopologicalSpace.Opens.toTopCat_map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.to_Top_map TopologicalSpace.Opens.toTopCat_mapâ‚“'. -/
@[simp]
theorem toTopCat_map (X : TopCat.{u}) {U V : Opens X} {f : U âŸ¶ V} {x} {h} :
    ((toTopCat X).map f) âŸ¨x, hâŸ© = âŸ¨x, f.le hâŸ© :=
  rfl
#align topological_space.opens.to_Top_map TopologicalSpace.Opens.toTopCat_map

/- warning: topological_space.opens.inclusion -> TopologicalSpace.Opens.inclusion is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)), Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) TopCat.{u1} TopCat.largeCategory.{u1} (TopologicalSpace.Opens.toTopCat.{u1} X) U) X
but is expected to have type
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)), Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) TopCat.{u1} instTopCatLargeCategory.{u1} (TopologicalSpace.Opens.toTopCat.{u1} X)) U) X
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inclusion TopologicalSpace.Opens.inclusionâ‚“'. -/
/-- The inclusion map from an open subset to the whole space, as a morphism in `Top`.
-/
@[simps (config := { fullyApplied := false })]
def inclusion {X : TopCat.{u}} (U : Opens X) : (toTopCat X).obj U âŸ¶ X
    where
  toFun := _
  continuous_toFun := continuous_subtype_val
#align topological_space.opens.inclusion TopologicalSpace.Opens.inclusion

/- warning: topological_space.opens.open_embedding -> TopologicalSpace.Opens.openEmbedding is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.open_embedding TopologicalSpace.Opens.openEmbeddingâ‚“'. -/
theorem openEmbedding {X : TopCat.{u}} (U : Opens X) : OpenEmbedding (inclusion U) :=
  IsOpen.openEmbedding_subtype_val U.2
#align topological_space.opens.open_embedding TopologicalSpace.Opens.openEmbedding

/- warning: topological_space.opens.inclusion_top_iso -> TopologicalSpace.Opens.inclusionTopIso is a dubious translation:
lean 3 declaration is
  forall (X : TopCat.{u1}), CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) TopCat.{u1} TopCat.largeCategory.{u1} (TopologicalSpace.Opens.toTopCat.{u1} X) (Top.top.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CompleteLattice.toHasTop.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.Opens.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) X
but is expected to have type
  forall (X : TopCat.{u1}), CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) TopCat.{u1} instTopCatLargeCategory.{u1} (TopologicalSpace.Opens.toTopCat.{u1} X)) (Top.top.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toTop.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))) X
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inclusion_top_iso TopologicalSpace.Opens.inclusionTopIsoâ‚“'. -/
/-- The inclusion of the top open subset (i.e. the whole space) is an isomorphism.
-/
def inclusionTopIso (X : TopCat.{u}) : (toTopCat X).obj âŠ¤ â‰… X
    where
  Hom := inclusion âŠ¤
  inv := âŸ¨fun x => âŸ¨x, trivialâŸ©, continuous_def.2 fun U âŸ¨S, hS, hSUâŸ© => hSU â–¸ hSâŸ©
#align topological_space.opens.inclusion_top_iso TopologicalSpace.Opens.inclusionTopIso

/- warning: topological_space.opens.map -> TopologicalSpace.Opens.map is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) -> (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y) -> (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map TopologicalSpace.Opens.mapâ‚“'. -/
/-- `opens.map f` gives the functor from open sets in Y to open set in X,
    given by taking preimages under f. -/
def map (f : X âŸ¶ Y) : Opens Y â¥¤ Opens X
    where
  obj U := âŸ¨f â»Â¹' U, U.IsOpen.preimage f.ContinuousâŸ©
  map U V i := âŸ¨âŸ¨fun x h => i.le hâŸ©âŸ©
#align topological_space.opens.map TopologicalSpace.Opens.map

/- warning: topological_space.opens.map_coe -> TopologicalSpace.Opens.map_coe is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_coe TopologicalSpace.Opens.map_coeâ‚“'. -/
theorem map_coe (f : X âŸ¶ Y) (U : Opens Y) : â†‘((map f).obj U) = f â»Â¹' U :=
  rfl
#align topological_space.opens.map_coe TopologicalSpace.Opens.map_coe

/- warning: topological_space.opens.map_obj -> TopologicalSpace.Opens.map_obj is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_obj TopologicalSpace.Opens.map_objâ‚“'. -/
@[simp]
theorem map_obj (f : X âŸ¶ Y) (U) (p) : (map f).obj âŸ¨U, pâŸ© = âŸ¨f â»Â¹' U, p.preimage f.ContinuousâŸ© :=
  rfl
#align topological_space.opens.map_obj TopologicalSpace.Opens.map_obj

/- warning: topological_space.opens.map_id_obj -> TopologicalSpace.Opens.map_id_obj is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Functor.obj.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X)) U) U
but is expected to have type
  forall {X : TopCat.{u1}} (U : TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Prefunctor.obj.{succ u1, succ u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X))) U) U
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_id_obj TopologicalSpace.Opens.map_id_objâ‚“'. -/
@[simp]
theorem map_id_obj (U : Opens X) : (map (ðŸ™ X)).obj U = U :=
  let âŸ¨_, _âŸ© := U
  rfl
#align topological_space.opens.map_id_obj TopologicalSpace.Opens.map_id_obj

/- warning: topological_space.opens.map_id_obj' -> TopologicalSpace.Opens.map_id_obj' is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X)) (p : IsOpen.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X) U), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Functor.obj.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X)) (TopologicalSpace.Opens.mk.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X) U p)) (TopologicalSpace.Opens.mk.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X) U p)
but is expected to have type
  forall {X : TopCat.{u1}} (U : Set.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X)) (p : IsOpen.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X) U), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Prefunctor.obj.{succ u1, succ u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X))) (TopologicalSpace.Opens.mk.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X) U p)) (TopologicalSpace.Opens.mk.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X) U p)
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_id_obj' TopologicalSpace.Opens.map_id_obj'â‚“'. -/
@[simp]
theorem map_id_obj' (U) (p) : (map (ðŸ™ X)).obj âŸ¨U, pâŸ© = âŸ¨U, pâŸ© :=
  rfl
#align topological_space.opens.map_id_obj' TopologicalSpace.Opens.map_id_obj'

/- warning: topological_space.opens.map_id_obj_unop -> TopologicalSpace.Opens.map_id_obj_unop is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} (U : Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (CategoryTheory.Functor.obj.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X)) (Opposite.unop.{succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) U)) (Opposite.unop.{succ u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) U)
but is expected to have type
  forall {X : TopCat.{u1}} (U : Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Prefunctor.obj.{succ u1, succ u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X))) (Opposite.unop.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) U)) (Opposite.unop.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) U)
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_id_obj_unop TopologicalSpace.Opens.map_id_obj_unopâ‚“'. -/
@[simp]
theorem map_id_obj_unop (U : (Opens X)áµ’áµ–) : (map (ðŸ™ X)).obj (unop U) = unop U :=
  let âŸ¨_, _âŸ© := U.unop
  rfl
#align topological_space.opens.map_id_obj_unop TopologicalSpace.Opens.map_id_obj_unop

/- warning: topological_space.opens.op_map_id_obj -> TopologicalSpace.Opens.op_map_id_obj is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.op_map_id_obj TopologicalSpace.Opens.op_map_id_objâ‚“'. -/
@[simp]
theorem op_map_id_obj (U : (Opens X)áµ’áµ–) : (map (ðŸ™ X)).op.obj U = U := by simp
#align topological_space.opens.op_map_id_obj TopologicalSpace.Opens.op_map_id_obj

/- warning: topological_space.opens.le_map_top -> TopologicalSpace.Opens.leMapTop is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.le_map_top TopologicalSpace.Opens.leMapTopâ‚“'. -/
/-- The inclusion `U âŸ¶ (map f).obj âŠ¤` as a morphism in the category of open sets.
-/
def leMapTop (f : X âŸ¶ Y) (U : Opens X) : U âŸ¶ (map f).obj âŠ¤ :=
  leTop U
#align topological_space.opens.le_map_top TopologicalSpace.Opens.leMapTop

/- warning: topological_space.opens.map_comp_obj -> TopologicalSpace.Opens.map_comp_obj is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_comp_obj TopologicalSpace.Opens.map_comp_objâ‚“'. -/
@[simp]
theorem map_comp_obj (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :
    (map (f â‰« g)).obj U = (map f).obj ((map g).obj U) :=
  rfl
#align topological_space.opens.map_comp_obj TopologicalSpace.Opens.map_comp_obj

/- warning: topological_space.opens.map_comp_obj' -> TopologicalSpace.Opens.map_comp_obj' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_comp_obj' TopologicalSpace.Opens.map_comp_obj'â‚“'. -/
@[simp]
theorem map_comp_obj' (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) (p) :
    (map (f â‰« g)).obj âŸ¨U, pâŸ© = (map f).obj ((map g).obj âŸ¨U, pâŸ©) :=
  rfl
#align topological_space.opens.map_comp_obj' TopologicalSpace.Opens.map_comp_obj'

/- warning: topological_space.opens.map_comp_map -> TopologicalSpace.Opens.map_comp_map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_comp_map TopologicalSpace.Opens.map_comp_mapâ‚“'. -/
@[simp]
theorem map_comp_map (f : X âŸ¶ Y) (g : Y âŸ¶ Z) {U V} (i : U âŸ¶ V) :
    (map (f â‰« g)).map i = (map f).map ((map g).map i) :=
  rfl
#align topological_space.opens.map_comp_map TopologicalSpace.Opens.map_comp_map

/- warning: topological_space.opens.map_comp_obj_unop -> TopologicalSpace.Opens.map_comp_obj_unop is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_comp_obj_unop TopologicalSpace.Opens.map_comp_obj_unopâ‚“'. -/
@[simp]
theorem map_comp_obj_unop (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :
    (map (f â‰« g)).obj (unop U) = (map f).obj ((map g).obj (unop U)) :=
  rfl
#align topological_space.opens.map_comp_obj_unop TopologicalSpace.Opens.map_comp_obj_unop

/- warning: topological_space.opens.op_map_comp_obj -> TopologicalSpace.Opens.op_map_comp_obj is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.op_map_comp_obj TopologicalSpace.Opens.op_map_comp_objâ‚“'. -/
@[simp]
theorem op_map_comp_obj (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :
    (map (f â‰« g)).op.obj U = (map f).op.obj ((map g).op.obj U) :=
  rfl
#align topological_space.opens.op_map_comp_obj TopologicalSpace.Opens.op_map_comp_obj

/- warning: topological_space.opens.map_supr -> TopologicalSpace.Opens.map_iSup is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_supr TopologicalSpace.Opens.map_iSupâ‚“'. -/
theorem map_iSup (f : X âŸ¶ Y) {Î¹ : Type _} (U : Î¹ â†’ Opens Y) :
    (map f).obj (iSup U) = iSup ((map f).obj âˆ˜ U) :=
  by
  ext1; rw [supr_def, supr_def, map_obj]
  dsimp; rw [Set.preimage_iUnion]; rfl
#align topological_space.opens.map_supr TopologicalSpace.Opens.map_iSup

section

variable (X)

/- warning: topological_space.opens.map_id -> TopologicalSpace.Opens.mapId is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_id TopologicalSpace.Opens.mapIdâ‚“'. -/
/-- The functor `opens X â¥¤ opens X` given by taking preimages under the identity function
is naturally isomorphic to the identity functor.
-/
@[simps]
def mapId : map (ðŸ™ X) â‰… ðŸ­ (Opens X)
    where
  Hom := { app := fun U => eqToHom (map_id_obj U) }
  inv := { app := fun U => eqToHom (map_id_obj U).symm }
#align topological_space.opens.map_id TopologicalSpace.Opens.mapId

/- warning: topological_space.opens.map_id_eq -> TopologicalSpace.Opens.map_id_eq is a dubious translation:
lean 3 declaration is
  forall (X : TopCat.{u1}), Eq.{succ u1} (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X)) (CategoryTheory.Functor.id.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))
but is expected to have type
  forall (X : TopCat.{u1}), Eq.{succ u1} (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))))) (TopologicalSpace.Opens.map.{u1} X X (CategoryTheory.CategoryStruct.id.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X)) (CategoryTheory.Functor.id.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_id_eq TopologicalSpace.Opens.map_id_eqâ‚“'. -/
theorem map_id_eq : map (ðŸ™ X) = ðŸ­ (Opens X) := by unfold map; congr ; ext; rfl; ext
#align topological_space.opens.map_id_eq TopologicalSpace.Opens.map_id_eq

end

/- warning: topological_space.opens.map_comp -> TopologicalSpace.Opens.mapComp is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_comp TopologicalSpace.Opens.mapCompâ‚“'. -/
/-- The natural isomorphism between taking preimages under `f â‰« g`, and the composite
of taking preimages under `g`, then preimages under `f`.
-/
@[simps]
def mapComp (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : map (f â‰« g) â‰… map g â‹™ map f
    where
  Hom := { app := fun U => eqToHom (map_comp_obj f g U) }
  inv := { app := fun U => eqToHom (map_comp_obj f g U).symm }
#align topological_space.opens.map_comp TopologicalSpace.Opens.mapComp

/- warning: topological_space.opens.map_comp_eq -> TopologicalSpace.Opens.map_comp_eq is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_comp_eq TopologicalSpace.Opens.map_comp_eqâ‚“'. -/
theorem map_comp_eq (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : map (f â‰« g) = map g â‹™ map f :=
  rfl
#align topological_space.opens.map_comp_eq TopologicalSpace.Opens.map_comp_eq

/- warning: topological_space.opens.map_iso -> TopologicalSpace.Opens.mapIso is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) f g) -> (CategoryTheory.Iso.{u1, u1} (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))) (CategoryTheory.Functor.category.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))) (TopologicalSpace.Opens.map.{u1} X Y f) (TopologicalSpace.Opens.map.{u1} X Y g))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y) f g) -> (CategoryTheory.Iso.{u1, u1} (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))))) (CategoryTheory.Functor.category.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))))) (TopologicalSpace.Opens.map.{u1} X Y f) (TopologicalSpace.Opens.map.{u1} X Y g))
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_iso TopologicalSpace.Opens.mapIsoâ‚“'. -/
-- We could make `f g` implicit here, but it's nice to be able to see when
-- they are the identity (often!)
/-- If two continuous maps `f g : X âŸ¶ Y` are equal,
then the functors `opens Y â¥¤ opens X` they induce are isomorphic.
-/
def mapIso (f g : X âŸ¶ Y) (h : f = g) : map f â‰… map g :=
  NatIso.ofComponents (fun U => eqToIso (congr_fun (congr_arg Functor.obj (congr_arg map h)) U))
    (by obviously)
#align topological_space.opens.map_iso TopologicalSpace.Opens.mapIso

/- warning: topological_space.opens.map_eq -> TopologicalSpace.Opens.map_eq is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) f g) -> (Eq.{succ u1} (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)))))) (TopologicalSpace.Opens.map.{u1} X Y f) (TopologicalSpace.Opens.map.{u1} X Y g))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y) f g) -> (Eq.{succ u1} (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X))))))) (TopologicalSpace.Opens.map.{u1} X Y f) (TopologicalSpace.Opens.map.{u1} X Y g))
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_eq TopologicalSpace.Opens.map_eqâ‚“'. -/
theorem map_eq (f g : X âŸ¶ Y) (h : f = g) : map f = map g := by unfold map; congr ; ext; rw [h];
  rw [h]; assumption'
#align topological_space.opens.map_eq TopologicalSpace.Opens.map_eq

/- warning: topological_space.opens.map_iso_refl -> TopologicalSpace.Opens.mapIso_refl is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_iso_refl TopologicalSpace.Opens.mapIso_reflâ‚“'. -/
@[simp]
theorem mapIso_refl (f : X âŸ¶ Y) (h) : mapIso f f h = Iso.refl (map _) :=
  rfl
#align topological_space.opens.map_iso_refl TopologicalSpace.Opens.mapIso_refl

/- warning: topological_space.opens.map_iso_hom_app -> TopologicalSpace.Opens.mapIso_hom_app is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_iso_hom_app TopologicalSpace.Opens.mapIso_hom_appâ‚“'. -/
@[simp]
theorem mapIso_hom_app (f g : X âŸ¶ Y) (h : f = g) (U : Opens Y) :
    (mapIso f g h).Hom.app U = eqToHom (congr_fun (congr_arg Functor.obj (congr_arg map h)) U) :=
  rfl
#align topological_space.opens.map_iso_hom_app TopologicalSpace.Opens.mapIso_hom_app

/- warning: topological_space.opens.map_iso_inv_app -> TopologicalSpace.Opens.mapIso_inv_app is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_iso_inv_app TopologicalSpace.Opens.mapIso_inv_appâ‚“'. -/
@[simp]
theorem mapIso_inv_app (f g : X âŸ¶ Y) (h : f = g) (U : Opens Y) :
    (mapIso f g h).inv.app U =
      eqToHom (congr_fun (congr_arg Functor.obj (congr_arg map h.symm)) U) :=
  rfl
#align topological_space.opens.map_iso_inv_app TopologicalSpace.Opens.mapIso_inv_app

/- warning: topological_space.opens.map_map_iso -> TopologicalSpace.Opens.mapMapIso is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, (CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) -> (CategoryTheory.Equivalence.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, (CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) -> (CategoryTheory.Equivalence.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))))
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_map_iso TopologicalSpace.Opens.mapMapIsoâ‚“'. -/
/-- A homeomorphism of spaces gives an equivalence of categories of open sets.

TODO: define `order_iso.equivalence`, use it.
-/
@[simps]
def mapMapIso {X Y : TopCat.{u}} (H : X â‰… Y) : Opens Y â‰Œ Opens X
    where
  Functor := map H.Hom
  inverse := map H.inv
  unitIso :=
    NatIso.ofComponents (fun U => eqToIso (by simp [map, Set.preimage_preimage]))
      (by intro _ _ _; simp)
  counitIso :=
    NatIso.ofComponents (fun U => eqToIso (by simp [map, Set.preimage_preimage]))
      (by intro _ _ _; simp)
#align topological_space.opens.map_map_iso TopologicalSpace.Opens.mapMapIso

end TopologicalSpace.Opens

/- warning: is_open_map.functor -> IsOpenMap.functor is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y}, (IsOpenMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) f)) -> (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y}, (IsOpenMap.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Y f)) -> (CategoryTheory.Functor.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))))
Case conversion may be inaccurate. Consider using '#align is_open_map.functor IsOpenMap.functorâ‚“'. -/
/-- An open map `f : X âŸ¶ Y` induces a functor `opens X â¥¤ opens Y`.
-/
@[simps]
def IsOpenMap.functor {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) : Opens X â¥¤ Opens Y
    where
  obj U := âŸ¨f '' U, hf U U.2âŸ©
  map U V h := âŸ¨âŸ¨Set.image_subset _ h.down.downâŸ©âŸ©
#align is_open_map.functor IsOpenMap.functor

/- warning: is_open_map.adjunction -> IsOpenMap.adjunction is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y} (hf : IsOpenMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) f)), CategoryTheory.Adjunction.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (IsOpenMap.functor.{u1} X Y f hf) (TopologicalSpace.Opens.map.{u1} X Y f)
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y} (hf : IsOpenMap.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Y f)), CategoryTheory.Adjunction.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (IsOpenMap.functor.{u1} X Y f hf) (TopologicalSpace.Opens.map.{u1} X Y f)
Case conversion may be inaccurate. Consider using '#align is_open_map.adjunction IsOpenMap.adjunctionâ‚“'. -/
/-- An open map `f : X âŸ¶ Y` induces an adjunction between `opens X` and `opens Y`.
-/
def IsOpenMap.adjunction {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) :
    Adjunction hf.Functor (TopologicalSpace.Opens.map f) :=
  Adjunction.mkOfUnitCounit
    { Unit := { app := fun U => homOfLE fun x hxU => âŸ¨x, hxU, rflâŸ© }
      counit := { app := fun V => homOfLE fun y âŸ¨x, hfxV, hxyâŸ© => hxy â–¸ hfxV } }
#align is_open_map.adjunction IsOpenMap.adjunction

/- warning: is_open_map.functor_full_of_mono -> IsOpenMap.functorFullOfMono is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y} (hf : IsOpenMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) f)) [H : CategoryTheory.Mono.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y f], CategoryTheory.Full.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (IsOpenMap.functor.{u1} X Y f hf)
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y} (hf : IsOpenMap.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Y f)) [H : CategoryTheory.Mono.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y f], CategoryTheory.Full.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (IsOpenMap.functor.{u1} X Y f hf)
Case conversion may be inaccurate. Consider using '#align is_open_map.functor_full_of_mono IsOpenMap.functorFullOfMonoâ‚“'. -/
instance IsOpenMap.functorFullOfMono {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) [H : Mono f] :
    Full hf.Functor
    where preimage U V i :=
    homOfLE fun x hx => by obtain âŸ¨y, hy, eqâŸ© := i.le âŸ¨x, hx, rflâŸ©;
      exact (TopCat.mono_iff_injective f).mp H Eq â–¸ hy
#align is_open_map.functor_full_of_mono IsOpenMap.functorFullOfMono

/- warning: is_open_map.functor_faithful -> IsOpenMap.functor_faithful is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y} (hf : IsOpenMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) f)), CategoryTheory.Faithful.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (TopCat.topologicalSpace.{u1} X))))) (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y)) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopologicalSpace.Opens.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} Y))))) (IsOpenMap.functor.{u1} X Y f hf)
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Y} (hf : IsOpenMap.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Y f)), CategoryTheory.Faithful.{u1, u1, u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} X) (TopCat.topologicalSpace_coe.{u1} X)))))) (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} Y)))))) (IsOpenMap.functor.{u1} X Y f hf)
Case conversion may be inaccurate. Consider using '#align is_open_map.functor_faithful IsOpenMap.functor_faithfulâ‚“'. -/
instance IsOpenMap.functor_faithful {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) :
    Faithful hf.Functor where
#align is_open_map.functor_faithful IsOpenMap.functor_faithful

namespace TopologicalSpace.Opens

open TopologicalSpace

/- warning: topological_space.opens.open_embedding_obj_top -> TopologicalSpace.Opens.openEmbedding_obj_top is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.open_embedding_obj_top TopologicalSpace.Opens.openEmbedding_obj_topâ‚“'. -/
@[simp]
theorem openEmbedding_obj_top {X : TopCat} (U : Opens X) :
    U.OpenEmbedding.IsOpenMap.Functor.obj âŠ¤ = U := by ext1;
  exact set.image_univ.trans Subtype.range_coe
#align topological_space.opens.open_embedding_obj_top TopologicalSpace.Opens.openEmbedding_obj_top

/- warning: topological_space.opens.inclusion_map_eq_top -> TopologicalSpace.Opens.inclusion_map_eq_top is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inclusion_map_eq_top TopologicalSpace.Opens.inclusion_map_eq_topâ‚“'. -/
@[simp]
theorem inclusion_map_eq_top {X : TopCat} (U : Opens X) : (Opens.map U.inclusion).obj U = âŠ¤ := by
  ext1; exact Subtype.coe_preimage_self _
#align topological_space.opens.inclusion_map_eq_top TopologicalSpace.Opens.inclusion_map_eq_top

/- warning: topological_space.opens.adjunction_counit_app_self -> TopologicalSpace.Opens.adjunction_counit_app_self is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.adjunction_counit_app_self TopologicalSpace.Opens.adjunction_counit_app_selfâ‚“'. -/
@[simp]
theorem adjunction_counit_app_self {X : TopCat} (U : Opens X) :
    U.OpenEmbedding.IsOpenMap.Adjunction.counit.app U = eqToHom (by simp) := by ext
#align topological_space.opens.adjunction_counit_app_self TopologicalSpace.Opens.adjunction_counit_app_self

/- warning: topological_space.opens.inclusion_top_functor -> TopologicalSpace.Opens.inclusion_top_functor is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.inclusion_top_functor TopologicalSpace.Opens.inclusion_top_functorâ‚“'. -/
theorem inclusion_top_functor (X : TopCat) :
    (@Opens.openEmbedding X âŠ¤).IsOpenMap.Functor = map (inclusionTopIso X).inv :=
  by
  apply functor.hext; intro ;
  abstract obj_eq 
    ext
    exact âŸ¨fun âŸ¨âŸ¨_, _âŸ©, h, rflâŸ© => h, fun h => âŸ¨âŸ¨x, trivialâŸ©, h, rflâŸ©âŸ©
  intros ; apply Subsingleton.helim; congr 1
  iterate 2 apply inclusion_top_functor.obj_eq
#align topological_space.opens.inclusion_top_functor TopologicalSpace.Opens.inclusion_top_functor

/- warning: topological_space.opens.functor_obj_map_obj -> TopologicalSpace.Opens.functor_obj_map_obj is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.functor_obj_map_obj TopologicalSpace.Opens.functor_obj_map_objâ‚“'. -/
theorem functor_obj_map_obj {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) (U : Opens Y) :
    hf.Functor.obj ((Opens.map f).obj U) = hf.Functor.obj âŠ¤ âŠ“ U :=
  by
  ext; constructor
  Â· rintro âŸ¨x, hx, rflâŸ©; exact âŸ¨âŸ¨x, trivial, rflâŸ©, hxâŸ©
  Â· rintro âŸ¨âŸ¨x, -, rflâŸ©, hxâŸ©; exact âŸ¨x, hx, rflâŸ©
#align topological_space.opens.functor_obj_map_obj TopologicalSpace.Opens.functor_obj_map_obj

/- warning: topological_space.opens.functor_map_eq_inf -> TopologicalSpace.Opens.functor_map_eq_inf is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.functor_map_eq_inf TopologicalSpace.Opens.functor_map_eq_infâ‚“'. -/
@[simp]
theorem functor_map_eq_inf {X : TopCat} (U V : Opens X) :
    U.OpenEmbedding.IsOpenMap.Functor.obj ((Opens.map U.inclusion).obj V) = V âŠ“ U := by ext1;
  refine' set.image_preimage_eq_inter_range.trans _; simpa
#align topological_space.opens.functor_map_eq_inf TopologicalSpace.Opens.functor_map_eq_inf

/- warning: topological_space.opens.map_functor_eq' -> TopologicalSpace.Opens.map_functor_eq' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_functor_eq' TopologicalSpace.Opens.map_functor_eq'â‚“'. -/
theorem map_functor_eq' {X U : TopCat} (f : U âŸ¶ X) (hf : OpenEmbedding f) (V) :
    ((Opens.map f).obj <| hf.IsOpenMap.Functor.obj V) = V :=
  Opens.ext <| Set.preimage_image_eq _ hf.inj
#align topological_space.opens.map_functor_eq' TopologicalSpace.Opens.map_functor_eq'

/- warning: topological_space.opens.map_functor_eq -> TopologicalSpace.Opens.map_functor_eq is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.map_functor_eq TopologicalSpace.Opens.map_functor_eqâ‚“'. -/
@[simp]
theorem map_functor_eq {X : TopCat} {U : Opens X} (V : Opens U) :
    ((Opens.map U.inclusion).obj <| U.OpenEmbedding.IsOpenMap.Functor.obj V) = V :=
  TopologicalSpace.Opens.map_functor_eq' _ U.OpenEmbedding V
#align topological_space.opens.map_functor_eq TopologicalSpace.Opens.map_functor_eq

/- warning: topological_space.opens.adjunction_counit_map_functor -> TopologicalSpace.Opens.adjunction_counit_map_functor is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align topological_space.opens.adjunction_counit_map_functor TopologicalSpace.Opens.adjunction_counit_map_functorâ‚“'. -/
@[simp]
theorem adjunction_counit_map_functor {X : TopCat} {U : Opens X} (V : Opens U) :
    U.OpenEmbedding.IsOpenMap.Adjunction.counit.app (U.OpenEmbedding.IsOpenMap.Functor.obj V) =
      eqToHom (by conv_rhs => rw [â† V.map_functor_eq]; rfl) :=
  by ext
#align topological_space.opens.adjunction_counit_map_functor TopologicalSpace.Opens.adjunction_counit_map_functor

end TopologicalSpace.Opens

