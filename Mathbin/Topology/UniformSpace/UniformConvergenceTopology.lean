/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import Mathbin.Topology.UniformSpace.UniformConvergence
import Mathbin.Topology.UniformSpace.Pi
import Mathbin.Topology.UniformSpace.Equiv

/-!
# Topology and uniform structure of uniform convergence

This files endows `Î± â†’ Î²` with the topologies / uniform structures of
- uniform convergence on `Î±` (in the `uniform_convergence` namespace)
- uniform convergence on a specified family `ğ”–` of sets of `Î±`
  (in the `uniform_convergence_on` namespace), also called `ğ”–`-convergence

Usual examples of the second construction include :
- the topology of compact convergence, when `ğ”–` is the set of compacts of `Î±`
- the strong topology on the dual of a topological vector space (TVS) `E`, when `ğ”–` is the set of
  Von Neuman bounded subsets of `E`
- the weak-* topology on the dual of a TVS `E`, when `ğ”–` is the set of singletons of `E`.

This file contains a lot of technical facts, so it is heavily commented, proofs included!

## Main definitions

* `uniform_convergence.gen`: basis sets for the uniformity of uniform convergence. These are sets
  of the form `S(V) := {(f, g) | âˆ€ x : Î±, (f x, g x) âˆˆ V}` for some `V : set (Î² Ã— Î²)`
* `uniform_convergence.uniform_space`: uniform structure of uniform convergence. This is the
  `uniform_space` on `Î± â†’ Î²` whose uniformity is generated by the sets `S(V)` for `V âˆˆ ğ“¤ Î²`.
  We will denote this uniform space as `ğ’°(Î±, Î², uÎ²)`, both in the comments and as a local notation
  in the Lean code, where `uÎ²` is the uniform space structure on `Î²`.
* `uniform_convergence_on.uniform_space`: uniform structure of ğ”–-convergence, where
  `ğ”– : set (set Î±)`. This is the infimum, for `S âˆˆ ğ”–`, of the pullback of `ğ’° S Î²` by the map of
  restriction to `S`. We will denote it `ğ’±(Î±, Î², ğ”–, uÎ²)`, where `uÎ²` is the uniform space structure
  on `Î²`.

## Main statements

### Basic properties

* `uniform_convergence.uniform_continuous_eval`: evaluation is uniformly continuous for `ğ’°(Î±, uÎ²)`.
* `uniform_convergence.t2_space`: the topology of uniform convergence on `Î± â†’ Î²` is Tâ‚‚ if
  `Î²` is Tâ‚‚.
* `uniform_convergence.tendsto_iff_tendsto_uniformly`: `ğ’°(Î±, Î², uÎ²)` is
  indeed the uniform structure of uniform convergence
* `uniform_convergence_on.uniform_continuous_eval_of_mem`: evaluation at a point contained in a
  set of `ğ”–` is uniformly continuous for `ğ’±(Î±, Î², ğ”– uÎ²)`
* `uniform_convergence.t2_space`: the topology of `ğ”–`-convergence on `Î± â†’ Î²` is Tâ‚‚ if
  `Î²` is Tâ‚‚ and `ğ”–` covers `Î±`
* `uniform_convergence_on.tendsto_iff_tendsto_uniformly_on`:
  `ğ’±(Î±, Î², ğ”– uÎ²)` is indeed the uniform structure of `ğ”–`-convergence

### Functoriality and compatibility with product of uniform spaces

In order to avoid the need for filter bases as much as possible when using these definitions,
we develop an extensive API for manipulating these structures abstractly. As usual in the topology
section of mathlib, we first state results about the complete lattices of `uniform_space`s on
fixed types, and then we use these to deduce categorical-like results about maps between two
uniform spaces.

We only describe these in the harder case of `ğ”–`-convergence, as the names of the corresponding
results for uniform convergence can easily be guessed.

#### Order statements

* `uniform_convergence_on.mono`: let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and
  `ğ”–â‚ ğ”–â‚‚ : set (set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and `ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`.
* `uniform_convergence_on.infi_eq`: if `u` is a family of uniform structures on `Î³`, then
  `ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`.
* `uniform_convergence_on.comap_eq`: if `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
  `ğ’±(Î±, Î³, ğ”–, comap f u) = comap (Î» g, f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`.

An interesting note about these statements is that they are proved without ever unfolding the basis
definition of the uniform structure of uniform convergence! Instead, we build a
(not very interesting) Galois connection `uniform_convergence.gc` and then rely on the Galois
connection API to do most of the work.

#### Morphism statements (unbundled)

* `uniform_convergence_on.postcomp_uniform_continuous`: if `f : (Î³, uÎ³) â†’ (Î², uÎ²)` is uniformly
  continuous, then `(Î» g, f âˆ˜ g) : (Î± â†’ Î³, ğ’±(Î±, Î³, ğ”–, uÎ³)) â†’ (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` is
  uniformly continuous.
* `uniform_convergence_on.postcomp_uniform_inducing`: if `f : (Î³, uÎ³) â†’ (Î², uÎ²)` is a uniform
  inducing, then `(Î» g, f âˆ˜ g) : (Î± â†’ Î³, ğ’±(Î±, Î³, ğ”–, uÎ³)) â†’ (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` is a
  uniform inducing.
* `uniform_convergence_on.precomp_uniform_continuous`: let `f : Î³ â†’ Î±`, `ğ”– : set (set Î±)`,
  `ğ”— : set (set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`. Then, the function
  `(Î» g, g âˆ˜ f) : (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²)) â†’ (Î³ â†’ Î², ğ’±(Î³, Î², ğ”— uÎ²))` is uniformly continuous.

#### Isomorphism statements (bundled)

* `uniform_convergence_on.congr_right`: turn a uniform isomorphism `(Î³, uÎ³) â‰ƒáµ¤ (Î², uÎ²)` into a
  uniform isomorphism `(Î± â†’ Î³, ğ’±(Î±, Î³, ğ”–, uÎ³)) â‰ƒáµ¤ (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` by post-composing.
* `uniform_convergence_on.congr_left`: turn a bijection `e : Î³ â‰ƒ Î±` such that we have both
  `âˆ€ T âˆˆ ğ”—, e '' T âˆˆ ğ”–` and `âˆ€ S âˆˆ ğ”–, e â»Â¹' S âˆˆ ğ”—` into a uniform isomorphism
  `(Î³ â†’ Î², ğ’°(Î³, Î², uÎ²)) â‰ƒáµ¤ (Î± â†’ Î², ğ’°(Î±, Î², uÎ²))` by pre-composing.
* `uniform_convergence_on.uniform_equiv_Pi_comm`: the natural bijection between `Î± â†’ Î  i, Î´ i`
  and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform isomorphism between
  `(Î± â†’ (Î  i, Î´ i), ğ’±(Î±, (Î  i, Î´ i), ğ”–, (Î  i, uÎ´ i)))` and
  `((Î  i, Î± â†’ Î´ i), (Î  i, ğ’±(Î±, Î´ i, ğ”–, uÎ´ i)))`.

#### Important use cases

* If `(G, uG)` is a uniform group, then `(Î± â†’ G, ğ’±(Î±, G, ğ”–, uG))` is a uniform group: since
  `(/) : G Ã— G â†’ G` is uniformly continuous, `uniform_convergence_on.postcomp_uniform_continuous`
  tells us that `((/) âˆ˜ â€”) : (Î± â†’ G Ã— G) â†’ (Î± â†’ G)` is uniformly continuous. By precomposing with
  `uniform_convergence_on.uniform_equiv_prod_arrow`, this gives that
  `(/) : (Î± â†’ G) Ã— (Î± â†’ G) â†’ (Î± â†’ G)` is also uniformly continuous
* The transpose of a continuous linear map is continuous for the strong topologies: since
  continuous linear maps are uniformly continuous and map bounded sets to bounded sets,
  this is just a special case of `uniform_convergence_on.precomp_uniform_continuous`.

## Implementation details

We do not declare these structures as instances, since they would conflict with `Pi.uniform_space`.

## TODO

* Show that the uniform structure of `ğ”–`-convergence is exactly the structure of `ğ”–'`-convergence,
  where `ğ”–'` is the ***noncovering*** bornology (i.e ***not*** what `bornology` currently refers
  to in mathlib) generated by `ğ”–`.
* Add a type synonym for `Î± â†’ Î²` endowed with the structures of uniform convergence?

## References

* [N. Bourbaki, *General Topology, Chapter X*][bourbaki1966]

## Tags

uniform convergence
-/


noncomputable section

open TopologicalSpace Classical uniformity Filter

attribute [-instance] PiCat.uniformSpace

attribute [-instance] PiCat.topologicalSpace

open Set Filter

namespace UniformConvergence

variable (Î± Î² : Type _) {Î³ Î¹ : Type _}

variable {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : Set Î±} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±}

/-- Basis sets for the uniformity of uniform convergence: `gen Î± Î² V` is the set of pairs `(f, g)`
of functions `Î± â†’ Î²` such that `âˆ€ x, (f x, g x) âˆˆ V`. -/
protected def gen (V : Set (Î² Ã— Î²)) : Set ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  { uv : (Î± â†’ Î²) Ã— (Î± â†’ Î²) | âˆ€ x, (uv.1 x, uv.2 x) âˆˆ V }
#align uniform_convergence.gen UniformConvergence.gen

/-- If `ğ“•` is a filter on `Î² Ã— Î²`, then the set of all `uniform_convergence.gen Î± Î² V` for
`V âˆˆ ğ“•` is too. This will only be applied to `ğ“• = ğ“¤ Î²` when `Î²` is equipped with a `uniform_space`
structure, but it is useful to define it for any filter in order to be able to state that it
has a lower adjoint (see `uniform_convergence.gc`). -/
protected theorem is_basis_gen (ğ“‘ : Filter <| Î² Ã— Î²) :
    IsBasis (fun V : Set (Î² Ã— Î²) => V âˆˆ ğ“‘) (UniformConvergence.gen Î± Î²) :=
  âŸ¨âŸ¨univ, univ_memâŸ©, fun U V hU hV =>
    âŸ¨U âˆ© V, inter_mem hU hV, fun uv huv => âŸ¨fun x => (huv x).left, fun x => (huv x).rightâŸ©âŸ©âŸ©
#align uniform_convergence.is_basis_gen UniformConvergence.is_basis_gen

/-- For `ğ“• : filter (Î² Ã— Î²)`, this is the set of all `uniform_convergence.gen Î± Î² V` for
`V âˆˆ ğ“•` is as a bundled `filter_basis`. This will only be applied to `ğ“• = ğ“¤ Î²` when `Î²` is
equipped with a `uniform_space` structure, but it is useful to define it for any filter in order
to be able to state that it has a lower adjoint (see `uniform_convergence.gc`). -/
protected def basis (ğ“• : Filter <| Î² Ã— Î²) : FilterBasis ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  (UniformConvergence.is_basis_gen Î± Î² ğ“•).FilterBasis
#align uniform_convergence.basis UniformConvergence.basis

/-- For `ğ“• : filter (Î² Ã— Î²)`, this is the filter generated by the filter basis
`uniform_convergence.basis Î± Î² ğ“•`. For `ğ“• = ğ“¤ Î²`, this will be the uniformity of uniform
convergence on `Î±`. -/
protected def filter (ğ“• : Filter <| Î² Ã— Î²) : Filter ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  (UniformConvergence.basis Î± Î² ğ“•).filter
#align uniform_convergence.filter UniformConvergence.filter

-- mathport name: exprÎ¦
local notation "Î¦" => fun (Î± Î² : Type _) (uvx : ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) Ã— Î±) => (uvx.1.1 uvx.2, uvx.1.2 uvx.2)

-- mathport name: exprlower_adjoint
/- This is a lower adjoint to `uniform_convergence.filter` (see `uniform_convergence.gc`).
The exact definition of the lower adjoint `l` is not interesting; we will only use that it exists
(in `uniform_convergence.mono` and `uniform_convergence.infi_eq`) and that
`l (filter.map (prod.map f f) ğ“•) = filter.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each
`ğ“• : filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `uniform_convergence.comap_eq`). -/
local notation "lower_adjoint" => fun ğ“ => map (Î¦ Î± Î²) (ğ“ Ã—á¶  âŠ¤)

/-- The function `uniform_convergence.filter Î± Î² : filter (Î² Ã— Î²) â†’ filter ((Î± â†’ Î²) Ã— (Î± â†’ Î²))`
has a lower adjoint `l` (in the sense of `galois_connection`). The exact definition of `l` is not
interesting; we will only use that it exists (in `uniform_convergence.mono` and
`uniform_convergence.infi_eq`) and that
`l (filter.map (prod.map f f) ğ“•) = filter.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each
`ğ“• : filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `uniform_convergence.comap_eq`). -/
protected theorem gc : GaloisConnection lower_adjoint fun ğ“• => UniformConvergence.filter Î± Î² ğ“• := by
  intro ğ“ ğ“•
  symm
  calc
    ğ“ â‰¤ UniformConvergence.filter Î± Î² ğ“• â†” (UniformConvergence.basis Î± Î² ğ“•).sets âŠ† ğ“.sets := by
      rw [UniformConvergence.filter, â† FilterBasis.generate, sets_iff_generate]
    _ â†” âˆ€ U âˆˆ ğ“•, UniformConvergence.gen Î± Î² U âˆˆ ğ“ := image_subset_iff
    _ â†” âˆ€ U âˆˆ ğ“•, { uv | âˆ€ x, (uv, x) âˆˆ { t : ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) Ã— Î± | (t.1.1 t.2, t.1.2 t.2) âˆˆ U } } âˆˆ ğ“ := Iff.rfl
    _ â†” âˆ€ U âˆˆ ğ“•, { uvx : ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) Ã— Î± | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) âˆˆ U } âˆˆ ğ“ Ã—á¶  (âŠ¤ : Filter Î±) :=
      forallâ‚‚_congr fun U hU => mem_prod_top.symm
    _ â†” lower_adjoint ğ“ â‰¤ ğ“• := Iff.rfl
    
#align uniform_convergence.gc UniformConvergence.gc

variable [UniformSpace Î²]

/-- Core of the uniform structure of uniform convergence. -/
protected def uniformCore : UniformSpace.Core (Î± â†’ Î²) :=
  UniformSpace.Core.mkOfBasis (UniformConvergence.basis Î± Î² (ğ“¤ Î²))
    (fun U âŸ¨V, hV, hVUâŸ© f => hVU â–¸ fun x => refl_mem_uniformity hV)
    (fun U âŸ¨V, hV, hVUâŸ© =>
      hVU â–¸
        âŸ¨UniformConvergence.gen Î± Î² (Prod.swap â»Â¹' V), âŸ¨Prod.swap â»Â¹' V, tendsto_swap_uniformity hV, rflâŸ©,
          fun uv huv x => huv xâŸ©)
    fun U âŸ¨V, hV, hVUâŸ© =>
    hVU â–¸
      let âŸ¨W, hW, hWVâŸ© := comp_mem_uniformity_sets hV
      âŸ¨UniformConvergence.gen Î± Î² W, âŸ¨W, hW, rflâŸ©, fun uv âŸ¨w, huw, hwvâŸ© x => hWV âŸ¨w x, âŸ¨huw x, hwv xâŸ©âŸ©âŸ©
#align uniform_convergence.uniform_core UniformConvergence.uniformCore

/-- Uniform structure of uniform convergence. We will denote it `ğ’°(Î±, Î², uÎ²)`. -/
protected def uniformSpace : UniformSpace (Î± â†’ Î²) :=
  UniformSpace.ofCore (UniformConvergence.uniformCore Î± Î²)
#align uniform_convergence.uniform_space UniformConvergence.uniformSpace

attribute [local instance] UniformConvergence.uniformSpace

-- mathport name: Â«exprğ’°( , , )Â»
local notation "ğ’°(" Î± ", " Î² ", " u ")" => @UniformConvergence.uniformSpace Î± Î² u

/-- By definition, the uniformity of `Î± â†’ Î²` endowed with the structure of uniform convergence on
`Î±` admits the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected theorem has_basis_uniformity : (ğ“¤ (Î± â†’ Î²)).HasBasis (fun V => V âˆˆ ğ“¤ Î²) (UniformConvergence.gen Î± Î²) :=
  (UniformConvergence.is_basis_gen Î± Î² (ğ“¤ Î²)).HasBasis
#align uniform_convergence.has_basis_uniformity UniformConvergence.has_basis_uniformity

/-- The uniformity of `Î± â†’ Î²` endowed with the uniform structure of uniform convergence on admits
the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as a filter basis, for any basis
`ğ“‘` of `ğ“¤ Î²` (in the case `ğ“‘ = (ğ“¤ Î²).as_basis` this is true by definition). -/
protected theorem has_basis_uniformity_of_basis {Î¹ : Sort _} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}
    (h : (ğ“¤ Î²).HasBasis p s) : (ğ“¤ (Î± â†’ Î²)).HasBasis p (UniformConvergence.gen Î± Î² âˆ˜ s) :=
  (UniformConvergence.has_basis_uniformity Î± Î²).to_has_basis
    (fun U hU =>
      let âŸ¨i, hi, hiUâŸ© := h.mem_iff.mp hU
      âŸ¨i, hi, fun uv huv x => hiU (huv x)âŸ©)
    fun i hi => âŸ¨s i, h.mem_of_mem hi, subset_refl _âŸ©
#align uniform_convergence.has_basis_uniformity_of_basis UniformConvergence.has_basis_uniformity_of_basis

/-- Topology of uniform convergence. -/
protected def topologicalSpace : TopologicalSpace (Î± â†’ Î²) :=
  ğ’°(Î±, Î², inferInstance).toTopologicalSpace
#align uniform_convergence.topological_space UniformConvergence.topologicalSpace

/-- If `Î± â†’ Î²` is endowed with the topology of uniform convergence, `ğ“ f` admits the family
`{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as a filter basis, for any basis `ğ“‘` of `ğ“¤ Î²`. -/
protected theorem has_basis_nhds_of_basis (f) {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (h : HasBasis (ğ“¤ Î²) p s) :
    (ğ“ f).HasBasis p fun i => { g | (f, g) âˆˆ UniformConvergence.gen Î± Î² (s i) } :=
  nhds_basis_uniformity' (UniformConvergence.has_basis_uniformity_of_basis Î± Î² h)
#align uniform_convergence.has_basis_nhds_of_basis UniformConvergence.has_basis_nhds_of_basis

/-- If `Î± â†’ Î²` is endowed with the topology of uniform convergence, `ğ“ f` admits the family
`{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected theorem has_basis_nhds (f) :
    (ğ“ f).HasBasis (fun V => V âˆˆ ğ“¤ Î²) fun V => { g | (f, g) âˆˆ UniformConvergence.gen Î± Î² V } :=
  UniformConvergence.has_basis_nhds_of_basis Î± Î² f (Filter.basis_sets _)
#align uniform_convergence.has_basis_nhds UniformConvergence.has_basis_nhds

variable {Î±}

/-- Evaluation at a fixed point is uniformly continuous for `ğ’°(Î±, Î², uÎ²)`. -/
theorem uniform_continuous_eval (x : Î±) : UniformContinuous (Function.eval x : (Î± â†’ Î²) â†’ Î²) := by
  change _ â‰¤ _
  rw [map_le_iff_le_comap, (UniformConvergence.has_basis_uniformity Î± Î²).le_basis_iff ((ğ“¤ _).basis_sets.comap _)]
  exact fun U hU => âŸ¨U, hU, fun uv huv => huv xâŸ©
#align uniform_convergence.uniform_continuous_eval UniformConvergence.uniform_continuous_eval

variable {Î²}

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³` and `uâ‚ â‰¤ uâ‚‚`, then
`ğ’°(Î±, Î³, uâ‚) â‰¤ ğ’°(Î±, Î³, uâ‚‚)`. -/
protected theorem mono : Monotone (@UniformConvergence.uniformSpace Î± Î³) := fun uâ‚ uâ‚‚ hu =>
  (UniformConvergence.gc Î± Î³).monotone_u hu
#align uniform_convergence.mono UniformConvergence.mono

/-- If `u` is a family of uniform structures on `Î³`, then
`ğ’°(Î±, Î³, (â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i)`. -/
protected theorem infi_eq {u : Î¹ â†’ UniformSpace Î³} : ğ’°(Î±, Î³, â¨… i, u i) = â¨… i, ğ’°(Î±, Î³, u i) := by
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  ext : 1
  change UniformConvergence.filter Î± Î³ (@uniformity _ (â¨… i, u i)) = @uniformity _ (â¨… i, ğ’°(Î±, Î³, u i))
  rw [infi_uniformity', infi_uniformity']
  exact (UniformConvergence.gc Î± Î³).u_infi
#align uniform_convergence.infi_eq UniformConvergence.infi_eq

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then
`ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚) = ğ’°(Î±, Î³, uâ‚) âŠ“ ğ’°(Î±, Î³, uâ‚‚)`. -/
protected theorem inf_eq {uâ‚ uâ‚‚ : UniformSpace Î³} : ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚) = ğ’°(Î±, Î³, uâ‚) âŠ“ ğ’°(Î±, Î³, uâ‚‚) := by
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  rw [inf_eq_infi, inf_eq_infi, UniformConvergence.infi_eq]
  refine' infi_congr fun i => _
  cases i <;> rfl
#align uniform_convergence.inf_eq UniformConvergence.inf_eq

/-- If `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
`ğ’°(Î±, Î³, comap f u) = comap (Î» g, f âˆ˜ g) ğ’°(Î±, Î³, uâ‚)`. -/
protected theorem comap_eq {f : Î³ â†’ Î²} : ğ’°(Î±, Î³, â€¹UniformSpace Î²â€º.comap f) = ğ’°(Î±, Î², _).comap ((Â· âˆ˜ Â·) f) := by
  letI : UniformSpace Î³ := â€¹UniformSpace Î²â€º.comap f
  ext : 1
  change UniformConvergence.filter Î± Î³ ((ğ“¤ Î²).comap _) = (UniformConvergence.filter Î± Î² (ğ“¤ Î²)).comap _
  -- We have the following four Galois connection which form a square diagram, and we want
  -- to show that the square of upper adjoints is commutative. The trick then is to use
  -- `galois_connection.u_comm_of_l_comm` to reduce it to commutativity of the lower adjoints,
  -- which is way easier to prove.
  have hâ‚ := Filter.gc_map_comap (Prod.map ((Â· âˆ˜ Â·) f) ((Â· âˆ˜ Â·) f))
  have hâ‚‚ := Filter.gc_map_comap (Prod.map f f)
  have hâ‚ƒ := UniformConvergence.gc Î± Î²
  have hâ‚„ := UniformConvergence.gc Î± Î³
  refine' GaloisConnection.u_comm_of_l_comm hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ fun ğ“ => _
  have : Prod.map f f âˆ˜ Î¦ Î± Î³ = Î¦ Î± Î² âˆ˜ Prod.map (Prod.map ((Â· âˆ˜ Â·) f) ((Â· âˆ˜ Â·) f)) id := by ext <;> rfl
  rw [map_comm this, â† prod_map_map_eq']
  rfl
#align uniform_convergence.comap_eq UniformConvergence.comap_eq

/-- Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of uniform convergence.

More precisely, if `f : (Î³, uÎ³) â†’ (Î², uÎ²)` is uniformly continuous, then
`(Î» g, f âˆ˜ g) : (Î± â†’ Î³, ğ’°(Î±, Î³, uÎ³)) â†’ (Î± â†’ Î², ğ’°(Î±, Î², uÎ²))` is uniformly continuous. -/
protected theorem postcomp_uniform_continuous [UniformSpace Î³] {f : Î³ â†’ Î²} (hf : UniformContinuous f) :
    UniformContinuous ((Â· âˆ˜ Â·) f : (Î± â†’ Î³) â†’ Î± â†’ Î²) :=
  -- This is a direct consequence of `uniform_convergence.comap_eq`
      uniform_continuous_iff.mpr <|
    calc
      ğ’°(Î±, Î³, _) â‰¤ ğ’°(Î±, Î³, â€¹UniformSpace Î²â€º.comap f) := UniformConvergence.mono (uniform_continuous_iff.mp hf)
      _ = ğ’°(Î±, Î², _).comap ((Â· âˆ˜ Â·) f) := UniformConvergence.comap_eq
      
#align uniform_convergence.postcomp_uniform_continuous UniformConvergence.postcomp_uniform_continuous

/-- Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of uniform convergence.

More precisely, if `f : (Î³, uÎ³) â†’ (Î², uÎ²)` is a uniform inducing, then
`(Î» g, f âˆ˜ g) : (Î± â†’ Î³, ğ’°(Î±, Î³, uÎ³)) â†’ (Î± â†’ Î², ğ’°(Î±, Î², uÎ²))` is a uniform inducing. -/
protected theorem postcomp_uniform_inducing [UniformSpace Î³] {f : Î³ â†’ Î²} (hf : UniformInducing f) :
    UniformInducing ((Â· âˆ˜ Â·) f : (Î± â†’ Î³) â†’ Î± â†’ Î²) := by
  -- This is a direct consequence of `uniform_convergence.comap_eq`
  constructor
  replace hf : (ğ“¤ Î²).comap (Prod.map f f) = _ := hf.comap_uniformity
  change comap (Prod.map ((Â· âˆ˜ Â·) f) ((Â· âˆ˜ Â·) f)) _ = _
  rw [â† uniformity_comap rfl] at hfâŠ¢
  congr
  rw [â† uniform_space_eq hf, UniformConvergence.comap_eq]
#align uniform_convergence.postcomp_uniform_inducing UniformConvergence.postcomp_uniform_inducing

/-- Turn a uniform isomorphism `(Î³, uÎ³) â‰ƒáµ¤ (Î², uÎ²)` into a uniform isomorphism
`(Î± â†’ Î³, ğ’°(Î±, Î³, uÎ³)) â‰ƒáµ¤ (Î± â†’ Î², ğ’°(Î±, Î², uÎ²))` by post-composing. -/
protected def congrRight [UniformSpace Î³] (e : Î³ â‰ƒáµ¤ Î²) : (Î± â†’ Î³) â‰ƒáµ¤ (Î± â†’ Î²) :=
  { Equiv.piCongrRight fun a => e.toEquiv with
    uniform_continuous_to_fun := UniformConvergence.postcomp_uniform_continuous e.UniformContinuous,
    uniform_continuous_inv_fun := UniformConvergence.postcomp_uniform_continuous e.symm.UniformContinuous }
#align uniform_convergence.congr_right UniformConvergence.congrRight

/-- Pre-composition by a any function is uniformly continuous for the uniform structures of
uniform convergence.

More precisely, for any `f : Î³ â†’ Î±`, the function
`(Î» g, g âˆ˜ f) : (Î± â†’ Î², ğ’°(Î±, Î², uÎ²)) â†’ (Î³ â†’ Î², ğ’°(Î³, Î², uÎ²))` is uniformly continuous. -/
protected theorem precomp_uniform_continuous {f : Î³ â†’ Î±} : UniformContinuous fun g : Î± â†’ Î² => g âˆ˜ f := by
  -- Here we simply go back to filter bases.
  rw [uniform_continuous_iff]
  change ğ“¤ (Î± â†’ Î²) â‰¤ (ğ“¤ (Î³ â†’ Î²)).comap (Prod.map (fun g : Î± â†’ Î² => g âˆ˜ f) fun g : Î± â†’ Î² => g âˆ˜ f)
  rw [(UniformConvergence.has_basis_uniformity Î± Î²).le_basis_iff
      ((UniformConvergence.has_basis_uniformity Î³ Î²).comap _)]
  exact fun U hU => âŸ¨U, hU, fun uv huv x => huv (f x)âŸ©
#align uniform_convergence.precomp_uniform_continuous UniformConvergence.precomp_uniform_continuous

/-- Turn a bijection `Î³ â‰ƒ Î±` into a uniform isomorphism
`(Î³ â†’ Î², ğ’°(Î³, Î², uÎ²)) â‰ƒáµ¤ (Î± â†’ Î², ğ’°(Î±, Î², uÎ²))` by pre-composing. -/
protected def congrLeft (e : Î³ â‰ƒ Î±) : (Î³ â†’ Î²) â‰ƒáµ¤ (Î± â†’ Î²) :=
  { Equiv.arrowCongr e (Equiv.refl _) with uniform_continuous_to_fun := UniformConvergence.precomp_uniform_continuous,
    uniform_continuous_inv_fun := UniformConvergence.precomp_uniform_continuous }
#align uniform_convergence.congr_left UniformConvergence.congrLeft

/-- The topology of uniform convergence is Tâ‚‚. -/
theorem t2Space [T2Space Î²] : T2Space (Î± â†’ Î²) :=
  { t2 := by
      letI : UniformSpace (Î± â†’ Î²) := ğ’°(Î±, Î², _)
      letI : TopologicalSpace (Î± â†’ Î²) := UniformConvergence.topologicalSpace Î± Î²
      intro f g h
      obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext h)
      exact separated_by_continuous (uniform_continuous_eval Î² x).Continuous hx }
#align uniform_convergence.t2_space UniformConvergence.t2Space

/-- The uniform structure of uniform convergence is finer than that of pointwise convergence,
aka the product uniform structure. -/
protected theorem le_Pi : ğ’°(Î±, Î², _) â‰¤ PiCat.uniformSpace fun _ => Î² := by
  -- By definition of the product uniform structure, this is just `uniform_continuous_eval`.
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi]
  intro x
  exact uniform_continuous_eval Î² x
#align uniform_convergence.le_Pi UniformConvergence.le_Pi

/-- The topology of uniform convergence indeed gives the same notion of convergence as
`tendsto_uniformly`. -/
protected theorem tendsto_iff_tendsto_uniformly : Tendsto F p (ğ“ f) â†” TendstoUniformly F f p := by
  letI : UniformSpace (Î± â†’ Î²) := ğ’°(Î±, Î², _)
  rw [(UniformConvergence.has_basis_nhds Î± Î² f).tendsto_right_iff, TendstoUniformly]
  exact Iff.rfl
#align uniform_convergence.tendsto_iff_tendsto_uniformly UniformConvergence.tendsto_iff_tendsto_uniformly

/-- The natural bijection between `Î± â†’ Î² Ã— Î³` and `(Î± â†’ Î²) Ã— (Î± â†’ Î³)`, upgraded to a uniform
isomorphism between `(Î± â†’ Î² Ã— Î³, ğ’°(Î±, Î² Ã— Î³, uÎ² Ã— uÎ³))` and
`((Î± â†’ Î²) Ã— (Î± â†’ Î³), ğ’°(Î±, Î², uÎ²) Ã— ğ’°(Î±, Î³, uÎ³))`. -/
protected def uniformEquivProdArrow [UniformSpace Î³] : (Î± â†’ Î² Ã— Î³) â‰ƒáµ¤ (Î± â†’ Î²) Ã— (Î± â†’ Î³) :=
  (-- Denote `Ï†` this bijection. We want to show that
        -- `comap Ï† (ğ’°(Î±, Î², uÎ²) Ã— ğ’°(Î±, Î³, uÎ³)) = ğ’°(Î±, Î² Ã— Î³, uÎ² Ã— uÎ³)`.
        -- But `uÎ² Ã— uÎ³` is defined as `comap fst uÎ² âŠ“ comap snd uÎ³`, so we just have to apply
        -- `uniform_convergence.inf_eq` and `uniform_convergence.comap_eq`, which leaves us to check
        -- that some square commutes.
        Equiv.arrowProdEquivProdArrow
        _ _ _).toUniformEquivOfUniformInducing
    (by
      constructor
      change comap (Prod.map (Equiv.arrowProdEquivProdArrow _ _ _) (Equiv.arrowProdEquivProdArrow _ _ _)) _ = _
      rw [â† uniformity_comap rfl]
      congr
      rw [Prod.uniformSpace, Prod.uniformSpace, UniformSpace.comap_inf, UniformConvergence.inf_eq]
      congr <;> rw [â† UniformSpace.comap_comap, UniformConvergence.comap_eq] <;> rfl)
#align uniform_convergence.uniform_equiv_prod_arrow UniformConvergence.uniformEquivProdArrow

-- the relevant diagram commutes by definition
variable (Î±) (Î´ : Î¹ â†’ Type _) [âˆ€ i, UniformSpace (Î´ i)]

attribute [-instance] UniformConvergence.uniformSpace

/-- The natural bijection between `Î± â†’ Î  i, Î´ i` and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform
isomorphism between `(Î± â†’ (Î  i, Î´ i), ğ’°(Î±, (Î  i, Î´ i), (Î  i, uÎ´ i)))` and
`((Î  i, Î± â†’ Î´ i), (Î  i, ğ’°(Î±, Î´ i, uÎ´ i)))`. -/
protected def uniformEquivPiComm :
    @UniformEquiv (Î± â†’ âˆ€ i, Î´ i) (âˆ€ i, Î± â†’ Î´ i) ğ’°(Î±, âˆ€ i, Î´ i, PiCat.uniformSpace Î´)
      (@PiCat.uniformSpace Î¹ (fun i => Î± â†’ Î´ i) fun i => ğ’°(Î±, Î´ i, _)) :=
  -- Denote `Ï†` this bijection. We want to show that
    -- `comap Ï† (Î  i, ğ’°(Î±, Î´ i, uÎ´ i)) = ğ’°(Î±, (Î  i, Î´ i), (Î  i, uÎ´ i))`.
    -- But `Î  i, uÎ´ i` is defined as `â¨… i, comap (eval i) (uÎ´ i)`, so we just have to apply
    -- `uniform_convergence.infi_eq` and `uniform_convergence.comap_eq`, which leaves us to check
    -- that some square commutes.
    @Equiv.toUniformEquivOfUniformInducing
    _ _ ğ’°(Î±, âˆ€ i, Î´ i, PiCat.uniformSpace Î´) (@PiCat.uniformSpace Î¹ (fun i => Î± â†’ Î´ i) fun i => ğ’°(Î±, Î´ i, _))
    (Equiv.piComm _)
    (by
      constructor
      change comap (Prod.map Function.swap Function.swap) _ = _
      rw [â† uniformity_comap rfl]
      congr
      rw [PiCat.uniformSpace, UniformSpace.of_core_eq_to_core, PiCat.uniformSpace, UniformSpace.of_core_eq_to_core,
        UniformSpace.comap_infi, UniformConvergence.infi_eq]
      refine' infi_congr fun i => _
      rw [â† UniformSpace.comap_comap, UniformConvergence.comap_eq])
#align uniform_convergence.uniform_equiv_Pi_comm UniformConvergence.uniformEquivPiComm

-- Like in the previous lemma, the diagram actually commutes by definition
end UniformConvergence

namespace UniformConvergenceOn

variable {Î± Î² : Type _} {Î³ Î¹ : Type _}

variable {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : Set Î±} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±}

-- mathport name: Â«exprğ’°( , , )Â»
local notation "ğ’°(" Î± ", " Î² ", " u ")" => @UniformConvergence.uniformSpace Î± Î² u

/-- Basis sets for the uniformity of `ğ”–`-convergence: for `S : set Î±` and `V : set (Î² Ã— Î²)`,
`gen S V` is the set of pairs `(f, g)` of functions `Î± â†’ Î²` such that `âˆ€ x âˆˆ S, (f x, g x) âˆˆ V`. -/
protected def gen (S : Set Î±) (V : Set (Î² Ã— Î²)) : Set ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  { uv : (Î± â†’ Î²) Ã— (Î± â†’ Î²) | âˆ€ x âˆˆ S, (uv.1 x, uv.2 x) âˆˆ V }
#align uniform_convergence_on.gen UniformConvergenceOn.gen

/-- For `S : set Î±` and `V : set (Î² Ã— Î²)`, we have
`uniform_convergence_on.gen S V = (S.restrict Ã— S.restrict) â»Â¹' (uniform_convergence.gen S Î² V)`.
This is the crucial fact for proving that the family `uniform_convergence_on.gen S V` for
`S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` is indeed a basis for the uniformity `Î± â†’ Î²` endowed with `ğ’±(Î±, Î², ğ”–, uÎ²)`
the uniform structure of `ğ”–`-convergence, as defined in `uniform_convergence_on.uniform_space`. -/
protected theorem gen_eq_preimage_restrict (S : Set Î±) (V : Set (Î² Ã— Î²)) :
    UniformConvergenceOn.gen S V = Prod.map S.restrict S.restrict â»Â¹' UniformConvergence.gen S Î² V := by
  ext uv
  exact âŸ¨fun h âŸ¨x, hxâŸ© => h x hx, fun h x hx => h âŸ¨x, hxâŸ©âŸ©
#align uniform_convergence_on.gen_eq_preimage_restrict UniformConvergenceOn.gen_eq_preimage_restrict

/-- `uniform_convergence_on.gen` is antitone in the first argument and monotone in the second. -/
protected theorem gen_mono {S S' : Set Î±} {V V' : Set (Î² Ã— Î²)} (hS : S' âŠ† S) (hV : V âŠ† V') :
    UniformConvergenceOn.gen S V âŠ† UniformConvergenceOn.gen S' V' := fun uv h x hx => hV (h x <| hS hx)
#align uniform_convergence_on.gen_mono UniformConvergenceOn.gen_mono

/-- If `ğ”– : set (set Î±)` is nonempty and directed and `ğ“‘` is a filter basis on `Î² Ã— Î²`, then the
family `uniform_convergence_on.gen S V` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` is a filter basis.
We will show in `has_basis_uniformity_of_basis` that, if `ğ“‘` is a basis for `ğ“¤ Î²`, then the
corresponding filter is the uniformity of `(Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))`. -/
protected theorem is_basis_gen (ğ”– : Set (Set Î±)) (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–)
    (ğ“‘ : FilterBasis <| Î² Ã— Î²) :
    IsBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“‘) fun SV => UniformConvergenceOn.gen SV.1 SV.2 :=
  âŸ¨h.Prod ğ“‘.Nonempty, fun Uâ‚Vâ‚ Uâ‚‚Vâ‚‚ hâ‚ hâ‚‚ =>
    let âŸ¨Uâ‚ƒ, hUâ‚ƒ, hUâ‚â‚ƒ, hUâ‚‚â‚ƒâŸ© := h' Uâ‚Vâ‚.1 hâ‚.1 Uâ‚‚Vâ‚‚.1 hâ‚‚.1
    let âŸ¨Vâ‚ƒ, hVâ‚ƒ, hVâ‚â‚‚â‚ƒâŸ© := ğ“‘.inter_sets hâ‚.2 hâ‚‚.2
    âŸ¨âŸ¨Uâ‚ƒ, Vâ‚ƒâŸ©,
      âŸ¨âŸ¨hUâ‚ƒ, hVâ‚ƒâŸ©, fun uv huv =>
        âŸ¨fun x hx => (hVâ‚â‚‚â‚ƒ <| huv x <| hUâ‚â‚ƒ hx).1, fun x hx => (hVâ‚â‚‚â‚ƒ <| huv x <| hUâ‚‚â‚ƒ hx).2âŸ©âŸ©âŸ©âŸ©
#align uniform_convergence_on.is_basis_gen UniformConvergenceOn.is_basis_gen

variable (Î± Î²) [UniformSpace Î²] (ğ”– : Set (Set Î±))

/-- Uniform structure of `ğ”–`-convergence, i.e uniform convergence on the elements of `ğ”–`.
It is defined as the infimum, for `S âˆˆ ğ”–`, of the pullback of `ğ’° S Î²` by `S.restrict`, the
map of restriction to `S`. We will denote it `ğ’±(Î±, Î², ğ”–, uÎ²)`, where `uÎ²` is the uniform structure
on `Î²`. -/
protected def uniformSpace : UniformSpace (Î± â†’ Î²) :=
  â¨… (s : Set Î±) (hs : s âˆˆ ğ”–), UniformSpace.comap s.restrict ğ’°(s, Î², _)
#align uniform_convergence_on.uniform_space UniformConvergenceOn.uniformSpace

-- mathport name: Â«exprğ’±( , , , )Â»
local notation "ğ’±(" Î± ", " Î² ", " ğ”– ", " u ")" => @UniformConvergenceOn.uniformSpace Î± Î² u ğ”–

/-- Topology of `ğ”–`-convergence, i.e uniform convergence on the elements of `ğ”–`. -/
protected def topologicalSpace : TopologicalSpace (Î± â†’ Î²) :=
  ğ’±(Î±, Î², ğ”–, _).toTopologicalSpace
#align uniform_convergence_on.topological_space UniformConvergenceOn.topologicalSpace

/-- The topology of `ğ”–`-convergence is the infimum, for `S âˆˆ ğ”–`, of topology induced by the map
of restriction to `S`, where `â†¥S â†’ Î²` is endowed with the topology of uniform convergence. -/
protected theorem topological_space_eq :
    UniformConvergenceOn.topologicalSpace Î± Î² ğ”– =
      â¨… (s : Set Î±) (hs : s âˆˆ ğ”–), TopologicalSpace.induced s.restrict (UniformConvergence.topologicalSpace s Î²) :=
  by
  simp only [UniformConvergenceOn.topologicalSpace, to_topological_space_infi, to_topological_space_infi,
    to_topological_space_comap]
  rfl
#align uniform_convergence_on.topological_space_eq UniformConvergenceOn.topological_space_eq

protected theorem has_basis_uniformity_of_basis_auxâ‚ {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s)
    (S : Set Î±) :
    (@uniformity (Î± â†’ Î²) ((UniformConvergence.uniformSpace S Î²).comap S.restrict)).HasBasis p fun i =>
      UniformConvergenceOn.gen S (s i) :=
  by
  simp_rw [UniformConvergenceOn.gen_eq_preimage_restrict, uniformity_comap rfl]
  exact (UniformConvergence.has_basis_uniformity_of_basis S Î² hb).comap _
#align uniform_convergence_on.has_basis_uniformity_of_basis_auxâ‚ UniformConvergenceOn.has_basis_uniformity_of_basis_auxâ‚

protected theorem has_basis_uniformity_of_basis_auxâ‚‚ (h : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}
    (hb : HasBasis (ğ“¤ Î²) p s) :
    DirectedOn
      ((fun s : Set Î± => (UniformConvergence.uniformSpace s Î²).comap (s.restrict : (Î± â†’ Î²) â†’ s â†’ Î²)) â»Â¹'o GE.ge) ğ”– :=
  h.mono fun s t hst =>
    ((UniformConvergenceOn.has_basis_uniformity_of_basis_auxâ‚ Î± Î² hb _).le_basis_iff
          (UniformConvergenceOn.has_basis_uniformity_of_basis_auxâ‚ Î± Î² hb _)).mpr
      fun V hV => âŸ¨V, hV, UniformConvergenceOn.gen_mono hst subset_rflâŸ©
#align uniform_convergence_on.has_basis_uniformity_of_basis_auxâ‚‚ UniformConvergenceOn.has_basis_uniformity_of_basis_auxâ‚‚

/-- If `ğ”– : set (set Î±)` is nonempty and directed and `ğ“‘` is a filter basis of `ğ“¤ Î²`, then the
uniformity of `(Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` admits the family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for
`S âˆˆ ğ”–` and `V âˆˆ ğ“‘` as a filter basis. -/
protected theorem has_basis_uniformity_of_basis (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop}
    {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :
    (@uniformity (Î± â†’ Î²) (UniformConvergenceOn.uniformSpace Î± Î² ğ”–)).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2)
      fun Si => UniformConvergenceOn.gen Si.1 (s Si.2) :=
  by
  simp only [infi_uniformity']
  exact
    has_basis_binfi_of_directed h (fun S => @UniformConvergenceOn.gen Î± Î² S âˆ˜ s) _
      (fun S hS => UniformConvergenceOn.has_basis_uniformity_of_basis_auxâ‚ Î± Î² hb S)
      (UniformConvergenceOn.has_basis_uniformity_of_basis_auxâ‚‚ Î± Î² ğ”– h' hb)
#align uniform_convergence_on.has_basis_uniformity_of_basis UniformConvergenceOn.has_basis_uniformity_of_basis

/-- If `ğ”– : set (set Î±)` is nonempty and directed, then the uniformity of
`(Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` admits the family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and
`V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected theorem has_basis_uniformity (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :
    (@uniformity (Î± â†’ Î²) (UniformConvergenceOn.uniformSpace Î± Î² ğ”–)).HasBasis
      (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²) fun SV => UniformConvergenceOn.gen SV.1 SV.2 :=
  UniformConvergenceOn.has_basis_uniformity_of_basis Î± Î² ğ”– h h' (ğ“¤ Î²).basis_sets
#align uniform_convergence_on.has_basis_uniformity UniformConvergenceOn.has_basis_uniformity

/-- If `Î± â†’ Î²` is endowed with the topology of `ğ”–`-convergence, where `ğ”– : set (set Î±)` is
nonempty and directed, then `ğ“ f` admits the family `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–`
and `V âˆˆ ğ“‘` as a filter basis, for any basis `ğ“‘` of `ğ“¤ Î²`. -/
protected theorem has_basis_nhds_of_basis (f) (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop}
    {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :
    (@nhds (Î± â†’ Î²) (UniformConvergenceOn.topologicalSpace Î± Î² ğ”–) f).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2)
      fun Si => { g | (g, f) âˆˆ UniformConvergenceOn.gen Si.1 (s Si.2) } :=
  letI : UniformSpace (Î± â†’ Î²) := UniformConvergenceOn.uniformSpace Î± Î² ğ”–
  nhds_basis_uniformity (UniformConvergenceOn.has_basis_uniformity_of_basis Î± Î² ğ”– h h' hb)
#align uniform_convergence_on.has_basis_nhds_of_basis UniformConvergenceOn.has_basis_nhds_of_basis

/-- If `Î± â†’ Î²` is endowed with the topology of `ğ”–`-convergence, where `ğ”– : set (set Î±)` is
nonempty and directed, then `ğ“ f` admits the family `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–`
and `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected theorem has_basis_nhds (f) (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :
    (@nhds (Î± â†’ Î²) (UniformConvergenceOn.topologicalSpace Î± Î² ğ”–) f).HasBasis
      (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²) fun SV =>
      { g | (g, f) âˆˆ UniformConvergenceOn.gen SV.1 SV.2 } :=
  UniformConvergenceOn.has_basis_nhds_of_basis Î± Î² ğ”– f h h' (Filter.basis_sets _)
#align uniform_convergence_on.has_basis_nhds UniformConvergenceOn.has_basis_nhds

/-- If `S âˆˆ ğ”–`, then the restriction to `S` is a uniformly continuous map from `ğ’±(Î±, Î², ğ”–, uÎ²)` to
`ğ’°(â†¥S, Î², uÎ²)`. -/
protected theorem uniform_continuous_restrict (h : s âˆˆ ğ”–) :
    @UniformContinuous _ _ ğ’±(Î±, Î², ğ”–, _) ğ’°(s, Î², _) s.restrict := by
  change _ â‰¤ _
  rw [UniformConvergenceOn.uniformSpace, map_le_iff_le_comap, uniformity, infi_uniformity]
  refine' infi_le_of_le s _
  rw [infi_uniformity]
  exact infi_le _ h
#align uniform_convergence_on.uniform_continuous_restrict UniformConvergenceOn.uniform_continuous_restrict

variable {Î±}

/-- Let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and `ğ”–â‚ ğ”–â‚‚ : set (set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and
`ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`. -/
protected theorem mono â¦ƒuâ‚ uâ‚‚ : UniformSpace Î³â¦„ (hu : uâ‚ â‰¤ uâ‚‚) â¦ƒğ”–â‚ ğ”–â‚‚ : Set (Set Î±)â¦„ (hğ”– : ğ”–â‚‚ âŠ† ğ”–â‚) :
    ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) :=
  calc
    ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚) := infi_le_infi_of_subset hğ”–
    _ â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) := infiâ‚‚_mono fun i hi => UniformSpace.comap_mono <| UniformConvergence.mono hu
    
#align uniform_convergence_on.mono UniformConvergenceOn.mono

/-- If `x : Î±` is in some `S âˆˆ ğ”–`, then evaluation at `x` is uniformly continuous for
`ğ’±(Î±, Î², ğ”–, uÎ²)`. -/
theorem uniform_continuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ğ”–) :
    @UniformContinuous _ _ ğ’±(Î±, Î², ğ”–, _) _ (Function.eval x) :=
  @UniformContinuous.comp (Î± â†’ Î²) (s â†’ Î²) Î² ğ’±(Î±, Î², ğ”–, _) ğ’°(s, Î², _) _ _ _
    (UniformConvergence.uniform_continuous_eval Î² (âŸ¨x, hxsâŸ© : s))
    (UniformConvergenceOn.uniform_continuous_restrict Î± Î² ğ”– hs)
#align uniform_convergence_on.uniform_continuous_eval_of_mem UniformConvergenceOn.uniform_continuous_eval_of_mem

variable {Î²} {ğ”–}

/-- If `u` is a family of uniform structures on `Î³`, then
`ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`. -/
protected theorem infi_eq {u : Î¹ â†’ UniformSpace Î³} : ğ’±(Î±, Î³, ğ”–, â¨… i, u i) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i) := by
  simp_rw [UniformConvergenceOn.uniformSpace, UniformConvergence.infi_eq, UniformSpace.comap_infi]
  rw [infi_comm]
  exact infi_congr fun s => infi_comm
#align uniform_convergence_on.infi_eq UniformConvergenceOn.infi_eq

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then
`ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚)`. -/
protected theorem inf_eq {uâ‚ uâ‚‚ : UniformSpace Î³} : ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚) := by
  rw [inf_eq_infi, inf_eq_infi, UniformConvergenceOn.infi_eq]
  refine' infi_congr fun i => _
  cases i <;> rfl
#align uniform_convergence_on.inf_eq UniformConvergenceOn.inf_eq

/-- If `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
`ğ’±(Î±, Î³, ğ”–, comap f u) = comap (Î» g, f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`. -/
protected theorem comap_eq {f : Î³ â†’ Î²} : ğ’±(Î±, Î³, ğ”–, â€¹UniformSpace Î²â€º.comap f) = ğ’±(Î±, Î², ğ”–, _).comap ((Â· âˆ˜ Â·) f) := by
  -- We reduce this to `uniform_convergence.comap_eq` using the fact that `comap` distributes
  -- on `infi`.
  simp_rw [UniformConvergenceOn.uniformSpace, UniformSpace.comap_infi, UniformConvergence.comap_eq, â†
    UniformSpace.comap_comap]
  rfl
#align uniform_convergence_on.comap_eq UniformConvergenceOn.comap_eq

-- by definition, `âˆ€ S âˆˆ ğ”–, (f âˆ˜ â€”) âˆ˜ S.restrict = S.restrict âˆ˜ (f âˆ˜ â€”)`.
/-- Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of `ğ”–`-convergence.

More precisely, if `f : (Î³, uÎ³) â†’ (Î², uÎ²)` is uniformly continuous, then
`(Î» g, f âˆ˜ g) : (Î± â†’ Î³, ğ’±(Î±, Î³, ğ”–, uÎ³)) â†’ (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` is uniformly continuous. -/
protected theorem postcomp_uniform_continuous [UniformSpace Î³] {f : Î³ â†’ Î²} (hf : UniformContinuous f) :
    @UniformContinuous (Î± â†’ Î³) (Î± â†’ Î²) ğ’±(Î±, Î³, ğ”–, _) ğ’±(Î±, Î², ğ”–, _) ((Â· âˆ˜ Â·) f) := by
  -- This is a direct consequence of `uniform_convergence.comap_eq`
  rw [uniform_continuous_iff]
  calc
    ğ’±(Î±, Î³, ğ”–, _) â‰¤ ğ’±(Î±, Î³, ğ”–, â€¹UniformSpace Î²â€º.comap f) :=
      UniformConvergenceOn.mono (uniform_continuous_iff.mp hf) subset_rfl
    _ = ğ’±(Î±, Î², ğ”–, _).comap ((Â· âˆ˜ Â·) f) := UniformConvergenceOn.comap_eq
    
#align uniform_convergence_on.postcomp_uniform_continuous UniformConvergenceOn.postcomp_uniform_continuous

/-- Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of `ğ”–`-convergence.

More precisely, if `f : (Î³, uÎ³) â†’ (Î², uÎ²)` is a uniform inducing, then
`(Î» g, f âˆ˜ g) : (Î± â†’ Î³, ğ’±(Î±, Î³, ğ”–, uÎ³)) â†’ (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` is a uniform inducing. -/
protected theorem postcomp_uniform_inducing [UniformSpace Î³] {f : Î³ â†’ Î²} (hf : UniformInducing f) :
    @UniformInducing (Î± â†’ Î³) (Î± â†’ Î²) ğ’±(Î±, Î³, ğ”–, _) ğ’±(Î±, Î², ğ”–, _) ((Â· âˆ˜ Â·) f) := by
  -- This is a direct consequence of `uniform_convergence.comap_eq`
  constructor
  replace hf : (ğ“¤ Î²).comap (Prod.map f f) = _ := hf.comap_uniformity
  change comap (Prod.map ((Â· âˆ˜ Â·) f) ((Â· âˆ˜ Â·) f)) _ = _
  rw [â† uniformity_comap rfl] at hfâŠ¢
  congr
  rw [â† uniform_space_eq hf, UniformConvergenceOn.comap_eq]
#align uniform_convergence_on.postcomp_uniform_inducing UniformConvergenceOn.postcomp_uniform_inducing

/-- Turn a uniform isomorphism `(Î³, uÎ³) â‰ƒáµ¤ (Î², uÎ²)` into a uniform isomorphism
`(Î± â†’ Î³, ğ’±(Î±, Î³, ğ”–, uÎ³)) â‰ƒáµ¤ (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²))` by post-composing. -/
protected def congrRight [UniformSpace Î³] (e : Î³ â‰ƒáµ¤ Î²) : @UniformEquiv (Î± â†’ Î³) (Î± â†’ Î²) ğ’±(Î±, Î³, ğ”–, _) ğ’±(Î±, Î², ğ”–, _) :=
  { Equiv.piCongrRight fun a => e.toEquiv with
    uniform_continuous_to_fun := UniformConvergenceOn.postcomp_uniform_continuous e.UniformContinuous,
    uniform_continuous_inv_fun := UniformConvergenceOn.postcomp_uniform_continuous e.symm.UniformContinuous }
#align uniform_convergence_on.congr_right UniformConvergenceOn.congrRight

/-- Let `f : Î³ â†’ Î±`, `ğ”– : set (set Î±)`, `ğ”— : set (set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`.
Then, the function `(Î» g, g âˆ˜ f) : (Î± â†’ Î², ğ’±(Î±, Î², ğ”–, uÎ²)) â†’ (Î³ â†’ Î², ğ’±(Î³, Î², ğ”— uÎ²))` is
uniformly continuous.

Note that one can easily see that assuming `âˆ€ T âˆˆ ğ”—, âˆƒ S âˆˆ ğ”–, f '' T âŠ† S` would work too, but
we will get this for free when we prove that `ğ’±(Î±, Î², ğ”–, uÎ²) = ğ’±(Î±, Î², ğ”–', uÎ²)` for `ğ”–'` the
***noncovering*** bornology generated by `ğ”–`. -/
protected theorem precomp_uniform_continuous {ğ”— : Set (Set Î³)} {f : Î³ â†’ Î±} (hf : ğ”— âŠ† image f â»Â¹' ğ”–) :
    @UniformContinuous (Î± â†’ Î²) (Î³ â†’ Î²) ğ’±(Î±, Î², ğ”–, _) ğ’±(Î³, Î², ğ”—, _) fun g : Î± â†’ Î² => g âˆ˜ f := by
  -- Since `comap` distributes on `infi`, it suffices to prove that
  -- `â¨… s âˆˆ ğ”–, comap s.restrict ğ’°(â†¥s, Î², uÎ²) â‰¤ â¨… t âˆˆ ğ”—, comap (t.restrict âˆ˜ (â€” âˆ˜ f)) ğ’°(â†¥t, Î², uÎ²)`.
  simp_rw [uniform_continuous_iff, UniformConvergenceOn.uniformSpace, UniformSpace.comap_infi, â†
    UniformSpace.comap_comap]
  -- For any `t âˆˆ ğ”—`, note `s := f '' t âˆˆ ğ”–`.
  -- We will show that `comap s.restrict ğ’°(â†¥s, Î², uÎ²) â‰¤ comap (t.restrict âˆ˜ (â€” âˆ˜ f)) ğ’°(â†¥t, Î², uÎ²)`.
  refine' le_infiâ‚‚ fun t ht => infi_le_of_le (f '' t) <| infi_le_of_le (hf ht) _
  -- Let `f'` be the map from `t` to `f '' t` induced by `f`.
  let f' : t â†’ f '' t := (maps_to_image f t).restrict f t (f '' t)
  -- By definition `t.restrict âˆ˜ (â€” âˆ˜ f) = (â€” âˆ˜ f') âˆ˜ (f '' t).restrict`.
  have : (t.restrict âˆ˜ fun g : Î± â†’ Î² => g âˆ˜ f) = (fun g : f '' t â†’ Î² => g âˆ˜ f') âˆ˜ (f '' t).restrict := rfl
  -- Thus, we have to show `comap (f '' t).restrict ğ’°(â†¥(f '' t), Î², uÎ²) â‰¤`
  -- `comap (f '' t).restrict (comap (â€” âˆ˜ f') ğ’°(â†¥t, Î², uÎ²))`.
  rw [this, @UniformSpace.comap_comap (Î± â†’ Î²) (f '' t â†’ Î²)]
  -- But this is exactly monotonicity of `comap` applied to
  -- `uniform_convergence.precomp_continuous`.
  refine' UniformSpace.comap_mono _
  rw [â† uniform_continuous_iff]
  exact UniformConvergence.precomp_uniform_continuous
#align uniform_convergence_on.precomp_uniform_continuous UniformConvergenceOn.precomp_uniform_continuous

/-- Turn a bijection `e : Î³ â‰ƒ Î±` such that we have both `âˆ€ T âˆˆ ğ”—, e '' T âˆˆ ğ”–` and
`âˆ€ S âˆˆ ğ”–, e â»Â¹' S âˆˆ ğ”—` into a uniform isomorphism `(Î³ â†’ Î², ğ’°(Î³, Î², uÎ²)) â‰ƒáµ¤ (Î± â†’ Î², ğ’°(Î±, Î², uÎ²))`
by pre-composing. -/
protected def congrLeft {ğ”— : Set (Set Î³)} (e : Î³ â‰ƒ Î±) (he : ğ”— âŠ† image e â»Â¹' ğ”–) (he' : ğ”– âŠ† preimage e â»Â¹' ğ”—) :
    @UniformEquiv (Î³ â†’ Î²) (Î± â†’ Î²) ğ’±(Î³, Î², ğ”—, _) ğ’±(Î±, Î², ğ”–, _) :=
  { Equiv.arrowCongr e (Equiv.refl _) with
    uniform_continuous_to_fun :=
      UniformConvergenceOn.precomp_uniform_continuous
        (by
          intro s hs
          change e.symm '' s âˆˆ ğ”—
          rw [â† preimage_equiv_eq_image_symm]
          exact he' hs),
    uniform_continuous_inv_fun := UniformConvergenceOn.precomp_uniform_continuous he }
#align uniform_convergence_on.congr_left UniformConvergenceOn.congrLeft

/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/
theorem t2SpaceOfCovering [T2Space Î²] (h : â‹ƒâ‚€ğ”– = univ) : @T2Space _ (UniformConvergenceOn.topologicalSpace Î± Î² ğ”–) :=
  { t2 := by
      letI : UniformSpace (Î± â†’ Î²) := ğ’±(Î±, Î², ğ”–, _)
      letI : TopologicalSpace (Î± â†’ Î²) := UniformConvergenceOn.topologicalSpace Î± Î² ğ”–
      intro f g hfg
      obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg)
      obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ True.intro)
      exact separated_by_continuous (uniform_continuous_eval_of_mem Î² ğ”– hxs hs).Continuous hx }
#align uniform_convergence_on.t2_space_of_covering UniformConvergenceOn.t2SpaceOfCovering

/-- If `ğ”–` covers `Î±`, then the uniform structure of `ğ”–`-convergence is finer than that of
pointwise convergence. -/
protected theorem le_Pi_of_covering (h : â‹ƒâ‚€ğ”– = univ) : ğ’±(Î±, Î², ğ”–, _) â‰¤ PiCat.uniformSpace fun _ => Î² := by
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi]
  intro x
  obtain âŸ¨s : Set Î±, hs : s âˆˆ ğ”–, hxs : x âˆˆ sâŸ© := sUnion_eq_univ_iff.mp h x
  exact uniform_continuous_eval_of_mem Î² ğ”– hxs hs
#align uniform_convergence_on.le_Pi_of_covering UniformConvergenceOn.le_Pi_of_covering

/-- Convergence in the topology of `ğ”–`-convergence means uniform convergence on `S` (in the sense
of `tendsto_uniformly_on`) for all `S âˆˆ ğ”–`. -/
protected theorem tendsto_iff_tendsto_uniformly_on :
    Tendsto F p (@nhds _ (UniformConvergenceOn.topologicalSpace Î± Î² ğ”–) f) â†” âˆ€ s âˆˆ ğ”–, TendstoUniformlyOn F f p s := by
  letI : UniformSpace (Î± â†’ Î²) := ğ’±(Î±, Î², ğ”–, _)
  rw [UniformConvergenceOn.topological_space_eq, nhds_infi, tendsto_infi]
  refine' forall_congr' fun s => _
  rw [nhds_infi, tendsto_infi]
  refine' forall_congr' fun hs => _
  rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,
    UniformConvergence.tendsto_iff_tendsto_uniformly]
  rfl
#align uniform_convergence_on.tendsto_iff_tendsto_uniformly_on UniformConvergenceOn.tendsto_iff_tendsto_uniformly_on

/-- The natural bijection between `Î± â†’ Î² Ã— Î³` and `(Î± â†’ Î²) Ã— (Î± â†’ Î³)`, upgraded to a uniform
isomorphism between `(Î± â†’ Î² Ã— Î³, ğ’±(Î±, Î² Ã— Î³, ğ”–, uÎ² Ã— uÎ³))` and
`((Î± â†’ Î²) Ã— (Î± â†’ Î³), ğ’±(Î±, Î², ğ”–, uÎ²) Ã— ğ’°(Î±, Î³, ğ”–, uÎ³))`. -/
protected def uniformEquivProdArrow [UniformSpace Î³] :
    @UniformEquiv (Î± â†’ Î² Ã— Î³) ((Î± â†’ Î²) Ã— (Î± â†’ Î³)) ğ’±(Î±, Î² Ã— Î³, ğ”–, _)
      (@Prod.uniformSpace _ _ ğ’±(Î±, Î², ğ”–, _) ğ’±(Î±, Î³, ğ”–, _)) :=
  -- Denote `Ï†` this bijection. We want to show that
    -- `comap Ï† (ğ’±(Î±, Î², ğ”–, uÎ²) Ã— ğ’±(Î±, Î³, ğ”–, uÎ³)) = ğ’±(Î±, Î² Ã— Î³, ğ”–, uÎ² Ã— uÎ³)`.
    -- But `uÎ² Ã— uÎ³` is defined as `comap fst uÎ² âŠ“ comap snd uÎ³`, so we just have to apply
    -- `uniform_convergence_on.inf_eq` and `uniform_convergence_on.comap_eq`, which leaves us to check
    -- that some square commutes.
    -- We could also deduce this from `uniform_convergence.uniform_equiv_prod_arrow`, but it turns out
    -- to be more annoying.
    @Equiv.toUniformEquivOfUniformInducing
    _ _ ğ’±(Î±, Î² Ã— Î³, ğ”–, _) (@Prod.uniformSpace _ _ ğ’±(Î±, Î², ğ”–, _) ğ’±(Î±, Î³, ğ”–, _)) (Equiv.arrowProdEquivProdArrow _ _ _)
    (by
      constructor
      change comap (Prod.map (Equiv.arrowProdEquivProdArrow _ _ _) (Equiv.arrowProdEquivProdArrow _ _ _)) _ = _
      rw [â† uniformity_comap rfl]
      congr
      rw [Prod.uniformSpace, Prod.uniformSpace, UniformSpace.comap_inf, UniformConvergenceOn.inf_eq]
      congr <;> rw [â† UniformSpace.comap_comap, UniformConvergenceOn.comap_eq] <;> rfl)
#align uniform_convergence_on.uniform_equiv_prod_arrow UniformConvergenceOn.uniformEquivProdArrow

-- the relevant diagram commutes by definition
variable (ğ”–) (Î´ : Î¹ â†’ Type _) [âˆ€ i, UniformSpace (Î´ i)]

/-- The natural bijection between `Î± â†’ Î  i, Î´ i` and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform
isomorphism between `(Î± â†’ (Î  i, Î´ i), ğ’±(Î±, (Î  i, Î´ i), ğ”–, (Î  i, uÎ´ i)))` and
`((Î  i, Î± â†’ Î´ i), (Î  i, ğ’±(Î±, Î´ i, ğ”–, uÎ´ i)))`. -/
protected def uniformEquivPiComm :
    @UniformEquiv (Î± â†’ âˆ€ i, Î´ i) (âˆ€ i, Î± â†’ Î´ i) ğ’±(Î±, âˆ€ i, Î´ i, ğ”–, PiCat.uniformSpace Î´)
      (@PiCat.uniformSpace Î¹ (fun i => Î± â†’ Î´ i) fun i => ğ’±(Î±, Î´ i, ğ”–, _)) :=
  -- Denote `Ï†` this bijection. We want to show that
    -- `comap Ï† (Î  i, ğ’±(Î±, Î´ i, ğ”–, uÎ´ i)) = ğ’±(Î±, (Î  i, Î´ i), ğ”–, (Î  i, uÎ´ i))`.
    -- But `Î  i, uÎ´ i` is defined as `â¨… i, comap (eval i) (uÎ´ i)`, so we just have to apply
    -- `uniform_convergence_on.infi_eq` and `uniform_convergence_on.comap_eq`, which leaves us to check
    -- that some square commutes.
    -- We could also deduce this from `uniform_convergence.uniform_equiv_Pi_comm`, but it turns out
    -- to be more annoying.
    @Equiv.toUniformEquivOfUniformInducing
    _ _ ğ’±(Î±, âˆ€ i, Î´ i, ğ”–, PiCat.uniformSpace Î´) (@PiCat.uniformSpace Î¹ (fun i => Î± â†’ Î´ i) fun i => ğ’±(Î±, Î´ i, ğ”–, _))
    (Equiv.piComm _)
    (by
      constructor
      change comap (Prod.map Function.swap Function.swap) _ = _
      rw [â† uniformity_comap rfl]
      congr
      rw [PiCat.uniformSpace, UniformSpace.of_core_eq_to_core, PiCat.uniformSpace, UniformSpace.of_core_eq_to_core,
        UniformSpace.comap_infi, UniformConvergenceOn.infi_eq]
      refine' infi_congr fun i => _
      rw [â† UniformSpace.comap_comap, UniformConvergenceOn.comap_eq])
#align uniform_convergence_on.uniform_equiv_Pi_comm UniformConvergenceOn.uniformEquivPiComm

-- Like in the previous lemma, the diagram actually commutes by definition
end UniformConvergenceOn

