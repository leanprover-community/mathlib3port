/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes H√∂lzl

! This file was ported from Lean 3 source module topology.uniform_space.completion
! leanprover-community/mathlib commit 23aa88e32dcc9d2a24cca7bc23268567ed4cd7d6
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.UniformSpace.AbstractCompletion

/-!
# Hausdorff completions of uniform spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The goal is to construct a left-adjoint to the inclusion of complete Hausdorff uniform spaces
into all uniform spaces. Any uniform space `Œ±` gets a completion `completion Œ±` and a morphism
(ie. uniformly continuous map) `coe : Œ± ‚Üí completion Œ±` which solves the universal
mapping problem of factorizing morphisms from `Œ±` to any complete Hausdorff uniform space `Œ≤`.
It means any uniformly continuous `f : Œ± ‚Üí Œ≤` gives rise to a unique morphism
`completion.extension f : completion Œ± ‚Üí Œ≤` such that `f = completion.extension f ‚àò coe`.
Actually `completion.extension f` is defined for all maps from `Œ±` to `Œ≤` but it has the desired
properties only if `f` is uniformly continuous.

Beware that `coe` is not injective if `Œ±` is not Hausdorff. But its image is always
dense. The adjoint functor acting on morphisms is then constructed by the usual abstract nonsense.
For every uniform spaces `Œ±` and `Œ≤`, it turns `f : Œ± ‚Üí Œ≤` into a morphism
  `completion.map f : completion Œ± ‚Üí completion Œ≤`
such that
  `coe ‚àò f = (completion.map f) ‚àò coe`
provided `f` is uniformly continuous. This construction is compatible with composition.

In this file we introduce the following concepts:

* `Cauchy Œ±` the uniform completion of the uniform space `Œ±` (using Cauchy filters). These are not
  minimal filters.

* `completion Œ± := quotient (separation_setoid (Cauchy Œ±))` the Hausdorff completion.

## References

This formalization is mostly based on
  N. Bourbaki: General Topology
  I. M. James: Topologies and Uniformities
From a slightly different perspective in order to reuse material in topology.uniform_space.basic.
-/


noncomputable section

open Filter Set

universe u v w x

open uniformity Classical Topology Filter

#print CauchyFilter /-
/-- Space of Cauchy filters

This is essentially the completion of a uniform space. The embeddings are the neighbourhood filters.
This space is not minimal, the separated uniform space (i.e. quotiented on the intersection of all
entourages) is necessary for this.
-/
def CauchyFilter (Œ± : Type u) [UniformSpace Œ±] : Type u :=
  { f : Filter Œ± // Cauchy f }
#align Cauchy CauchyFilter
-/

namespace CauchyFilter

section

parameter {Œ± : Type u}[UniformSpace Œ±]

variable {Œ≤ : Type v} {Œ≥ : Type w}

variable [UniformSpace Œ≤] [UniformSpace Œ≥]

#print CauchyFilter.gen /-
/-- The pairs of Cauchy filters generated by a set. -/
def gen (s : Set (Œ± √ó Œ±)) : Set (CauchyFilter Œ± √ó CauchyFilter Œ±) :=
  { p | s ‚àà p.1.val √ó·∂† p.2.val }
#align Cauchy.gen CauchyFilter.gen
-/

/- warning: Cauchy.monotone_gen -> CauchyFilter.monotone_gen is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], Monotone.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (PartialOrder.toPreorder.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Set.completeBooleanAlgebra.{u1} (Prod.{u1, u1} Œ± Œ±)))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Set.completeBooleanAlgebra.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))))))))) (CauchyFilter.gen.{u1} Œ± _inst_1)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], Monotone.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (PartialOrder.toPreorder.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Set.instCompleteBooleanAlgebraSet.{u1} (Prod.{u1, u1} Œ± Œ±)))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Set.instCompleteBooleanAlgebraSet.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))))))))) (CauchyFilter.gen.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align Cauchy.monotone_gen CauchyFilter.monotone_gen‚Çì'. -/
theorem monotone_gen : Monotone gen :=
  monotone_setOf fun p => @Filter.monotone_mem _ (p.1.val √ó·∂† p.2.val)
#align Cauchy.monotone_gen CauchyFilter.monotone_gen

private theorem symm_gen : map Prod.swap ((ùì§ Œ±).lift' gen) ‚â§ (ùì§ Œ±).lift' gen :=
  calc
    map Prod.swap ((ùì§ Œ±).lift' gen) =
        (ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => { p | s ‚àà p.2.val √ó·∂† p.1.val } :=
      by
      delta gen
      simp [map_lift'_eq, monotone_set_of, Filter.monotone_mem, Function.comp,
        image_swap_eq_preimage_swap, -Subtype.val_eq_coe]
    _ ‚â§ (ùì§ Œ±).lift' gen :=
      uniformity_lift_le_swap
        (monotone_principal.comp
          (monotone_setOf fun p => @Filter.monotone_mem _ (p.2.val √ó·∂† p.1.val)))
        (by
          have h := fun p : CauchyFilter Œ± √ó CauchyFilter Œ± => @Filter.prod_comm _ _ p.2.val p.1.val
          simp [Function.comp, h, -Subtype.val_eq_coe, mem_map']
          exact le_rfl)
    

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
private theorem comp_rel_gen_gen_subset_gen_comp_rel {s t : Set (Œ± √ó Œ±)} :
    compRel (gen s) (gen t) ‚äÜ (gen (compRel s t) : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)) :=
  fun ‚ü®f, g‚ü© ‚ü®h, h‚ÇÅ, h‚ÇÇ‚ü© =>
  let ‚ü®t‚ÇÅ, (ht‚ÇÅ : t‚ÇÅ ‚àà f), t‚ÇÇ, (ht‚ÇÇ : t‚ÇÇ ‚àà h), (h‚ÇÅ : t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s)‚ü© := mem_prod_iff.mp h‚ÇÅ
  let ‚ü®t‚ÇÉ, (ht‚ÇÉ : t‚ÇÉ ‚àà h), t‚ÇÑ, (ht‚ÇÑ : t‚ÇÑ ‚àà g), (h‚ÇÇ : t‚ÇÉ √óÀ¢ t‚ÇÑ ‚äÜ t)‚ü© := mem_prod_iff.mp h‚ÇÇ
  have : t‚ÇÇ ‚à© t‚ÇÉ ‚àà h.val := inter_mem ht‚ÇÇ ht‚ÇÉ
  let ‚ü®x, xt‚ÇÇ, xt‚ÇÉ‚ü© := h.property.left.nonempty_of_mem this
  (f.val √ó·∂† g.val).sets_of_superset (prod_mem_prod ht‚ÇÅ ht‚ÇÑ)
    fun ‚ü®a, b‚ü© ‚ü®(ha : a ‚àà t‚ÇÅ), (hb : b ‚àà t‚ÇÑ)‚ü© =>
    ‚ü®x, h‚ÇÅ (show (a, x) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ from ‚ü®ha, xt‚ÇÇ‚ü©), h‚ÇÇ (show (x, b) ‚àà t‚ÇÉ √óÀ¢ t‚ÇÑ from ‚ü®xt‚ÇÉ, hb‚ü©)‚ü©

private theorem comp_gen : (((ùì§ Œ±).lift' gen).lift' fun s => compRel s s) ‚â§ (ùì§ Œ±).lift' gen :=
  calc
    (((ùì§ Œ±).lift' gen).lift' fun s => compRel s s) = (ùì§ Œ±).lift' fun s => compRel (gen s) (gen s) :=
      by
      rw [lift'_lift'_assoc]
      exact monotone_gen
      exact monotone_id.comp_rel monotone_id
    _ ‚â§ (ùì§ Œ±).lift' fun s => gen <| compRel s s :=
      (lift'_mono' fun s hs => comp_rel_gen_gen_subset_gen_comp_rel)
    _ = ((ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => compRel s s).lift' gen :=
      by
      rw [lift'_lift'_assoc]
      exact monotone_id.comp_rel monotone_id
      exact monotone_gen
    _ ‚â§ (ùì§ Œ±).lift' gen := lift'_mono comp_le_uniformity le_rfl
    

instance : UniformSpace (CauchyFilter Œ±) :=
  UniformSpace.ofCore
    { uniformity := (ùì§ Œ±).lift' gen
      refl := principal_le_lift'.2 fun s hs ‚ü®a, b‚ü© (a_eq_b : a = b) => a_eq_b ‚ñ∏ a.property.right hs
      symm := symm_gen
      comp := comp_gen }

/- warning: Cauchy.mem_uniformity -> CauchyFilter.mem_uniformity is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {s : Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))}, Iff (Membership.Mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Filter.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Filter.hasMem.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) s (uniformity.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1))) (Exists.{succ u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (fun (t : Set.{u1} (Prod.{u1, u1} Œ± Œ±)) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.hasMem.{u1} (Prod.{u1, u1} Œ± Œ±)) t (uniformity.{u1} Œ± _inst_1)) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.hasMem.{u1} (Prod.{u1, u1} Œ± Œ±)) t (uniformity.{u1} Œ± _inst_1)) => HasSubset.Subset.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Set.hasSubset.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CauchyFilter.gen.{u1} Œ± _inst_1 t) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {s : Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))}, Iff (Membership.mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Filter.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (instMembershipSetFilter.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) s (uniformity.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1))) (Exists.{succ u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (fun (t : Set.{u1} (Prod.{u1, u1} Œ± Œ±)) => And (Membership.mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (instMembershipSetFilter.{u1} (Prod.{u1, u1} Œ± Œ±)) t (uniformity.{u1} Œ± _inst_1)) (HasSubset.Subset.{u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Set.instHasSubsetSet.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (CauchyFilter.gen.{u1} Œ± _inst_1 t) s)))
Case conversion may be inaccurate. Consider using '#align Cauchy.mem_uniformity CauchyFilter.mem_uniformity‚Çì'. -/
theorem mem_uniformity {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, gen t ‚äÜ s :=
  mem_lift'_sets monotone_gen
#align Cauchy.mem_uniformity CauchyFilter.mem_uniformity

/- warning: Cauchy.mem_uniformity' -> CauchyFilter.mem_uniformity' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {s : Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))}, Iff (Membership.Mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Filter.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Filter.hasMem.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) s (uniformity.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1))) (Exists.{succ u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (fun (t : Set.{u1} (Prod.{u1, u1} Œ± Œ±)) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.hasMem.{u1} (Prod.{u1, u1} Œ± Œ±)) t (uniformity.{u1} Œ± _inst_1)) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.hasMem.{u1} (Prod.{u1, u1} Œ± Œ±)) t (uniformity.{u1} Œ± _inst_1)) => forall (f : CauchyFilter.{u1} Œ± _inst_1) (g : CauchyFilter.{u1} Œ± _inst_1), (Membership.Mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.hasMem.{u1} (Prod.{u1, u1} Œ± Œ±)) t (Filter.prod.{u1, u1} Œ± Œ± (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_1 f) f) (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_1 f) g))) -> (Membership.Mem.{u1, u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1)) (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Set.hasMem.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Prod.mk.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1) f g) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {s : Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))}, Iff (Membership.mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Filter.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (instMembershipSetFilter.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) s (uniformity.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1))) (Exists.{succ u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (fun (t : Set.{u1} (Prod.{u1, u1} Œ± Œ±)) => And (Membership.mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (instMembershipSetFilter.{u1} (Prod.{u1, u1} Œ± Œ±)) t (uniformity.{u1} Œ± _inst_1)) (forall (f : CauchyFilter.{u1} Œ± _inst_1) (g : CauchyFilter.{u1} Œ± _inst_1), (Membership.mem.{u1, u1} (Set.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (instMembershipSetFilter.{u1} (Prod.{u1, u1} Œ± Œ±)) t (Filter.prod.{u1, u1} Œ± Œ± (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_1 f) f) (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_1 f) g))) -> (Membership.mem.{u1, u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1)) (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Set.instMembershipSet.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1))) (Prod.mk.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.{u1} Œ± _inst_1) f g) s))))
Case conversion may be inaccurate. Consider using '#align Cauchy.mem_uniformity' CauchyFilter.mem_uniformity'‚Çì'. -/
theorem mem_uniformity' {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, ‚àÄ f g : CauchyFilter Œ±, t ‚àà f.1 √ó·∂† g.1 ‚Üí (f, g) ‚àà s :=
  mem_uniformity.trans <| bex_congr fun t h => Prod.forall
#align Cauchy.mem_uniformity' CauchyFilter.mem_uniformity'

#print CauchyFilter.pureCauchy /-
/-- Embedding of `Œ±` into its completion `Cauchy Œ±` -/
def pureCauchy (a : Œ±) : CauchyFilter Œ± :=
  ‚ü®pure a, cauchy_pure‚ü©
#align Cauchy.pure_cauchy CauchyFilter.pureCauchy
-/

/- warning: Cauchy.uniform_inducing_pure_cauchy -> CauchyFilter.uniformInducing_pureCauchy is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], UniformInducing.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) _inst_1 (CauchyFilter.uniformSpace.{u1} Œ± _inst_1) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], UniformInducing.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) _inst_1 (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align Cauchy.uniform_inducing_pure_cauchy CauchyFilter.uniformInducing_pureCauchy‚Çì'. -/
theorem uniformInducing_pureCauchy : UniformInducing (pure_cauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  ‚ü®have : (preimage fun x : Œ± √ó Œ± => (pure_cauchy x.fst, pure_cauchy x.snd)) ‚àò gen = id :=
      funext fun s =>
        Set.ext fun ‚ü®a‚ÇÅ, a‚ÇÇ‚ü© => by simp [preimage, gen, pure_cauchy, prod_principal_principal]
    calc
      comap (fun x : Œ± √ó Œ± => (pure_cauchy x.fst, pure_cauchy x.snd)) ((ùì§ Œ±).lift' gen) =
          (ùì§ Œ±).lift' ((preimage fun x : Œ± √ó Œ± => (pure_cauchy x.fst, pure_cauchy x.snd)) ‚àò gen) :=
        comap_lift'_eq
      _ = ùì§ Œ± := by simp [this]
      ‚ü©
#align Cauchy.uniform_inducing_pure_cauchy CauchyFilter.uniformInducing_pureCauchy

/- warning: Cauchy.uniform_embedding_pure_cauchy -> CauchyFilter.uniformEmbedding_pureCauchy is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], UniformEmbedding.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) _inst_1 (CauchyFilter.uniformSpace.{u1} Œ± _inst_1) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], UniformEmbedding.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) _inst_1 (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align Cauchy.uniform_embedding_pure_cauchy CauchyFilter.uniformEmbedding_pureCauchy‚Çì'. -/
theorem uniformEmbedding_pureCauchy : UniformEmbedding (pure_cauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  { uniform_inducing_pure_cauchy with
    inj := fun a‚ÇÅ a‚ÇÇ h => pure_injective <| Subtype.ext_iff_val.1 h }
#align Cauchy.uniform_embedding_pure_cauchy CauchyFilter.uniformEmbedding_pureCauchy

/- warning: Cauchy.dense_range_pure_cauchy -> CauchyFilter.denseRange_pureCauchy is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseRange.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1)) Œ± (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseRange.{u1, u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1)) Œ± (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align Cauchy.dense_range_pure_cauchy CauchyFilter.denseRange_pureCauchy‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem denseRange_pureCauchy : DenseRange pure_cauchy := fun f =>
  by
  have h_ex : ‚àÄ s ‚àà ùì§ (CauchyFilter Œ±), ‚àÉ y : Œ±, (f, pure_cauchy y) ‚àà s := fun s hs =>
    let ‚ü®t'', ht''‚ÇÅ, (ht''‚ÇÇ : gen t'' ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs
    let ‚ü®t', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := comp_mem_uniformity_sets ht''‚ÇÅ
    have : t' ‚àà f.val √ó·∂† f.val := f.property.right ht'‚ÇÅ
    let ‚ü®t, ht, (h : t √óÀ¢ t ‚äÜ t')‚ü© := mem_prod_same_iff.mp this
    let ‚ü®x, (hx : x ‚àà t)‚ü© := f.property.left.nonempty_of_mem ht
    have : t'' ‚àà f.val √ó·∂† pure x :=
      mem_prod_iff.mpr
        ‚ü®t, ht, { y : Œ± | (x, y) ‚àà t' }, h <| mk_mem_prod hx hx,
          fun ‚ü®a, b‚ü© ‚ü®(h‚ÇÅ : a ‚àà t), (h‚ÇÇ : (x, b) ‚àà t')‚ü© =>
          ht'‚ÇÇ <| prod_mk_mem_compRel (@h (a, x) ‚ü®h‚ÇÅ, hx‚ü©) h‚ÇÇ‚ü©
    ‚ü®x, ht''‚ÇÇ <| by dsimp [gen] <;> exact this‚ü©
  simp only [closure_eq_cluster_pts, ClusterPt, nhds_eq_uniformity, lift'_inf_principal_eq,
    Set.inter_comm _ (range pure_cauchy), mem_set_of_eq]
  exact
    (lift'_ne_bot_iff <| monotone_const.inter monotone_preimage).mpr fun s hs =>
      let ‚ü®y, hy‚ü© := h_ex s hs
      have : pure_cauchy y ‚àà range pure_cauchy ‚à© { y : CauchyFilter Œ± | (f, y) ‚àà s } :=
        ‚ü®mem_range_self y, hy‚ü©
      ‚ü®_, this‚ü©
#align Cauchy.dense_range_pure_cauchy CauchyFilter.denseRange_pureCauchy

/- warning: Cauchy.dense_inducing_pure_cauchy -> CauchyFilter.denseInducing_pureCauchy is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseInducing.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1)) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseInducing.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1)) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align Cauchy.dense_inducing_pure_cauchy CauchyFilter.denseInducing_pureCauchy‚Çì'. -/
theorem denseInducing_pureCauchy : DenseInducing pure_cauchy :=
  uniform_inducing_pure_cauchy.DenseInducing dense_range_pure_cauchy
#align Cauchy.dense_inducing_pure_cauchy CauchyFilter.denseInducing_pureCauchy

/- warning: Cauchy.dense_embedding_pure_cauchy -> CauchyFilter.denseEmbedding_pureCauchy is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseEmbedding.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1)) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseEmbedding.{u1, u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1)) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align Cauchy.dense_embedding_pure_cauchy CauchyFilter.denseEmbedding_pureCauchy‚Çì'. -/
theorem denseEmbedding_pureCauchy : DenseEmbedding pure_cauchy :=
  uniform_embedding_pure_cauchy.DenseEmbedding dense_range_pure_cauchy
#align Cauchy.dense_embedding_pure_cauchy CauchyFilter.denseEmbedding_pureCauchy

#print CauchyFilter.nonempty_cauchyFilter_iff /-
theorem nonempty_cauchyFilter_iff : Nonempty (CauchyFilter Œ±) ‚Üî Nonempty Œ± :=
  by
  constructor <;> rintro ‚ü®c‚ü©
  ¬∑ have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c
    obtain ‚ü®_, ‚ü®_, a, _‚ü©‚ü© := mem_closure_iff.1 this _ isOpen_univ trivial
    exact ‚ü®a‚ü©
  ¬∑ exact ‚ü®pure_cauchy c‚ü©
#align Cauchy.nonempty_Cauchy_iff CauchyFilter.nonempty_cauchyFilter_iff
-/

section

/- ./././Mathport/Syntax/Translate/Basic.lean:334:40: warning: unsupported option eqn_compiler.zeta -/
set_option eqn_compiler.zeta true

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
instance : CompleteSpace (CauchyFilter Œ±) :=
  completeSpace_extension uniform_inducing_pure_cauchy dense_range_pure_cauchy fun f hf =>
    let f' : CauchyFilter Œ± := ‚ü®f, hf‚ü©
    have : map pure_cauchy f ‚â§ (ùì§ <| CauchyFilter Œ±).lift' (preimage (Prod.mk f')) :=
      le_lift'.2 fun s hs =>
        let ‚ü®t, ht‚ÇÅ, (ht‚ÇÇ : gen t ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs
        let ‚ü®t', ht', (h : t' √óÀ¢ t' ‚äÜ t)‚ü© := mem_prod_same_iff.mp (hf.right ht‚ÇÅ)
        have : t' ‚äÜ { y : Œ± | (f', pure_cauchy y) ‚àà gen t } := fun x hx =>
          (f √ó·∂† pure x).sets_of_superset (prod_mem_prod ht' hx) h
        f.sets_of_superset ht' <| Subset.trans this (preimage_mono ht‚ÇÇ)
    ‚ü®f', by simp [nhds_eq_uniformity] <;> assumption‚ü©

end

instance [Inhabited Œ±] : Inhabited (CauchyFilter Œ±) :=
  ‚ü®pure_cauchy default‚ü©

instance [h : Nonempty Œ±] : Nonempty (CauchyFilter Œ±) :=
  h.recOn fun a => Nonempty.intro <| CauchyFilter.pureCauchy a

section Extend

#print CauchyFilter.extend /-
/-- Extend a uniformly continuous function `Œ± ‚Üí Œ≤` to a function `Cauchy Œ± ‚Üí Œ≤`. Outputs junk when
`f` is not uniformly continuous. -/
def extend (f : Œ± ‚Üí Œ≤) : CauchyFilter Œ± ‚Üí Œ≤ :=
  if UniformContinuous f then dense_inducing_pure_cauchy.extend f
  else fun x => f (nonempty_Cauchy_iff.1 ‚ü®x‚ü©).some
#align Cauchy.extend CauchyFilter.extend
-/

section SeparatedSpace

variable [SeparatedSpace Œ≤]

#print CauchyFilter.extend_pureCauchy /-
theorem extend_pureCauchy {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f) (a : Œ±) :
    extend f (pure_cauchy a) = f a := by
  rw [extend, if_pos hf]
  exact uniformly_extend_of_ind uniform_inducing_pure_cauchy dense_range_pure_cauchy hf _
#align Cauchy.extend_pure_cauchy CauchyFilter.extend_pureCauchy
-/

end SeparatedSpace

variable [CompleteSpace Œ≤]

/- warning: Cauchy.uniform_continuous_extend -> CauchyFilter.uniformContinuous_extend is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] [_inst_4 : CompleteSpace.{u2} Œ≤ _inst_2] {f : Œ± -> Œ≤}, UniformContinuous.{u1, u2} (CauchyFilter.{u1} Œ± _inst_1) Œ≤ (CauchyFilter.uniformSpace.{u1} Œ± _inst_1) _inst_2 (CauchyFilter.extend.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] [_inst_4 : CompleteSpace.{u2} Œ≤ _inst_2] {f : Œ± -> Œ≤}, UniformContinuous.{u1, u2} (CauchyFilter.{u1} Œ± _inst_1) Œ≤ (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1) _inst_2 (CauchyFilter.extend.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f)
Case conversion may be inaccurate. Consider using '#align Cauchy.uniform_continuous_extend CauchyFilter.uniformContinuous_extend‚Çì'. -/
theorem uniformContinuous_extend {f : Œ± ‚Üí Œ≤} : UniformContinuous (extend f) :=
  by
  by_cases hf : UniformContinuous f
  ¬∑ rw [extend, if_pos hf]
    exact uniformContinuous_uniformly_extend uniform_inducing_pure_cauchy dense_range_pure_cauchy hf
  ¬∑ rw [extend, if_neg hf]
    exact uniformContinuous_of_const fun a b => by congr
#align Cauchy.uniform_continuous_extend CauchyFilter.uniformContinuous_extend

end Extend

end

/- warning: Cauchy.Cauchy_eq -> CauchyFilter.cauchyFilter_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Inhabited.{succ u1} Œ±] [_inst_2 : UniformSpace.{u1} Œ±] [_inst_3 : CompleteSpace.{u1} Œ± _inst_2] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_2] {f : CauchyFilter.{u1} Œ± _inst_2} {g : CauchyFilter.{u1} Œ± _inst_2}, Iff (Eq.{succ u1} Œ± (lim.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_2) (instNonempty.{succ u1} Œ± _inst_1) (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_2 f) f)) (lim.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_2) (instNonempty.{succ u1} Œ± _inst_1) (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_2 f) g))) (Membership.Mem.{u1, u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2)) (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2))) (Set.hasMem.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2))) (Prod.mk.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2) f g) (separationRel.{u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.uniformSpace.{u1} Œ± _inst_2)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Inhabited.{succ u1} Œ±] [_inst_2 : UniformSpace.{u1} Œ±] [_inst_3 : CompleteSpace.{u1} Œ± _inst_2] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_2] {f : CauchyFilter.{u1} Œ± _inst_2} {g : CauchyFilter.{u1} Œ± _inst_2}, Iff (Eq.{succ u1} Œ± (lim.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_2) (instNonempty.{succ u1} Œ± _inst_1) (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_2 f) f)) (lim.{u1} Œ± (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_2) (instNonempty.{succ u1} Œ± _inst_1) (Subtype.val.{succ u1} (Filter.{u1} Œ±) (fun (f : Filter.{u1} Œ±) => Cauchy.{u1} Œ± _inst_2 f) g))) (Membership.mem.{u1, u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2)) (Set.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2))) (Set.instMembershipSet.{u1} (Prod.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2))) (Prod.mk.{u1, u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.{u1} Œ± _inst_2) f g) (separationRel.{u1} (CauchyFilter.{u1} Œ± _inst_2) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_2)))
Case conversion may be inaccurate. Consider using '#align Cauchy.Cauchy_eq CauchyFilter.cauchyFilter_eq‚Çì'. -/
theorem cauchyFilter_eq {Œ± : Type _} [Inhabited Œ±] [UniformSpace Œ±] [CompleteSpace Œ±]
    [SeparatedSpace Œ±] {f g : CauchyFilter Œ±} :
    lim f.1 = lim g.1 ‚Üî (f, g) ‚àà separationRel (CauchyFilter Œ±) :=
  by
  constructor
  ¬∑ intro e s hs
    rcases CauchyFilter.mem_uniformity'.1 hs with ‚ü®t, tu, ts‚ü©
    apply ts
    rcases comp_mem_uniformity_sets tu with ‚ü®d, du, dt‚ü©
    refine'
      mem_prod_iff.2
        ‚ü®_, f.2.le_nhds_lim (mem_nhds_right (lim f.1) du), _,
          g.2.le_nhds_lim (mem_nhds_left (lim g.1) du), fun x h => _‚ü©
    cases' x with a b; cases' h with h‚ÇÅ h‚ÇÇ
    rw [‚Üê e] at h‚ÇÇ
    exact dt ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü©
  ¬∑ intro H
    refine' separated_def.1 (by infer_instance) _ _ fun t tu => _
    rcases mem_uniformity_isClosed tu with ‚ü®d, du, dc, dt‚ü©
    refine'
      H { p | (lim p.1.1, lim p.2.1) ‚àà t } (CauchyFilter.mem_uniformity'.2 ‚ü®d, du, fun f g h => _‚ü©)
    rcases mem_prod_iff.1 h with ‚ü®x, xf, y, yg, h‚ü©
    have limc : ‚àÄ (f : CauchyFilter Œ±), ‚àÄ x ‚àà f.1, lim f.1 ‚àà closure x :=
      by
      intro f x xf
      rw [closure_eq_cluster_pts]
      exact f.2.1.mono (le_inf f.2.le_nhds_lim (le_principal_iff.2 xf))
    have := dc.closure_subset_iff.2 h
    rw [closure_prod_eq] at this
    refine' dt (this ‚ü®_, _‚ü©) <;> dsimp <;> apply limc <;> assumption
#align Cauchy.Cauchy_eq CauchyFilter.cauchyFilter_eq

section

attribute [local instance] UniformSpace.separationSetoid

/- warning: Cauchy.separated_pure_cauchy_injective -> CauchyFilter.separated_pureCauchy_injective is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] [s : SeparatedSpace.{u1} Œ± _inst_1], Function.Injective.{succ u1, succ u1} Œ± (Quotient.{succ u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.separationSetoid.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1))) (fun (a : Œ±) => Quotient.mk'.{succ u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.separationSetoid.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1)) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1 a))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] [s : SeparatedSpace.{u1} Œ± _inst_1], Function.Injective.{succ u1, succ u1} Œ± (Quotient.{succ u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.separationSetoid.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1))) (fun (a : Œ±) => Quotient.mk.{succ u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.separationSetoid.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1)) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1 a))
Case conversion may be inaccurate. Consider using '#align Cauchy.separated_pure_cauchy_injective CauchyFilter.separated_pureCauchy_injective‚Çì'. -/
theorem separated_pureCauchy_injective {Œ± : Type _} [UniformSpace Œ±] [s : SeparatedSpace Œ±] :
    Function.Injective fun a : Œ± => ‚ü¶pureCauchy a‚üß
  | a, b, h =>
    separated_def.1 s _ _ fun s hs =>
      let ‚ü®t, ht, hts‚ü© := by
        rw [‚Üê (@uniform_embedding_pure_cauchy Œ± _).comap_uniformity, Filter.mem_comap] at hs <;>
          exact hs
      have : (pureCauchy a, pureCauchy b) ‚àà t := Quotient.exact h t ht
      @hts (a, b) this
#align Cauchy.separated_pure_cauchy_injective CauchyFilter.separated_pureCauchy_injective

end

end CauchyFilter

attribute [local instance] UniformSpace.separationSetoid

open CauchyFilter Set

namespace UniformSpace

variable (Œ± : Type _) [UniformSpace Œ±]

variable {Œ≤ : Type _} [UniformSpace Œ≤]

variable {Œ≥ : Type _} [UniformSpace Œ≥]

#print UniformSpace.completeSpace_separation /-
instance completeSpace_separation [h : CompleteSpace Œ±] :
    CompleteSpace (Quotient (separationSetoid Œ±)) :=
  ‚ü®fun f => fun hf : Cauchy f =>
    have : Cauchy (f.comap fun x => ‚ü¶x‚üß) :=
      hf.comap' comap_quotient_le_uniformity <| hf.left.comap_of_surj (surjective_quotient_mk _)
    let ‚ü®x, (hx : (f fun x => ‚ü¶x‚üß) ‚â§ ùìù x)‚ü© := CompleteSpace.complete this
    ‚ü®‚ü¶x‚üß,
      (comap_le_comap_iff <| by simp).1
        (hx.trans <| map_le_iff_le_comap.1 continuous_quotient_mk'.ContinuousAt)‚ü©‚ü©
#align uniform_space.complete_space_separation UniformSpace.completeSpace_separation
-/

#print UniformSpace.Completion /-
/-- Hausdorff completion of `Œ±` -/
def Completion :=
  Quotient (separationSetoid <| CauchyFilter Œ±)
#align uniform_space.completion UniformSpace.Completion
-/

namespace Completion

instance [Inhabited Œ±] : Inhabited (Completion Œ±) :=
  Quotient.inhabited (separationSetoid (CauchyFilter Œ±))

instance (priority := 50) : UniformSpace (Completion Œ±) :=
  separationSetoid.uniformSpace

instance : CompleteSpace (Completion Œ±) :=
  UniformSpace.completeSpace_separation (CauchyFilter Œ±)

instance : SeparatedSpace (Completion Œ±) :=
  UniformSpace.separated_separation

instance : T3Space (Completion Œ±) :=
  separated_t3

/-- Automatic coercion from `Œ±` to its completion. Not always injective. -/
instance : CoeTC Œ± (Completion Œ±) :=
  ‚ü®Quotient.mk' ‚àò pureCauchy‚ü©

/- warning: uniform_space.completion.coe_eq -> UniformSpace.Completion.coe_eq is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], Eq.{succ u1} (Œ± -> (UniformSpace.Completion.{u1} Œ± _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1)))) (Function.comp.{succ u1, succ u1, succ u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ± _inst_1) (Quotient.mk'.{succ u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.separationSetoid.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.uniformSpace.{u1} Œ± _inst_1))) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], Eq.{succ u1} (Œ± -> (UniformSpace.Completion.{u1} Œ± _inst_1)) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1) (Function.comp.{succ u1, succ u1, succ u1} Œ± (CauchyFilter.{u1} Œ± _inst_1) (Quotient.{succ u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.separationSetoid.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1))) (Quotient.mk'.{succ u1} (CauchyFilter.{u1} Œ± _inst_1) (UniformSpace.separationSetoid.{u1} (CauchyFilter.{u1} Œ± _inst_1) (CauchyFilter.instUniformSpaceCauchyFilter.{u1} Œ± _inst_1))) (CauchyFilter.pureCauchy.{u1} Œ± _inst_1))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_eq UniformSpace.Completion.coe_eq‚Çì'. -/
-- note [use has_coe_t]
protected theorem coe_eq : (coe : Œ± ‚Üí Completion Œ±) = Quotient.mk' ‚àò pureCauchy :=
  rfl
#align uniform_space.completion.coe_eq UniformSpace.Completion.coe_eq

/- warning: uniform_space.completion.comap_coe_eq_uniformity -> UniformSpace.Completion.comap_coe_eq_uniformity is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], Eq.{succ u1} (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.comap.{u1, u1} (Prod.{u1, u1} Œ± Œ±) (Prod.{u1, u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ± _inst_1)) (fun (p : Prod.{u1, u1} Œ± Œ±) => Prod.mk.{u1, u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ± _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) (Prod.fst.{u1, u1} Œ± Œ± p)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) (Prod.snd.{u1, u1} Œ± Œ± p))) (uniformity.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1))) (uniformity.{u1} Œ± _inst_1)
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], Eq.{succ u1} (Filter.{u1} (Prod.{u1, u1} Œ± Œ±)) (Filter.comap.{u1, u1} (Prod.{u1, u1} Œ± Œ±) (Prod.{u1, u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ± _inst_1)) (fun (p : Prod.{u1, u1} Œ± Œ±) => Prod.mk.{u1, u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 (Prod.fst.{u1, u1} Œ± Œ± p)) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 (Prod.snd.{u1, u1} Œ± Œ± p))) (uniformity.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1))) (uniformity.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.comap_coe_eq_uniformity UniformSpace.Completion.comap_coe_eq_uniformity‚Çì'. -/
theorem comap_coe_eq_uniformity :
    ((ùì§ _).comap fun p : Œ± √ó Œ± => ((p.1 : Completion Œ±), (p.2 : Completion Œ±))) = ùì§ Œ± :=
  by
  have :
    (fun x : Œ± √ó Œ± => ((x.1 : completion Œ±), (x.2 : completion Œ±))) =
      (fun x : CauchyFilter Œ± √ó CauchyFilter Œ± => (‚ü¶x.1‚üß, ‚ü¶x.2‚üß)) ‚àò fun x : Œ± √ó Œ± =>
        (pure_cauchy x.1, pure_cauchy x.2) :=
    by ext ‚ü®a, b‚ü© <;> simp <;> rfl
  rw [this, ‚Üê Filter.comap_comap]
  change
    Filter.comap _ (Filter.comap _ (ùì§ <| Quotient <| separation_setoid <| CauchyFilter Œ±)) = ùì§ Œ±
  rw [comap_quotient_eq_uniformity, uniform_embedding_pure_cauchy.comap_uniformity]
#align uniform_space.completion.comap_coe_eq_uniformity UniformSpace.Completion.comap_coe_eq_uniformity

/- warning: uniform_space.completion.uniform_inducing_coe -> UniformSpace.Completion.uniformInducing_coe is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], UniformInducing.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) _inst_1 (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], UniformInducing.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) _inst_1 (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.uniform_inducing_coe UniformSpace.Completion.uniformInducing_coe‚Çì'. -/
theorem uniformInducing_coe : UniformInducing (coe : Œ± ‚Üí Completion Œ±) :=
  ‚ü®comap_coe_eq_uniformity Œ±‚ü©
#align uniform_space.completion.uniform_inducing_coe UniformSpace.Completion.uniformInducing_coe

variable {Œ±}

/- warning: uniform_space.completion.dense_range_coe -> UniformSpace.Completion.denseRange_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseRange.{u1, u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseRange.{u1, u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) Œ± (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.dense_range_coe UniformSpace.Completion.denseRange_coe‚Çì'. -/
theorem denseRange_coe : DenseRange (coe : Œ± ‚Üí Completion Œ±) :=
  denseRange_pureCauchy.Quotient
#align uniform_space.completion.dense_range_coe UniformSpace.Completion.denseRange_coe

variable (Œ±)

#print UniformSpace.Completion.cPkg /-
/-- The Haudorff completion as an abstract completion. -/
def cPkg {Œ± : Type _} [UniformSpace Œ±] : AbstractCompletion Œ±
    where
  Space := Completion Œ±
  coe := coe
  uniformStruct := by infer_instance
  complete := by infer_instance
  separation := by infer_instance
  UniformInducing := Completion.uniformInducing_coe Œ±
  dense := Completion.denseRange_coe
#align uniform_space.completion.cpkg UniformSpace.Completion.cPkg
-/

#print UniformSpace.Completion.AbstractCompletion.inhabited /-
instance AbstractCompletion.inhabited : Inhabited (AbstractCompletion Œ±) :=
  ‚ü®cPkg‚ü©
#align uniform_space.completion.abstract_completion.inhabited UniformSpace.Completion.AbstractCompletion.inhabited
-/

attribute [local instance]
  AbstractCompletion.uniformStruct AbstractCompletion.complete AbstractCompletion.separation

#print UniformSpace.Completion.nonempty_completion_iff /-
theorem nonempty_completion_iff : Nonempty (Completion Œ±) ‚Üî Nonempty Œ± :=
  cPkg.dense.nonempty_iff.symm
#align uniform_space.completion.nonempty_completion_iff UniformSpace.Completion.nonempty_completion_iff
-/

/- warning: uniform_space.completion.uniform_continuous_coe -> UniformSpace.Completion.uniformContinuous_coe is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], UniformContinuous.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) _inst_1 (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], UniformContinuous.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) _inst_1 (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.uniform_continuous_coe UniformSpace.Completion.uniformContinuous_coe‚Çì'. -/
theorem uniformContinuous_coe : UniformContinuous (coe : Œ± ‚Üí Completion Œ±) :=
  cPkg.uniformContinuous_coe
#align uniform_space.completion.uniform_continuous_coe UniformSpace.Completion.uniformContinuous_coe

/- warning: uniform_space.completion.continuous_coe -> UniformSpace.Completion.continuous_coe is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], Continuous.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±], Continuous.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous_coe UniformSpace.Completion.continuous_coe‚Çì'. -/
theorem continuous_coe : Continuous (coe : Œ± ‚Üí Completion Œ±) :=
  cPkg.continuous_coe
#align uniform_space.completion.continuous_coe UniformSpace.Completion.continuous_coe

/- warning: uniform_space.completion.uniform_embedding_coe -> UniformSpace.Completion.uniformEmbedding_coe is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_1], UniformEmbedding.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) _inst_1 (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_1], UniformEmbedding.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) _inst_1 (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.uniform_embedding_coe UniformSpace.Completion.uniformEmbedding_coe‚Çì'. -/
theorem uniformEmbedding_coe [SeparatedSpace Œ±] : UniformEmbedding (coe : Œ± ‚Üí Completion Œ±) :=
  { comap_uniformity := comap_coe_eq_uniformity Œ±
    inj := separated_pureCauchy_injective }
#align uniform_space.completion.uniform_embedding_coe UniformSpace.Completion.uniformEmbedding_coe

/- warning: uniform_space.completion.coe_injective -> UniformSpace.Completion.coe_injective is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_1], Function.Injective.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : UniformSpace.{u1} Œ±] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_1], Function.Injective.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_injective UniformSpace.Completion.coe_injective‚Çì'. -/
theorem coe_injective [SeparatedSpace Œ±] : Function.Injective (coe : Œ± ‚Üí Completion Œ±) :=
  UniformEmbedding.inj (uniformEmbedding_coe _)
#align uniform_space.completion.coe_injective UniformSpace.Completion.coe_injective

variable {Œ±}

/- warning: uniform_space.completion.dense_inducing_coe -> UniformSpace.Completion.denseInducing_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseInducing.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±], DenseInducing.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.dense_inducing_coe UniformSpace.Completion.denseInducing_coe‚Çì'. -/
theorem denseInducing_coe : DenseInducing (coe : Œ± ‚Üí Completion Œ±) :=
  { (uniformInducing_coe Œ±).Inducing with dense := denseRange_coe }
#align uniform_space.completion.dense_inducing_coe UniformSpace.Completion.denseInducing_coe

#print UniformSpace.Completion.UniformCompletion.completeEquivSelf /-
/-- The uniform bijection between a complete space and its uniform completion. -/
def UniformCompletion.completeEquivSelf [CompleteSpace Œ±] [SeparatedSpace Œ±] : Completion Œ± ‚âÉ·µ§ Œ± :=
  AbstractCompletion.compareEquiv Completion.cPkg AbstractCompletion.ofComplete
#align uniform_space.completion.uniform_completion.complete_equiv_self UniformSpace.Completion.UniformCompletion.completeEquivSelf
-/

open TopologicalSpace

#print UniformSpace.Completion.separableSpace_completion /-
instance separableSpace_completion [SeparableSpace Œ±] : SeparableSpace (Completion Œ±) :=
  Completion.denseInducing_coe.SeparableSpace
#align uniform_space.completion.separable_space_completion UniformSpace.Completion.separableSpace_completion
-/

/- warning: uniform_space.completion.dense_embedding_coe -> UniformSpace.Completion.denseEmbedding_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_1], DenseEmbedding.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] [_inst_4 : SeparatedSpace.{u1} Œ± _inst_1], DenseEmbedding.{u1, u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.dense_embedding_coe UniformSpace.Completion.denseEmbedding_coe‚Çì'. -/
theorem denseEmbedding_coe [SeparatedSpace Œ±] : DenseEmbedding (coe : Œ± ‚Üí Completion Œ±) :=
  { denseInducing_coe with inj := separated_pureCauchy_injective }
#align uniform_space.completion.dense_embedding_coe UniformSpace.Completion.denseEmbedding_coe

/- warning: uniform_space.completion.dense_range_coe‚ÇÇ -> UniformSpace.Completion.denseRange_coe‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤], DenseRange.{max u1 u2, max u1 u2} (Prod.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2)) (Prod.topologicalSpace.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2))) (Prod.{u1, u2} Œ± Œ≤) (fun (x : Prod.{u1, u2} Œ± Œ≤) => Prod.mk.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) (Prod.fst.{u1, u2} Œ± Œ≤ x)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) (Prod.snd.{u1, u2} Œ± Œ≤ x)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤], DenseRange.{max u2 u1, max u1 u2} (Prod.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2)) (instTopologicalSpaceProd.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2))) (Prod.{u1, u2} Œ± Œ≤) (fun (x : Prod.{u1, u2} Œ± Œ≤) => Prod.mk.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 (Prod.fst.{u1, u2} Œ± Œ≤ x)) (UniformSpace.Completion.coe'.{u2} Œ≤ _inst_2 (Prod.snd.{u1, u2} Œ± Œ≤ x)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.dense_range_coe‚ÇÇ UniformSpace.Completion.denseRange_coe‚ÇÇ‚Çì'. -/
theorem denseRange_coe‚ÇÇ :
    DenseRange fun x : Œ± √ó Œ≤ => ((x.1 : Completion Œ±), (x.2 : Completion Œ≤)) :=
  denseRange_coe.Prod_map denseRange_coe
#align uniform_space.completion.dense_range_coe‚ÇÇ UniformSpace.Completion.denseRange_coe‚ÇÇ

/- warning: uniform_space.completion.dense_range_coe‚ÇÉ -> UniformSpace.Completion.denseRange_coe‚ÇÉ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥], DenseRange.{max u1 u2 u3, max u1 u2 u3} (Prod.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3))) (Prod.topologicalSpace.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (Prod.topologicalSpace.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2)) (UniformSpace.toTopologicalSpace.{u3} (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u3} Œ≥ _inst_3)))) (Prod.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥)) (fun (x : Prod.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥)) => Prod.mk.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) (Prod.fst.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥) x)) (Prod.mk.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) (Prod.fst.{u2, u3} Œ≤ Œ≥ (Prod.snd.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥) x))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (HasLiftT.mk.{succ u3, succ u3} Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (CoeTC‚Çì.coe.{succ u3, succ u3} Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.hasCoeT.{u3} Œ≥ _inst_3))) (Prod.snd.{u2, u3} Œ≤ Œ≥ (Prod.snd.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥) x)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥], DenseRange.{max (max u3 u2) u1, max (max u1 u2) u3} (Prod.{u1, max u3 u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3))) (instTopologicalSpaceProd.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (instTopologicalSpaceProd.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2)) (UniformSpace.toTopologicalSpace.{u3} (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u3} Œ≥ _inst_3)))) (Prod.{u1, max u3 u2} Œ± (Prod.{u2, u3} Œ≤ Œ≥)) (fun (x : Prod.{u1, max u3 u2} Œ± (Prod.{u2, u3} Œ≤ Œ≥)) => Prod.mk.{u1, max u3 u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 (Prod.fst.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥) x)) (Prod.mk.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.coe'.{u2} Œ≤ _inst_2 (Prod.fst.{u2, u3} Œ≤ Œ≥ (Prod.snd.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥) x))) (UniformSpace.Completion.coe'.{u3} Œ≥ _inst_3 (Prod.snd.{u2, u3} Œ≤ Œ≥ (Prod.snd.{u1, max u2 u3} Œ± (Prod.{u2, u3} Œ≤ Œ≥) x)))))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.dense_range_coe‚ÇÉ UniformSpace.Completion.denseRange_coe‚ÇÉ‚Çì'. -/
theorem denseRange_coe‚ÇÉ :
    DenseRange fun x : Œ± √ó Œ≤ √ó Œ≥ =>
      ((x.1 : Completion Œ±), ((x.2.1 : Completion Œ≤), (x.2.2 : Completion Œ≥))) :=
  denseRange_coe.Prod_map denseRange_coe‚ÇÇ
#align uniform_space.completion.dense_range_coe‚ÇÉ UniformSpace.Completion.denseRange_coe‚ÇÉ

/- warning: uniform_space.completion.induction_on -> UniformSpace.Completion.induction_on is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {p : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Prop} (a : UniformSpace.Completion.{u1} Œ± _inst_1), (IsClosed.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (setOf.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (fun (a : UniformSpace.Completion.{u1} Œ± _inst_1) => p a))) -> (forall (a : Œ±), p ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a)) -> (p a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {p : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Prop} (a : UniformSpace.Completion.{u1} Œ± _inst_1), (IsClosed.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (setOf.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (fun (a : UniformSpace.Completion.{u1} Œ± _inst_1) => p a))) -> (forall (a : Œ±), p (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 a)) -> (p a)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.induction_on UniformSpace.Completion.induction_on‚Çì'. -/
@[elab_as_elim]
theorem induction_on {p : Completion Œ± ‚Üí Prop} (a : Completion Œ±) (hp : IsClosed { a | p a })
    (ih : ‚àÄ a : Œ±, p a) : p a :=
  isClosed_property denseRange_coe hp ih a
#align uniform_space.completion.induction_on UniformSpace.Completion.induction_on

/- warning: uniform_space.completion.induction_on‚ÇÇ -> UniformSpace.Completion.induction_on‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {p : (UniformSpace.Completion.{u1} Œ± _inst_1) -> (UniformSpace.Completion.{u2} Œ≤ _inst_2) -> Prop} (a : UniformSpace.Completion.{u1} Œ± _inst_1) (b : UniformSpace.Completion.{u2} Œ≤ _inst_2), (IsClosed.{max u1 u2} (Prod.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2)) (Prod.topologicalSpace.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2))) (setOf.{max u1 u2} (Prod.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2)) (fun (x : Prod.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2)) => p (Prod.fst.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) x) (Prod.snd.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) x)))) -> (forall (a : Œ±) (b : Œ≤), p ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) b)) -> (p a b)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {p : (UniformSpace.Completion.{u2} Œ± _inst_1) -> (UniformSpace.Completion.{u1} Œ≤ _inst_2) -> Prop} (a : UniformSpace.Completion.{u2} Œ± _inst_1) (b : UniformSpace.Completion.{u1} Œ≤ _inst_2), (IsClosed.{max u2 u1} (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2)) (instTopologicalSpaceProd.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u1} Œ≤ _inst_2))) (setOf.{max u2 u1} (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2)) (fun (x : Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2)) => p (Prod.fst.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2) x) (Prod.snd.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2) x)))) -> (forall (a : Œ±) (b : Œ≤), p (UniformSpace.Completion.coe'.{u2} Œ± _inst_1 a) (UniformSpace.Completion.coe'.{u1} Œ≤ _inst_2 b)) -> (p a b)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.induction_on‚ÇÇ UniformSpace.Completion.induction_on‚ÇÇ‚Çì'. -/
@[elab_as_elim]
theorem induction_on‚ÇÇ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Prop} (a : Completion Œ±) (b : Completion Œ≤)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ | p x.1 x.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤), p a b) : p a b :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤, p x.1 x.2 :=
    isClosed_property denseRange_coe‚ÇÇ hp fun ‚ü®a, b‚ü© => ih a b
  this (a, b)
#align uniform_space.completion.induction_on‚ÇÇ UniformSpace.Completion.induction_on‚ÇÇ

/- warning: uniform_space.completion.induction_on‚ÇÉ -> UniformSpace.Completion.induction_on‚ÇÉ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥] {p : (UniformSpace.Completion.{u1} Œ± _inst_1) -> (UniformSpace.Completion.{u2} Œ≤ _inst_2) -> (UniformSpace.Completion.{u3} Œ≥ _inst_3) -> Prop} (a : UniformSpace.Completion.{u1} Œ± _inst_1) (b : UniformSpace.Completion.{u2} Œ≤ _inst_2) (c : UniformSpace.Completion.{u3} Œ≥ _inst_3), (IsClosed.{max u1 u2 u3} (Prod.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3))) (Prod.topologicalSpace.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (Prod.topologicalSpace.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2)) (UniformSpace.toTopologicalSpace.{u3} (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u3} Œ≥ _inst_3)))) (setOf.{max u1 u2 u3} (Prod.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3))) (fun (x : Prod.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3))) => p (Prod.fst.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) x) (Prod.fst.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (Prod.snd.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) x)) (Prod.snd.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (Prod.snd.{u1, max u2 u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (Prod.{u2, u3} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3)) x))))) -> (forall (a : Œ±) (b : Œ≤) (c : Œ≥), p ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) b) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (HasLiftT.mk.{succ u3, succ u3} Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (CoeTC‚Çì.coe.{succ u3, succ u3} Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.hasCoeT.{u3} Œ≥ _inst_3))) c)) -> (p a b c)
but is expected to have type
  forall {Œ± : Type.{u3}} [_inst_1 : UniformSpace.{u3} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u1}} [_inst_3 : UniformSpace.{u1} Œ≥] {p : (UniformSpace.Completion.{u3} Œ± _inst_1) -> (UniformSpace.Completion.{u2} Œ≤ _inst_2) -> (UniformSpace.Completion.{u1} Œ≥ _inst_3) -> Prop} (a : UniformSpace.Completion.{u3} Œ± _inst_1) (b : UniformSpace.Completion.{u2} Œ≤ _inst_2) (c : UniformSpace.Completion.{u1} Œ≥ _inst_3), (IsClosed.{max (max u3 u2) u1} (Prod.{u3, max u1 u2} (UniformSpace.Completion.{u3} Œ± _inst_1) (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3))) (instTopologicalSpaceProd.{u3, max u2 u1} (UniformSpace.Completion.{u3} Œ± _inst_1) (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3)) (UniformSpace.toTopologicalSpace.{u3} (UniformSpace.Completion.{u3} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u3} Œ± _inst_1)) (instTopologicalSpaceProd.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u1} Œ≥ _inst_3)))) (setOf.{max (max u3 u2) u1} (Prod.{u3, max u1 u2} (UniformSpace.Completion.{u3} Œ± _inst_1) (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3))) (fun (x : Prod.{u3, max u1 u2} (UniformSpace.Completion.{u3} Œ± _inst_1) (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3))) => p (Prod.fst.{u3, max u2 u1} (UniformSpace.Completion.{u3} Œ± _inst_1) (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3)) x) (Prod.fst.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3) (Prod.snd.{u3, max u2 u1} (UniformSpace.Completion.{u3} Œ± _inst_1) (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3)) x)) (Prod.snd.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3) (Prod.snd.{u3, max u2 u1} (UniformSpace.Completion.{u3} Œ± _inst_1) (Prod.{u2, u1} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3)) x))))) -> (forall (a : Œ±) (b : Œ≤) (c : Œ≥), p (UniformSpace.Completion.coe'.{u3} Œ± _inst_1 a) (UniformSpace.Completion.coe'.{u2} Œ≤ _inst_2 b) (UniformSpace.Completion.coe'.{u1} Œ≥ _inst_3 c)) -> (p a b c)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.induction_on‚ÇÉ UniformSpace.Completion.induction_on‚ÇÉ‚Çì'. -/
@[elab_as_elim]
theorem induction_on‚ÇÉ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ ‚Üí Prop} (a : Completion Œ±)
    (b : Completion Œ≤) (c : Completion Œ≥)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥ | p x.1 x.2.1 x.2.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), p a b c) : p a b c :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥, p x.1 x.2.1 x.2.2 :=
    isClosed_property denseRange_coe‚ÇÉ hp fun ‚ü®a, b, c‚ü© => ih a b c
  this (a, b, c)
#align uniform_space.completion.induction_on‚ÇÉ UniformSpace.Completion.induction_on‚ÇÉ

/- warning: uniform_space.completion.ext -> UniformSpace.Completion.ext is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Y : Type.{u2}} [_inst_4 : TopologicalSpace.{u2} Y] [_inst_5 : T2Space.{u2} Y _inst_4] {f : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y} {g : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y}, (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 f) -> (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 g) -> (forall (a : Œ±), Eq.{succ u2} Y (f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a)) (g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a))) -> (Eq.{max (succ u1) (succ u2)} ((UniformSpace.Completion.{u1} Œ± _inst_1) -> Y) f g)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Y : Type.{u2}} [_inst_4 : TopologicalSpace.{u2} Y] [_inst_5 : T2Space.{u2} Y _inst_4] {f : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y} {g : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y}, (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 f) -> (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 g) -> (forall (a : Œ±), Eq.{succ u2} Y (f (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 a)) (g (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 a))) -> (Eq.{max (succ u1) (succ u2)} ((UniformSpace.Completion.{u1} Œ± _inst_1) -> Y) f g)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.ext UniformSpace.Completion.ext‚Çì'. -/
theorem ext {Y : Type _} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) : f = g :=
  cPkg.funext hf hg h
#align uniform_space.completion.ext UniformSpace.Completion.ext

/- warning: uniform_space.completion.ext' -> UniformSpace.Completion.ext' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Y : Type.{u2}} [_inst_4 : TopologicalSpace.{u2} Y] [_inst_5 : T2Space.{u2} Y _inst_4] {f : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y} {g : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y}, (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 f) -> (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 g) -> (forall (a : Œ±), Eq.{succ u2} Y (f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a)) (g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a))) -> (forall (a : UniformSpace.Completion.{u1} Œ± _inst_1), Eq.{succ u2} Y (f a) (g a))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Y : Type.{u2}} [_inst_4 : TopologicalSpace.{u2} Y] [_inst_5 : T2Space.{u2} Y _inst_4] {f : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y} {g : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Y}, (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 f) -> (Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Y (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) _inst_4 g) -> (forall (a : Œ±), Eq.{succ u2} Y (f (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 a)) (g (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 a))) -> (forall (a : UniformSpace.Completion.{u1} Œ± _inst_1), Eq.{succ u2} Y (f a) (g a))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.ext' UniformSpace.Completion.ext'‚Çì'. -/
theorem ext' {Y : Type _} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) (a : Completion Œ±) :
    f a = g a :=
  congr_fun (ext hf hg h) a
#align uniform_space.completion.ext' UniformSpace.Completion.ext'

section Extension

variable {f : Œ± ‚Üí Œ≤}

#print UniformSpace.Completion.extension /-
/-- "Extension" to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous -/
protected def extension (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Œ≤ :=
  cPkg.extend f
#align uniform_space.completion.extension UniformSpace.Completion.extension
-/

section CompleteSpace

variable [CompleteSpace Œ≤]

/- warning: uniform_space.completion.uniform_continuous_extension -> UniformSpace.Completion.uniformContinuous_extension is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : CompleteSpace.{u2} Œ≤ _inst_2], UniformContinuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Œ≤ (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) _inst_2 (UniformSpace.Completion.extension.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : CompleteSpace.{u1} Œ≤ _inst_2], UniformContinuous.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) Œ≤ (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1) _inst_2 (UniformSpace.Completion.extension.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 f)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.uniform_continuous_extension UniformSpace.Completion.uniformContinuous_extension‚Çì'. -/
theorem uniformContinuous_extension : UniformContinuous (Completion.extension f) :=
  cPkg.uniformContinuous_extend
#align uniform_space.completion.uniform_continuous_extension UniformSpace.Completion.uniformContinuous_extension

/- warning: uniform_space.completion.continuous_extension -> UniformSpace.Completion.continuous_extension is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : CompleteSpace.{u2} Œ≤ _inst_2], Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Œ≤ (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u2} Œ≤ _inst_2) (UniformSpace.Completion.extension.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : CompleteSpace.{u1} Œ≤ _inst_2], Continuous.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) Œ≤ (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u1} Œ≤ _inst_2) (UniformSpace.Completion.extension.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 f)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous_extension UniformSpace.Completion.continuous_extension‚Çì'. -/
theorem continuous_extension : Continuous (Completion.extension f) :=
  cPkg.continuous_extend
#align uniform_space.completion.continuous_extension UniformSpace.Completion.continuous_extension

end CompleteSpace

/- warning: uniform_space.completion.extension_coe -> UniformSpace.Completion.extension_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : SeparatedSpace.{u2} Œ≤ _inst_2], (UniformContinuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u2} Œ≤ (UniformSpace.Completion.extension.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a)) (f a))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : SeparatedSpace.{u2} Œ≤ _inst_2], (UniformContinuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u2} Œ≤ (UniformSpace.Completion.extension.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f (UniformSpace.Completion.coe'.{u1} Œ± _inst_1 a)) (f a))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.extension_coe UniformSpace.Completion.extension_coe‚Çì'. -/
@[simp]
theorem extension_coe [SeparatedSpace Œ≤] (hf : UniformContinuous f) (a : Œ±) :
    (Completion.extension f) a = f a :=
  cPkg.extend_coe hf a
#align uniform_space.completion.extension_coe UniformSpace.Completion.extension_coe

variable [SeparatedSpace Œ≤] [CompleteSpace Œ≤]

/- warning: uniform_space.completion.extension_unique -> UniformSpace.Completion.extension_unique is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : SeparatedSpace.{u2} Œ≤ _inst_2] [_inst_5 : CompleteSpace.{u2} Œ≤ _inst_2], (UniformContinuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {g : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Œ≤}, (UniformContinuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Œ≤ (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) _inst_2 g) -> (forall (a : Œ±), Eq.{succ u2} Œ≤ (f a) (g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a))) -> (Eq.{max (succ u1) (succ u2)} ((UniformSpace.Completion.{u1} Œ± _inst_1) -> Œ≤) (UniformSpace.Completion.extension.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f) g))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {f : Œ± -> Œ≤} [_inst_4 : SeparatedSpace.{u1} Œ≤ _inst_2] [_inst_5 : CompleteSpace.{u1} Œ≤ _inst_2], (UniformContinuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {g : (UniformSpace.Completion.{u2} Œ± _inst_1) -> Œ≤}, (UniformContinuous.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) Œ≤ (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1) _inst_2 g) -> (forall (a : Œ±), Eq.{succ u1} Œ≤ (f a) (g (UniformSpace.Completion.coe'.{u2} Œ± _inst_1 a))) -> (Eq.{max (succ u2) (succ u1)} ((UniformSpace.Completion.{u2} Œ± _inst_1) -> Œ≤) (UniformSpace.Completion.extension.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 f) g))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.extension_unique UniformSpace.Completion.extension_unique‚Çì'. -/
theorem extension_unique (hf : UniformContinuous f) {g : Completion Œ± ‚Üí Œ≤}
    (hg : UniformContinuous g) (h : ‚àÄ a : Œ±, f a = g (a : Completion Œ±)) :
    Completion.extension f = g :=
  cPkg.extend_unique hf hg h
#align uniform_space.completion.extension_unique UniformSpace.Completion.extension_unique

/- warning: uniform_space.completion.extension_comp_coe -> UniformSpace.Completion.extension_comp_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] [_inst_4 : SeparatedSpace.{u2} Œ≤ _inst_2] [_inst_5 : CompleteSpace.{u2} Œ≤ _inst_2] {f : (UniformSpace.Completion.{u1} Œ± _inst_1) -> Œ≤}, (UniformContinuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) Œ≤ (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) _inst_2 f) -> (Eq.{max (succ u1) (succ u2)} ((UniformSpace.Completion.{u1} Œ± _inst_1) -> Œ≤) (UniformSpace.Completion.extension.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 (Function.comp.{succ u1, succ u1, succ u2} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) Œ≤ f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1)))))) f)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] [_inst_4 : SeparatedSpace.{u1} Œ≤ _inst_2] [_inst_5 : CompleteSpace.{u1} Œ≤ _inst_2] {f : (UniformSpace.Completion.{u2} Œ± _inst_1) -> Œ≤}, (UniformContinuous.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) Œ≤ (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1) _inst_2 f) -> (Eq.{max (succ u2) (succ u1)} ((UniformSpace.Completion.{u2} Œ± _inst_1) -> Œ≤) (UniformSpace.Completion.extension.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 (Function.comp.{succ u2, succ u2, succ u1} Œ± (UniformSpace.Completion.{u2} Œ± _inst_1) Œ≤ f (UniformSpace.Completion.coe'.{u2} Œ± _inst_1))) f)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.extension_comp_coe UniformSpace.Completion.extension_comp_coe‚Çì'. -/
@[simp]
theorem extension_comp_coe {f : Completion Œ± ‚Üí Œ≤} (hf : UniformContinuous f) :
    Completion.extension (f ‚àò coe) = f :=
  cPkg.extend_comp_coe hf
#align uniform_space.completion.extension_comp_coe UniformSpace.Completion.extension_comp_coe

end Extension

section Map

variable {f : Œ± ‚Üí Œ≤}

#print UniformSpace.Completion.map /-
/-- Completion functor acting on morphisms -/
protected def map (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Completion Œ≤ :=
  cPkg.map cPkg f
#align uniform_space.completion.map UniformSpace.Completion.map
-/

/- warning: uniform_space.completion.uniform_continuous_map -> UniformSpace.Completion.uniformContinuous_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, UniformContinuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2) (UniformSpace.Completion.map.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, UniformContinuous.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ≤ _inst_2) (UniformSpace.Completion.map.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 f)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.uniform_continuous_map UniformSpace.Completion.uniformContinuous_map‚Çì'. -/
theorem uniformContinuous_map : UniformContinuous (Completion.map f) :=
  cPkg.uniformContinuous_map cPkg f
#align uniform_space.completion.uniform_continuous_map UniformSpace.Completion.uniformContinuous_map

/- warning: uniform_space.completion.continuous_map -> UniformSpace.Completion.continuous_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Continuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2)) (UniformSpace.Completion.map.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Continuous.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u1} Œ≤ _inst_2)) (UniformSpace.Completion.map.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 f)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous_map UniformSpace.Completion.continuous_map‚Çì'. -/
theorem continuous_map : Continuous (Completion.map f) :=
  cPkg.continuous_map cPkg f
#align uniform_space.completion.continuous_map UniformSpace.Completion.continuous_map

/- warning: uniform_space.completion.map_coe -> UniformSpace.Completion.map_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (UniformContinuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.map.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) (f a)))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (UniformContinuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u1} (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.Completion.map.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 f (UniformSpace.Completion.coe'.{u2} Œ± _inst_1 a)) (UniformSpace.Completion.coe'.{u1} Œ≤ _inst_2 (f a)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.map_coe UniformSpace.Completion.map_coe‚Çì'. -/
@[simp]
theorem map_coe (hf : UniformContinuous f) (a : Œ±) : (Completion.map f) a = f a :=
  cPkg.map_coe cPkg hf a
#align uniform_space.completion.map_coe UniformSpace.Completion.map_coe

/- warning: uniform_space.completion.map_unique -> UniformSpace.Completion.map_unique is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {f : Œ± -> Œ≤} {g : (UniformSpace.Completion.{u1} Œ± _inst_1) -> (UniformSpace.Completion.{u2} Œ≤ _inst_2)}, (UniformContinuous.{u1, u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2) g) -> (forall (a : Œ±), Eq.{succ u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) (f a)) (g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a))) -> (Eq.{max (succ u1) (succ u2)} ((UniformSpace.Completion.{u1} Œ± _inst_1) -> (UniformSpace.Completion.{u2} Œ≤ _inst_2)) (UniformSpace.Completion.map.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f) g)
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : UniformSpace.{u2} Œ±] {Œ≤ : Type.{u1}} [_inst_2 : UniformSpace.{u1} Œ≤] {f : Œ± -> Œ≤} {g : (UniformSpace.Completion.{u2} Œ± _inst_1) -> (UniformSpace.Completion.{u1} Œ≤ _inst_2)}, (UniformContinuous.{u2, u1} (UniformSpace.Completion.{u2} Œ± _inst_1) (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ≤ _inst_2) g) -> (forall (a : Œ±), Eq.{succ u1} (UniformSpace.Completion.{u1} Œ≤ _inst_2) (UniformSpace.Completion.coe'.{u1} Œ≤ _inst_2 (f a)) (g (UniformSpace.Completion.coe'.{u2} Œ± _inst_1 a))) -> (Eq.{max (succ u2) (succ u1)} ((UniformSpace.Completion.{u2} Œ± _inst_1) -> (UniformSpace.Completion.{u1} Œ≤ _inst_2)) (UniformSpace.Completion.map.{u2, u1} Œ± _inst_1 Œ≤ _inst_2 f) g)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.map_unique UniformSpace.Completion.map_unique‚Çì'. -/
theorem map_unique {f : Œ± ‚Üí Œ≤} {g : Completion Œ± ‚Üí Completion Œ≤} (hg : UniformContinuous g)
    (h : ‚àÄ a : Œ±, ‚Üë(f a) = g a) : Completion.map f = g :=
  cPkg.map_unique cPkg hg h
#align uniform_space.completion.map_unique UniformSpace.Completion.map_unique

#print UniformSpace.Completion.map_id /-
@[simp]
theorem map_id : Completion.map (@id Œ±) = id :=
  cPkg.map_id
#align uniform_space.completion.map_id UniformSpace.Completion.map_id
-/

#print UniformSpace.Completion.extension_map /-
theorem extension_map [CompleteSpace Œ≥] [SeparatedSpace Œ≥] {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤}
    (hf : UniformContinuous f) (hg : UniformContinuous g) :
    Completion.extension f ‚àò Completion.map g = Completion.extension (f ‚àò g) :=
  Completion.ext (continuous_extension.comp continuous_map) continuous_extension <| by
    intro a <;> simp only [hg, hf, hf.comp hg, (¬∑ ‚àò ¬∑), map_coe, extension_coe]
#align uniform_space.completion.extension_map UniformSpace.Completion.extension_map
-/

/- warning: uniform_space.completion.map_comp -> UniformSpace.Completion.map_comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (UniformContinuous.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (UniformContinuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Eq.{max (succ u1) (succ u3)} ((UniformSpace.Completion.{u1} Œ± _inst_1) -> (UniformSpace.Completion.{u3} Œ≥ _inst_3)) (Function.comp.{succ u1, succ u2, succ u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.map.{u2, u3} Œ≤ _inst_2 Œ≥ _inst_3 g) (UniformSpace.Completion.map.{u1, u2} Œ± _inst_1 Œ≤ _inst_2 f)) (UniformSpace.Completion.map.{u1, u3} Œ± _inst_1 Œ≥ _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u3}} [_inst_2 : UniformSpace.{u3} Œ≤] {Œ≥ : Type.{u2}} [_inst_3 : UniformSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (UniformContinuous.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (UniformContinuous.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (Eq.{max (succ u1) (succ u2)} ((UniformSpace.Completion.{u1} Œ± _inst_1) -> (UniformSpace.Completion.{u2} Œ≥ _inst_3)) (Function.comp.{succ u1, succ u3, succ u2} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u3} Œ≤ _inst_2) (UniformSpace.Completion.{u2} Œ≥ _inst_3) (UniformSpace.Completion.map.{u3, u2} Œ≤ _inst_2 Œ≥ _inst_3 g) (UniformSpace.Completion.map.{u1, u3} Œ± _inst_1 Œ≤ _inst_2 f)) (UniformSpace.Completion.map.{u1, u2} Œ± _inst_1 Œ≥ _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.map_comp UniformSpace.Completion.map_comp‚Çì'. -/
theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : UniformContinuous g) (hf : UniformContinuous f) :
    Completion.map g ‚àò Completion.map f = Completion.map (g ‚àò f) :=
  extension_map ((uniformContinuous_coe _).comp hg) hf
#align uniform_space.completion.map_comp UniformSpace.Completion.map_comp

end Map

/- In this section we construct isomorphisms between the completion of a uniform space and the
completion of its separation quotient -/
section SeparationQuotientCompletion

#print UniformSpace.Completion.completionSeparationQuotientEquiv /-
/-- The isomorphism between the completion of a uniform space and the completion of its separation
quotient. -/
def completionSeparationQuotientEquiv (Œ± : Type u) [UniformSpace Œ±] :
    Completion (SeparationQuotient Œ±) ‚âÉ Completion Œ± :=
  by
  refine'
    ‚ü®completion.extension (SeparationQuotient.lift (coe : Œ± ‚Üí completion Œ±)),
      completion.map Quotient.mk', _, _‚ü©
  ¬∑ intro a
    refine' induction_on a (isClosed_eq (ContinuousMap.comp continuous_extension) continuous_id) _
    rintro ‚ü®a‚ü©
    show
      completion.map Quotient.mk' (completion.extension (SeparationQuotient.lift coe) ‚Üë(‚ü¶a‚üß)) =
        ‚Üë(‚ü¶a‚üß)
    rw [extension_coe (separation_quotient.uniform_continuous_lift _),
        SeparationQuotient.lift_mk (uniform_continuous_coe Œ±),
        completion.map_coe uniform_continuous_quotient_mk] <;>
      infer_instance
  ¬∑ intro a
    refine'
      completion.induction_on a
        (isClosed_eq (continuous_extension.comp ContinuousMap) continuous_id) fun a => _
    rw [map_coe uniform_continuous_quotient_mk,
        extension_coe (separation_quotient.uniform_continuous_lift _),
        SeparationQuotient.lift_mk (uniform_continuous_coe Œ±) _] <;>
      infer_instance
#align uniform_space.completion.completion_separation_quotient_equiv UniformSpace.Completion.completionSeparationQuotientEquiv
-/

#print UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv /-
theorem uniformContinuous_completionSeparationQuotientEquiv :
    UniformContinuous ‚áë(completionSeparationQuotientEquiv Œ±) :=
  uniformContinuous_extension
#align uniform_space.completion.uniform_continuous_completion_separation_quotient_equiv UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv
-/

#print UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv_symm /-
theorem uniformContinuous_completionSeparationQuotientEquiv_symm :
    UniformContinuous ‚áë(completionSeparationQuotientEquiv Œ±).symm :=
  uniformContinuous_map
#align uniform_space.completion.uniform_continuous_completion_separation_quotient_equiv_symm UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv_symm
-/

end SeparationQuotientCompletion

section Extension‚ÇÇ

variable (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)

open Function

#print UniformSpace.Completion.extension‚ÇÇ /-
/-- Extend a two variable map to the Hausdorff completions. -/
protected def extension‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Œ≥ :=
  cPkg.extend‚ÇÇ cPkg f
#align uniform_space.completion.extension‚ÇÇ UniformSpace.Completion.extension‚ÇÇ
-/

section SeparatedSpace

variable [SeparatedSpace Œ≥] {f}

/- warning: uniform_space.completion.extension‚ÇÇ_coe_coe -> UniformSpace.Completion.extension‚ÇÇ_coe_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥] {f : Œ± -> Œ≤ -> Œ≥} [_inst_4 : SeparatedSpace.{u3} Œ≥ _inst_3], (UniformContinuous‚ÇÇ.{u1, u2, u3} Œ± Œ≤ Œ≥ _inst_1 _inst_2 _inst_3 f) -> (forall (a : Œ±) (b : Œ≤), Eq.{succ u3} Œ≥ (UniformSpace.Completion.extension‚ÇÇ.{u1, u2, u3} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) b)) (f a b))
but is expected to have type
  forall {Œ± : Type.{u3}} [_inst_1 : UniformSpace.{u3} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u1}} [_inst_3 : UniformSpace.{u1} Œ≥] {f : Œ± -> Œ≤ -> Œ≥} [_inst_4 : SeparatedSpace.{u1} Œ≥ _inst_3], (UniformContinuous‚ÇÇ.{u3, u2, u1} Œ± Œ≤ Œ≥ _inst_1 _inst_2 _inst_3 f) -> (forall (a : Œ±) (b : Œ≤), Eq.{succ u1} Œ≥ (UniformSpace.Completion.extension‚ÇÇ.{u3, u2, u1} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f (UniformSpace.Completion.coe'.{u3} Œ± _inst_1 a) (UniformSpace.Completion.coe'.{u2} Œ≤ _inst_2 b)) (f a b))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.extension‚ÇÇ_coe_coe UniformSpace.Completion.extension‚ÇÇ_coe_coe‚Çì'. -/
@[simp]
theorem extension‚ÇÇ_coe_coe (hf : UniformContinuous‚ÇÇ f) (a : Œ±) (b : Œ≤) :
    Completion.extension‚ÇÇ f a b = f a b :=
  cPkg.extension‚ÇÇ_coe_coe cPkg hf a b
#align uniform_space.completion.extension‚ÇÇ_coe_coe UniformSpace.Completion.extension‚ÇÇ_coe_coe

end SeparatedSpace

variable [CompleteSpace Œ≥] (f)

/- warning: uniform_space.completion.uniform_continuous_extension‚ÇÇ -> UniformSpace.Completion.uniformContinuous_extension‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥] (f : Œ± -> Œ≤ -> Œ≥) [_inst_4 : CompleteSpace.{u3} Œ≥ _inst_3], UniformContinuous‚ÇÇ.{u1, u2, u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) Œ≥ (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2) _inst_3 (UniformSpace.Completion.extension‚ÇÇ.{u1, u2, u3} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f)
but is expected to have type
  forall {Œ± : Type.{u3}} [_inst_1 : UniformSpace.{u3} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u1}} [_inst_3 : UniformSpace.{u1} Œ≥] (f : Œ± -> Œ≤ -> Œ≥) [_inst_4 : CompleteSpace.{u1} Œ≥ _inst_3], UniformContinuous‚ÇÇ.{u3, u2, u1} (UniformSpace.Completion.{u3} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) Œ≥ (UniformSpace.Completion.uniformSpace.{u3} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2) _inst_3 (UniformSpace.Completion.extension‚ÇÇ.{u3, u2, u1} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.uniform_continuous_extension‚ÇÇ UniformSpace.Completion.uniformContinuous_extension‚ÇÇ‚Çì'. -/
theorem uniformContinuous_extension‚ÇÇ : UniformContinuous‚ÇÇ (Completion.extension‚ÇÇ f) :=
  cPkg.uniformContinuous_extension‚ÇÇ cPkg f
#align uniform_space.completion.uniform_continuous_extension‚ÇÇ UniformSpace.Completion.uniformContinuous_extension‚ÇÇ

end Extension‚ÇÇ

section Map‚ÇÇ

open Function

#print UniformSpace.Completion.map‚ÇÇ /-
/-- Lift a two variable map to the Hausdorff completions. -/
protected def map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ :=
  cPkg.zipWith cPkg cPkg f
#align uniform_space.completion.map‚ÇÇ UniformSpace.Completion.map‚ÇÇ
-/

/- warning: uniform_space.completion.uniform_continuous_map‚ÇÇ -> UniformSpace.Completion.uniformContinuous_map‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥] (f : Œ± -> Œ≤ -> Œ≥), UniformContinuous‚ÇÇ.{u1, u2, u3} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u3} Œ≥ _inst_3) (UniformSpace.Completion.map‚ÇÇ.{u1, u2, u3} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f)
but is expected to have type
  forall {Œ± : Type.{u3}} [_inst_1 : UniformSpace.{u3} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u1}} [_inst_3 : UniformSpace.{u1} Œ≥] (f : Œ± -> Œ≤ -> Œ≥), UniformContinuous‚ÇÇ.{u3, u2, u1} (UniformSpace.Completion.{u3} Œ± _inst_1) (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.{u1} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u3} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u1} Œ≥ _inst_3) (UniformSpace.Completion.map‚ÇÇ.{u3, u2, u1} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f)
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.uniform_continuous_map‚ÇÇ UniformSpace.Completion.uniformContinuous_map‚ÇÇ‚Çì'. -/
theorem uniformContinuous_map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : UniformContinuous‚ÇÇ (Completion.map‚ÇÇ f) :=
  cPkg.uniformContinuous_map‚ÇÇ cPkg cPkg f
#align uniform_space.completion.uniform_continuous_map‚ÇÇ UniformSpace.Completion.uniformContinuous_map‚ÇÇ

/- warning: uniform_space.completion.continuous_map‚ÇÇ -> UniformSpace.Completion.continuous_map‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥] {Œ¥ : Type.{u4}} [_inst_4 : TopologicalSpace.{u4} Œ¥] {f : Œ± -> Œ≤ -> Œ≥} {a : Œ¥ -> (UniformSpace.Completion.{u1} Œ± _inst_1)} {b : Œ¥ -> (UniformSpace.Completion.{u2} Œ≤ _inst_2)}, (Continuous.{u4, u1} Œ¥ (UniformSpace.Completion.{u1} Œ± _inst_1) _inst_4 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u1} Œ± _inst_1)) a) -> (Continuous.{u4, u2} Œ¥ (UniformSpace.Completion.{u2} Œ≤ _inst_2) _inst_4 (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2)) b) -> (Continuous.{u4, u3} Œ¥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) _inst_4 (UniformSpace.toTopologicalSpace.{u3} (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u3} Œ≥ _inst_3)) (fun (d : Œ¥) => UniformSpace.Completion.map‚ÇÇ.{u1, u2, u3} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f (a d) (b d)))
but is expected to have type
  forall {Œ± : Type.{u3}} [_inst_1 : UniformSpace.{u3} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u1}} [_inst_3 : UniformSpace.{u1} Œ≥] {Œ¥ : Type.{u4}} [_inst_4 : TopologicalSpace.{u4} Œ¥] {f : Œ± -> Œ≤ -> Œ≥} {a : Œ¥ -> (UniformSpace.Completion.{u3} Œ± _inst_1)} {b : Œ¥ -> (UniformSpace.Completion.{u2} Œ≤ _inst_2)}, (Continuous.{u4, u3} Œ¥ (UniformSpace.Completion.{u3} Œ± _inst_1) _inst_4 (UniformSpace.toTopologicalSpace.{u3} (UniformSpace.Completion.{u3} Œ± _inst_1) (UniformSpace.Completion.uniformSpace.{u3} Œ± _inst_1)) a) -> (Continuous.{u4, u2} Œ¥ (UniformSpace.Completion.{u2} Œ≤ _inst_2) _inst_4 (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.uniformSpace.{u2} Œ≤ _inst_2)) b) -> (Continuous.{u4, u1} Œ¥ (UniformSpace.Completion.{u1} Œ≥ _inst_3) _inst_4 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} Œ≥ _inst_3) (UniformSpace.Completion.uniformSpace.{u1} Œ≥ _inst_3)) (fun (d : Œ¥) => UniformSpace.Completion.map‚ÇÇ.{u3, u2, u1} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f (a d) (b d)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous_map‚ÇÇ UniformSpace.Completion.continuous_map‚ÇÇ‚Çì'. -/
theorem continuous_map‚ÇÇ {Œ¥} [TopologicalSpace Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ¥ ‚Üí Completion Œ±}
    {b : Œ¥ ‚Üí Completion Œ≤} (ha : Continuous a) (hb : Continuous b) :
    Continuous fun d : Œ¥ => Completion.map‚ÇÇ f (a d) (b d) :=
  cPkg.continuous_map‚ÇÇ cPkg cPkg ha hb
#align uniform_space.completion.continuous_map‚ÇÇ UniformSpace.Completion.continuous_map‚ÇÇ

/- warning: uniform_space.completion.map‚ÇÇ_coe_coe -> UniformSpace.Completion.map‚ÇÇ_coe_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : UniformSpace.{u1} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u3}} [_inst_3 : UniformSpace.{u3} Œ≥] (a : Œ±) (b : Œ≤) (f : Œ± -> Œ≤ -> Œ≥), (UniformContinuous‚ÇÇ.{u1, u2, u3} Œ± Œ≤ Œ≥ _inst_1 _inst_2 _inst_3 f) -> (Eq.{succ u3} (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.map‚ÇÇ.{u1, u2, u3} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (HasLiftT.mk.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (CoeTC‚Çì.coe.{succ u1, succ u1} Œ± (UniformSpace.Completion.{u1} Œ± _inst_1) (UniformSpace.Completion.hasCoeT.{u1} Œ± _inst_1))) a) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (HasLiftT.mk.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (CoeTC‚Çì.coe.{succ u2, succ u2} Œ≤ (UniformSpace.Completion.{u2} Œ≤ _inst_2) (UniformSpace.Completion.hasCoeT.{u2} Œ≤ _inst_2))) b)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (HasLiftT.mk.{succ u3, succ u3} Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (CoeTC‚Çì.coe.{succ u3, succ u3} Œ≥ (UniformSpace.Completion.{u3} Œ≥ _inst_3) (UniformSpace.Completion.hasCoeT.{u3} Œ≥ _inst_3))) (f a b)))
but is expected to have type
  forall {Œ± : Type.{u3}} [_inst_1 : UniformSpace.{u3} Œ±] {Œ≤ : Type.{u2}} [_inst_2 : UniformSpace.{u2} Œ≤] {Œ≥ : Type.{u1}} [_inst_3 : UniformSpace.{u1} Œ≥] (a : Œ±) (b : Œ≤) (f : Œ± -> Œ≤ -> Œ≥), (UniformContinuous‚ÇÇ.{u3, u2, u1} Œ± Œ≤ Œ≥ _inst_1 _inst_2 _inst_3 f) -> (Eq.{succ u1} (UniformSpace.Completion.{u1} Œ≥ _inst_3) (UniformSpace.Completion.map‚ÇÇ.{u3, u2, u1} Œ± _inst_1 Œ≤ _inst_2 Œ≥ _inst_3 f (UniformSpace.Completion.coe'.{u3} Œ± _inst_1 a) (UniformSpace.Completion.coe'.{u2} Œ≤ _inst_2 b)) (UniformSpace.Completion.coe'.{u1} Œ≥ _inst_3 (f a b)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.map‚ÇÇ_coe_coe UniformSpace.Completion.map‚ÇÇ_coe_coe‚Çì'. -/
theorem map‚ÇÇ_coe_coe (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hf : UniformContinuous‚ÇÇ f) :
    Completion.map‚ÇÇ f (a : Completion Œ±) (b : Completion Œ≤) = f a b :=
  cPkg.map‚ÇÇ_coe_coe cPkg cPkg a b f hf
#align uniform_space.completion.map‚ÇÇ_coe_coe UniformSpace.Completion.map‚ÇÇ_coe_coe

end Map‚ÇÇ

end Completion

end UniformSpace

