/-
Copyright (c) 2022 Jireh Loreaux. All rights reserved.
Reeased under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathbin.Analysis.NormedSpace.Star.Spectrum
import Mathbin.Analysis.Normed.Group.Quotient
import Mathbin.Analysis.NormedSpace.Algebra
import Mathbin.Topology.ContinuousFunction.Units
import Mathbin.Topology.ContinuousFunction.Compact
import Mathbin.Topology.Algebra.Algebra
import Mathbin.Topology.ContinuousFunction.StoneWeierstrass

/-!
# Gelfand Duality

The `gelfand_transform` is an algebra homomorphism from a topological `ð•œ`-algebra `A` to
`C(character_space ð•œ A, ð•œ)`. In the case where `A` is a commutative complex Banach algebra, then
the Gelfand transform is actually spectrum-preserving (`spectrum.gelfand_transform_eq`). Moreover,
when `A` is a commutative Câ‹†-algebra over `â„‚`, then the Gelfand transform is a surjective isometry,
and even an equivalence between Câ‹†-algebras.

## Main definitions

* `ideal.to_character_space` : constructs an element of the character space from a maximal ideal in
  a commutative complex Banach algebra
* `weak_dual.character_space.comp_continuous_map`: The functorial map taking `Ïˆ : A â†’â‹†â‚[â„‚] B` to a
  continuous function `character_space â„‚ B â†’ character_space â„‚ A` given by pre-composition with `Ïˆ`.

## Main statements

* `spectrum.gelfand_transform_eq` : the Gelfand transform is spectrum-preserving when the algebra is
  a commutative complex Banach algebra.
* `gelfand_transform_isometry` : the Gelfand transform is an isometry when the algebra is a
  commutative (unital) Câ‹†-algebra over `â„‚`.
* `gelfand_transform_bijective` : the Gelfand transform is bijective when the algebra is a
  commutative (unital) Câ‹†-algebra over `â„‚`.

## TODO

* After `star_alg_equiv` is defined, realize `gelfand_transform` as a `star_alg_equiv`.
* Prove that if `A` is the unital Câ‹†-algebra over `â„‚` generated by a fixed normal element `x` in
  a larger Câ‹†-algebra `B`, then `character_space â„‚ A` is homeomorphic to `spectrum â„‚ x`.
* From the previous result, construct the **continuous functional calculus**.
* Show that if `X` is a compact Hausdorff space, then `X` is (canonically) homeomorphic to
  `character_space â„‚ C(X, â„‚)`.
* Conclude using the previous fact that the functors `C(â¬, â„‚)` and `character_space â„‚ â¬` along with
  the canonical homeomorphisms described above constitute a natural contravariant equivalence of
  the categories of compact Hausdorff spaces (with continuous maps) and commutative unital
  Câ‹†-algebras (with unital â‹†-algebra homomoprhisms); this is known as **Gelfand duality**.

## Tags

Gelfand transform, character space, Câ‹†-algebra
-/


open WeakDual

open Nnreal

section ComplexBanachAlgebra

open Ideal

variable {A : Type _} [NormedCommRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] (I : Ideal A) [Ideal.IsMaximal I]

/-- Every maximal ideal in a commutative complex Banach algebra gives rise to a character on that
algebra. In particular, the character, which may be identified as an algebra homomorphism due to
`weak_dual.character_space.equiv_alg_hom`, is given by the composition of the quotient map and
the Gelfand-Mazur isomorphism `normed_ring.alg_equiv_complex_of_complete`. -/
noncomputable def Ideal.toCharacterSpace : characterSpace â„‚ A :=
  characterSpace.equivAlgHom.symm $
    ((@NormedRing.algEquivComplexOfComplete (A â§¸ I) _ _
              (letI := quotient.field I
              @is_unit_iff_ne_zero (A â§¸ I) _)
              _).symm :
          A â§¸ I â†’â‚[â„‚] â„‚).comp
      (Quotient.mkâ‚ â„‚ I)
#align ideal.to_character_space Ideal.toCharacterSpace

theorem Ideal.to_character_space_apply_eq_zero_of_mem {a : A} (ha : a âˆˆ I) : I.toCharacterSpace a = 0 := by
  unfold Ideal.toCharacterSpace
  simpa only [character_space.equiv_alg_hom_symm_coe, AlgHom.coe_comp, AlgEquiv.coe_alg_hom, quotient.mkâ‚_eq_mk,
    Function.comp_apply, quotient.eq_zero_iff_mem.mpr ha, spectrum.zero_eq,
    NormedRing.alg_equiv_complex_of_complete_symm_apply] using
    Set.eq_of_mem_singleton (Set.singleton_nonempty (0 : â„‚)).some_mem
#align ideal.to_character_space_apply_eq_zero_of_mem Ideal.to_character_space_apply_eq_zero_of_mem

/-- If `a : A` is not a unit, then some character takes the value zero at `a`. This is equivlaent
to `gelfand_transform â„‚ A a` takes the value zero at some character. -/
theorem WeakDual.characterSpace.exists_apply_eq_zero {a : A} (ha : Â¬IsUnit a) : âˆƒ f : characterSpace â„‚ A, f a = 0 := by
  obtain âŸ¨M, hM, haMâŸ© := (span {a}).exists_le_maximal (span_singleton_ne_top ha)
  exact
    âŸ¨M.to_character_space,
      M.to_character_space_apply_eq_zero_of_mem (haM (mem_span_singleton.mpr âŸ¨1, (mul_one a).symmâŸ©))âŸ©
#align weak_dual.character_space.exists_apply_eq_zero WeakDual.characterSpace.exists_apply_eq_zero

/-- The Gelfand transform is spectrum-preserving. -/
theorem spectrum.gelfand_transform_eq (a : A) : spectrum â„‚ (gelfandTransform â„‚ A a) = spectrum â„‚ a := by
  refine' Set.Subset.antisymm (AlgHom.spectrum_apply_subset (gelfand_transform â„‚ A) a) fun z hz => _
  obtain âŸ¨f, hfâŸ© := WeakDual.characterSpace.exists_apply_eq_zero hz
  simp only [map_sub, sub_eq_zero, AlgHomClass.commutes, Algebra.id.map_eq_id, RingHom.id_apply] at hf
  exact (ContinuousMap.spectrum_eq_range (gelfand_transform â„‚ A a)).symm â–¸ âŸ¨f, hf.symmâŸ©
#align spectrum.gelfand_transform_eq spectrum.gelfand_transform_eq

instance [Nontrivial A] : Nonempty (characterSpace â„‚ A) :=
  âŸ¨Classical.choose $ WeakDual.characterSpace.exists_apply_eq_zero $ zero_mem_nonunits.2 zero_ne_oneâŸ©

end ComplexBanachAlgebra

section ComplexCstarAlgebra

variable {A : Type _} [NormedCommRing A] [NormedAlgebra â„‚ A] [CompleteSpace A]

variable [StarRing A] [CstarRing A] [StarModule â„‚ A]

theorem gelfand_transform_map_star (a : A) : gelfandTransform â„‚ A (star a) = star (gelfandTransform â„‚ A a) :=
  ContinuousMap.ext $ fun Ï† => map_star Ï† a
#align gelfand_transform_map_star gelfand_transform_map_star

variable (A)

/-- The Gelfand transform is an isometry when the algebra is a Câ‹†-algebra over `â„‚`. -/
theorem gelfandTransformIsometry : Isometry (gelfandTransform â„‚ A) := by
  nontriviality A
  refine' AddMonoidHomClass.isometryOfNorm (gelfand_transform â„‚ A) fun a => _
  /- By `spectrum.gelfand_transform_eq`, the spectra of `star a * a` and its
    `gelfand_transform` coincide. Therefore, so do their spectral radii, and since they are
    self-adjoint, so also do their norms. Applying the Câ‹†-property of the norm and taking square
    roots shows that the norm is preserved. -/
  have : spectralRadius â„‚ (gelfand_transform â„‚ A (star a * a)) = spectralRadius â„‚ (star a * a) := by
    unfold spectralRadius
    rw [spectrum.gelfand_transform_eq]
  simp only [map_mul, (IsSelfAdjoint.star_mul_self _).spectral_radius_eq_nnnorm, gelfand_transform_map_star a,
    Ennreal.coe_eq_coe, CstarRing.nnnorm_star_mul_self, â† sq] at this
  simpa only [Function.comp_apply, Nnreal.sqrt_sq] using congr_arg ((coe : â„â‰¥0 â†’ â„) âˆ˜ â‡‘Nnreal.sqrt) this
#align gelfand_transform_isometry gelfandTransformIsometry

/-- The Gelfand transform is bijective when the algebra is a Câ‹†-algebra over `â„‚`. -/
theorem gelfand_transform_bijective : Function.Bijective (gelfandTransform â„‚ A) := by
  refine' âŸ¨(gelfandTransformIsometry A).Injective, _âŸ©
  suffices (gelfand_transform â„‚ A).range = âŠ¤ by
    exact fun x => this.symm â–¸ (gelfand_transform â„‚ A).mem_range.mp (this.symm â–¸ Algebra.mem_top)
  /- Because the `gelfand_transform â„‚ A` is an isometry, it has closed range, and so by the
    Stone-Weierstrass theorem, it suffices to show that the image of the Gelfand transform separates
    points in `C(character_space â„‚ A, â„‚)` and is closed under `star`. -/
  have h : (gelfand_transform â„‚ A).range.topologicalClosure = (gelfand_transform â„‚ A).range :=
    le_antisymm
      (Subalgebra.topological_closure_minimal _ le_rfl (gelfandTransformIsometry A).ClosedEmbedding.closedRange)
      (Subalgebra.subalgebra_topological_closure _)
  refine'
    h â–¸ ContinuousMap.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points _ (fun _ _ => _) fun f hf => _
  /- Separating points just means that elements of the `character_space` which agree at all points
    of `A` are the same functional, which is just extensionality. -/
  Â· contrapose!
    exact fun h =>
      Subtype.ext
        (ContinuousLinearMap.ext $ fun a => h (gelfand_transform â„‚ A a) âŸ¨gelfand_transform â„‚ A a, âŸ¨a, rflâŸ©, rflâŸ©)
    
  /- If `f = gelfand_transform â„‚ A a`, then `star f` is also in the range of `gelfand_transform â„‚ A`
    using the argument `star a`. The key lemma below may be hard to spot; it's `map_star` coming from
    `weak_dual.star_hom_class`, which is a nontrivial result. -/
  Â· obtain âŸ¨f, âŸ¨a, rflâŸ©, rflâŸ© := subalgebra.mem_map.mp hf
    refine' âŸ¨star a, ContinuousMap.ext $ fun Ïˆ => _âŸ©
    simpa only [gelfand_transform_map_star a, AlgHom.to_ring_hom_eq_coe, AlgHom.coe_to_ring_hom]
    
#align gelfand_transform_bijective gelfand_transform_bijective

/-- The Gelfand transform as a `star_alg_equiv` between a commutative unital Câ‹†-algebra over `â„‚`
and the continuous functions on its `character_space`. -/
@[simps]
noncomputable def gelfandStarTransform : A â‰ƒâ‹†â‚[â„‚] C(characterSpace â„‚ A, â„‚) :=
  StarAlgEquiv.ofBijective
    (show A â†’â‹†â‚[â„‚] C(characterSpace â„‚ A, â„‚) from
      { gelfandTransform â„‚ A with map_star' := fun x => gelfand_transform_map_star x })
    (gelfand_transform_bijective A)
#align gelfand_star_transform gelfandStarTransform

end ComplexCstarAlgebra

section Functoriality

namespace WeakDual

namespace CharacterSpace

variable {A B C : Type _}

variable [NormedRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] [StarRing A]

variable [NormedRing B] [NormedAlgebra â„‚ B] [CompleteSpace B] [StarRing B]

variable [NormedRing C] [NormedAlgebra â„‚ C] [CompleteSpace C] [StarRing C]

/-- The functorial map taking `Ïˆ : A â†’â‹†â‚[â„‚] B` to a continuous function
`character_space â„‚ B â†’ character_space â„‚ A` obtained by pre-composition with `Ïˆ`. -/
@[simps]
noncomputable def compContinuousMap (Ïˆ : A â†’â‹†â‚[â„‚] B) : C(characterSpace â„‚ B, characterSpace â„‚ A) where
  toFun Ï† := equivAlgHom.symm ((equivAlgHom Ï†).comp Ïˆ.toAlgHom)
  continuous_to_fun :=
    Continuous.subtype_mk (continuous_of_continuous_eval $ fun a => map_continuous $ gelfandTransform â„‚ B (Ïˆ a)) _
#align weak_dual.character_space.comp_continuous_map WeakDual.characterSpace.compContinuousMap

variable (A)

/-- `weak_dual.character_space.comp_continuous_map` sends the identity to the identity. -/
@[simp]
theorem comp_continuous_map_id : compContinuousMap (StarAlgHom.id â„‚ A) = ContinuousMap.id (characterSpace â„‚ A) :=
  ContinuousMap.ext $ fun a => ext $ fun x => rfl
#align weak_dual.character_space.comp_continuous_map_id WeakDual.characterSpace.comp_continuous_map_id

variable {A}

/-- `weak_dual.character_space.comp_continuous_map` is functorial. -/
@[simp]
theorem comp_continuous_map_comp (Ïˆâ‚‚ : B â†’â‹†â‚[â„‚] C) (Ïˆâ‚ : A â†’â‹†â‚[â„‚] B) :
    compContinuousMap (Ïˆâ‚‚.comp Ïˆâ‚) = (compContinuousMap Ïˆâ‚).comp (compContinuousMap Ïˆâ‚‚) :=
  ContinuousMap.ext $ fun a => ext $ fun x => rfl
#align weak_dual.character_space.comp_continuous_map_comp WeakDual.characterSpace.comp_continuous_map_comp

end CharacterSpace

end WeakDual

end Functoriality

