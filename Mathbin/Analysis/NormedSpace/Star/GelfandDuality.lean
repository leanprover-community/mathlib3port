/-
Copyright (c) 2022 Jireh Loreaux. All rights reserved.
Reeased under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathbin.Analysis.NormedSpace.Star.Spectrum
import Mathbin.Analysis.Normed.Group.Quotient
import Mathbin.Analysis.NormedSpace.Algebra
import Mathbin.Topology.ContinuousFunction.Units
import Mathbin.Topology.ContinuousFunction.Compact
import Mathbin.Topology.Algebra.Algebra
import Mathbin.Topology.ContinuousFunction.StoneWeierstrass

/-!
# Gelfand Duality

The `gelfand_transform` is an algebra homomorphism from a topological `ùïú`-algebra `A` to
`C(character_space ùïú A, ùïú)`. In the case where `A` is a commutative complex Banach algebra, then
the Gelfand transform is actually spectrum-preserving (`spectrum.gelfand_transform_eq`). Moreover,
when `A` is a commutative C‚ãÜ-algebra over `‚ÑÇ`, then the Gelfand transform is a surjective isometry,
and even an equivalence between C‚ãÜ-algebras.

## Main definitions

* `ideal.to_character_space` : constructs an element of the character space from a maximal ideal in
  a commutative complex Banach algebra

## Main statements

* `spectrum.gelfand_transform_eq` : the Gelfand transform is spectrum-preserving when the algebra is
  a commutative complex Banach algebra.
* `gelfand_transform_isometry` : the Gelfand transform is an isometry when the algebra is a
  commutative (unital) C‚ãÜ-algebra over `‚ÑÇ`.
* `gelfand_transform_bijective` : the Gelfand transform is bijective when the algebra is a
  commutative (unital) C‚ãÜ-algebra over `‚ÑÇ`.

## TODO

* After `star_alg_equiv` is defined, realize `gelfand_transform` as a `star_alg_equiv`.
* Prove that if `A` is the unital C‚ãÜ-algebra over `‚ÑÇ` generated by a fixed normal element `x` in
  a larger C‚ãÜ-algebra `B`, then `character_space ‚ÑÇ A` is homeomorphic to `spectrum ‚ÑÇ x`.
* From the previous result, construct the **continuous functional calculus**.
* Show that if `X` is a compact Hausdorff space, then `X` is (canonically) homeomorphic to
  `character_space ‚ÑÇ C(X, ‚ÑÇ)`.
* Conclude using the previous fact that the functors `C(‚¨ù, ‚ÑÇ)` and `character_space ‚ÑÇ ‚¨ù` along with
  the canonical homeomorphisms described above constitute a natural contravariant equivalence of
  the categories of compact Hausdorff spaces (with continuous maps) and commutative unital
  C‚ãÜ-algebras (with unital ‚ãÜ-algebra homomoprhisms); this is known as **Gelfand duality**.

## Tags

Gelfand transform, character space, C‚ãÜ-algebra
-/


open WeakDual

open Nnreal

section ComplexBanachAlgebra

open Ideal

variable {A : Type _} [NormedCommRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A] [NormOneClass A] (I : Ideal A)
  [Ideal.IsMaximal I]

/-- Every maximal ideal in a commutative complex Banach algebra gives rise to a character on that
algebra. In particular, the character, which may be identified as an algebra homomorphism due to
`weak_dual.character_space.equiv_alg_hom`, is given by the composition of the quotient map and
the Gelfand-Mazur isomorphism `normed_ring.alg_equiv_complex_of_complete`. -/
noncomputable def Ideal.toCharacterSpace : CharacterSpace ‚ÑÇ A :=
  CharacterSpace.equivAlgHom.symm <|
    ((@NormedRing.algEquivComplexOfComplete (A ‚ß∏ I) _ _
            (letI := quotient.field I
            @is_unit_iff_ne_zero (A ‚ß∏ I) _)
            _).symm :
          A ‚ß∏ I ‚Üí‚Çê[‚ÑÇ] ‚ÑÇ).comp
      (Quotient.mk‚Çê ‚ÑÇ I)

theorem Ideal.to_character_space_apply_eq_zero_of_mem {a : A} (ha : a ‚àà I) : I.toCharacterSpace a = 0 := by
  unfold Ideal.toCharacterSpace
  simpa only [character_space.equiv_alg_hom_symm_coe, AlgHom.coe_comp, AlgEquiv.coe_alg_hom, quotient.mk‚Çê_eq_mk,
    Function.comp_app, quotient.eq_zero_iff_mem.mpr ha, Spectrum.zero_eq,
    NormedRing.alg_equiv_complex_of_complete_symm_apply] using
    Set.eq_of_mem_singleton (Set.singleton_nonempty (0 : ‚ÑÇ)).some_mem

/-- If `a : A` is not a unit, then some character takes the value zero at `a`. This is equivlaent
to `gelfand_transform ‚ÑÇ A a` takes the value zero at some character. -/
theorem WeakDual.CharacterSpace.exists_apply_eq_zero {a : A} (ha : ¬¨IsUnit a) : ‚àÉ f : CharacterSpace ‚ÑÇ A, f a = 0 := by
  obtain ‚ü®M, hM, haM‚ü© := (span {a}).exists_le_maximal (span_singleton_ne_top ha)
  exact
    ‚ü®M.to_character_space,
      M.to_character_space_apply_eq_zero_of_mem (haM (mem_span_singleton.mpr ‚ü®1, (mul_one‚Çì a).symm‚ü©))‚ü©

/-- The Gelfand transform is spectrum-preserving. -/
theorem Spectrum.gelfand_transform_eq (a : A) : Spectrum ‚ÑÇ (gelfandTransform ‚ÑÇ A a) = Spectrum ‚ÑÇ a := by
  refine' Set.Subset.antisymm (AlgHom.spectrum_apply_subset (gelfand_transform ‚ÑÇ A) a) fun z hz => _
  obtain ‚ü®f, hf‚ü© := WeakDual.CharacterSpace.exists_apply_eq_zero hz
  simp only [map_sub, sub_eq_zero, AlgHomClass.commutes, Algebra.id.map_eq_id, RingHom.id_apply] at hf
  exact (ContinuousMap.spectrum_eq_range (gelfand_transform ‚ÑÇ A a)).symm ‚ñ∏ ‚ü®f, hf.symm‚ü©

instance : Nonempty (CharacterSpace ‚ÑÇ A) :=
  haveI := NormOneClass.nontrivial A
  ‚ü®Classical.choose <| WeakDual.CharacterSpace.exists_apply_eq_zero (zero_mem_nonunits.mpr zero_ne_one)‚ü©

end ComplexBanachAlgebra

section ComplexCstarAlgebra

variable (A : Type _) [NormedCommRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A]

variable [StarRing A] [CstarRing A] [StarModule ‚ÑÇ A] [Nontrivial A]

/-- The Gelfand transform is an isometry when the algebra is a C‚ãÜ-algebra over `‚ÑÇ`. -/
theorem gelfand_transform_isometry : Isometry (gelfandTransform ‚ÑÇ A) := by
  refine' AddMonoidHomClass.isometry_of_norm (gelfand_transform ‚ÑÇ A) fun a => _
  have gt_map_star : gelfand_transform ‚ÑÇ A (star a) = star (gelfand_transform ‚ÑÇ A a) :=
    ContinuousMap.ext fun œÜ => map_star œÜ a
  /- By `spectrum.gelfand_transform_eq`, the spectra of `star a * a` and its
    `gelfand_transform` coincide. Therefore, so do their spectral radii, and since they are
    self-adjoint, so also do their norms. Applying the C‚ãÜ-property of the norm and taking square
    roots shows that the norm is preserved. -/
  have : spectralRadius ‚ÑÇ (gelfand_transform ‚ÑÇ A (star a * a)) = spectralRadius ‚ÑÇ (star a * a) := by
    unfold spectralRadius
    rw [Spectrum.gelfand_transform_eq]
  simp only [map_mul, gt_map_star, (IsSelfAdjoint.star_mul_self _).spectral_radius_eq_nnnorm, Ennreal.coe_eq_coe,
    CstarRing.nnnorm_star_mul_self, ‚Üê sq] at this
  simpa only [Function.comp_app, Nnreal.sqrt_sq] using congr_arg ((coe : ‚Ñù‚â•0 ‚Üí ‚Ñù) ‚àò ‚áëNnreal.sqrt) this

/-- The Gelfand transform is bijective when the algebra is a C‚ãÜ-algebra over `‚ÑÇ`. -/
theorem gelfand_transform_bijective : Function.Bijective (gelfandTransform ‚ÑÇ A) := by
  refine' ‚ü®(gelfand_transform_isometry A).Injective, _‚ü©
  suffices (gelfand_transform ‚ÑÇ A).range = ‚ä§ by
    exact fun x => this.symm ‚ñ∏ (gelfand_transform ‚ÑÇ A).mem_range.mp (this.symm ‚ñ∏ Algebra.mem_top)
  /- Because the `gelfand_transform ‚ÑÇ A` is an isometry, it has closed range, and so by the
    Stone-Weierstrass theorem, it suffices to show that the image of the Gelfand transform separates
    points in `C(character_space ‚ÑÇ A, ‚ÑÇ)` and is closed under `star`. -/
  have h : (gelfand_transform ‚ÑÇ A).range.topologicalClosure = (gelfand_transform ‚ÑÇ A).range :=
    le_antisymm‚Çì
      (Subalgebra.topological_closure_minimal _ le_rfl‚Çì (gelfand_transform_isometry A).ClosedEmbedding.closed_range)
      (Subalgebra.subalgebra_topological_closure _)
  refine'
    h ‚ñ∏ ContinuousMap.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points _ (fun _ _ => _) fun f hf => _
  /- Separating points just means that elements of the `character_space` which agree at all points
    of `A` are the same functional, which is just extensionality. -/
  ¬∑ contrapose!
    exact fun h =>
      Subtype.ext
        (ContinuousLinearMap.ext fun a => h (gelfand_transform ‚ÑÇ A a) ‚ü®gelfand_transform ‚ÑÇ A a, ‚ü®a, rfl‚ü©, rfl‚ü©)
    
  /- If `f = gelfand_transform ‚ÑÇ A a`, then `star f` is also in the range of `gelfand_transform ‚ÑÇ A`
    using the argument `star a`. The key lemma below may be hard to spot; it's `map_star` coming from
    `weak_dual.star_hom_class`, which is a nontrivial result. -/
  ¬∑ obtain ‚ü®f, ‚ü®a, rfl‚ü©, rfl‚ü© := subalgebra.mem_map.mp hf
    refine' ‚ü®star a, ContinuousMap.ext fun œà => _‚ü©
    simpa only [gelfand_transform_apply_apply, map_star, RingHom.coe_monoid_hom, AlgEquiv.coe_alg_hom,
      RingHom.to_monoid_hom_eq_coe, AlgEquiv.to_alg_hom_eq_coe, RingHom.to_fun_eq_coe, ContinuousMap.coe_mk,
      IsROrC.conj_ae_coe, AlgHom.coe_to_ring_hom, MonoidHom.to_fun_eq_coe, RingHom.comp_left_continuous_apply,
      MonoidHom.comp_left_continuous_apply, ContinuousMap.comp_apply, AlgHom.to_ring_hom_eq_coe,
      AlgHom.comp_left_continuous_apply]
    

end ComplexCstarAlgebra

