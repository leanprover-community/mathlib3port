/-
Copyright (c) 2021 SÃ©bastien GouÃ«zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel, YaÃ«l Dillies

! This file was ported from Lean 3 source module analysis.normed_space.pointwise
! leanprover-community/mathlib commit bc91ed7093bf098d253401e69df601fc33dde156
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Normed.Group.AddTorsor
import Mathbin.Analysis.Normed.Group.Pointwise
import Mathbin.Analysis.NormedSpace.Basic

/-!
# Properties of pointwise scalar multiplication of sets in normed spaces.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We explore the relationships between scalar multiplication of sets in vector spaces, and the norm.
Notably, we express arbitrary balls as rescaling of other balls, and we show that the
multiplication of bounded sets remain bounded.
-/


open Metric Set

open Pointwise Topology

variable {ğ•œ E : Type _}

section SMulZeroClass

variable [SeminormedAddCommGroup ğ•œ] [SeminormedAddCommGroup E]

variable [SMulZeroClass ğ•œ E] [BoundedSMul ğ•œ E]

/- warning: ediam_smul_le -> ediam_smul_le is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : SMulZeroClass.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2))))))] [_inst_4 : BoundedSMul.{u1, u2} ğ•œ E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} ğ•œ _inst_1) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (AddZeroClass.toHasZero.{u1} ğ•œ (AddMonoid.toAddZeroClass.{u1} ğ•œ (SubNegMonoid.toAddMonoid.{u1} ğ•œ (AddGroup.toSubNegMonoid.{u1} ğ•œ (SeminormedAddGroup.toAddGroup.{u1} ğ•œ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) _inst_3)] (c : ğ•œ) (s : Set.{u2} E), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EMetric.diam.{u2} E (PseudoMetricSpace.toPseudoEMetricSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) _inst_3)) c s)) (SMul.smul.{0, 0} NNReal ENNReal (SMulZeroClass.toHasSmul.{0, 0} NNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} NNReal ENNReal (MulZeroClass.toHasZero.{0} NNReal (MulZeroOneClass.toMulZeroClass.{0} NNReal (MonoidWithZero.toMulZeroOneClass.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} NNReal ENNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} NNReal ENNReal NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (ENNReal.module.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (NNNorm.nnnorm.{u1} ğ•œ (SeminormedAddGroup.toNNNorm.{u1} ğ•œ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ğ•œ _inst_1)) c) (EMetric.diam.{u2} E (PseudoMetricSpace.toPseudoEMetricSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedAddCommGroup.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : SMulZeroClass.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))))] [_inst_4 : BoundedSMul.{u1, u2} ğ•œ E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} ğ•œ _inst_1) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (NegZeroClass.toZero.{u1} ğ•œ (SubNegZeroMonoid.toNegZeroClass.{u1} ğ•œ (SubtractionMonoid.toSubNegZeroMonoid.{u1} ğ•œ (SubtractionCommMonoid.toSubtractionMonoid.{u1} ğ•œ (AddCommGroup.toDivisionAddCommMonoid.{u1} ğ•œ (SeminormedAddCommGroup.toAddCommGroup.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) _inst_3)] (c : ğ•œ) (s : Set.{u2} E), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EMetric.diam.{u2} E (PseudoMetricSpace.toPseudoEMetricSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) _inst_3))) c s)) (HSMul.hSMul.{0, 0, 0} NNReal ENNReal ENNReal (instHSMul.{0, 0} NNReal ENNReal (Algebra.toSMul.{0, 0} NNReal ENNReal instNNRealCommSemiring (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (ENNReal.instAlgebraNNRealInstNNRealCommSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (NNNorm.nnnorm.{u1} ğ•œ (SeminormedAddGroup.toNNNorm.{u1} ğ•œ (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ğ•œ _inst_1)) c) (EMetric.diam.{u2} E (PseudoMetricSpace.toPseudoEMetricSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2)) s))
Case conversion may be inaccurate. Consider using '#align ediam_smul_le ediam_smul_leâ‚“'. -/
theorem ediam_smul_le (c : ğ•œ) (s : Set E) : EMetric.diam (c â€¢ s) â‰¤ â€–câ€–â‚Š â€¢ EMetric.diam s :=
  (lipschitzWith_smul c).ediam_image_le s
#align ediam_smul_le ediam_smul_le

end SMulZeroClass

section DivisionRing

variable [NormedDivisionRing ğ•œ] [SeminormedAddCommGroup E]

variable [Module ğ•œ E] [BoundedSMul ğ•œ E]

/- warning: ediam_smulâ‚€ -> ediam_smulâ‚€ is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align ediam_smulâ‚€ ediam_smulâ‚€â‚“'. -/
theorem ediam_smulâ‚€ (c : ğ•œ) (s : Set E) : EMetric.diam (c â€¢ s) = â€–câ€–â‚Š â€¢ EMetric.diam s :=
  by
  refine' le_antisymm (ediam_smul_le c s) _
  obtain rfl | hc := eq_or_ne c 0
  Â· obtain rfl | hs := s.eq_empty_or_nonempty
    Â· simp
    simp [zero_smul_set hs, â† Set.singleton_zero]
  Â· have := (lipschitzWith_smul câ»Â¹).ediam_image_le (c â€¢ s)
    rwa [â† smul_eq_mul, â† ENNReal.smul_def, Set.image_smul, inv_smul_smulâ‚€ hc s, nnnorm_inv,
      ENNReal.le_inv_smul_iff (nnnorm_ne_zero_iff.mpr hc)] at this
#align ediam_smulâ‚€ ediam_smulâ‚€

/- warning: diam_smulâ‚€ -> diam_smulâ‚€ is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedDivisionRing.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))] [_inst_4 : BoundedSMul.{u1, u2} ğ•œ E (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (NormedRing.toSeminormedRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) _inst_3))))] (c : ğ•œ) (x : Set.{u2} E), Eq.{1} Real (Metric.diam.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) _inst_3))))) c x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} ğ•œ (NormedDivisionRing.toHasNorm.{u1} ğ•œ _inst_1) c) (Metric.diam.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) x))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedDivisionRing.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))] [_inst_4 : BoundedSMul.{u1, u2} ğ•œ E (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (NormedRing.toSeminormedRing.{u1} ğ•œ (NormedDivisionRing.toNormedRing.{u1} ğ•œ _inst_1))) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) _inst_3))))] (c : ğ•œ) (x : Set.{u2} E), Eq.{1} Real (Metric.diam.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ (NormedDivisionRing.toDivisionRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) _inst_3)))))) c x)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u1} ğ•œ (NormedDivisionRing.toNorm.{u1} ğ•œ _inst_1) c) (Metric.diam.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) x))
Case conversion may be inaccurate. Consider using '#align diam_smulâ‚€ diam_smulâ‚€â‚“'. -/
theorem diam_smulâ‚€ (c : ğ•œ) (x : Set E) : diam (c â€¢ x) = â€–câ€– * diam x := by
  simp_rw [diam, ediam_smulâ‚€, ENNReal.toReal_smul, NNReal.smul_def, coe_nnnorm, smul_eq_mul]
#align diam_smulâ‚€ diam_smulâ‚€

/- warning: inf_edist_smulâ‚€ -> infEdist_smulâ‚€ is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align inf_edist_smulâ‚€ infEdist_smulâ‚€â‚“'. -/
theorem infEdist_smulâ‚€ {c : ğ•œ} (hc : c â‰  0) (s : Set E) (x : E) :
    EMetric.infEdist (c â€¢ x) (c â€¢ s) = â€–câ€–â‚Š â€¢ EMetric.infEdist x s :=
  by
  simp_rw [EMetric.infEdist]
  have : Function.Surjective ((Â· â€¢ Â·) c : E â†’ E) :=
    Function.RightInverse.surjective (smul_inv_smulâ‚€ hc)
  trans â¨… (y) (H : y âˆˆ s), â€–câ€–â‚Š â€¢ edist x y
  Â· refine' (this.infi_congr _ fun y => _).symm
    simp_rw [smul_mem_smul_set_iffâ‚€ hc, edist_smulâ‚€]
  Â· have : (â€–câ€–â‚Š : ENNReal) â‰  0 := by simp [hc]
    simp_rw [ENNReal.smul_def, smul_eq_mul, ENNReal.mul_iInf_of_ne this ENNReal.coe_ne_top]
#align inf_edist_smulâ‚€ infEdist_smulâ‚€

/- warning: inf_dist_smulâ‚€ -> infDist_smulâ‚€ is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align inf_dist_smulâ‚€ infDist_smulâ‚€â‚“'. -/
theorem infDist_smulâ‚€ {c : ğ•œ} (hc : c â‰  0) (s : Set E) (x : E) :
    Metric.infDist (c â€¢ x) (c â€¢ s) = â€–câ€– * Metric.infDist x s := by
  simp_rw [Metric.infDist, infEdist_smulâ‚€ hc, ENNReal.toReal_smul, NNReal.smul_def, coe_nnnorm,
    smul_eq_mul]
#align inf_dist_smulâ‚€ infDist_smulâ‚€

end DivisionRing

variable [NormedField ğ•œ]

section SeminormedAddCommGroup

variable [SeminormedAddCommGroup E] [NormedSpace ğ•œ E]

/- warning: smul_ball -> smul_ball is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u1} ğ•œ c (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))))))) -> (forall (x : E) (r : Real), Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3)))))) c (Metric.ball.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) x r)) (Metric.ball.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) c) r)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : NormedField.{u2} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u2} ğ•œ c (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))))))) -> (forall (x : E) (r : Real), Eq.{succ u1} (Set.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3))))))) c (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x r)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3)))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} ğ•œ (NormedField.toNorm.{u2} ğ•œ _inst_1) c) r)))
Case conversion may be inaccurate. Consider using '#align smul_ball smul_ballâ‚“'. -/
theorem smul_ball {c : ğ•œ} (hc : c â‰  0) (x : E) (r : â„) : c â€¢ ball x r = ball (c â€¢ x) (â€–câ€– * r) :=
  by
  ext y
  rw [mem_smul_set_iff_inv_smul_memâ‚€ hc]
  conv_lhs => rw [â† inv_smul_smulâ‚€ hc x]
  simp [â† div_eq_inv_mul, div_lt_iff (norm_pos_iff.2 hc), mul_comm _ r, dist_smulâ‚€]
#align smul_ball smul_ball

/- warning: smul_unit_ball -> smul_unitBall is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u1} ğ•œ c (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))))))) -> (Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3)))))) c (Metric.ball.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Metric.ball.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (SeminormedAddGroup.toAddGroup.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E _inst_2))))))))) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) c)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : NormedField.{u2} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u2} ğ•œ c (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))))))) -> (Eq.{succ u1} (Set.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3))))))) c (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) (Norm.norm.{u2} ğ•œ (NormedField.toNorm.{u2} ğ•œ _inst_1) c)))
Case conversion may be inaccurate. Consider using '#align smul_unit_ball smul_unitBallâ‚“'. -/
theorem smul_unitBall {c : ğ•œ} (hc : c â‰  0) : c â€¢ ball (0 : E) (1 : â„) = ball (0 : E) â€–câ€– := by
  rw [smul_ball hc, smul_zero, mul_one]
#align smul_unit_ball smul_unitBall

/- warning: smul_sphere' -> smul_sphere' is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u1} ğ•œ c (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))))))) -> (forall (x : E) (r : Real), Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3)))))) c (Metric.sphere.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) x r)) (Metric.sphere.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) c) r)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : NormedField.{u2} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u2} ğ•œ c (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))))))) -> (forall (x : E) (r : Real), Eq.{succ u1} (Set.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3))))))) c (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x r)) (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3)))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} ğ•œ (NormedField.toNorm.{u2} ğ•œ _inst_1) c) r)))
Case conversion may be inaccurate. Consider using '#align smul_sphere' smul_sphere'â‚“'. -/
theorem smul_sphere' {c : ğ•œ} (hc : c â‰  0) (x : E) (r : â„) :
    c â€¢ sphere x r = sphere (c â€¢ x) (â€–câ€– * r) :=
  by
  ext y
  rw [mem_smul_set_iff_inv_smul_memâ‚€ hc]
  conv_lhs => rw [â† inv_smul_smulâ‚€ hc x]
  simp only [mem_sphere, dist_smulâ‚€, norm_inv, â† div_eq_inv_mul, div_eq_iff (norm_pos_iff.2 hc).ne',
    mul_comm r]
#align smul_sphere' smul_sphere'

/- warning: smul_closed_ball' -> smul_closedBall' is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u1} ğ•œ c (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))))))) -> (forall (x : E) (r : Real), Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3)))))) c (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) x r)) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E _inst_2) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) c) r)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : NormedField.{u2} ğ•œ] [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_3 : NormedSpace.{u2, u1} ğ•œ E _inst_1 _inst_2] {c : ğ•œ}, (Ne.{succ u2} ğ•œ c (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))))))) -> (forall (x : E) (r : Real), Eq.{succ u1} (Set.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3))))))) c (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x r)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (Field.toSemifield.{u2} ğ•œ (NormedField.toField.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3)))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u2} ğ•œ (NormedField.toNorm.{u2} ğ•œ _inst_1) c) r)))
Case conversion may be inaccurate. Consider using '#align smul_closed_ball' smul_closedBall'â‚“'. -/
theorem smul_closedBall' {c : ğ•œ} (hc : c â‰  0) (x : E) (r : â„) :
    c â€¢ closedBall x r = closedBall (c â€¢ x) (â€–câ€– * r) := by
  simp only [â† ball_union_sphere, Set.smul_set_union, smul_ball hc, smul_sphere' hc]
#align smul_closed_ball' smul_closedBall'

#print Metric.Bounded.smul /-
theorem Metric.Bounded.smul {s : Set E} (hs : Bounded s) (c : ğ•œ) : Bounded (c â€¢ s) :=
  by
  obtain âŸ¨R, hRâŸ© : âˆƒ R : â„, âˆ€ x âˆˆ s, â€–xâ€– â‰¤ R := hs.exists_norm_le
  refine' bounded_iff_forall_norm_le.2 âŸ¨â€–câ€– * R, fun z hz => _âŸ©
  obtain âŸ¨y, ys, rflâŸ© : âˆƒ y : E, y âˆˆ s âˆ§ c â€¢ y = z := mem_smul_set.1 hz
  calc
    â€–c â€¢ yâ€– = â€–câ€– * â€–yâ€– := norm_smul _ _
    _ â‰¤ â€–câ€– * R := mul_le_mul_of_nonneg_left (hR y ys) (norm_nonneg _)
    
#align metric.bounded.smul Metric.Bounded.smul
-/

/- warning: eventually_singleton_add_smul_subset -> eventually_singleton_add_smul_subset is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align eventually_singleton_add_smul_subset eventually_singleton_add_smul_subsetâ‚“'. -/
/-- If `s` is a bounded set, then for small enough `r`, the set `{x} + r â€¢ s` is contained in any
fixed neighborhood of `x`. -/
theorem eventually_singleton_add_smul_subset {x : E} {s : Set E} (hs : Bounded s) {u : Set E}
    (hu : u âˆˆ ğ“ x) : âˆ€á¶  r in ğ“ (0 : ğ•œ), {x} + r â€¢ s âŠ† u :=
  by
  obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ (Îµ : _)(hÎµ : 0 < Îµ), closed_ball x Îµ âŠ† u :=
    nhds_basis_closed_ball.mem_iff.1 hu
  obtain âŸ¨R, Rpos, hRâŸ© : âˆƒ R : â„, 0 < R âˆ§ s âŠ† closed_ball 0 R := hs.subset_ball_lt 0 0
  have : Metric.closedBall (0 : ğ•œ) (Îµ / R) âˆˆ ğ“ (0 : ğ•œ) := closed_ball_mem_nhds _ (div_pos Îµpos Rpos)
  filter_upwards [this]with r hr
  simp only [image_add_left, singleton_add]
  intro y hy
  obtain âŸ¨z, zs, hzâŸ© : âˆƒ z : E, z âˆˆ s âˆ§ r â€¢ z = -x + y := by simpa [mem_smul_set] using hy
  have I : â€–r â€¢ zâ€– â‰¤ Îµ :=
    calc
      â€–r â€¢ zâ€– = â€–râ€– * â€–zâ€– := norm_smul _ _
      _ â‰¤ Îµ / R * R :=
        (mul_le_mul (mem_closedBall_zero_iff.1 hr) (mem_closedBall_zero_iff.1 (hR zs))
          (norm_nonneg _) (div_pos Îµpos Rpos).le)
      _ = Îµ := by field_simp [Rpos.ne']
      
  have : y = x + r â€¢ z := by simp only [hz, add_neg_cancel_left]
  apply hÎµ
  simpa only [this, dist_eq_norm, add_sub_cancel', mem_closed_ball] using I
#align eventually_singleton_add_smul_subset eventually_singleton_add_smul_subset

variable [NormedSpace â„ E] {x y z : E} {Î´ Îµ : â„}

/- warning: smul_unit_ball_of_pos -> smul_unitBall_of_pos is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {r : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (Eq.{succ u1} (Set.{u1} E) (SMul.smul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField _inst_2 _inst_4)))))) r (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))))) r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {r : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (Eq.{succ u1} (Set.{u1} E) (HSMul.hSMul.{0, u1, u1} Real (Set.{u1} E) (Set.{u1} E) (instHSMul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField _inst_2 _inst_4))))))) r (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) r))
Case conversion may be inaccurate. Consider using '#align smul_unit_ball_of_pos smul_unitBall_of_posâ‚“'. -/
/-- In a real normed space, the image of the unit ball under scalar multiplication by a positive
constant `r` is the ball of radius `r`. -/
theorem smul_unitBall_of_pos {r : â„} (hr : 0 < r) : r â€¢ ball 0 1 = ball (0 : E) r := by
  rw [smul_unitBall hr.ne', Real.norm_of_nonneg hr.le]
#align smul_unit_ball_of_pos smul_unitBall_of_pos

/- warning: exists_dist_eq -> exists_dist_eq is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] (x : E) (z : E) {a : Real} {b : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) a) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) b) -> (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) a b) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Exists.{succ u1} E (fun (y : E) => And (Eq.{1} Real (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) b (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z))) (Eq.{1} Real (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) a (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z)))))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] (x : E) (z : E) {a : Real} {b : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) a) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) b) -> (Eq.{1} Real (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) a b) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Exists.{succ u1} E (fun (y : E) => And (Eq.{1} Real (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) b (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z))) (Eq.{1} Real (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) a (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z)))))
Case conversion may be inaccurate. Consider using '#align exists_dist_eq exists_dist_eqâ‚“'. -/
-- This is also true for `â„š`-normed spaces
theorem exists_dist_eq (x z : E) {a b : â„} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
    âˆƒ y, dist x y = b * dist x z âˆ§ dist y z = a * dist x z :=
  by
  use a â€¢ x + b â€¢ z
  nth_rw 1 [â† one_smul â„ x]
  nth_rw 4 [â† one_smul â„ z]
  simp [dist_eq_norm, â† hab, add_smul, â† smul_sub, norm_smul_of_nonneg, ha, hb]
#align exists_dist_eq exists_dist_eq

/- warning: exists_dist_le_le -> exists_dist_le_le is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LE.le.{0} Real Real.hasLe (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LE.le.{0} Real Real.hasLe (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
Case conversion may be inaccurate. Consider using '#align exists_dist_le_le exists_dist_le_leâ‚“'. -/
theorem exists_dist_le_le (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 â‰¤ Îµ) (h : dist x z â‰¤ Îµ + Î´) :
    âˆƒ y, dist x y â‰¤ Î´ âˆ§ dist y z â‰¤ Îµ :=
  by
  obtain rfl | hÎµ' := hÎµ.eq_or_lt
  Â· exact âŸ¨z, by rwa [zero_add] at h, (dist_self _).leâŸ©
  have hÎµÎ´ := add_pos_of_pos_of_nonneg hÎµ' hÎ´
  refine'
    (exists_dist_eq x z (div_nonneg hÎµ <| add_nonneg hÎµ hÎ´) (div_nonneg hÎ´ <| add_nonneg hÎµ hÎ´) <|
          by rw [â† add_div, div_self hÎµÎ´.ne']).imp
      fun y hy => _
  rw [hy.1, hy.2, div_mul_comm, div_mul_comm Îµ]
  rw [â† div_le_one hÎµÎ´] at h
  exact âŸ¨mul_le_of_le_one_left hÎ´ h, mul_le_of_le_one_left hÎµ hâŸ©
#align exists_dist_le_le exists_dist_le_le

/- warning: exists_dist_le_lt -> exists_dist_le_lt is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LE.le.{0} Real Real.hasLe (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
Case conversion may be inaccurate. Consider using '#align exists_dist_le_lt exists_dist_le_ltâ‚“'. -/
-- This is also true for `â„š`-normed spaces
theorem exists_dist_le_lt (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 < Îµ) (h : dist x z < Îµ + Î´) :
    âˆƒ y, dist x y â‰¤ Î´ âˆ§ dist y z < Îµ :=
  by
  refine'
    (exists_dist_eq x z (div_nonneg hÎµ.le <| add_nonneg hÎµ.le hÎ´)
            (div_nonneg hÎ´ <| add_nonneg hÎµ.le hÎ´) <|
          by rw [â† add_div, div_self (add_pos_of_pos_of_nonneg hÎµ hÎ´).ne']).imp
      fun y hy => _
  rw [hy.1, hy.2, div_mul_comm, div_mul_comm Îµ]
  rw [â† div_lt_one (add_pos_of_pos_of_nonneg hÎµ hÎ´)] at h
  exact âŸ¨mul_le_of_le_one_left hÎ´ h.le, mul_lt_of_lt_one_left hÎµ hâŸ©
#align exists_dist_le_lt exists_dist_le_lt

/- warning: exists_dist_lt_le -> exists_dist_lt_le is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LE.le.{0} Real Real.hasLe (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
Case conversion may be inaccurate. Consider using '#align exists_dist_lt_le exists_dist_lt_leâ‚“'. -/
-- This is also true for `â„š`-normed spaces
theorem exists_dist_lt_le (hÎ´ : 0 < Î´) (hÎµ : 0 â‰¤ Îµ) (h : dist x z < Îµ + Î´) :
    âˆƒ y, dist x y < Î´ âˆ§ dist y z â‰¤ Îµ :=
  by
  obtain âŸ¨y, yz, xyâŸ© :=
    exists_dist_le_lt hÎµ hÎ´ (show dist z x < Î´ + Îµ by simpa only [dist_comm, add_comm] using h)
  exact âŸ¨y, by simp [dist_comm x y, dist_comm y z, *]âŸ©
#align exists_dist_lt_le exists_dist_lt_le

/- warning: exists_dist_lt_lt -> exists_dist_lt_lt is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {z : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)) -> (Exists.{succ u1} E (fun (y : E) => And (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y) Î´) (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) y z) Îµ)))
Case conversion may be inaccurate. Consider using '#align exists_dist_lt_lt exists_dist_lt_ltâ‚“'. -/
-- This is also true for `â„š`-normed spaces
theorem exists_dist_lt_lt (hÎ´ : 0 < Î´) (hÎµ : 0 < Îµ) (h : dist x z < Îµ + Î´) :
    âˆƒ y, dist x y < Î´ âˆ§ dist y z < Îµ :=
  by
  refine'
    (exists_dist_eq x z (div_nonneg hÎµ.le <| add_nonneg hÎµ.le hÎ´.le)
            (div_nonneg hÎ´.le <| add_nonneg hÎµ.le hÎ´.le) <|
          by rw [â† add_div, div_self (add_pos hÎµ hÎ´).ne']).imp
      fun y hy => _
  rw [hy.1, hy.2, div_mul_comm, div_mul_comm Îµ]
  rw [â† div_lt_one (add_pos hÎµ hÎ´)] at h
  exact âŸ¨mul_lt_of_lt_one_left hÎ´ h, mul_lt_of_lt_one_left hÎµ hâŸ©
#align exists_dist_lt_lt exists_dist_lt_lt

/- warning: disjoint_ball_ball_iff -> disjoint_ball_ball_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} E) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} E) (Set.booleanAlgebra.{u1} E))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} E) (Preorder.toLE.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
Case conversion may be inaccurate. Consider using '#align disjoint_ball_ball_iff disjoint_ball_ball_iffâ‚“'. -/
-- This is also true for `â„š`-normed spaces
theorem disjoint_ball_ball_iff (hÎ´ : 0 < Î´) (hÎµ : 0 < Îµ) :
    Disjoint (ball x Î´) (ball y Îµ) â†” Î´ + Îµ â‰¤ dist x y :=
  by
  refine' âŸ¨fun h => le_of_not_lt fun hxy => _, ball_disjoint_ballâŸ©
  rw [add_comm] at hxy
  obtain âŸ¨z, hxz, hzyâŸ© := exists_dist_lt_lt hÎ´ hÎµ hxy
  rw [dist_comm] at hxz
  exact h.le_bot âŸ¨hxz, hzyâŸ©
#align disjoint_ball_ball_iff disjoint_ball_ball_iff

/- warning: disjoint_ball_closed_ball_iff -> disjoint_ball_closedBall_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} E) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} E) (Set.booleanAlgebra.{u1} E))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} E) (Preorder.toLE.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
Case conversion may be inaccurate. Consider using '#align disjoint_ball_closed_ball_iff disjoint_ball_closedBall_iffâ‚“'. -/
-- This is also true for `â„š`-normed spaces
theorem disjoint_ball_closedBall_iff (hÎ´ : 0 < Î´) (hÎµ : 0 â‰¤ Îµ) :
    Disjoint (ball x Î´) (closedBall y Îµ) â†” Î´ + Îµ â‰¤ dist x y :=
  by
  refine' âŸ¨fun h => le_of_not_lt fun hxy => _, ball_disjoint_closed_ballâŸ©
  rw [add_comm] at hxy
  obtain âŸ¨z, hxz, hzyâŸ© := exists_dist_lt_le hÎ´ hÎµ hxy
  rw [dist_comm] at hxz
  exact h.le_bot âŸ¨hxz, hzyâŸ©
#align disjoint_ball_closed_ball_iff disjoint_ball_closedBall_iff

/- warning: disjoint_closed_ball_ball_iff -> disjoint_closedBall_ball_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} E) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} E) (Set.booleanAlgebra.{u1} E))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} E) (Preorder.toLE.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
Case conversion may be inaccurate. Consider using '#align disjoint_closed_ball_ball_iff disjoint_closedBall_ball_iffâ‚“'. -/
-- This is also true for `â„š`-normed spaces
theorem disjoint_closedBall_ball_iff (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 < Îµ) :
    Disjoint (closedBall x Î´) (ball y Îµ) â†” Î´ + Îµ â‰¤ dist x y := by
  rw [disjoint_comm, disjoint_ball_closedBall_iff hÎµ hÎ´, add_comm, dist_comm] <;> infer_instance
#align disjoint_closed_ball_ball_iff disjoint_closedBall_ball_iff

/- warning: disjoint_closed_ball_closed_ball_iff -> disjoint_closedBall_closedBall_iff is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} E) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} E) (Set.booleanAlgebra.{u1} E))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LT.lt.{0} Real Real.hasLt (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toHasDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {x : E} {y : E} {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (Iff (Disjoint.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} E) (Preorder.toLE.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E)))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) y Îµ)) (LT.lt.{0} Real Real.instLTReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Î´ Îµ) (Dist.dist.{u1} E (PseudoMetricSpace.toDist.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x y)))
Case conversion may be inaccurate. Consider using '#align disjoint_closed_ball_closed_ball_iff disjoint_closedBall_closedBall_iffâ‚“'. -/
theorem disjoint_closedBall_closedBall_iff (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 â‰¤ Îµ) :
    Disjoint (closedBall x Î´) (closedBall y Îµ) â†” Î´ + Îµ < dist x y :=
  by
  refine' âŸ¨fun h => lt_of_not_ge fun hxy => _, closed_ball_disjoint_closed_ballâŸ©
  rw [add_comm] at hxy
  obtain âŸ¨z, hxz, hzyâŸ© := exists_dist_le_le hÎ´ hÎµ hxy
  rw [dist_comm] at hxz
  exact h.le_bot âŸ¨hxz, hzyâŸ©
#align disjoint_closed_ball_closed_ball_iff disjoint_closedBall_closedBall_iff

open Emetric ENNReal

/- warning: inf_edist_thickening -> infEdist_thickening is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (s : Set.{u1} E) (x : E), Eq.{1} ENNReal (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x s) (ENNReal.ofReal Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (s : Set.{u1} E) (x : E), Eq.{1} ENNReal (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSub) (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x s) (ENNReal.ofReal Î´)))
Case conversion may be inaccurate. Consider using '#align inf_edist_thickening infEdist_thickeningâ‚“'. -/
@[simp]
theorem infEdist_thickening (hÎ´ : 0 < Î´) (s : Set E) (x : E) :
    infEdist x (thickening Î´ s) = infEdist x s - ENNReal.ofReal Î´ :=
  by
  obtain hs | hs := lt_or_le (inf_edist x s) (ENNReal.ofReal Î´)
  Â· rw [inf_edist_zero_of_mem, tsub_eq_zero_of_le hs.le]; exact hs
  refine' (tsub_le_iff_right.2 inf_edist_le_inf_edist_thickening_add).antisymm' _
  refine' le_sub_of_add_le_right of_real_ne_top _
  refine' le_inf_edist.2 fun z hz => le_of_forall_lt' fun r h => _
  cases r
  Â·
    exact
      add_lt_top.2
        âŸ¨lt_top_iff_ne_top.2 <| inf_edist_ne_top âŸ¨z, self_subset_thickening hÎ´ _ hzâŸ©,
          of_real_lt_topâŸ©
  have hr : 0 < â†‘r - Î´ := by
    refine' sub_pos_of_lt _
    have := hs.trans_lt ((inf_edist_le_edist_of_mem hz).trans_lt h)
    rw [of_real_eq_coe_nnreal hÎ´.le, some_eq_coe] at this
    exact_mod_cast this
  rw [some_eq_coe, edist_lt_coe, â† dist_lt_coe, â† add_sub_cancel'_right Î´ â†‘r] at h
  obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hr hÎ´ h
  refine'
    (ENNReal.add_lt_add_right of_real_ne_top <|
          inf_edist_lt_iff.2 âŸ¨_, mem_thickening_iff.2 âŸ¨_, hz, hyzâŸ©, edist_lt_ofReal.2 hxyâŸ©).trans_le
      _
  rw [â† of_real_add hr.le hÎ´.le, sub_add_cancel, of_real_coe_nnreal]
  exact le_rfl
#align inf_edist_thickening infEdist_thickening

/- warning: thickening_thickening -> thickening_thickening is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´) s))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´) s))
Case conversion may be inaccurate. Consider using '#align thickening_thickening thickening_thickeningâ‚“'. -/
@[simp]
theorem thickening_thickening (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (s : Set E) :
    thickening Îµ (thickening Î´ s) = thickening (Îµ + Î´) s :=
  (thickening_thickening_subset _ _ _).antisymm fun x =>
    by
    simp_rw [mem_thickening_iff]
    rintro âŸ¨z, hz, hxzâŸ©
    rw [add_comm] at hxz
    obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hÎµ hÎ´ hxz
    exact âŸ¨y, âŸ¨_, hz, hyzâŸ©, hxyâŸ©
#align thickening_thickening thickening_thickening

/- warning: cthickening_thickening -> cthickening_thickening is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´) s))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´) s))
Case conversion may be inaccurate. Consider using '#align cthickening_thickening cthickening_thickeningâ‚“'. -/
@[simp]
theorem cthickening_thickening (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (s : Set E) :
    cthickening Îµ (thickening Î´ s) = cthickening (Îµ + Î´) s :=
  (cthickening_thickening_subset hÎµ _ _).antisymm fun x =>
    by
    simp_rw [mem_cthickening_iff, ENNReal.ofReal_add hÎµ hÎ´.le, infEdist_thickening hÎ´]
    exact tsub_le_iff_right.2
#align cthickening_thickening cthickening_thickening

/- warning: closure_thickening -> closure_thickening is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (closure.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2))) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (closure.{u1} E (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2))) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s))
Case conversion may be inaccurate. Consider using '#align closure_thickening closure_thickeningâ‚“'. -/
-- Note: `interior (cthickening Î´ s) â‰  thickening Î´ s` in general
@[simp]
theorem closure_thickening (hÎ´ : 0 < Î´) (s : Set E) : closure (thickening Î´ s) = cthickening Î´ s :=
  by rw [â† cthickening_zero, cthickening_thickening le_rfl hÎ´, zero_add]; infer_instance
#align closure_thickening closure_thickening

/- warning: inf_edist_cthickening -> infEdist_cthickening is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] (Î´ : Real) (s : Set.{u1} E) (x : E), Eq.{1} ENNReal (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x s) (ENNReal.ofReal Î´))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] (Î´ : Real) (s : Set.{u1} E) (x : E), Eq.{1} ENNReal (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSub) (EMetric.infEdist.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) x s) (ENNReal.ofReal Î´))
Case conversion may be inaccurate. Consider using '#align inf_edist_cthickening infEdist_cthickeningâ‚“'. -/
@[simp]
theorem infEdist_cthickening (Î´ : â„) (s : Set E) (x : E) :
    infEdist x (cthickening Î´ s) = infEdist x s - ENNReal.ofReal Î´ :=
  by
  obtain hÎ´ | hÎ´ := le_or_lt Î´ 0
  Â· rw [cthickening_of_nonpos hÎ´, inf_edist_closure, of_real_of_nonpos hÎ´, tsub_zero]
  Â· rw [â† closure_thickening hÎ´, inf_edist_closure, infEdist_thickening hÎ´] <;> infer_instance
#align inf_edist_cthickening infEdist_cthickening

/- warning: thickening_cthickening -> thickening_cthickening is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´) s))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´) s))
Case conversion may be inaccurate. Consider using '#align thickening_cthickening thickening_cthickeningâ‚“'. -/
@[simp]
theorem thickening_cthickening (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (s : Set E) :
    thickening Îµ (cthickening Î´ s) = thickening (Îµ + Î´) s :=
  by
  obtain rfl | hÎ´ := hÎ´.eq_or_lt
  Â· rw [cthickening_zero, thickening_closure, add_zero]
  Â· rw [â† closure_thickening hÎ´, thickening_closure, thickening_thickening hÎµ hÎ´] <;> infer_instance
#align thickening_cthickening thickening_cthickening

/- warning: cthickening_cthickening -> cthickening_cthickening is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´) s))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (s : Set.{u1} E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Î´ s)) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´) s))
Case conversion may be inaccurate. Consider using '#align cthickening_cthickening cthickening_cthickeningâ‚“'. -/
@[simp]
theorem cthickening_cthickening (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (s : Set E) :
    cthickening Îµ (cthickening Î´ s) = cthickening (Îµ + Î´) s :=
  (cthickening_cthickening_subset hÎµ hÎ´ _).antisymm fun x =>
    by
    simp_rw [mem_cthickening_iff, ENNReal.ofReal_add hÎµ hÎ´, infEdist_cthickening]
    exact tsub_le_iff_right.2
#align cthickening_cthickening cthickening_cthickening

/- warning: thickening_ball -> thickening_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align thickening_ball thickening_ballâ‚“'. -/
@[simp]
theorem thickening_ball (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (x : E) :
    thickening Îµ (ball x Î´) = ball x (Îµ + Î´) := by
  rw [â† thickening_singleton, thickening_thickening hÎµ hÎ´, thickening_singleton] <;> infer_instance
#align thickening_ball thickening_ball

/- warning: thickening_closed_ball -> thickening_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.thickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align thickening_closed_ball thickening_closedBallâ‚“'. -/
@[simp]
theorem thickening_closedBall (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (x : E) :
    thickening Îµ (closedBall x Î´) = ball x (Îµ + Î´) := by
  rw [â† cthickening_singleton _ hÎ´, thickening_cthickening hÎµ hÎ´, thickening_singleton] <;>
    infer_instance
#align thickening_closed_ball thickening_closedBall

/- warning: cthickening_ball -> cthickening_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align cthickening_ball cthickening_ballâ‚“'. -/
@[simp]
theorem cthickening_ball (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (x : E) :
    cthickening Îµ (ball x Î´) = closedBall x (Îµ + Î´) := by
  rw [â† thickening_singleton, cthickening_thickening hÎµ hÎ´,
      cthickening_singleton _ (add_nonneg hÎµ hÎ´.le)] <;>
    infer_instance
#align cthickening_ball cthickening_ball

/- warning: cthickening_closed_ball -> cthickening_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (Metric.cthickening.{u1} E (PseudoMetricSpace.toPseudoEMetricSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)) Îµ (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) x (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align cthickening_closed_ball cthickening_closedBallâ‚“'. -/
@[simp]
theorem cthickening_closedBall (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (x : E) :
    cthickening Îµ (closedBall x Î´) = closedBall x (Îµ + Î´) := by
  rw [â† cthickening_singleton _ hÎ´, cthickening_cthickening hÎµ hÎ´,
      cthickening_singleton _ (add_nonneg hÎµ hÎ´)] <;>
    infer_instance
#align cthickening_closed_ball cthickening_closedBall

/- warning: ball_add_ball -> ball_add_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align ball_add_ball ball_add_ballâ‚“'. -/
theorem ball_add_ball (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (a b : E) :
    ball a Îµ + ball b Î´ = ball (a + b) (Îµ + Î´) := by
  rw [ball_add, thickening_ball hÎµ hÎ´ b, Metric.vadd_ball, vadd_eq_add]
#align ball_add_ball ball_add_ball

/- warning: ball_sub_ball -> ball_sub_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align ball_sub_ball ball_sub_ballâ‚“'. -/
theorem ball_sub_ball (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (a b : E) :
    ball a Îµ - ball b Î´ = ball (a - b) (Îµ + Î´) := by
  simp_rw [sub_eq_add_neg, neg_ball, ball_add_ball hÎµ hÎ´]
#align ball_sub_ball ball_sub_ball

/- warning: ball_add_closed_ball -> ball_add_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align ball_add_closed_ball ball_add_closedBallâ‚“'. -/
theorem ball_add_closedBall (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :
    ball a Îµ + closedBall b Î´ = ball (a + b) (Îµ + Î´) := by
  rw [ball_add, thickening_closedBall hÎµ hÎ´ b, Metric.vadd_ball, vadd_eq_add]
#align ball_add_closed_ball ball_add_closedBall

/- warning: ball_sub_closed_ball -> ball_sub_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align ball_sub_closed_ball ball_sub_closedBallâ‚“'. -/
theorem ball_sub_closedBall (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :
    ball a Îµ - closedBall b Î´ = ball (a - b) (Îµ + Î´) := by
  simp_rw [sub_eq_add_neg, neg_closedBall, ball_add_closedBall hÎµ hÎ´]
#align ball_sub_closed_ball ball_sub_closedBall

/- warning: closed_ball_add_ball -> closedBall_add_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align closed_ball_add_ball closedBall_add_ballâ‚“'. -/
theorem closedBall_add_ball (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (a b : E) :
    closedBall a Îµ + ball b Î´ = ball (a + b) (Îµ + Î´) := by
  rw [add_comm, ball_add_closedBall hÎ´ hÎµ b, add_comm, add_comm Î´]
#align closed_ball_add_ball closedBall_add_ball

/- warning: closed_ball_sub_ball -> closedBall_sub_ball is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align closed_ball_sub_ball closedBall_sub_ballâ‚“'. -/
theorem closedBall_sub_ball (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (a b : E) :
    closedBall a Îµ - ball b Î´ = ball (a - b) (Îµ + Î´) := by
  simp_rw [sub_eq_add_neg, neg_ball, closedBall_add_ball hÎµ hÎ´]
#align closed_ball_sub_ball closedBall_sub_ball

/- warning: closed_ball_add_closed_ball -> closedBall_add_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real} [_inst_5 : ProperSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)], (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real} [_inst_5 : ProperSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)], (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align closed_ball_add_closed_ball closedBall_add_closedBallâ‚“'. -/
theorem closedBall_add_closedBall [ProperSpace E] (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :
    closedBall a Îµ + closedBall b Î´ = closedBall (a + b) (Îµ + Î´) := by
  rw [(is_compact_closed_ball _ _).add_closedBall hÎ´ b, cthickening_closedBall hÎ´ hÎµ a,
    Metric.vadd_closedBall, vadd_eq_add, add_comm, add_comm Î´]
#align closed_ball_add_closed_ball closedBall_add_closedBall

/- warning: closed_ball_sub_closed_ball -> closedBall_sub_closedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real} [_inst_5 : ProperSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)], (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toHasSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) Îµ Î´)))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : SeminormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField _inst_2] {Î´ : Real} {Îµ : Real} [_inst_5 : ProperSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2)], (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Î´) -> (forall (a : E) (b : E), Eq.{succ u1} (Set.{u1} E) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2)))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) a Îµ) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) b Î´)) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E _inst_2) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (SeminormedAddGroup.toAddGroup.{u1} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} E _inst_2))))) a b) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) Îµ Î´)))
Case conversion may be inaccurate. Consider using '#align closed_ball_sub_closed_ball closedBall_sub_closedBallâ‚“'. -/
theorem closedBall_sub_closedBall [ProperSpace E] (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :
    closedBall a Îµ - closedBall b Î´ = closedBall (a - b) (Îµ + Î´) := by
  simp_rw [sub_eq_add_neg, neg_closedBall, closedBall_add_closedBall hÎµ hÎ´]
#align closed_ball_sub_closed_ball closedBall_sub_closedBall

end SeminormedAddCommGroup

section NormedAddCommGroup

variable [NormedAddCommGroup E] [NormedSpace ğ•œ E]

/- warning: smul_closed_ball -> smul_closedBall is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] (c : ğ•œ) (x : E) {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)))))) c (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) x r)) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) c) r)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] (c : ğ•œ) (x : E) {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (Eq.{succ u2} (Set.{u2} E) (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))))) c (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) x r)) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u1} ğ•œ (NormedField.toNorm.{u1} ğ•œ _inst_1) c) r)))
Case conversion may be inaccurate. Consider using '#align smul_closed_ball smul_closedBallâ‚“'. -/
theorem smul_closedBall (c : ğ•œ) (x : E) {r : â„} (hr : 0 â‰¤ r) :
    c â€¢ closedBall x r = closedBall (c â€¢ x) (â€–câ€– * r) :=
  by
  rcases eq_or_ne c 0 with (rfl | hc)
  Â· simp [hr, zero_smul_set, Set.singleton_zero, â† nonempty_closed_ball]
  Â· exact smul_closedBall' hc x r
#align smul_closed_ball smul_closedBall

/- warning: smul_closed_unit_ball -> smul_closedUnitBall is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] (c : ğ•œ), Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)))))) c (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (NormedAddGroup.toAddGroup.{u2} E (NormedAddCommGroup.toNormedAddGroup.{u2} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (NormedAddGroup.toAddGroup.{u2} E (NormedAddCommGroup.toNormedAddGroup.{u2} E _inst_2))))))))) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) c))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] (c : ğ•œ), Eq.{succ u2} (Set.{u2} E) (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))))) c (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Metric.closedBall.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))))) (Norm.norm.{u1} ğ•œ (NormedField.toNorm.{u1} ğ•œ _inst_1) c))
Case conversion may be inaccurate. Consider using '#align smul_closed_unit_ball smul_closedUnitBallâ‚“'. -/
theorem smul_closedUnitBall (c : ğ•œ) : c â€¢ closedBall (0 : E) (1 : â„) = closedBall (0 : E) â€–câ€– := by
  rw [smul_closedBall _ _ zero_le_one, smul_zero, mul_one]
#align smul_closed_unit_ball smul_closedUnitBall

variable [NormedSpace â„ E]

/- warning: smul_closed_unit_ball_of_nonneg -> smul_closedUnitBall_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (Eq.{succ u1} (Set.{u1} E) (SMul.smul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) r (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))))) r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (Eq.{succ u1} (Set.{u1} E) (HSMul.hSMul.{0, u1, u1} Real (Set.{u1} E) (Set.{u1} E) (instHSMul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))))) r (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) r))
Case conversion may be inaccurate. Consider using '#align smul_closed_unit_ball_of_nonneg smul_closedUnitBall_of_nonnegâ‚“'. -/
/-- In a real normed space, the image of the unit closed ball under multiplication by a nonnegative
number `r` is the closed ball of radius `r` with center at the origin. -/
theorem smul_closedUnitBall_of_nonneg {r : â„} (hr : 0 â‰¤ r) :
    r â€¢ closedBall 0 1 = closedBall (0 : E) r := by rw [smul_closedUnitBall, Real.norm_of_nonneg hr]
#align smul_closed_unit_ball_of_nonneg smul_closedUnitBall_of_nonneg

/- warning: normed_space.sphere_nonempty -> NormedSpace.sphere_nonempty is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : Nontrivial.{u1} E] {x : E} {r : Real}, Iff (Set.Nonempty.{u1} E (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) x r)) (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] [_inst_5 : Nontrivial.{u1} E] {x : E} {r : Real}, Iff (Set.Nonempty.{u1} E (Metric.sphere.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) x r)) (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r)
Case conversion may be inaccurate. Consider using '#align normed_space.sphere_nonempty NormedSpace.sphere_nonemptyâ‚“'. -/
/-- In a nontrivial real normed space, a sphere is nonempty if and only if its radius is
nonnegative. -/
@[simp]
theorem NormedSpace.sphere_nonempty [Nontrivial E] {x : E} {r : â„} :
    (sphere x r).Nonempty â†” 0 â‰¤ r :=
  by
  obtain âŸ¨y, hyâŸ© := exists_ne x
  refine'
    âŸ¨fun h => nonempty_closed_ball.1 (h.mono sphere_subset_closed_ball), fun hr =>
      âŸ¨r â€¢ â€–y - xâ€–â»Â¹ â€¢ (y - x) + x, _âŸ©âŸ©
  have : â€–y - xâ€– â‰  0 := by simpa [sub_eq_zero]
  simp [norm_smul, this, Real.norm_of_nonneg hr]
#align normed_space.sphere_nonempty NormedSpace.sphere_nonempty

/- warning: smul_sphere -> smul_sphere is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : NormedSpace.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_5 : Nontrivial.{u2} E] (c : ğ•œ) (x : E) {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)))))) c (Metric.sphere.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) x r)) (Metric.sphere.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (SeminormedAddCommGroup.toAddCommGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2))) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) c) r)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : NormedAddCommGroup.{u2} E] [_inst_3 : NormedSpace.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_4 : NormedSpace.{0, u2} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)] [_inst_5 : Nontrivial.{u2} E] (c : ğ•œ) (x : E) {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (Eq.{succ u2} (Set.{u2} E) (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3))))))) c (Metric.sphere.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) x r)) (Metric.sphere.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2)) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E (NormedAddCommGroup.toAddCommGroup.{u2} E _inst_2)) (NormedSpace.toModule.{u1, u2} ğ•œ E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_2) _inst_3)))))) c x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Norm.norm.{u1} ğ•œ (NormedField.toNorm.{u1} ğ•œ _inst_1) c) r)))
Case conversion may be inaccurate. Consider using '#align smul_sphere smul_sphereâ‚“'. -/
theorem smul_sphere [Nontrivial E] (c : ğ•œ) (x : E) {r : â„} (hr : 0 â‰¤ r) :
    c â€¢ sphere x r = sphere (c â€¢ x) (â€–câ€– * r) :=
  by
  rcases eq_or_ne c 0 with (rfl | hc)
  Â· simp [zero_smul_set, Set.singleton_zero, hr]
  Â· exact smul_sphere' hc x r
#align smul_sphere smul_sphere

/- warning: affinity_unit_ball -> affinity_unitBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {r : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (VAdd.vadd.{u1, u1} E (Set.{u1} E) (Set.vaddSet.{u1, u1} E E (Add.toVAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2)))))))) x (SMul.smul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) r (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) x r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {r : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (HVAdd.hVAdd.{u1, u1, u1} E (Set.{u1} E) (Set.{u1} E) (instHVAdd.{u1, u1} E (Set.{u1} E) (Set.vaddSet.{u1, u1} E E (AddAction.toVAdd.{u1, u1} E E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2)))) (AddTorsor.toAddAction.{u1, u1} E E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2)) (NormedAddTorsor.toAddTorsor.{u1, u1} E E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (SeminormedAddCommGroup.toNormedAddTorsor.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))))))) x (HSMul.hSMul.{0, u1, u1} Real (Set.{u1} E) (Set.{u1} E) (instHSMul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))))) r (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))) (Metric.ball.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) x r))
Case conversion may be inaccurate. Consider using '#align affinity_unit_ball affinity_unitBallâ‚“'. -/
/-- Any ball `metric.ball x r`, `0 < r` is the image of the unit ball under `Î» y, x + r â€¢ y`. -/
theorem affinity_unitBall {r : â„} (hr : 0 < r) (x : E) : x +áµ¥ r â€¢ ball 0 1 = ball x r := by
  rw [smul_unitBall_of_pos hr, vadd_ball_zero]
#align affinity_unit_ball affinity_unitBall

/- warning: affinity_unit_closed_ball -> affinity_unitClosedBall is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (VAdd.vadd.{u1, u1} E (Set.{u1} E) (Set.vaddSet.{u1, u1} E E (Add.toVAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2)))))))) x (SMul.smul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toHasSmul.{0, u1} Real E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real E (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E (Semiring.toMonoidWithZero.{0} Real (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E (Ring.toSemiring.{0} Real (NormedRing.toRing.{0} Real (NormedCommRing.toNormedRing.{0} Real (NormedField.toNormedCommRing.{0} Real Real.normedField)))) (AddCommGroup.toAddCommMonoid.{u1} E (SeminormedAddCommGroup.toAddCommGroup.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4)))))) r (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (OfNat.mk.{u1} E 0 (Zero.zero.{u1} E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2))))))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) x r))
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : NormedAddCommGroup.{u1} E] [_inst_4 : NormedSpace.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)] {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (forall (x : E), Eq.{succ u1} (Set.{u1} E) (HVAdd.hVAdd.{u1, u1, u1} E (Set.{u1} E) (Set.{u1} E) (instHVAdd.{u1, u1} E (Set.{u1} E) (Set.vaddSet.{u1, u1} E E (AddAction.toVAdd.{u1, u1} E E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2)))) (AddTorsor.toAddAction.{u1, u1} E E (NormedAddGroup.toAddGroup.{u1} E (NormedAddCommGroup.toNormedAddGroup.{u1} E _inst_2)) (NormedAddTorsor.toAddTorsor.{u1, u1} E E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (SeminormedAddCommGroup.toNormedAddTorsor.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2))))))) x (HSMul.hSMul.{0, u1, u1} Real (Set.{u1} E) (Set.{u1} E) (instHSMul.{0, u1} Real (Set.{u1} E) (Set.smulSet.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real E Real.instMonoidWithZeroReal (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))) (Module.toMulActionWithZero.{0, u1} Real E Real.semiring (AddCommGroup.toAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)) (NormedSpace.toModule.{0, u1} Real E Real.normedField (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2) _inst_4))))))) r (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E (NormedAddCommGroup.toAddCommGroup.{u1} E _inst_2)))))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))) (Metric.closedBall.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_2)) x r))
Case conversion may be inaccurate. Consider using '#align affinity_unit_closed_ball affinity_unitClosedBallâ‚“'. -/
/-- Any closed ball `metric.closed_ball x r`, `0 â‰¤ r` is the image of the unit closed ball under
`Î» y, x + r â€¢ y`. -/
theorem affinity_unitClosedBall {r : â„} (hr : 0 â‰¤ r) (x : E) :
    x +áµ¥ r â€¢ closedBall 0 1 = closedBall x r := by
  rw [smul_closedUnitBall, Real.norm_of_nonneg hr, vadd_closedBall_zero]
#align affinity_unit_closed_ball affinity_unitClosedBall

end NormedAddCommGroup

