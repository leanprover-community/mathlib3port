/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll

! This file was ported from Lean 3 source module analysis.locally_convex.balanced_core_hull
! leanprover-community/mathlib commit 4f4a1c875d0baa92ab5d92f3fb1bb258ad9f3e5b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.LocallyConvex.Basic

/-!
# Balanced Core and Balanced Hull

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

* `balanced_core`: The largest balanced subset of a set `s`.
* `balanced_hull`: The smallest balanced superset of a set `s`.

## Main statements

* `balanced_core_eq_Inter`: Characterization of the balanced core as an intersection over subsets.
* `nhds_basis_closed_balanced`: The closed balanced sets form a basis of the neighborhood filter.

## Implementation details

The balanced core and hull are implemented differently: for the core we take the obvious definition
of the union over all balanced sets that are contained in `s`, whereas for the hull, we take the
union over `r â€¢ s`, for `r` the scalars with `â€–râ€– â‰¤ 1`. We show that `balanced_hull` has the
defining properties of a hull in `balanced.hull_minimal` and `subset_balanced_hull`.
For the core we need slightly stronger assumptions to obtain a characterization as an intersection,
this is `balanced_core_eq_Inter`.

## References

* [Bourbaki, *Topological Vector Spaces*][bourbaki1987]

## Tags

balanced
-/


open Set

open Pointwise Topology Filter

variable {ğ•œ E Î¹ : Type _}

section balancedHull

section SeminormedRing

variable [SeminormedRing ğ•œ]

section SMul

variable (ğ•œ) [SMul ğ•œ E] {s t : Set E} {x : E}

#print balancedCore /-
/-- The largest balanced subset of `s`.-/
def balancedCore (s : Set E) :=
  â‹ƒâ‚€ { t : Set E | Balanced ğ•œ t âˆ§ t âŠ† s }
#align balanced_core balancedCore
-/

#print balancedCoreAux /-
/-- Helper definition to prove `balanced_core_eq_Inter`-/
def balancedCoreAux (s : Set E) :=
  â‹‚ (r : ğ•œ) (hr : 1 â‰¤ â€–râ€–), r â€¢ s
#align balanced_core_aux balancedCoreAux
-/

#print balancedHull /-
/-- The smallest balanced superset of `s`.-/
def balancedHull (s : Set E) :=
  â‹ƒ (r : ğ•œ) (hr : â€–râ€– â‰¤ 1), r â€¢ s
#align balanced_hull balancedHull
-/

variable {ğ•œ}

#print balancedCore_subset /-
theorem balancedCore_subset (s : Set E) : balancedCore ğ•œ s âŠ† s :=
  unionâ‚›_subset fun t ht => ht.2
#align balanced_core_subset balancedCore_subset
-/

#print balancedCore_empty /-
theorem balancedCore_empty : balancedCore ğ•œ (âˆ… : Set E) = âˆ… :=
  eq_empty_of_subset_empty (balancedCore_subset _)
#align balanced_core_empty balancedCore_empty
-/

#print mem_balancedCore_iff /-
theorem mem_balancedCore_iff : x âˆˆ balancedCore ğ•œ s â†” âˆƒ t, Balanced ğ•œ t âˆ§ t âŠ† s âˆ§ x âˆˆ t := by
  simp_rw [balancedCore, mem_sUnion, mem_set_of_eq, exists_prop, and_assoc']
#align mem_balanced_core_iff mem_balancedCore_iff
-/

/- warning: smul_balanced_core_subset -> smul_balancedCore_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] (s : Set.{u2} E) {a : ğ•œ}, (LE.le.{0} Real Real.hasLe (Norm.norm.{u1} ğ•œ (SeminormedRing.toHasNorm.{u1} ğ•œ _inst_1) a) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_2) a (balancedCore.{u1, u2} ğ•œ E _inst_1 _inst_2 s)) (balancedCore.{u1, u2} ğ•œ E _inst_1 _inst_2 s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] (s : Set.{u2} E) {a : ğ•œ}, (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ğ•œ (SeminormedRing.toNorm.{u1} ğ•œ _inst_1) a) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_2)) a (balancedCore.{u1, u2} ğ•œ E _inst_1 _inst_2 s)) (balancedCore.{u1, u2} ğ•œ E _inst_1 _inst_2 s))
Case conversion may be inaccurate. Consider using '#align smul_balanced_core_subset smul_balancedCore_subsetâ‚“'. -/
theorem smul_balancedCore_subset (s : Set E) {a : ğ•œ} (ha : â€–aâ€– â‰¤ 1) :
    a â€¢ balancedCore ğ•œ s âŠ† balancedCore ğ•œ s :=
  by
  rintro x âŸ¨y, hy, rflâŸ©
  rw [mem_balancedCore_iff] at hy
  rcases hy with âŸ¨t, ht1, ht2, hyâŸ©
  exact âŸ¨t, âŸ¨ht1, ht2âŸ©, ht1 a ha (smul_mem_smul_set hy)âŸ©
#align smul_balanced_core_subset smul_balancedCore_subset

#print balancedCore_balanced /-
theorem balancedCore_balanced (s : Set E) : Balanced ğ•œ (balancedCore ğ•œ s) := fun _ =>
  smul_balancedCore_subset s
#align balanced_core_balanced balancedCore_balanced
-/

/- warning: balanced.subset_core_of_subset -> Balanced.subset_balancedCore_of_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {t : Set.{u2} E}, (Balanced.{u1, u2} ğ•œ E _inst_1 _inst_2 s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s t) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s (balancedCore.{u1, u2} ğ•œ E _inst_1 _inst_2 t))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : SeminormedRing.{u2} ğ•œ] [_inst_2 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E} {t : Set.{u1} E}, (Balanced.{u2, u1} ğ•œ E _inst_1 _inst_2 s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) s t) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) s (balancedCore.{u2, u1} ğ•œ E _inst_1 _inst_2 t))
Case conversion may be inaccurate. Consider using '#align balanced.subset_core_of_subset Balanced.subset_balancedCore_of_subsetâ‚“'. -/
/-- The balanced core of `t` is maximal in the sense that it contains any balanced subset
`s` of `t`.-/
theorem Balanced.subset_balancedCore_of_subset (hs : Balanced ğ•œ s) (h : s âŠ† t) :
    s âŠ† balancedCore ğ•œ t :=
  subset_unionâ‚›_of_mem âŸ¨hs, hâŸ©
#align balanced.subset_core_of_subset Balanced.subset_balancedCore_of_subset

/- warning: mem_balanced_core_aux_iff -> mem_balancedCoreAux_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (balancedCoreAux.{u1, u2} ğ•œ E _inst_1 _inst_2 s)) (forall (r : ğ•œ), (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} ğ•œ (SeminormedRing.toHasNorm.{u1} ğ•œ _inst_1) r)) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_2) r s)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (balancedCoreAux.{u1, u2} ğ•œ E _inst_1 _inst_2 s)) (forall (r : ğ•œ), (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u1} ğ•œ (SeminormedRing.toNorm.{u1} ğ•œ _inst_1) r)) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_2)) r s)))
Case conversion may be inaccurate. Consider using '#align mem_balanced_core_aux_iff mem_balancedCoreAux_iffâ‚“'. -/
theorem mem_balancedCoreAux_iff : x âˆˆ balancedCoreAux ğ•œ s â†” âˆ€ r : ğ•œ, 1 â‰¤ â€–râ€– â†’ x âˆˆ r â€¢ s :=
  mem_interáµ¢â‚‚
#align mem_balanced_core_aux_iff mem_balancedCoreAux_iff

/- warning: mem_balanced_hull_iff -> mem_balancedHull_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (balancedHull.{u1, u2} ğ•œ E _inst_1 _inst_2 s)) (Exists.{succ u1} ğ•œ (fun (r : ğ•œ) => Exists.{0} (LE.le.{0} Real Real.hasLe (Norm.norm.{u1} ğ•œ (SeminormedRing.toHasNorm.{u1} ğ•œ _inst_1) r) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (fun (hr : LE.le.{0} Real Real.hasLe (Norm.norm.{u1} ğ•œ (SeminormedRing.toHasNorm.{u1} ğ•œ _inst_1) r) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) => Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_2) r s))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (balancedHull.{u1, u2} ğ•œ E _inst_1 _inst_2 s)) (Exists.{succ u1} ğ•œ (fun (r : ğ•œ) => Exists.{0} (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ğ•œ (SeminormedRing.toNorm.{u1} ğ•œ _inst_1) r) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (fun (hr : LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ğ•œ (SeminormedRing.toNorm.{u1} ğ•œ _inst_1) r) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_2)) r s))))
Case conversion may be inaccurate. Consider using '#align mem_balanced_hull_iff mem_balancedHull_iffâ‚“'. -/
theorem mem_balancedHull_iff : x âˆˆ balancedHull ğ•œ s â†” âˆƒ (r : ğ•œ)(hr : â€–râ€– â‰¤ 1), x âˆˆ r â€¢ s :=
  mem_unionáµ¢â‚‚
#align mem_balanced_hull_iff mem_balancedHull_iff

/- warning: balanced.hull_subset_of_subset -> Balanced.balancedHull_subset_of_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {t : Set.{u2} E}, (Balanced.{u1, u2} ğ•œ E _inst_1 _inst_2 t) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s t) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (balancedHull.{u1, u2} ğ•œ E _inst_1 _inst_2 s) t)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : SeminormedRing.{u2} ğ•œ] [_inst_2 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E} {t : Set.{u1} E}, (Balanced.{u2, u1} ğ•œ E _inst_1 _inst_2 t) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) s t) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (balancedHull.{u2, u1} ğ•œ E _inst_1 _inst_2 s) t)
Case conversion may be inaccurate. Consider using '#align balanced.hull_subset_of_subset Balanced.balancedHull_subset_of_subsetâ‚“'. -/
/-- The balanced hull of `s` is minimal in the sense that it is contained in any balanced superset
`t` of `s`. -/
theorem Balanced.balancedHull_subset_of_subset (ht : Balanced ğ•œ t) (h : s âŠ† t) :
    balancedHull ğ•œ s âŠ† t := fun x hx =>
  by
  obtain âŸ¨r, hr, y, hy, rflâŸ© := mem_balancedHull_iff.1 hx
  exact ht.smul_mem hr (h hy)
#align balanced.hull_subset_of_subset Balanced.balancedHull_subset_of_subset

end SMul

section Module

variable [AddCommGroup E] [Module ğ•œ E] {s : Set E}

/- warning: balanced_core_zero_mem -> balancedCore_zero_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) (balancedCore.{u1, u2} ğ•œ E _inst_1 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))) s) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))) (balancedCore.{u1, u2} ğ•œ E _inst_1 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s))
Case conversion may be inaccurate. Consider using '#align balanced_core_zero_mem balancedCore_zero_memâ‚“'. -/
theorem balancedCore_zero_mem (hs : (0 : E) âˆˆ s) : (0 : E) âˆˆ balancedCore ğ•œ s :=
  mem_balancedCore_iff.2 âŸ¨0, balanced_zero, zero_subset.2 hs, zero_mem_zeroâŸ©
#align balanced_core_zero_mem balancedCore_zero_mem

/- warning: balanced_core_nonempty_iff -> balancedCore_nonempty_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, Iff (Set.Nonempty.{u2} E (balancedCore.{u1, u2} ğ•œ E _inst_1 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)) (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) s)
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, Iff (Set.Nonempty.{u2} E (balancedCore.{u1, u2} ğ•œ E _inst_1 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)) (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))) s)
Case conversion may be inaccurate. Consider using '#align balanced_core_nonempty_iff balancedCore_nonempty_iffâ‚“'. -/
theorem balancedCore_nonempty_iff : (balancedCore ğ•œ s).Nonempty â†” (0 : E) âˆˆ s :=
  âŸ¨fun h =>
    zero_subset.1 <|
      (zero_smul_set h).Superset.trans <|
        (balancedCore_balanced s (0 : ğ•œ) <| norm_zero.trans_le zero_le_one).trans <|
          balancedCore_subset _,
    fun h => âŸ¨0, balancedCore_zero_mem hâŸ©âŸ©
#align balanced_core_nonempty_iff balancedCore_nonempty_iff

variable (ğ•œ)

/- warning: subset_balanced_hull -> subset_balancedHull is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : SeminormedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : NormOneClass.{u1} ğ•œ (SeminormedRing.toHasNorm.{u1} ğ•œ _inst_1) (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)))))] {s : Set.{u2} E}, HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s (balancedHull.{u1, u2} ğ•œ E _inst_1 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (SeminormedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)
but is expected to have type
  forall (ğ•œ : Type.{u2}) {E : Type.{u1}} [_inst_1 : SeminormedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (SeminormedRing.toRing.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : NormOneClass.{u2} ğ•œ (SeminormedRing.toNorm.{u2} ğ•œ _inst_1) (Semiring.toOne.{u2} ğ•œ (Ring.toSemiring.{u2} ğ•œ (SeminormedRing.toRing.{u2} ğ•œ _inst_1)))] {s : Set.{u1} E}, HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) s (balancedHull.{u2, u1} ğ•œ E _inst_1 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (Ring.toSemiring.{u2} ğ•œ (SeminormedRing.toRing.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (Ring.toSemiring.{u2} ğ•œ (SeminormedRing.toRing.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (SeminormedRing.toRing.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) s)
Case conversion may be inaccurate. Consider using '#align subset_balanced_hull subset_balancedHullâ‚“'. -/
theorem subset_balancedHull [NormOneClass ğ•œ] {s : Set E} : s âŠ† balancedHull ğ•œ s := fun _ hx =>
  mem_balancedHull_iff.2 âŸ¨1, norm_one.le, _, hx, one_smul _ _âŸ©
#align subset_balanced_hull subset_balancedHull

variable {ğ•œ}

#print balancedHull.balanced /-
theorem balancedHull.balanced (s : Set E) : Balanced ğ•œ (balancedHull ğ•œ s) :=
  by
  intro a ha
  simp_rw [balancedHull, smul_set_Unionâ‚‚, subset_def, mem_Unionâ‚‚]
  rintro x âŸ¨r, hr, hxâŸ©
  rw [â† smul_assoc] at hx
  exact âŸ¨a â€¢ r, (SeminormedRing.norm_mul _ _).trans (mul_le_one ha (norm_nonneg r) hr), hxâŸ©
#align balanced_hull.balanced balancedHull.balanced
-/

end Module

end SeminormedRing

section NormedField

variable [NormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E] {s t : Set E}

#print balancedCoreAux_empty /-
@[simp]
theorem balancedCoreAux_empty : balancedCoreAux ğ•œ (âˆ… : Set E) = âˆ… :=
  by
  simp_rw [balancedCoreAux, Interâ‚‚_eq_empty_iff, smul_set_empty]
  exact fun _ => âŸ¨1, norm_one.ge, not_mem_empty _âŸ©
#align balanced_core_aux_empty balancedCoreAux_empty
-/

#print balancedCoreAux_subset /-
theorem balancedCoreAux_subset (s : Set E) : balancedCoreAux ğ•œ s âŠ† s := fun x hx => by
  simpa only [one_smul] using mem_balancedCoreAux_iff.1 hx 1 norm_one.ge
#align balanced_core_aux_subset balancedCoreAux_subset
-/

/- warning: balanced_core_aux_balanced -> balancedCoreAux_balanced is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) (balancedCoreAux.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)) -> (Balanced.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (balancedCoreAux.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))) (balancedCoreAux.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)) -> (Balanced.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (balancedCoreAux.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s))
Case conversion may be inaccurate. Consider using '#align balanced_core_aux_balanced balancedCoreAux_balancedâ‚“'. -/
theorem balancedCoreAux_balanced (h0 : (0 : E) âˆˆ balancedCoreAux ğ•œ s) :
    Balanced ğ•œ (balancedCoreAux ğ•œ s) :=
  by
  rintro a ha x âŸ¨y, hy, rflâŸ©
  obtain rfl | h := eq_or_ne a 0
  Â· rwa [zero_smul]
  rw [mem_balancedCoreAux_iff] at hyâŠ¢
  intro r hr
  have h'' : 1 â‰¤ â€–aâ»Â¹ â€¢ râ€– := by
    rw [norm_smul, norm_inv]
    exact one_le_mul_of_one_le_of_one_le (one_le_inv (norm_pos_iff.mpr h) ha) hr
  have h' := hy (aâ»Â¹ â€¢ r) h''
  rwa [smul_assoc, mem_inv_smul_set_iffâ‚€ h] at h'
#align balanced_core_aux_balanced balancedCoreAux_balanced

#print balancedCoreAux_maximal /-
theorem balancedCoreAux_maximal (h : t âŠ† s) (ht : Balanced ğ•œ t) : t âŠ† balancedCoreAux ğ•œ s :=
  by
  refine' fun x hx => mem_balancedCoreAux_iff.2 fun r hr => _
  rw [mem_smul_set_iff_inv_smul_memâ‚€ (norm_pos_iff.mp <| zero_lt_one.trans_le hr)]
  refine' h (ht.smul_mem _ hx)
  rw [norm_inv]
  exact inv_le_one hr
#align balanced_core_aux_maximal balancedCoreAux_maximal
-/

#print balancedCore_subset_balancedCoreAux /-
theorem balancedCore_subset_balancedCoreAux : balancedCore ğ•œ s âŠ† balancedCoreAux ğ•œ s :=
  balancedCoreAux_maximal (balancedCore_subset s) (balancedCore_balanced s)
#align balanced_core_subset_balanced_core_aux balancedCore_subset_balancedCoreAux
-/

/- warning: balanced_core_eq_Inter -> balancedCore_eq_interáµ¢ is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) s) -> (Eq.{succ u2} (Set.{u2} E) (balancedCore.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s) (Set.interáµ¢.{u2, succ u1} E ğ•œ (fun (r : ğ•œ) => Set.interáµ¢.{u2, 0} E (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) r)) (fun (hr : LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) r)) => SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) r s))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))) s) -> (Eq.{succ u2} (Set.{u2} E) (balancedCore.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s) (Set.interáµ¢.{u2, succ u1} E ğ•œ (fun (r : ğ•œ) => Set.interáµ¢.{u2, 0} E (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u1} ğ•œ (NormedField.toNorm.{u1} ğ•œ _inst_1) r)) (fun (hr : LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Norm.norm.{u1} ğ•œ (NormedField.toNorm.{u1} ğ•œ _inst_1) r)) => HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))))) r s))))
Case conversion may be inaccurate. Consider using '#align balanced_core_eq_Inter balancedCore_eq_interáµ¢â‚“'. -/
theorem balancedCore_eq_interáµ¢ (hs : (0 : E) âˆˆ s) :
    balancedCore ğ•œ s = â‹‚ (r : ğ•œ) (hr : 1 â‰¤ â€–râ€–), r â€¢ s :=
  by
  refine' balanced_core_subset_balanced_core_aux.antisymm _
  refine' (balancedCoreAux_balanced _).subset_balancedCore_of_subset (balancedCoreAux_subset s)
  exact balancedCore_subset_balancedCoreAux (balancedCore_zero_mem hs)
#align balanced_core_eq_Inter balancedCore_eq_interáµ¢

/- warning: subset_balanced_core -> subset_balancedCore is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {t : Set.{u2} E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) t) -> (forall (a : ğ•œ), (LE.le.{0} Real Real.hasLe (Norm.norm.{u1} ğ•œ (NormedField.toHasNorm.{u1} ğ•œ _inst_1) a) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) a s) t)) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s (balancedCore.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {t : Set.{u2} E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))) t) -> (forall (a : ğ•œ), (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ğ•œ (NormedField.toNorm.{u1} ğ•œ _inst_1) a) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (HSMul.hSMul.{u1, u2, u2} ğ•œ (Set.{u2} E) (Set.{u2} E) (instHSMul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))))) a s) t)) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) s (balancedCore.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ _inst_1))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) t))
Case conversion may be inaccurate. Consider using '#align subset_balanced_core subset_balancedCoreâ‚“'. -/
theorem subset_balancedCore (ht : (0 : E) âˆˆ t) (hst : âˆ€ (a : ğ•œ) (ha : â€–aâ€– â‰¤ 1), a â€¢ s âŠ† t) :
    s âŠ† balancedCore ğ•œ t := by
  rw [balancedCore_eq_interáµ¢ ht]
  refine' subset_Interâ‚‚ fun a ha => _
  rw [â† smul_inv_smulâ‚€ (norm_pos_iff.mp <| zero_lt_one.trans_le ha) s]
  refine' smul_set_mono (hst _ _)
  rw [norm_inv]
  exact inv_le_one ha
#align subset_balanced_core subset_balancedCore

end NormedField

end balancedHull

/-! ### Topological properties -/


section Topology

variable [NontriviallyNormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E]
  [ContinuousSMul ğ•œ E] {U : Set E}

#print IsClosed.balancedCore /-
protected theorem IsClosed.balancedCore (hU : IsClosed U) : IsClosed (balancedCore ğ•œ U) :=
  by
  by_cases h : (0 : E) âˆˆ U
  Â· rw [balancedCore_eq_interáµ¢ h]
    refine' isClosed_interáµ¢ fun a => _
    refine' isClosed_interáµ¢ fun ha => _
    have ha' := lt_of_lt_of_le zero_lt_one ha
    rw [norm_pos_iff] at ha'
    refine' isClosedMap_smul_of_ne_zero ha' U hU
  convert isClosed_empty
  contrapose! h
  exact balanced_core_nonempty_iff.mp (Set.nonempty_iff_ne_empty.2 h)
#align is_closed.balanced_core IsClosed.balancedCore
-/

/- warning: balanced_core_mem_nhds_zero -> balancedCore_mem_nhds_zero is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NontriviallyNormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))) _inst_4] {U : Set.{u2} E}, (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) U (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))))) -> (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) (balancedCore.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) U) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : NontriviallyNormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))) _inst_4] {U : Set.{u2} E}, (Membership.mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (instMembershipSetFilter.{u2} E) U (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))))) -> (Membership.mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (instMembershipSetFilter.{u2} E) (balancedCore.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) U) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align balanced_core_mem_nhds_zero balancedCore_mem_nhds_zeroâ‚“'. -/
theorem balancedCore_mem_nhds_zero (hU : U âˆˆ ğ“ (0 : E)) : balancedCore ğ•œ U âˆˆ ğ“ (0 : E) :=
  by
  -- Getting neighborhoods of the origin for `0 : ğ•œ` and `0 : E`
  obtain âŸ¨r, V, hr, hV, hrVUâŸ© :
    âˆƒ (r : â„)(V : Set E), 0 < r âˆ§ V âˆˆ ğ“ (0 : E) âˆ§ âˆ€ (c : ğ•œ) (y : E), â€–câ€– < r â†’ y âˆˆ V â†’ c â€¢ y âˆˆ U :=
    by
    have h : Filter.Tendsto (fun x : ğ•œ Ã— E => x.fst â€¢ x.snd) (ğ“ (0, 0)) (ğ“ 0) :=
      continuous_smul.tendsto' (0, 0) _ (smul_zero _)
    simpa only [â† Prod.exists', â† Prod.forall', â† and_imp, â† and_assoc, exists_prop] using
      h.basis_left (normed_add_comm_group.nhds_zero_basis_norm_lt.prod_nhds (ğ“ _).basis_sets) U hU
  rcases NormedField.exists_norm_lt ğ•œ hr with âŸ¨y, hyâ‚€, hyrâŸ©
  rw [norm_pos_iff] at hyâ‚€
  have : y â€¢ V âˆˆ ğ“ (0 : E) := (set_smul_mem_nhds_zero_iff hyâ‚€).mpr hV
  -- It remains to show that `y â€¢ V âŠ† balanced_core ğ•œ U`
  refine' Filter.mem_of_superset this (subset_balancedCore (mem_of_mem_nhds hU) fun a ha => _)
  rw [smul_smul]
  rintro _ âŸ¨z, hz, rflâŸ©
  refine' hrVU _ _ _ hz
  rw [norm_mul, â† one_mul r]
  exact mul_lt_mul' ha hyr (norm_nonneg y) one_pos
#align balanced_core_mem_nhds_zero balancedCore_mem_nhds_zero

variable (ğ•œ E)

/- warning: nhds_basis_balanced -> nhds_basis_balanced is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))) _inst_4], Filter.HasBasis.{u2, succ u2} E (Set.{u2} E) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) (fun (s : Set.{u2} E) => And (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) s (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))))) (Balanced.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)) (id.{succ u2} (Set.{u2} E))
but is expected to have type
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))) _inst_4], Filter.HasBasis.{u2, succ u2} E (Set.{u2} E) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))) (fun (s : Set.{u2} E) => And (Membership.mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (instMembershipSetFilter.{u2} E) s (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))))) (Balanced.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)) (id.{succ u2} (Set.{u2} E))
Case conversion may be inaccurate. Consider using '#align nhds_basis_balanced nhds_basis_balancedâ‚“'. -/
theorem nhds_basis_balanced :
    (ğ“ (0 : E)).HasBasis (fun s : Set E => s âˆˆ ğ“ (0 : E) âˆ§ Balanced ğ•œ s) id :=
  Filter.hasBasis_self.mpr fun s hs =>
    âŸ¨balancedCore ğ•œ s, balancedCore_mem_nhds_zero hs, balancedCore_balanced s,
      balancedCore_subset sâŸ©
#align nhds_basis_balanced nhds_basis_balanced

/- warning: nhds_basis_closed_balanced -> nhds_basis_closed_balanced is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))) _inst_4] [_inst_6 : RegularSpace.{u2} E _inst_4], Filter.HasBasis.{u2, succ u2} E (Set.{u2} E) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) (fun (s : Set.{u2} E) => And (Membership.Mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (Filter.hasMem.{u2} E) s (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))))) (And (IsClosed.{u2} E _inst_4 s) (Balanced.{u1, u2} ğ•œ E (SeminormedCommRing.toSemiNormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (NormedRing.toRing.{u1} ğ•œ (NormedCommRing.toNormedRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s))) (id.{succ u2} (Set.{u2} E))
but is expected to have type
  forall (ğ•œ : Type.{u1}) (E : Type.{u2}) [_inst_1 : NontriviallyNormedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : ContinuousSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ğ•œ (PseudoMetricSpace.toUniformSpace.{u1} ğ•œ (SeminormedRing.toPseudoMetricSpace.{u1} ğ•œ (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))))) _inst_4] [_inst_6 : RegularSpace.{u2} E _inst_4], Filter.HasBasis.{u2, succ u2} E (Set.{u2} E) (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))) (fun (s : Set.{u2} E) => And (Membership.mem.{u2, u2} (Set.{u2} E) (Filter.{u2} E) (instMembershipSetFilter.{u2} E) s (nhds.{u2} E _inst_4 (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))))))) (And (IsClosed.{u2} E _inst_4 s) (Balanced.{u1, u2} ğ•œ E (SeminormedCommRing.toSeminormedRing.{u1} ğ•œ (NormedCommRing.toSeminormedCommRing.{u1} ğ•œ (NormedField.toNormedCommRing.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (Field.toSemifield.{u1} ğ•œ (NormedField.toField.{u1} ğ•œ (NontriviallyNormedField.toNormedField.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s))) (id.{succ u2} (Set.{u2} E))
Case conversion may be inaccurate. Consider using '#align nhds_basis_closed_balanced nhds_basis_closed_balancedâ‚“'. -/
theorem nhds_basis_closed_balanced [RegularSpace E] :
    (ğ“ (0 : E)).HasBasis (fun s : Set E => s âˆˆ ğ“ (0 : E) âˆ§ IsClosed s âˆ§ Balanced ğ•œ s) id :=
  by
  refine'
    (closed_nhds_basis 0).to_hasBasis (fun s hs => _) fun s hs => âŸ¨s, âŸ¨hs.1, hs.2.1âŸ©, rfl.subsetâŸ©
  refine' âŸ¨balancedCore ğ•œ s, âŸ¨balancedCore_mem_nhds_zero hs.1, _âŸ©, balancedCore_subset sâŸ©
  exact âŸ¨hs.2.balancedCore, balancedCore_balanced sâŸ©
#align nhds_basis_closed_balanced nhds_basis_closed_balanced

end Topology

