/-
Copyright (c) 2021 Devon Tuma. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Devon Tuma

! This file was ported from Lean 3 source module analysis.asymptotics.superpolynomial_decay
! leanprover-community/mathlib commit f2ce6086713c78a7f880485f7917ea547a215982
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Asymptotics.Asymptotics
import Mathbin.Analysis.Normed.Order.Basic
import Mathbin.Data.Polynomial.Eval
import Mathbin.Topology.Algebra.Order.LiminfLimsup

/-!
# Super-Polynomial Function Decay

This file defines a predicate `asymptotics.superpolynomial_decay f` for a function satisfying
  one of following equivalent definitions (The definition is in terms of the first condition):

* `x ^ n * f` tends to `ð“ 0` for all (or sufficiently large) naturals `n`
* `|x ^ n * f|` tends to `ð“ 0` for all naturals `n` (`superpolynomial_decay_iff_abs_tendsto_zero`)
* `|x ^ n * f|` is bounded for all naturals `n` (`superpolynomial_decay_iff_abs_is_bounded_under`)
* `f` is `o(x ^ c)` for all integers `c` (`superpolynomial_decay_iff_is_o`)
* `f` is `O(x ^ c)` for all integers `c` (`superpolynomial_decay_iff_is_O`)

These conditions are all equivalent to conditions in terms of polynomials, replacing `x ^ c` with
  `p(x)` or `p(x)â»Â¹` as appropriate, since asymptotically `p(x)` behaves like `X ^ p.nat_degree`.
These further equivalences are not proven in mathlib but would be good future projects.

The definition of superpolynomial decay for `f : Î± â†’ Î²` is relative to a parameter `k : Î± â†’ Î²`.
Super-polynomial decay then means `f x` decays faster than `(k x) ^ c` for all integers `c`.
Equivalently `f x` decays faster than `p.eval (k x)` for all polynomials `p : Î²[X]`.
The definition is also relative to a filter `l : filter Î±` where the decay rate is compared.

When the map `k` is given by `n â†¦ â†‘n : â„• â†’ â„` this defines negligible functions:
https://en.wikipedia.org/wiki/Negligible_function

When the map `k` is given by `(râ‚,...,râ‚™) â†¦ râ‚*...*râ‚™ : â„â¿ â†’ â„` this is equivalent
  to the definition of rapidly decreasing functions given here:
https://ncatlab.org/nlab/show/rapidly+decreasing+function

# Main Theorems

* `superpolynomial_decay.polynomial_mul` says that if `f(x)` is negligible,
    then so is `p(x) * f(x)` for any polynomial `p`.
* `superpolynomial_decay_iff_zpow_tendsto_zero` gives an equivalence between definitions in terms
    of decaying faster than `k(x) ^ n` for all naturals `n` or `k(x) ^ c` for all integer `c`.
-/


namespace Asymptotics

open Topology Polynomial

open Filter

#print Asymptotics.SuperpolynomialDecay /-
/-- `f` has superpolynomial decay in parameter `k` along filter `l` if
  `k ^ n * f` tends to zero at `l` for all naturals `n` -/
def SuperpolynomialDecay {Î± Î² : Type _} [TopologicalSpace Î²] [CommSemiring Î²] (l : Filter Î±)
    (k : Î± â†’ Î²) (f : Î± â†’ Î²) :=
  âˆ€ n : â„•, Tendsto (fun a : Î± => k a ^ n * f a) l (ð“ 0)
#align asymptotics.superpolynomial_decay Asymptotics.SuperpolynomialDecay
-/

variable {Î± Î² : Type _} {l : Filter Î±} {k : Î± â†’ Î²} {f g g' : Î± â†’ Î²}

section CommSemiring

variable [TopologicalSpace Î²] [CommSemiring Î²]

/- warning: asymptotics.superpolynomial_decay.congr' -> Asymptotics.SuperpolynomialDecay.congr' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (Filter.EventuallyEq.{u1, u2} Î± Î² l f g) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k g)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : CommSemiring.{u1} Î²], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k f) -> (Filter.EventuallyEq.{u2, u1} Î± Î² l f g) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k g)
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.congr' Asymptotics.SuperpolynomialDecay.congr'â‚“'. -/
theorem SuperpolynomialDecay.congr' (hf : SuperpolynomialDecay l k f) (hfg : f =á¶ [l] g) :
    SuperpolynomialDecay l k g := fun z =>
  (hf z).congr' (EventuallyEq.mul (EventuallyEq.refl l _) hfg)
#align asymptotics.superpolynomial_decay.congr' Asymptotics.SuperpolynomialDecay.congr'

/- warning: asymptotics.superpolynomial_decay.congr -> Asymptotics.SuperpolynomialDecay.congr is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (x : Î±), Eq.{succ u2} Î² (f x) (g x)) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k g)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : CommSemiring.{u1} Î²], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k f) -> (forall (x : Î±), Eq.{succ u1} Î² (f x) (g x)) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k g)
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.congr Asymptotics.SuperpolynomialDecay.congrâ‚“'. -/
theorem SuperpolynomialDecay.congr (hf : SuperpolynomialDecay l k f) (hfg : âˆ€ x, f x = g x) :
    SuperpolynomialDecay l k g := fun z =>
  (hf z).congr fun x => (congr_arg fun a => k x ^ z * a) <| hfg x
#align asymptotics.superpolynomial_decay.congr Asymptotics.SuperpolynomialDecay.congr

/- warning: asymptotics.superpolynomial_decay_zero -> Asymptotics.superpolynomialDecay_zero is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] (l : Filter.{u1} Î±) (k : Î± -> Î²), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (OfNat.ofNat.{max u1 u2} (Î± -> Î²) 0 (OfNat.mk.{max u1 u2} (Î± -> Î²) 0 (Zero.zero.{max u1 u2} (Î± -> Î²) (Pi.instZero.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => MulZeroClass.toHasZero.{u2} Î² (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : CommSemiring.{u1} Î²] (l : Filter.{u2} Î±) (k : Î± -> Î²), Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k (OfNat.ofNat.{max u2 u1} (Î± -> Î²) 0 (Zero.toOfNat0.{max u2 u1} (Î± -> Î²) (Pi.instZero.{u2, u1} Î± (fun (a._@.Mathlib.Analysis.Asymptotics.SuperpolynomialDecay._hyg.20 : Î±) => Î²) (fun (i : Î±) => CommMonoidWithZero.toZero.{u1} Î² (CommSemiring.toCommMonoidWithZero.{u1} Î² _inst_2)))))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_zero Asymptotics.superpolynomialDecay_zeroâ‚“'. -/
@[simp]
theorem superpolynomialDecay_zero (l : Filter Î±) (k : Î± â†’ Î²) : SuperpolynomialDecay l k 0 :=
  fun z => by simpa only [Pi.zero_apply, MulZeroClass.mul_zero] using tendsto_const_nhds
#align asymptotics.superpolynomial_decay_zero Asymptotics.superpolynomialDecay_zero

/- warning: asymptotics.superpolynomial_decay.add -> Asymptotics.SuperpolynomialDecay.add is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousAdd.{u2} Î² _inst_1 (Distrib.toHasAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k g) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHAdd.{max u1 u2} (Î± -> Î²) (Pi.instAdd.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))))) f g))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousAdd.{u2} Î² _inst_1 (Distrib.toAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k g) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHAdd.{max u1 u2} (Î± -> Î²) (Pi.instAdd.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))))) f g))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.add Asymptotics.SuperpolynomialDecay.addâ‚“'. -/
theorem SuperpolynomialDecay.add [ContinuousAdd Î²] (hf : SuperpolynomialDecay l k f)
    (hg : SuperpolynomialDecay l k g) : SuperpolynomialDecay l k (f + g) := fun z => by
  simpa only [mul_add, add_zero, Pi.add_apply] using (hf z).add (hg z)
#align asymptotics.superpolynomial_decay.add Asymptotics.SuperpolynomialDecay.add

/- warning: asymptotics.superpolynomial_decay.mul -> Asymptotics.SuperpolynomialDecay.mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k g) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))))) f g))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k g) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))) f g))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.mul Asymptotics.SuperpolynomialDecay.mulâ‚“'. -/
theorem SuperpolynomialDecay.mul [ContinuousMul Î²] (hf : SuperpolynomialDecay l k f)
    (hg : SuperpolynomialDecay l k g) : SuperpolynomialDecay l k (f * g) := fun z => by
  simpa only [mul_assoc, one_mul, MulZeroClass.mul_zero, pow_zero] using (hf z).mul (hg 0)
#align asymptotics.superpolynomial_decay.mul Asymptotics.SuperpolynomialDecay.mul

/- warning: asymptotics.superpolynomial_decay.mul_const -> Asymptotics.SuperpolynomialDecay.mul_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (c : Î²), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))) (f n) c))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (c : Î²), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))) (f n) c))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.mul_const Asymptotics.SuperpolynomialDecay.mul_constâ‚“'. -/
theorem SuperpolynomialDecay.mul_const [ContinuousMul Î²] (hf : SuperpolynomialDecay l k f) (c : Î²) :
    SuperpolynomialDecay l k fun n => f n * c := fun z => by
  simpa only [â† mul_assoc, MulZeroClass.zero_mul] using tendsto.mul_const c (hf z)
#align asymptotics.superpolynomial_decay.mul_const Asymptotics.SuperpolynomialDecay.mul_const

/- warning: asymptotics.superpolynomial_decay.const_mul -> Asymptotics.SuperpolynomialDecay.const_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (c : Î²), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))) c (f n)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (c : Î²), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))) c (f n)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.const_mul Asymptotics.SuperpolynomialDecay.const_mulâ‚“'. -/
theorem SuperpolynomialDecay.const_mul [ContinuousMul Î²] (hf : SuperpolynomialDecay l k f) (c : Î²) :
    SuperpolynomialDecay l k fun n => c * f n :=
  (hf.mul_const c).congr fun _ => mul_comm _ _
#align asymptotics.superpolynomial_decay.const_mul Asymptotics.SuperpolynomialDecay.const_mul

/- warning: asymptotics.superpolynomial_decay.param_mul -> Asymptotics.SuperpolynomialDecay.param_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))))) k f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : CommSemiring.{u1} Î²], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocSemiring.toMul.{u1} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î² (Semiring.toNonAssocSemiring.{u1} Î² (CommSemiring.toSemiring.{u1} Î² _inst_2)))))) k f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.param_mul Asymptotics.SuperpolynomialDecay.param_mulâ‚“'. -/
theorem SuperpolynomialDecay.param_mul (hf : SuperpolynomialDecay l k f) :
    SuperpolynomialDecay l k (k * f) := fun z =>
  tendsto_nhds.2 fun s hs hs0 =>
    l.sets_of_superset ((tendsto_nhds.1 (hf <| z + 1)) s hs hs0) fun x hx => by
      simpa only [Set.mem_preimage, Pi.mul_apply, â† mul_assoc, â† pow_succ'] using hx
#align asymptotics.superpolynomial_decay.param_mul Asymptotics.SuperpolynomialDecay.param_mul

/- warning: asymptotics.superpolynomial_decay.mul_param -> Asymptotics.SuperpolynomialDecay.mul_param is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))))) f k))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : CommSemiring.{u1} Î²], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k f) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocSemiring.toMul.{u1} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î² (Semiring.toNonAssocSemiring.{u1} Î² (CommSemiring.toSemiring.{u1} Î² _inst_2)))))) f k))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.mul_param Asymptotics.SuperpolynomialDecay.mul_paramâ‚“'. -/
theorem SuperpolynomialDecay.mul_param (hf : SuperpolynomialDecay l k f) :
    SuperpolynomialDecay l k (f * k) :=
  hf.param_mul.congr fun _ => mul_comm _ _
#align asymptotics.superpolynomial_decay.mul_param Asymptotics.SuperpolynomialDecay.mul_param

/- warning: asymptotics.superpolynomial_decay.param_pow_mul -> Asymptotics.SuperpolynomialDecay.param_pow_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (n : Nat), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))))) (HPow.hPow.{max u1 u2, 0, max u1 u2} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u1 u2, 0} (Î± -> Î²) Nat (Pi.hasPow.{u1, u2, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u2} Î² (MonoidWithZero.toMonoid.{u2} Î² (Semiring.toMonoidWithZero.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))) k n) f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : CommSemiring.{u1} Î²], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k f) -> (forall (n : Nat), Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocSemiring.toMul.{u1} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î² (Semiring.toNonAssocSemiring.{u1} Î² (CommSemiring.toSemiring.{u1} Î² _inst_2)))))) (HPow.hPow.{max u2 u1, 0, max u2 u1} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u2 u1, 0} (Î± -> Î²) Nat (Pi.instPow.{u2, u1, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u1} Î² (MonoidWithZero.toMonoid.{u1} Î² (Semiring.toMonoidWithZero.{u1} Î² (CommSemiring.toSemiring.{u1} Î² _inst_2)))))) k n) f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.param_pow_mul Asymptotics.SuperpolynomialDecay.param_pow_mulâ‚“'. -/
theorem SuperpolynomialDecay.param_pow_mul (hf : SuperpolynomialDecay l k f) (n : â„•) :
    SuperpolynomialDecay l k (k ^ n * f) :=
  by
  induction' n with n hn
  Â· simpa only [one_mul, pow_zero] using hf
  Â· simpa only [pow_succ, mul_assoc] using hn.param_mul
#align asymptotics.superpolynomial_decay.param_pow_mul Asymptotics.SuperpolynomialDecay.param_pow_mul

/- warning: asymptotics.superpolynomial_decay.mul_param_pow -> Asymptotics.SuperpolynomialDecay.mul_param_pow is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (n : Nat), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))))) f (HPow.hPow.{max u1 u2, 0, max u1 u2} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u1 u2, 0} (Î± -> Î²) Nat (Pi.hasPow.{u1, u2, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u2} Î² (MonoidWithZero.toMonoid.{u2} Î² (Semiring.toMonoidWithZero.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))) k n)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : CommSemiring.{u1} Î²], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k f) -> (forall (n : Nat), Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 _inst_2 l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocSemiring.toMul.{u1} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î² (Semiring.toNonAssocSemiring.{u1} Î² (CommSemiring.toSemiring.{u1} Î² _inst_2)))))) f (HPow.hPow.{max u2 u1, 0, max u2 u1} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u2 u1, 0} (Î± -> Î²) Nat (Pi.instPow.{u2, u1, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u1} Î² (MonoidWithZero.toMonoid.{u1} Î² (Semiring.toMonoidWithZero.{u1} Î² (CommSemiring.toSemiring.{u1} Î² _inst_2)))))) k n)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.mul_param_pow Asymptotics.SuperpolynomialDecay.mul_param_powâ‚“'. -/
theorem SuperpolynomialDecay.mul_param_pow (hf : SuperpolynomialDecay l k f) (n : â„•) :
    SuperpolynomialDecay l k (f * k ^ n) :=
  (hf.param_pow_mul n).congr fun _ => mul_comm _ _
#align asymptotics.superpolynomial_decay.mul_param_pow Asymptotics.SuperpolynomialDecay.mul_param_pow

/- warning: asymptotics.superpolynomial_decay.polynomial_mul -> Asymptotics.SuperpolynomialDecay.polynomial_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousAdd.{u2} Î² _inst_1 (Distrib.toHasAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))] [_inst_4 : ContinuousMul.{u2} Î² _inst_1 (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (p : Polynomial.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (x : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))) (Polynomial.eval.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2) (k x) p) (f x)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousAdd.{u2} Î² _inst_1 (Distrib.toAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))] [_inst_4 : ContinuousMul.{u2} Î² _inst_1 (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (p : Polynomial.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (x : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))) (Polynomial.eval.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2) (k x) p) (f x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.polynomial_mul Asymptotics.SuperpolynomialDecay.polynomial_mulâ‚“'. -/
theorem SuperpolynomialDecay.polynomial_mul [ContinuousAdd Î²] [ContinuousMul Î²]
    (hf : SuperpolynomialDecay l k f) (p : Î²[X]) :
    SuperpolynomialDecay l k fun x => (p.eval <| k x) * f x :=
  Polynomial.induction_on' p (fun p q hp hq => by simpa [add_mul] using hp.add hq) fun n c => by
    simpa [mul_assoc] using (hf.param_pow_mul n).const_mul c
#align asymptotics.superpolynomial_decay.polynomial_mul Asymptotics.SuperpolynomialDecay.polynomial_mul

/- warning: asymptotics.superpolynomial_decay.mul_polynomial -> Asymptotics.SuperpolynomialDecay.mul_polynomial is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousAdd.{u2} Î² _inst_1 (Distrib.toHasAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))] [_inst_4 : ContinuousMul.{u2} Î² _inst_1 (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (p : Polynomial.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (x : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))) (f x) (Polynomial.eval.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2) (k x) p)))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : CommSemiring.{u2} Î²] [_inst_3 : ContinuousAdd.{u2} Î² _inst_1 (Distrib.toAdd.{u2} Î² (NonUnitalNonAssocSemiring.toDistrib.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)))))] [_inst_4 : ContinuousMul.{u2} Î² _inst_1 (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k f) -> (forall (p : Polynomial.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2)), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 _inst_2 l k (fun (x : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (NonUnitalNonAssocSemiring.toMul.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2))))) (f x) (Polynomial.eval.{u2} Î² (CommSemiring.toSemiring.{u2} Î² _inst_2) (k x) p)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.mul_polynomial Asymptotics.SuperpolynomialDecay.mul_polynomialâ‚“'. -/
theorem SuperpolynomialDecay.mul_polynomial [ContinuousAdd Î²] [ContinuousMul Î²]
    (hf : SuperpolynomialDecay l k f) (p : Î²[X]) :
    SuperpolynomialDecay l k fun x => f x * (p.eval <| k x) :=
  (hf.polynomial_mul p).congr fun _ => mul_comm _ _
#align asymptotics.superpolynomial_decay.mul_polynomial Asymptotics.SuperpolynomialDecay.mul_polynomial

end CommSemiring

section OrderedCommSemiring

variable [TopologicalSpace Î²] [OrderedCommSemiring Î²] [OrderTopology Î²]

/- warning: asymptotics.superpolynomial_decay.trans_eventually_le -> Asymptotics.SuperpolynomialDecay.trans_eventuallyLE is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} {g' : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : OrderedCommSemiring.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² (OrderedSemiring.toOrderedAddCommMonoid.{u2} Î² (OrderedCommSemiring.toOrderedSemiring.{u2} Î² _inst_2))))], (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² (OrderedSemiring.toOrderedAddCommMonoid.{u2} Î² (OrderedCommSemiring.toOrderedSemiring.{u2} Î² _inst_2))))) l (OfNat.ofNat.{max u1 u2} (Î± -> Î²) 0 (OfNat.mk.{max u1 u2} (Î± -> Î²) 0 (Zero.zero.{max u1 u2} (Î± -> Î²) (Pi.instZero.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => MulZeroClass.toHasZero.{u2} Î² (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} Î² (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} Î² (Semiring.toNonAssocSemiring.{u2} Î² (OrderedSemiring.toSemiring.{u2} Î² (OrderedCommSemiring.toOrderedSemiring.{u2} Î² _inst_2)))))))))) k) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (OrderedCommSemiring.toCommSemiring.{u2} Î² _inst_2) l k g) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (OrderedCommSemiring.toCommSemiring.{u2} Î² _inst_2) l k g') -> (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² (OrderedSemiring.toOrderedAddCommMonoid.{u2} Î² (OrderedCommSemiring.toOrderedSemiring.{u2} Î² _inst_2))))) l g f) -> (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² (OrderedSemiring.toOrderedAddCommMonoid.{u2} Î² (OrderedCommSemiring.toOrderedSemiring.{u2} Î² _inst_2))))) l f g') -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (OrderedCommSemiring.toCommSemiring.{u2} Î² _inst_2) l k f)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} {g' : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : OrderedCommSemiring.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (OrderedSemiring.toPartialOrder.{u1} Î² (OrderedCommSemiring.toOrderedSemiring.{u1} Î² _inst_2)))], (Filter.EventuallyLE.{u2, u1} Î± Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedSemiring.toPartialOrder.{u1} Î² (OrderedCommSemiring.toOrderedSemiring.{u1} Î² _inst_2)))) l (OfNat.ofNat.{max u2 u1} (Î± -> Î²) 0 (Zero.toOfNat0.{max u2 u1} (Î± -> Î²) (Pi.instZero.{u2, u1} Î± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.21857 : Î±) => Î²) (fun (i : Î±) => CommMonoidWithZero.toZero.{u1} Î² (CommSemiring.toCommMonoidWithZero.{u1} Î² (OrderedCommSemiring.toCommSemiring.{u1} Î² _inst_2)))))) k) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (OrderedCommSemiring.toCommSemiring.{u1} Î² _inst_2) l k g) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (OrderedCommSemiring.toCommSemiring.{u1} Î² _inst_2) l k g') -> (Filter.EventuallyLE.{u2, u1} Î± Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedSemiring.toPartialOrder.{u1} Î² (OrderedCommSemiring.toOrderedSemiring.{u1} Î² _inst_2)))) l g f) -> (Filter.EventuallyLE.{u2, u1} Î± Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedSemiring.toPartialOrder.{u1} Î² (OrderedCommSemiring.toOrderedSemiring.{u1} Î² _inst_2)))) l f g') -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (OrderedCommSemiring.toCommSemiring.{u1} Î² _inst_2) l k f)
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.trans_eventually_le Asymptotics.SuperpolynomialDecay.trans_eventuallyLEâ‚“'. -/
theorem SuperpolynomialDecay.trans_eventuallyLE (hk : 0 â‰¤á¶ [l] k) (hg : SuperpolynomialDecay l k g)
    (hg' : SuperpolynomialDecay l k g') (hfg : g â‰¤á¶ [l] f) (hfg' : f â‰¤á¶ [l] g') :
    SuperpolynomialDecay l k f := fun z =>
  tendsto_of_tendsto_of_tendsto_of_le_of_le' (hg z) (hg' z)
    (hfg.mp (hk.mono fun x hx hx' => mul_le_mul_of_nonneg_left hx' (pow_nonneg hx z)))
    (hfg'.mp (hk.mono fun x hx hx' => mul_le_mul_of_nonneg_left hx' (pow_nonneg hx z)))
#align asymptotics.superpolynomial_decay.trans_eventually_le Asymptotics.SuperpolynomialDecay.trans_eventuallyLE

end OrderedCommSemiring

section LinearOrderedCommRing

variable [TopologicalSpace Î²] [LinearOrderedCommRing Î²] [OrderTopology Î²]

variable (l k f)

/- warning: asymptotics.superpolynomial_decay_iff_abs_tendsto_zero -> Asymptotics.superpolynomialDecay_iff_abs_tendsto_zero is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedCommRing.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))], Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u2} Î² (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} Î² (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} Î² _inst_2))) l k f) (forall (n : Nat), Filter.Tendsto.{u1, u2} Î± Î² (fun (a : Î±) => Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (HPow.hPow.{u2, 0, u2} Î² Nat Î² (instHPow.{u2, 0} Î² Nat (Monoid.Pow.{u2} Î² (Ring.toMonoid.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (k a) n) (f a))) l (nhds.{u2} Î² _inst_1 (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (MulZeroClass.toHasZero.{u2} Î² (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} Î² (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} (l : Filter.{u2} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedCommRing.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))], Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) l k f) (forall (n : Nat), Filter.Tendsto.{u2, u1} Î± Î² (fun (a : Î±) => Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))))) (HMul.hMul.{u1, u1, u1} Î² Î² Î² (instHMul.{u1} Î² (NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))))) (HPow.hPow.{u1, 0, u1} Î² Nat Î² (instHPow.{u1, 0} Î² Nat (Monoid.Pow.{u1} Î² (MonoidWithZero.toMonoid.{u1} Î² (Semiring.toMonoidWithZero.{u1} Î² (StrictOrderedSemiring.toSemiring.{u1} Î² (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î² (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2)))))))) (k a) n) (f a))) l (nhds.{u1} Î² _inst_1 (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (CommMonoidWithZero.toZero.{u1} Î² (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} Î² (IsDomain.toCancelCommMonoidWithZero.{u1} Î² (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) (LinearOrderedRing.isDomain.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_abs_tendsto_zero Asymptotics.superpolynomialDecay_iff_abs_tendsto_zeroâ‚“'. -/
theorem superpolynomialDecay_iff_abs_tendsto_zero :
    SuperpolynomialDecay l k f â†” âˆ€ n : â„•, Tendsto (fun a : Î± => |k a ^ n * f a|) l (ð“ 0) :=
  âŸ¨fun h z => (tendsto_zero_iff_abs_tendsto_zero _).1 (h z), fun h z =>
    (tendsto_zero_iff_abs_tendsto_zero _).2 (h z)âŸ©
#align asymptotics.superpolynomial_decay_iff_abs_tendsto_zero Asymptotics.superpolynomialDecay_iff_abs_tendsto_zero

/- warning: asymptotics.superpolynomial_decay_iff_superpolynomial_decay_abs -> Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_abs is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedCommRing.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))], Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u2} Î² (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} Î² (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} Î² _inst_2))) l k f) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u2} Î² (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} Î² (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} Î² _inst_2))) l (fun (a : Î±) => Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (k a)) (fun (a : Î±) => Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (f a)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} (l : Filter.{u2} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedCommRing.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))], Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) l k f) (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) l (fun (a : Î±) => Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))))) (k a)) (fun (a : Î±) => Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))))) (f a)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_superpolynomial_decay_abs Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_absâ‚“'. -/
theorem superpolynomialDecay_iff_superpolynomialDecay_abs :
    SuperpolynomialDecay l k f â†” SuperpolynomialDecay l (fun a => |k a|) fun a => |f a| :=
  (superpolynomialDecay_iff_abs_tendsto_zero l k f).trans
    (by simp_rw [superpolynomial_decay, abs_mul, abs_pow])
#align asymptotics.superpolynomial_decay_iff_superpolynomial_decay_abs Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_abs

variable {l k f}

/- warning: asymptotics.superpolynomial_decay.trans_eventually_abs_le -> Asymptotics.SuperpolynomialDecay.trans_eventually_abs_le is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedCommRing.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u2} Î² (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} Î² (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} Î² _inst_2))) l k f) -> (Filter.EventuallyLE.{u1, u2} Î± Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) l (Function.comp.{succ u1, succ u2, succ u2} Î± Î² Î² (Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2))))))) g) (Function.comp.{succ u1, succ u2, succ u2} Î± Î² Î² (Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2))))))) f)) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u2} Î² (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} Î² (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} Î² _inst_2))) l k g)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedCommRing.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) l k f) -> (Filter.EventuallyLE.{u2, u1} Î± Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))) l (Function.comp.{succ u2, succ u1, succ u1} Î± Î² Î² (Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))))))) g) (Function.comp.{succ u2, succ u1, succ u1} Î± Î² Î² (Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))))))) f)) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) l k g)
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.trans_eventually_abs_le Asymptotics.SuperpolynomialDecay.trans_eventually_abs_leâ‚“'. -/
theorem SuperpolynomialDecay.trans_eventually_abs_le (hf : SuperpolynomialDecay l k f)
    (hfg : abs âˆ˜ g â‰¤á¶ [l] abs âˆ˜ f) : SuperpolynomialDecay l k g :=
  by
  rw [superpolynomial_decay_iff_abs_tendsto_zero] at hfâŠ¢
  refine' fun z =>
    tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds (hf z)
      (eventually_of_forall fun x => abs_nonneg _) (hfg.mono fun x hx => _)
  calc
    |k x ^ z * g x| = |k x ^ z| * |g x| := abs_mul (k x ^ z) (g x)
    _ â‰¤ |k x ^ z| * |f x| := (mul_le_mul le_rfl hx (abs_nonneg _) (abs_nonneg _))
    _ = |k x ^ z * f x| := (abs_mul (k x ^ z) (f x)).symm
    
#align asymptotics.superpolynomial_decay.trans_eventually_abs_le Asymptotics.SuperpolynomialDecay.trans_eventually_abs_le

/- warning: asymptotics.superpolynomial_decay.trans_abs_le -> Asymptotics.SuperpolynomialDecay.trans_abs_le is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedCommRing.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))], (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u2} Î² (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} Î² (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} Î² _inst_2))) l k f) -> (forall (x : Î±), LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (g x)) (Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (StrictOrderedRing.toRing.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² _inst_2)))))) (f x))) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u2} Î² (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} Î² (LinearOrderedCommRing.toStrictOrderedCommRing.{u2} Î² _inst_2))) l k g)
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} {g : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedCommRing.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))], (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) l k f) -> (forall (x : Î±), LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))) (Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))))) (g x)) (Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (StrictOrderedRing.toRing.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² _inst_2))))))) (f x))) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (StrictOrderedCommSemiring.toCommSemiring.{u1} Î² (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} Î² (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} Î² _inst_2))) l k g)
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.trans_abs_le Asymptotics.SuperpolynomialDecay.trans_abs_leâ‚“'. -/
theorem SuperpolynomialDecay.trans_abs_le (hf : SuperpolynomialDecay l k f)
    (hfg : âˆ€ x, |g x| â‰¤ |f x|) : SuperpolynomialDecay l k g :=
  hf.trans_eventually_abs_le (eventually_of_forall hfg)
#align asymptotics.superpolynomial_decay.trans_abs_le Asymptotics.SuperpolynomialDecay.trans_abs_le

end LinearOrderedCommRing

section Field

variable [TopologicalSpace Î²] [Field Î²] (l k f)

/- warning: asymptotics.superpolynomial_decay_mul_const_iff -> Asymptotics.superpolynomialDecay_mul_const_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : Field.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2))))] {c : Î²}, (Ne.{succ u2} Î² c (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (MulZeroClass.toHasZero.{u2} Î² (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} Î² (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2))))))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2))))) (f n) c)) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k f))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : Field.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (NonUnitalNonAssocRing.toMul.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2)))))] {c : Î²}, (Ne.{succ u2} Î² c (OfNat.ofNat.{u2} Î² 0 (Zero.toOfNat0.{u2} Î² (CommMonoidWithZero.toZero.{u2} Î² (CommGroupWithZero.toCommMonoidWithZero.{u2} Î² (Semifield.toCommGroupWithZero.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (NonUnitalNonAssocRing.toMul.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2)))))) (f n) c)) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_mul_const_iff Asymptotics.superpolynomialDecay_mul_const_iffâ‚“'. -/
theorem superpolynomialDecay_mul_const_iff [ContinuousMul Î²] {c : Î²} (hc0 : c â‰  0) :
    (SuperpolynomialDecay l k fun n => f n * c) â†” SuperpolynomialDecay l k f :=
  âŸ¨fun h => (h.mul_const câ»Â¹).congr fun x => by simp [mul_assoc, mul_inv_cancel hc0], fun h =>
    h.mul_const câŸ©
#align asymptotics.superpolynomial_decay_mul_const_iff Asymptotics.superpolynomialDecay_mul_const_iff

/- warning: asymptotics.superpolynomial_decay_const_mul_iff -> Asymptotics.superpolynomialDecay_const_mul_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : Field.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2))))] {c : Î²}, (Ne.{succ u2} Î² c (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (MulZeroClass.toHasZero.{u2} Î² (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} Î² (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2))))))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2))))) c (f n))) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k f))
but is expected to have type
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : Field.{u2} Î²] [_inst_3 : ContinuousMul.{u2} Î² _inst_1 (NonUnitalNonAssocRing.toMul.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2)))))] {c : Î²}, (Ne.{succ u2} Î² c (OfNat.ofNat.{u2} Î² 0 (Zero.toOfNat0.{u2} Î² (CommMonoidWithZero.toZero.{u2} Î² (CommGroupWithZero.toCommMonoidWithZero.{u2} Î² (Semifield.toCommGroupWithZero.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k (fun (n : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (NonUnitalNonAssocRing.toMul.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² _inst_2)))))) c (f n))) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (Field.toSemifield.{u2} Î² _inst_2)) l k f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_const_mul_iff Asymptotics.superpolynomialDecay_const_mul_iffâ‚“'. -/
theorem superpolynomialDecay_const_mul_iff [ContinuousMul Î²] {c : Î²} (hc0 : c â‰  0) :
    (SuperpolynomialDecay l k fun n => c * f n) â†” SuperpolynomialDecay l k f :=
  âŸ¨fun h => (h.const_mul câ»Â¹).congr fun x => by simp [â† mul_assoc, inv_mul_cancel hc0], fun h =>
    h.const_mul câŸ©
#align asymptotics.superpolynomial_decay_const_mul_iff Asymptotics.superpolynomialDecay_const_mul_iff

variable {l k f}

end Field

section LinearOrderedField

variable [TopologicalSpace Î²] [LinearOrderedField Î²] [OrderTopology Î²]

variable (f)

/- warning: asymptotics.superpolynomial_decay_iff_abs_is_bounded_under -> Asymptotics.superpolynomialDecay_iff_abs_isBoundedUnder is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f) (forall (z : Nat), Filter.IsBoundedUnder.{u2, u1} Î² Î± (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) l (fun (a : Î±) => Abs.abs.{u2} Î² (Neg.toHasAbs.{u2} Î² (SubNegMonoid.toHasNeg.{u2} Î² (AddGroup.toSubNegMonoid.{u2} Î² (AddGroupWithOne.toAddGroup.{u2} Î² (AddCommGroupWithOne.toAddGroupWithOne.{u2} Î² (Ring.toAddCommGroupWithOne.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} Î² (Lattice.toSemilatticeSup.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedRing.toLinearOrder.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))) (HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2)))))) (HPow.hPow.{u2, 0, u2} Î² Nat Î² (instHPow.{u2, 0} Î² Nat (Monoid.Pow.{u2} Î² (Ring.toMonoid.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2)))))) (k a) z) (f a)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f) (forall (z : Nat), Filter.IsBoundedUnder.{u1, u2} Î² Î± (fun (x._@.Mathlib.Analysis.Asymptotics.SuperpolynomialDecay._hyg.1981 : Î²) (x._@.Mathlib.Analysis.Asymptotics.SuperpolynomialDecay._hyg.1983 : Î²) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))) x._@.Mathlib.Analysis.Asymptotics.SuperpolynomialDecay._hyg.1981 x._@.Mathlib.Analysis.Asymptotics.SuperpolynomialDecay._hyg.1983) l (fun (a : Î±) => Abs.abs.{u1} Î² (Neg.toHasAbs.{u1} Î² (Ring.toNeg.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2)))) (SemilatticeSup.toSup.{u1} Î² (Lattice.toSemilatticeSup.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedRing.toLinearOrder.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))))) (HMul.hMul.{u1, u1, u1} Î² Î² Î² (instHMul.{u1} Î² (NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2))))))) (HPow.hPow.{u1, 0, u1} Î² Nat Î² (instHPow.{u1, 0} Î² Nat (Monoid.Pow.{u1} Î² (MonoidWithZero.toMonoid.{u1} Î² (Semiring.toMonoidWithZero.{u1} Î² (DivisionSemiring.toSemiring.{u1} Î² (Semifield.toDivisionSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2)))))))) (k a) z) (f a)))))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_abs_is_bounded_under Asymptotics.superpolynomialDecay_iff_abs_isBoundedUnderâ‚“'. -/
theorem superpolynomialDecay_iff_abs_isBoundedUnder (hk : Tendsto k l atTop) :
    SuperpolynomialDecay l k f â†” âˆ€ z : â„•, IsBoundedUnder (Â· â‰¤ Â·) l fun a : Î± => |k a ^ z * f a| :=
  by
  refine'
    âŸ¨fun h z => tendsto.is_bounded_under_le (tendsto.abs (h z)), fun h =>
      (superpolynomial_decay_iff_abs_tendsto_zero l k f).2 fun z => _âŸ©
  obtain âŸ¨m, hmâŸ© := h (z + 1)
  have h1 : tendsto (fun a : Î± => (0 : Î²)) l (ð“ 0) := tendsto_const_nhds
  have h2 : tendsto (fun a : Î± => |(k a)â»Â¹| * m) l (ð“ 0) :=
    MulZeroClass.zero_mul m â–¸
      tendsto.mul_const m ((tendsto_zero_iff_abs_tendsto_zero _).1 hk.inv_tendsto_at_top)
  refine'
    tendsto_of_tendsto_of_tendsto_of_le_of_le' h1 h2 (eventually_of_forall fun x => abs_nonneg _)
      ((eventually_map.1 hm).mp _)
  refine' (hk.eventually_ne_at_top 0).mono fun x hk0 hx => _
  refine' Eq.trans_le _ (mul_le_mul_of_nonneg_left hx <| abs_nonneg (k x)â»Â¹)
  rw [â† abs_mul, â† mul_assoc, pow_succ, â† mul_assoc, inv_mul_cancel hk0, one_mul]
#align asymptotics.superpolynomial_decay_iff_abs_is_bounded_under Asymptotics.superpolynomialDecay_iff_abs_isBoundedUnder

/- warning: asymptotics.superpolynomial_decay_iff_zpow_tendsto_zero -> Asymptotics.superpolynomialDecay_iff_zpow_tendsto_zero is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f) (forall (z : Int), Filter.Tendsto.{u1, u2} Î± Î² (fun (a : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2)))))) (HPow.hPow.{u2, 0, u2} Î² Int Î² (instHPow.{u2, 0} Î² Int (DivInvMonoid.Pow.{u2} Î² (DivisionRing.toDivInvMonoid.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))) (k a) z) (f a)) l (nhds.{u2} Î² _inst_1 (OfNat.ofNat.{u2} Î² 0 (OfNat.mk.{u2} Î² 0 (Zero.zero.{u2} Î² (MulZeroClass.toHasZero.{u2} Î² (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} Î² (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u2} Î² (Ring.toNonAssocRing.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))))))))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f) (forall (z : Int), Filter.Tendsto.{u2, u1} Î± Î² (fun (a : Î±) => HMul.hMul.{u1, u1, u1} Î² Î² Î² (instHMul.{u1} Î² (NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2))))))) (HPow.hPow.{u1, 0, u1} Î² Int Î² (instHPow.{u1, 0} Î² Int (DivInvMonoid.Pow.{u1} Î² (DivisionRing.toDivInvMonoid.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2))))) (k a) z) (f a)) l (nhds.{u1} Î² _inst_1 (OfNat.ofNat.{u1} Î² 0 (Zero.toOfNat0.{u1} Î² (CommMonoidWithZero.toZero.{u1} Î² (CommGroupWithZero.toCommMonoidWithZero.{u1} Î² (Semifield.toCommGroupWithZero.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))))))))))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_zpow_tendsto_zero Asymptotics.superpolynomialDecay_iff_zpow_tendsto_zeroâ‚“'. -/
theorem superpolynomialDecay_iff_zpow_tendsto_zero (hk : Tendsto k l atTop) :
    SuperpolynomialDecay l k f â†” âˆ€ z : â„¤, Tendsto (fun a : Î± => k a ^ z * f a) l (ð“ 0) :=
  by
  refine' âŸ¨fun h z => _, fun h n => by simpa only [zpow_ofNat] using h (n : â„¤)âŸ©
  by_cases hz : 0 â‰¤ z
  Â· lift z to â„• using hz
    simpa using h z
  Â· have : tendsto (fun a => k a ^ z) l (ð“ 0) :=
      tendsto.comp (tendsto_zpow_atTop_zero (not_le.1 hz)) hk
    have h : tendsto f l (ð“ 0) := by simpa using h 0
    exact MulZeroClass.zero_mul (0 : Î²) â–¸ this.mul h
#align asymptotics.superpolynomial_decay_iff_zpow_tendsto_zero Asymptotics.superpolynomialDecay_iff_zpow_tendsto_zero

variable {f}

/- warning: asymptotics.superpolynomial_decay.param_zpow_mul -> Asymptotics.SuperpolynomialDecay.param_zpow_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f) -> (forall (z : Int), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (fun (a : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2)))))) (HPow.hPow.{u2, 0, u2} Î² Int Î² (instHPow.{u2, 0} Î² Int (DivInvMonoid.Pow.{u2} Î² (DivisionRing.toDivInvMonoid.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))) (k a) z) (f a)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f) -> (forall (z : Int), Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (fun (a : Î±) => HMul.hMul.{u1, u1, u1} Î² Î² Î² (instHMul.{u1} Î² (NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2))))))) (HPow.hPow.{u1, 0, u1} Î² Int Î² (instHPow.{u1, 0} Î² Int (DivInvMonoid.Pow.{u1} Î² (DivisionRing.toDivInvMonoid.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2))))) (k a) z) (f a)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.param_zpow_mul Asymptotics.SuperpolynomialDecay.param_zpow_mulâ‚“'. -/
theorem SuperpolynomialDecay.param_zpow_mul (hk : Tendsto k l atTop)
    (hf : SuperpolynomialDecay l k f) (z : â„¤) : SuperpolynomialDecay l k fun a => k a ^ z * f a :=
  by
  rw [superpolynomial_decay_iff_zpow_tendsto_zero _ hk] at hfâŠ¢
  refine' fun z' => (hf <| z' + z).congr' ((hk.eventually_ne_at_top 0).mono fun x hx => _)
  simp [zpow_addâ‚€ hx, mul_assoc, Pi.mul_apply]
#align asymptotics.superpolynomial_decay.param_zpow_mul Asymptotics.SuperpolynomialDecay.param_zpow_mul

/- warning: asymptotics.superpolynomial_decay.mul_param_zpow -> Asymptotics.SuperpolynomialDecay.mul_param_zpow is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f) -> (forall (z : Int), Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (fun (a : Î±) => HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2)))))) (f a) (HPow.hPow.{u2, 0, u2} Î² Int Î² (instHPow.{u2, 0} Î² Int (DivInvMonoid.Pow.{u2} Î² (DivisionRing.toDivInvMonoid.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))) (k a) z)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f) -> (forall (z : Int), Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (fun (a : Î±) => HMul.hMul.{u1, u1, u1} Î² Î² Î² (instHMul.{u1} Î² (NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2))))))) (f a) (HPow.hPow.{u1, 0, u1} Î² Int Î² (instHPow.{u1, 0} Î² Int (DivInvMonoid.Pow.{u1} Î² (DivisionRing.toDivInvMonoid.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2))))) (k a) z)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.mul_param_zpow Asymptotics.SuperpolynomialDecay.mul_param_zpowâ‚“'. -/
theorem SuperpolynomialDecay.mul_param_zpow (hk : Tendsto k l atTop)
    (hf : SuperpolynomialDecay l k f) (z : â„¤) : SuperpolynomialDecay l k fun a => f a * k a ^ z :=
  (hf.param_zpow_mul hk z).congr fun _ => mul_comm _ _
#align asymptotics.superpolynomial_decay.mul_param_zpow Asymptotics.SuperpolynomialDecay.mul_param_zpow

/- warning: asymptotics.superpolynomial_decay.inv_param_mul -> Asymptotics.SuperpolynomialDecay.inv_param_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) (Inv.inv.{max u1 u2} (Î± -> Î²) (Pi.instInv.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => DivInvMonoid.toHasInv.{u2} Î² (DivisionRing.toDivInvMonoid.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))) k) f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2)))))))) (Inv.inv.{max u2 u1} (Î± -> Î²) (Pi.instInv.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => LinearOrderedField.toInv.{u1} Î² _inst_2)) k) f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.inv_param_mul Asymptotics.SuperpolynomialDecay.inv_param_mulâ‚“'. -/
theorem SuperpolynomialDecay.inv_param_mul (hk : Tendsto k l atTop)
    (hf : SuperpolynomialDecay l k f) : SuperpolynomialDecay l k (kâ»Â¹ * f) := by
  simpa using hf.param_zpow_mul hk (-1)
#align asymptotics.superpolynomial_decay.inv_param_mul Asymptotics.SuperpolynomialDecay.inv_param_mul

/- warning: asymptotics.superpolynomial_decay.param_inv_mul -> Asymptotics.SuperpolynomialDecay.param_inv_mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f) -> (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) f (Inv.inv.{max u1 u2} (Î± -> Î²) (Pi.instInv.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => DivInvMonoid.toHasInv.{u2} Î² (DivisionRing.toDivInvMonoid.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))) k)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} {f : Î± -> Î²} [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f) -> (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2)))))))) f (Inv.inv.{max u2 u1} (Î± -> Î²) (Pi.instInv.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => LinearOrderedField.toInv.{u1} Î² _inst_2)) k)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay.param_inv_mul Asymptotics.SuperpolynomialDecay.param_inv_mulâ‚“'. -/
theorem SuperpolynomialDecay.param_inv_mul (hk : Tendsto k l atTop)
    (hf : SuperpolynomialDecay l k f) : SuperpolynomialDecay l k (f * kâ»Â¹) :=
  (hf.inv_param_mul hk).congr fun _ => mul_comm _ _
#align asymptotics.superpolynomial_decay.param_inv_mul Asymptotics.SuperpolynomialDecay.param_inv_mul

variable (f)

/- warning: asymptotics.superpolynomial_decay_param_mul_iff -> Asymptotics.superpolynomialDecay_param_mul_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) k f)) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2)))))))) k f)) (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_param_mul_iff Asymptotics.superpolynomialDecay_param_mul_iffâ‚“'. -/
theorem superpolynomialDecay_param_mul_iff (hk : Tendsto k l atTop) :
    SuperpolynomialDecay l k (k * f) â†” SuperpolynomialDecay l k f :=
  âŸ¨fun h =>
    (h.inv_param_mul hk).congr'
      ((hk.eventually_ne_atTop 0).mono fun x hx => by simp [â† mul_assoc, inv_mul_cancel hx]),
    fun h => h.param_mulâŸ©
#align asymptotics.superpolynomial_decay_param_mul_iff Asymptotics.superpolynomialDecay_param_mul_iff

/- warning: asymptotics.superpolynomial_decay_mul_param_iff -> Asymptotics.superpolynomialDecay_mul_param_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) f k)) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2)))))))) f k)) (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_mul_param_iff Asymptotics.superpolynomialDecay_mul_param_iffâ‚“'. -/
theorem superpolynomialDecay_mul_param_iff (hk : Tendsto k l atTop) :
    SuperpolynomialDecay l k (f * k) â†” SuperpolynomialDecay l k f := by
  simpa [mul_comm k] using superpolynomial_decay_param_mul_iff f hk
#align asymptotics.superpolynomial_decay_mul_param_iff Asymptotics.superpolynomialDecay_mul_param_iff

/- warning: asymptotics.superpolynomial_decay_param_pow_mul_iff -> Asymptotics.superpolynomialDecay_param_pow_mul_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (forall (n : Nat), Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) (HPow.hPow.{max u1 u2, 0, max u1 u2} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u1 u2, 0} (Î± -> Î²) Nat (Pi.hasPow.{u1, u2, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u2} Î² (Ring.toMonoid.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) k n) f)) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (forall (n : Nat), Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2)))))))) (HPow.hPow.{max u2 u1, 0, max u2 u1} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u2 u1, 0} (Î± -> Î²) Nat (Pi.instPow.{u2, u1, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u1} Î² (MonoidWithZero.toMonoid.{u1} Î² (Semiring.toMonoidWithZero.{u1} Î² (DivisionSemiring.toSemiring.{u1} Î² (Semifield.toDivisionSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))))))))) k n) f)) (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_param_pow_mul_iff Asymptotics.superpolynomialDecay_param_pow_mul_iffâ‚“'. -/
theorem superpolynomialDecay_param_pow_mul_iff (hk : Tendsto k l atTop) (n : â„•) :
    SuperpolynomialDecay l k (k ^ n * f) â†” SuperpolynomialDecay l k f :=
  by
  induction' n with n hn
  Â· simp
  Â·
    simpa [pow_succ, â† mul_comm k, mul_assoc,
      superpolynomial_decay_param_mul_iff (k ^ n * f) hk] using hn
#align asymptotics.superpolynomial_decay_param_pow_mul_iff Asymptotics.superpolynomialDecay_param_pow_mul_iff

/- warning: asymptotics.superpolynomial_decay_mul_param_pow_iff -> Asymptotics.superpolynomialDecay_mul_param_pow_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u2} Î²] [_inst_2 : LinearOrderedField.{u2} Î²] [_inst_3 : OrderTopology.{u2} Î² _inst_1 (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² _inst_2)))))))) -> (forall (n : Nat), Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u1 u2} (Î± -> Î²) (Pi.instMul.{u1, u2} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) f (HPow.hPow.{max u1 u2, 0, max u1 u2} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u1 u2, 0} (Î± -> Î²) Nat (Pi.hasPow.{u1, u2, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u2} Î² (Ring.toMonoid.{u2} Î² (DivisionRing.toRing.{u2} Î² (Field.toDivisionRing.{u2} Î² (LinearOrderedField.toField.{u2} Î² _inst_2))))))) k n))) (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² _inst_1 (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² _inst_2))) l k f))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : TopologicalSpace.{u1} Î²] [_inst_2 : LinearOrderedField.{u1} Î²] [_inst_3 : OrderTopology.{u1} Î² _inst_1 (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2)))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² _inst_2))))))) -> (forall (n : Nat), Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (Î± -> Î²) (Î± -> Î²) (Î± -> Î²) (instHMul.{max u2 u1} (Î± -> Î²) (Pi.instMul.{u2, u1} Î± (fun (á¾° : Î±) => Î²) (fun (i : Î±) => NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (DivisionRing.toRing.{u1} Î² (Field.toDivisionRing.{u1} Î² (LinearOrderedField.toField.{u1} Î² _inst_2)))))))) f (HPow.hPow.{max u2 u1, 0, max u2 u1} (Î± -> Î²) Nat (Î± -> Î²) (instHPow.{max u2 u1, 0} (Î± -> Î²) Nat (Pi.instPow.{u2, u1, 0} Î± Nat (fun (á¾° : Î±) => Î²) (fun (i : Î±) => Monoid.Pow.{u1} Î² (MonoidWithZero.toMonoid.{u1} Î² (Semiring.toMonoidWithZero.{u1} Î² (DivisionSemiring.toSemiring.{u1} Î² (Semifield.toDivisionSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))))))))) k n))) (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² _inst_1 (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² _inst_2))) l k f))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_mul_param_pow_iff Asymptotics.superpolynomialDecay_mul_param_pow_iffâ‚“'. -/
theorem superpolynomialDecay_mul_param_pow_iff (hk : Tendsto k l atTop) (n : â„•) :
    SuperpolynomialDecay l k (f * k ^ n) â†” SuperpolynomialDecay l k f := by
  simpa [mul_comm f] using superpolynomial_decay_param_pow_mul_iff f hk n
#align asymptotics.superpolynomial_decay_mul_param_pow_iff Asymptotics.superpolynomialDecay_mul_param_pow_iff

variable {f}

end LinearOrderedField

section NormedLinearOrderedField

variable [NormedLinearOrderedField Î²]

variable (l k f)

/- warning: asymptotics.superpolynomial_decay_iff_norm_tendsto_zero -> Asymptotics.superpolynomialDecay_iff_norm_tendsto_zero is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u2} Î²], Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedRing.toPseudoMetricSpace.{u2} Î² (SeminormedCommRing.toSemiNormedRing.{u2} Î² (NormedCommRing.toSeminormedCommRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1)))) l k f) (forall (n : Nat), Filter.Tendsto.{u1, 0} Î± Real (fun (a : Î±) => Norm.norm.{u2} Î² (NormedLinearOrderedField.toHasNorm.{u2} Î² _inst_1) (HMul.hMul.{u2, u2, u2} Î² Î² Î² (instHMul.{u2} Î² (Distrib.toHasMul.{u2} Î² (Ring.toDistrib.{u2} Î² (NormedRing.toRing.{u2} Î² (NormedCommRing.toNormedRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (HPow.hPow.{u2, 0, u2} Î² Nat Î² (instHPow.{u2, 0} Î² Nat (Monoid.Pow.{u2} Î² (Ring.toMonoid.{u2} Î² (NormedRing.toRing.{u2} Î² (NormedCommRing.toNormedRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (k a) n) (f a))) l (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} (l : Filter.{u2} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u1} Î²], Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedRing.toPseudoMetricSpace.{u1} Î² (SeminormedCommRing.toSeminormedRing.{u1} Î² (NormedCommRing.toSeminormedCommRing.{u1} Î² (NormedField.toNormedCommRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1))))))) (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1)))) l k f) (forall (n : Nat), Filter.Tendsto.{u2, 0} Î± Real (fun (a : Î±) => Norm.norm.{u1} Î² (NormedLinearOrderedField.toNorm.{u1} Î² _inst_1) (HMul.hMul.{u1, u1, u1} Î² Î² Î² (instHMul.{u1} Î² (NonUnitalNonAssocRing.toMul.{u1} Î² (NonAssocRing.toNonUnitalNonAssocRing.{u1} Î² (Ring.toNonAssocRing.{u1} Î² (NormedRing.toRing.{u1} Î² (NormedCommRing.toNormedRing.{u1} Î² (NormedField.toNormedCommRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1)))))))) (HPow.hPow.{u1, 0, u1} Î² Nat Î² (instHPow.{u1, 0} Î² Nat (Monoid.Pow.{u1} Î² (MonoidWithZero.toMonoid.{u1} Î² (Semiring.toMonoidWithZero.{u1} Î² (DivisionSemiring.toSemiring.{u1} Î² (Semifield.toDivisionSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1))))))))) (k a) n) (f a))) l (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_norm_tendsto_zero Asymptotics.superpolynomialDecay_iff_norm_tendsto_zeroâ‚“'. -/
theorem superpolynomialDecay_iff_norm_tendsto_zero :
    SuperpolynomialDecay l k f â†” âˆ€ n : â„•, Tendsto (fun a : Î± => â€–k a ^ n * f aâ€–) l (ð“ 0) :=
  âŸ¨fun h z => tendsto_zero_iff_norm_tendsto_zero.1 (h z), fun h z =>
    tendsto_zero_iff_norm_tendsto_zero.2 (h z)âŸ©
#align asymptotics.superpolynomial_decay_iff_norm_tendsto_zero Asymptotics.superpolynomialDecay_iff_norm_tendsto_zero

/- warning: asymptotics.superpolynomial_decay_iff_superpolynomial_decay_norm -> Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_norm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} (l : Filter.{u1} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u2} Î²], Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedRing.toPseudoMetricSpace.{u2} Î² (SeminormedCommRing.toSemiNormedRing.{u2} Î² (NormedCommRing.toSeminormedCommRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1)))) l k f) (Asymptotics.SuperpolynomialDecay.{u1, 0} Î± Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.commSemiring l (fun (a : Î±) => Norm.norm.{u2} Î² (NormedLinearOrderedField.toHasNorm.{u2} Î² _inst_1) (k a)) (fun (a : Î±) => Norm.norm.{u2} Î² (NormedLinearOrderedField.toHasNorm.{u2} Î² _inst_1) (f a)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} (l : Filter.{u2} Î±) (k : Î± -> Î²) (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u1} Î²], Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedRing.toPseudoMetricSpace.{u1} Î² (SeminormedCommRing.toSeminormedRing.{u1} Î² (NormedCommRing.toSeminormedCommRing.{u1} Î² (NormedField.toNormedCommRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1))))))) (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1)))) l k f) (Asymptotics.SuperpolynomialDecay.{u2, 0} Î± Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instCommSemiringReal l (fun (a : Î±) => Norm.norm.{u1} Î² (NormedLinearOrderedField.toNorm.{u1} Î² _inst_1) (k a)) (fun (a : Î±) => Norm.norm.{u1} Î² (NormedLinearOrderedField.toNorm.{u1} Î² _inst_1) (f a)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_superpolynomial_decay_norm Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_normâ‚“'. -/
theorem superpolynomialDecay_iff_superpolynomialDecay_norm :
    SuperpolynomialDecay l k f â†” SuperpolynomialDecay l (fun a => â€–k aâ€–) fun a => â€–f aâ€– :=
  (superpolynomialDecay_iff_norm_tendsto_zero l k f).trans (by simp [superpolynomial_decay])
#align asymptotics.superpolynomial_decay_iff_superpolynomial_decay_norm Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_norm

variable {l k}

variable [OrderTopology Î²]

/- warning: asymptotics.superpolynomial_decay_iff_is_O -> Asymptotics.superpolynomialDecay_iff_isBigO is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u2} Î²] [_inst_2 : OrderTopology.{u2} Î² (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedRing.toPseudoMetricSpace.{u2} Î² (SeminormedCommRing.toSemiNormedRing.{u2} Î² (NormedCommRing.toSeminormedCommRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1)))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1))))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedRing.toPseudoMetricSpace.{u2} Î² (SeminormedCommRing.toSemiNormedRing.{u2} Î² (NormedCommRing.toSeminormedCommRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1)))) l k f) (forall (z : Int), Asymptotics.IsBigO.{u1, u2, u2} Î± Î² Î² (NormedLinearOrderedField.toHasNorm.{u2} Î² _inst_1) (NormedLinearOrderedField.toHasNorm.{u2} Î² _inst_1) l f (fun (a : Î±) => HPow.hPow.{u2, 0, u2} Î² Int Î² (instHPow.{u2, 0} Î² Int (DivInvMonoid.Pow.{u2} Î² (DivisionRing.toDivInvMonoid.{u2} Î² (NormedDivisionRing.toDivisionRing.{u2} Î² (NormedField.toNormedDivisionRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1)))))) (k a) z)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u1} Î²] [_inst_2 : OrderTopology.{u1} Î² (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedRing.toPseudoMetricSpace.{u1} Î² (SeminormedCommRing.toSeminormedRing.{u1} Î² (NormedCommRing.toSeminormedCommRing.{u1} Î² (NormedField.toNormedCommRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1))))))) (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1))))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1)))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedRing.toPseudoMetricSpace.{u1} Î² (SeminormedCommRing.toSeminormedRing.{u1} Î² (NormedCommRing.toSeminormedCommRing.{u1} Î² (NormedField.toNormedCommRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1))))))) (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1)))) l k f) (forall (z : Int), Asymptotics.IsBigO.{u2, u1, u1} Î± Î² Î² (NormedLinearOrderedField.toNorm.{u1} Î² _inst_1) (NormedLinearOrderedField.toNorm.{u1} Î² _inst_1) l f (fun (a : Î±) => HPow.hPow.{u1, 0, u1} Î² Int Î² (instHPow.{u1, 0} Î² Int (DivInvMonoid.Pow.{u1} Î² (DivisionRing.toDivInvMonoid.{u1} Î² (NormedDivisionRing.toDivisionRing.{u1} Î² (NormedField.toNormedDivisionRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1)))))) (k a) z)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_is_O Asymptotics.superpolynomialDecay_iff_isBigOâ‚“'. -/
theorem superpolynomialDecay_iff_isBigO (hk : Tendsto k l atTop) :
    SuperpolynomialDecay l k f â†” âˆ€ z : â„¤, f =O[l] fun a : Î± => k a ^ z :=
  by
  refine' (superpolynomial_decay_iff_zpow_tendsto_zero f hk).trans _
  have hk0 : âˆ€á¶  x in l, k x â‰  0 := hk.eventually_ne_at_top 0
  refine' âŸ¨fun h z => _, fun h z => _âŸ©
  Â· refine' is_O_of_div_tendsto_nhds (hk0.mono fun x hx hxz => absurd (zpow_eq_zero hxz) hx) 0 _
    have : (fun a : Î± => k a ^ z)â»Â¹ = fun a : Î± => k a ^ (-z) := funext fun x => by simp
    rw [div_eq_mul_inv, mul_comm f, this]
    exact h (-z)
  Â· suffices : (fun a : Î± => k a ^ z * f a) =O[l] fun a : Î± => (k a)â»Â¹
    exact is_O.trans_tendsto this hk.inv_tendsto_at_top
    refine'
      ((is_O_refl (fun a => k a ^ z) l).mul (h (-(z + 1)))).trans
        (is_O.of_bound 1 <| hk0.mono fun a ha0 => _)
    simp only [one_mul, neg_add z 1, zpow_addâ‚€ ha0, â† mul_assoc, zpow_neg,
      mul_inv_cancel (zpow_ne_zero z ha0), zpow_one]
#align asymptotics.superpolynomial_decay_iff_is_O Asymptotics.superpolynomialDecay_iff_isBigO

/- warning: asymptotics.superpolynomial_decay_iff_is_o -> Asymptotics.superpolynomialDecay_iff_isLittleO is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {Î² : Type.{u2}} {l : Filter.{u1} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u2} Î²] [_inst_2 : OrderTopology.{u2} Î² (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedRing.toPseudoMetricSpace.{u2} Î² (SeminormedCommRing.toSemiNormedRing.{u2} Î² (NormedCommRing.toSeminormedCommRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1)))))))], (Filter.Tendsto.{u1, u2} Î± Î² k l (Filter.atTop.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommGroup.toPartialOrder.{u2} Î² (StrictOrderedRing.toOrderedAddCommGroup.{u2} Î² (LinearOrderedRing.toStrictOrderedRing.{u2} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u2} Î² (LinearOrderedField.toLinearOrderedCommRing.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1))))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u1, u2} Î± Î² (UniformSpace.toTopologicalSpace.{u2} Î² (PseudoMetricSpace.toUniformSpace.{u2} Î² (SeminormedRing.toPseudoMetricSpace.{u2} Î² (SeminormedCommRing.toSemiNormedRing.{u2} Î² (NormedCommRing.toSeminormedCommRing.{u2} Î² (NormedField.toNormedCommRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1))))))) (Semifield.toCommSemiring.{u2} Î² (LinearOrderedSemifield.toSemifield.{u2} Î² (LinearOrderedField.toLinearOrderedSemifield.{u2} Î² (NormedLinearOrderedField.toLinearOrderedField.{u2} Î² _inst_1)))) l k f) (forall (z : Int), Asymptotics.IsLittleO.{u1, u2, u2} Î± Î² Î² (NormedLinearOrderedField.toHasNorm.{u2} Î² _inst_1) (NormedLinearOrderedField.toHasNorm.{u2} Î² _inst_1) l f (fun (a : Î±) => HPow.hPow.{u2, 0, u2} Î² Int Î² (instHPow.{u2, 0} Î² Int (DivInvMonoid.Pow.{u2} Î² (DivisionRing.toDivInvMonoid.{u2} Î² (NormedDivisionRing.toDivisionRing.{u2} Î² (NormedField.toNormedDivisionRing.{u2} Î² (NormedLinearOrderedField.toNormedField.{u2} Î² _inst_1)))))) (k a) z)))
but is expected to have type
  forall {Î± : Type.{u2}} {Î² : Type.{u1}} {l : Filter.{u2} Î±} {k : Î± -> Î²} (f : Î± -> Î²) [_inst_1 : NormedLinearOrderedField.{u1} Î²] [_inst_2 : OrderTopology.{u1} Î² (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedRing.toPseudoMetricSpace.{u1} Î² (SeminormedCommRing.toSeminormedRing.{u1} Î² (NormedCommRing.toSeminormedCommRing.{u1} Î² (NormedField.toNormedCommRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1))))))) (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1))))))], (Filter.Tendsto.{u2, u1} Î± Î² k l (Filter.atTop.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (StrictOrderedRing.toPartialOrder.{u1} Î² (LinearOrderedRing.toStrictOrderedRing.{u1} Î² (LinearOrderedCommRing.toLinearOrderedRing.{u1} Î² (LinearOrderedField.toLinearOrderedCommRing.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1)))))))) -> (Iff (Asymptotics.SuperpolynomialDecay.{u2, u1} Î± Î² (UniformSpace.toTopologicalSpace.{u1} Î² (PseudoMetricSpace.toUniformSpace.{u1} Î² (SeminormedRing.toPseudoMetricSpace.{u1} Î² (SeminormedCommRing.toSeminormedRing.{u1} Î² (NormedCommRing.toSeminormedCommRing.{u1} Î² (NormedField.toNormedCommRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1))))))) (Semifield.toCommSemiring.{u1} Î² (LinearOrderedSemifield.toSemifield.{u1} Î² (LinearOrderedField.toLinearOrderedSemifield.{u1} Î² (NormedLinearOrderedField.toLinearOrderedField.{u1} Î² _inst_1)))) l k f) (forall (z : Int), Asymptotics.IsLittleO.{u2, u1, u1} Î± Î² Î² (NormedLinearOrderedField.toNorm.{u1} Î² _inst_1) (NormedLinearOrderedField.toNorm.{u1} Î² _inst_1) l f (fun (a : Î±) => HPow.hPow.{u1, 0, u1} Î² Int Î² (instHPow.{u1, 0} Î² Int (DivInvMonoid.Pow.{u1} Î² (DivisionRing.toDivInvMonoid.{u1} Î² (NormedDivisionRing.toDivisionRing.{u1} Î² (NormedField.toNormedDivisionRing.{u1} Î² (NormedLinearOrderedField.toNormedField.{u1} Î² _inst_1)))))) (k a) z)))
Case conversion may be inaccurate. Consider using '#align asymptotics.superpolynomial_decay_iff_is_o Asymptotics.superpolynomialDecay_iff_isLittleOâ‚“'. -/
theorem superpolynomialDecay_iff_isLittleO (hk : Tendsto k l atTop) :
    SuperpolynomialDecay l k f â†” âˆ€ z : â„¤, f =o[l] fun a : Î± => k a ^ z :=
  by
  refine' âŸ¨fun h z => _, fun h => (superpolynomial_decay_iff_is_O f hk).2 fun z => (h z).IsBigOâŸ©
  have hk0 : âˆ€á¶  x in l, k x â‰  0 := hk.eventually_ne_at_top 0
  have : (fun x : Î± => (1 : Î²)) =o[l] k :=
    is_o_of_tendsto' (hk0.mono fun x hkx hkx' => absurd hkx' hkx)
      (by simpa using hk.inv_tendsto_at_top)
  have : f =o[l] fun x : Î± => k x * k x ^ (z - 1) := by
    simpa using this.mul_is_O ((superpolynomial_decay_iff_is_O f hk).1 h <| z - 1)
  refine' this.trans_is_O (is_O.of_bound 1 (hk0.mono fun x hkx => le_of_eq _))
  rw [one_mul, zpow_sub_oneâ‚€ hkx, mul_comm (k x), mul_assoc, inv_mul_cancel hkx, mul_one]
#align asymptotics.superpolynomial_decay_iff_is_o Asymptotics.superpolynomialDecay_iff_isLittleO

end NormedLinearOrderedField

end Asymptotics

