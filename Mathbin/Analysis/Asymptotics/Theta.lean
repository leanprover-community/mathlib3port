/-
Copyright (c) 2022 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov

! This file was ported from Lean 3 source module analysis.asymptotics.theta
! leanprover-community/mathlib commit f2ce6086713c78a7f880485f7917ea547a215982
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Asymptotics.Asymptotics

/-!
# Asymptotic equivalence up to a constant

In this file we define `asymptotics.is_Theta l f g` (notation: `f =Î˜[l] g`) as
`f =O[l] g âˆ§ g =O[l] f`, then prove basic properties of this equivalence relation.
-/


open Filter

open Topology

namespace Asymptotics

variable {Î± : Type _} {Î² : Type _} {E : Type _} {F : Type _} {G : Type _} {E' : Type _}
  {F' : Type _} {G' : Type _} {E'' : Type _} {F'' : Type _} {G'' : Type _} {R : Type _}
  {R' : Type _} {ð•œ : Type _} {ð•œ' : Type _}

variable [Norm E] [Norm F] [Norm G]

variable [SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']
  [NormedAddCommGroup E''] [NormedAddCommGroup F''] [NormedAddCommGroup G''] [SeminormedRing R]
  [SeminormedRing R']

variable [NormedField ð•œ] [NormedField ð•œ']

variable {c c' câ‚ câ‚‚ : â„} {f : Î± â†’ E} {g : Î± â†’ F} {k : Î± â†’ G}

variable {f' : Î± â†’ E'} {g' : Î± â†’ F'} {k' : Î± â†’ G'}

variable {f'' : Î± â†’ E''} {g'' : Î± â†’ F''}

variable {l l' : Filter Î±}

#print Asymptotics.IsTheta /-
/-- We say that `f` is `Î˜(g)` along a filter `l` (notation: `f =Î˜[l] g`) if `f =O[l] g` and
`g =O[l] f`. -/
def IsTheta (l : Filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) : Prop :=
  IsBigO l f g âˆ§ IsBigO l g f
#align asymptotics.is_Theta Asymptotics.IsTheta
-/

-- mathport name: Â«expr =Î˜[ ] Â»
notation:100 f " =Î˜[" l "] " g:100 => IsTheta l f g

/- warning: asymptotics.is_O.antisymm -> Asymptotics.IsBigO.antisymm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u1} Î±}, (Asymptotics.IsBigO.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f g) -> (Asymptotics.IsBigO.{u1, u3, u2} Î± F E _inst_2 _inst_1 l g f) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f g)
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u1} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u3} Î±}, (Asymptotics.IsBigO.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f g) -> (Asymptotics.IsBigO.{u3, u1, u2} Î± F E _inst_2 _inst_1 l g f) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_O.antisymm Asymptotics.IsBigO.antisymmâ‚“'. -/
theorem IsBigO.antisymm (hâ‚ : f =O[l] g) (hâ‚‚ : g =O[l] f) : f =Î˜[l] g :=
  âŸ¨hâ‚, hâ‚‚âŸ©
#align asymptotics.is_O.antisymm Asymptotics.IsBigO.antisymm

/- warning: asymptotics.is_Theta_refl -> Asymptotics.isTheta_refl is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : Norm.{u2} E] (f : Î± -> E) (l : Filter.{u1} Î±), Asymptotics.IsTheta.{u1, u2, u2} Î± E E _inst_1 _inst_1 l f f
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : Norm.{u1} E] (f : Î± -> E) (l : Filter.{u2} Î±), Asymptotics.IsTheta.{u2, u1, u1} Î± E E _inst_1 _inst_1 l f f
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_refl Asymptotics.isTheta_reflâ‚“'. -/
@[refl]
theorem isTheta_refl (f : Î± â†’ E) (l : Filter Î±) : f =Î˜[l] f :=
  âŸ¨isBigO_refl _ _, isBigO_refl _ _âŸ©
#align asymptotics.is_Theta_refl Asymptotics.isTheta_refl

/- warning: asymptotics.is_Theta_rfl -> Asymptotics.isTheta_rfl is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} [_inst_1 : Norm.{u2} E] {f : Î± -> E} {l : Filter.{u1} Î±}, Asymptotics.IsTheta.{u1, u2, u2} Î± E E _inst_1 _inst_1 l f f
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} [_inst_1 : Norm.{u1} E] {f : Î± -> E} {l : Filter.{u2} Î±}, Asymptotics.IsTheta.{u2, u1, u1} Î± E E _inst_1 _inst_1 l f f
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_rfl Asymptotics.isTheta_rflâ‚“'. -/
theorem isTheta_rfl : f =Î˜[l] f :=
  isTheta_refl _ _
#align asymptotics.is_Theta_rfl Asymptotics.isTheta_rfl

/- warning: asymptotics.is_Theta.symm -> Asymptotics.IsTheta.symm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f g) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± F E _inst_2 _inst_1 l g f)
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u1} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f g) -> (Asymptotics.IsTheta.{u3, u1, u2} Î± F E _inst_2 _inst_1 l g f)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.symm Asymptotics.IsTheta.symmâ‚“'. -/
@[symm]
theorem IsTheta.symm (h : f =Î˜[l] g) : g =Î˜[l] f :=
  h.symm
#align asymptotics.is_Theta.symm Asymptotics.IsTheta.symm

/- warning: asymptotics.is_Theta_comm -> Asymptotics.isTheta_comm is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u1} Î±}, Iff (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f g) (Asymptotics.IsTheta.{u1, u3, u2} Î± F E _inst_2 _inst_1 l g f)
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u1} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u3} Î±}, Iff (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f g) (Asymptotics.IsTheta.{u3, u1, u2} Î± F E _inst_2 _inst_1 l g f)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_comm Asymptotics.isTheta_commâ‚“'. -/
theorem isTheta_comm : f =Î˜[l] g â†” g =Î˜[l] f :=
  âŸ¨fun h => h.symm, fun h => h.symmâŸ©
#align asymptotics.is_Theta_comm Asymptotics.isTheta_comm

/- warning: asymptotics.is_Theta.trans -> Asymptotics.IsTheta.trans is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {G : Type.{u3}} {F' : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_3 : Norm.{u3} G] [_inst_5 : SeminormedAddCommGroup.{u4} F'] {l : Filter.{u1} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsTheta.{u1, u2, u4} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) l f g) -> (Asymptotics.IsTheta.{u1, u4, u3} Î± F' G (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E G _inst_1 _inst_3 l f k)
but is expected to have type
  forall {Î± : Type.{u4}} {E : Type.{u3}} {G : Type.{u1}} {F' : Type.{u2}} [_inst_1 : Norm.{u3} E] [_inst_3 : Norm.{u1} G] [_inst_5 : SeminormedAddCommGroup.{u2} F'] {l : Filter.{u4} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsTheta.{u4, u3, u2} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l f g) -> (Asymptotics.IsTheta.{u4, u2, u1} Î± F' G (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsTheta.{u4, u3, u1} Î± E G _inst_1 _inst_3 l f k)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.trans Asymptotics.IsTheta.transâ‚“'. -/
@[trans]
theorem IsTheta.trans {f : Î± â†’ E} {g : Î± â†’ F'} {k : Î± â†’ G} (hâ‚ : f =Î˜[l] g) (hâ‚‚ : g =Î˜[l] k) :
    f =Î˜[l] k :=
  âŸ¨hâ‚.1.trans hâ‚‚.1, hâ‚‚.2.trans hâ‚.2âŸ©
#align asymptotics.is_Theta.trans Asymptotics.IsTheta.trans

/- warning: asymptotics.is_O.trans_is_Theta -> Asymptotics.IsBigO.trans_isTheta is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {G : Type.{u3}} {F' : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_3 : Norm.{u3} G] [_inst_5 : SeminormedAddCommGroup.{u4} F'] {l : Filter.{u1} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsBigO.{u1, u2, u4} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) l f g) -> (Asymptotics.IsTheta.{u1, u4, u3} Î± F' G (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsBigO.{u1, u2, u3} Î± E G _inst_1 _inst_3 l f k)
but is expected to have type
  forall {Î± : Type.{u4}} {E : Type.{u3}} {G : Type.{u1}} {F' : Type.{u2}} [_inst_1 : Norm.{u3} E] [_inst_3 : Norm.{u1} G] [_inst_5 : SeminormedAddCommGroup.{u2} F'] {l : Filter.{u4} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsBigO.{u4, u3, u2} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l f g) -> (Asymptotics.IsTheta.{u4, u2, u1} Î± F' G (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsBigO.{u4, u3, u1} Î± E G _inst_1 _inst_3 l f k)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_O.trans_is_Theta Asymptotics.IsBigO.trans_isThetaâ‚“'. -/
@[trans]
theorem IsBigO.trans_isTheta {f : Î± â†’ E} {g : Î± â†’ F'} {k : Î± â†’ G} (hâ‚ : f =O[l] g)
    (hâ‚‚ : g =Î˜[l] k) : f =O[l] k :=
  hâ‚.trans hâ‚‚.1
#align asymptotics.is_O.trans_is_Theta Asymptotics.IsBigO.trans_isTheta

/- warning: asymptotics.is_Theta.trans_is_O -> Asymptotics.IsTheta.trans_isBigO is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {G : Type.{u3}} {F' : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_3 : Norm.{u3} G] [_inst_5 : SeminormedAddCommGroup.{u4} F'] {l : Filter.{u1} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsTheta.{u1, u2, u4} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) l f g) -> (Asymptotics.IsBigO.{u1, u4, u3} Î± F' G (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsBigO.{u1, u2, u3} Î± E G _inst_1 _inst_3 l f k)
but is expected to have type
  forall {Î± : Type.{u4}} {E : Type.{u3}} {G : Type.{u1}} {F' : Type.{u2}} [_inst_1 : Norm.{u3} E] [_inst_3 : Norm.{u1} G] [_inst_5 : SeminormedAddCommGroup.{u2} F'] {l : Filter.{u4} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsTheta.{u4, u3, u2} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l f g) -> (Asymptotics.IsBigO.{u4, u2, u1} Î± F' G (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsBigO.{u4, u3, u1} Î± E G _inst_1 _inst_3 l f k)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.trans_is_O Asymptotics.IsTheta.trans_isBigOâ‚“'. -/
@[trans]
theorem IsTheta.trans_isBigO {f : Î± â†’ E} {g : Î± â†’ F'} {k : Î± â†’ G} (hâ‚ : f =Î˜[l] g)
    (hâ‚‚ : g =O[l] k) : f =O[l] k :=
  hâ‚.1.trans hâ‚‚
#align asymptotics.is_Theta.trans_is_O Asymptotics.IsTheta.trans_isBigO

/- warning: asymptotics.is_o.trans_is_Theta -> Asymptotics.IsLittleO.trans_isTheta is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} {G' : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] [_inst_6 : SeminormedAddCommGroup.{u4} G'] {l : Filter.{u1} Î±} {f : Î± -> E} {g : Î± -> F} {k : Î± -> G'}, (Asymptotics.IsLittleO.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f g) -> (Asymptotics.IsTheta.{u1, u3, u4} Î± F G' _inst_2 (SeminormedAddCommGroup.toHasNorm.{u4} G' _inst_6) l g k) -> (Asymptotics.IsLittleO.{u1, u2, u4} Î± E G' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u4} G' _inst_6) l f k)
but is expected to have type
  forall {Î± : Type.{u4}} {E : Type.{u3}} {F : Type.{u2}} {G' : Type.{u1}} [_inst_1 : Norm.{u3} E] [_inst_2 : Norm.{u2} F] [_inst_6 : SeminormedAddCommGroup.{u1} G'] {l : Filter.{u4} Î±} {f : Î± -> E} {g : Î± -> F} {k : Î± -> G'}, (Asymptotics.IsLittleO.{u4, u3, u2} Î± E F _inst_1 _inst_2 l f g) -> (Asymptotics.IsTheta.{u4, u2, u1} Î± F G' _inst_2 (SeminormedAddCommGroup.toNorm.{u1} G' _inst_6) l g k) -> (Asymptotics.IsLittleO.{u4, u3, u1} Î± E G' _inst_1 (SeminormedAddCommGroup.toNorm.{u1} G' _inst_6) l f k)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_o.trans_is_Theta Asymptotics.IsLittleO.trans_isThetaâ‚“'. -/
@[trans]
theorem IsLittleO.trans_isTheta {f : Î± â†’ E} {g : Î± â†’ F} {k : Î± â†’ G'} (hâ‚ : f =o[l] g)
    (hâ‚‚ : g =Î˜[l] k) : f =o[l] k :=
  hâ‚.trans_isBigO hâ‚‚.1
#align asymptotics.is_o.trans_is_Theta Asymptotics.IsLittleO.trans_isTheta

/- warning: asymptotics.is_Theta.trans_is_o -> Asymptotics.IsTheta.trans_isLittleO is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {G : Type.{u3}} {F' : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_3 : Norm.{u3} G] [_inst_5 : SeminormedAddCommGroup.{u4} F'] {l : Filter.{u1} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsTheta.{u1, u2, u4} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) l f g) -> (Asymptotics.IsLittleO.{u1, u4, u3} Î± F' G (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsLittleO.{u1, u2, u3} Î± E G _inst_1 _inst_3 l f k)
but is expected to have type
  forall {Î± : Type.{u4}} {E : Type.{u3}} {G : Type.{u1}} {F' : Type.{u2}} [_inst_1 : Norm.{u3} E] [_inst_3 : Norm.{u1} G] [_inst_5 : SeminormedAddCommGroup.{u2} F'] {l : Filter.{u4} Î±} {f : Î± -> E} {g : Î± -> F'} {k : Î± -> G}, (Asymptotics.IsTheta.{u4, u3, u2} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l f g) -> (Asymptotics.IsLittleO.{u4, u2, u1} Î± F' G (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) _inst_3 l g k) -> (Asymptotics.IsLittleO.{u4, u3, u1} Î± E G _inst_1 _inst_3 l f k)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.trans_is_o Asymptotics.IsTheta.trans_isLittleOâ‚“'. -/
@[trans]
theorem IsTheta.trans_isLittleO {f : Î± â†’ E} {g : Î± â†’ F'} {k : Î± â†’ G} (hâ‚ : f =Î˜[l] g)
    (hâ‚‚ : g =o[l] k) : f =o[l] k :=
  hâ‚.1.trans_isLittleO hâ‚‚
#align asymptotics.is_Theta.trans_is_o Asymptotics.IsTheta.trans_isLittleO

/- warning: asymptotics.is_Theta.trans_eventually_eq -> Asymptotics.IsTheta.trans_eventuallyEq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] {l : Filter.{u1} Î±} {f : Î± -> E} {gâ‚ : Î± -> F} {gâ‚‚ : Î± -> F}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f gâ‚) -> (Filter.EventuallyEq.{u1, u3} Î± F l gâ‚ gâ‚‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f gâ‚‚)
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u1} F] {l : Filter.{u3} Î±} {f : Î± -> E} {gâ‚ : Î± -> F} {gâ‚‚ : Î± -> F}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f gâ‚) -> (Filter.EventuallyEq.{u3, u1} Î± F l gâ‚ gâ‚‚) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f gâ‚‚)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.trans_eventually_eq Asymptotics.IsTheta.trans_eventuallyEqâ‚“'. -/
@[trans]
theorem IsTheta.trans_eventuallyEq {f : Î± â†’ E} {gâ‚ gâ‚‚ : Î± â†’ F} (h : f =Î˜[l] gâ‚) (hg : gâ‚ =á¶ [l] gâ‚‚) :
    f =Î˜[l] gâ‚‚ :=
  âŸ¨h.1.trans_eventuallyEq hg, hg.symm.trans_isBigO h.2âŸ©
#align asymptotics.is_Theta.trans_eventually_eq Asymptotics.IsTheta.trans_eventuallyEq

/- warning: filter.eventually_eq.trans_is_Theta -> Filter.EventuallyEq.trans_isTheta is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] {l : Filter.{u1} Î±} {fâ‚ : Î± -> E} {fâ‚‚ : Î± -> E} {g : Î± -> F}, (Filter.EventuallyEq.{u1, u2} Î± E l fâ‚ fâ‚‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l fâ‚‚ g) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l fâ‚ g)
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u1} F] {l : Filter.{u3} Î±} {fâ‚ : Î± -> E} {fâ‚‚ : Î± -> E} {g : Î± -> F}, (Filter.EventuallyEq.{u3, u2} Î± E l fâ‚ fâ‚‚) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l fâ‚‚ g) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l fâ‚ g)
Case conversion may be inaccurate. Consider using '#align filter.eventually_eq.trans_is_Theta Filter.EventuallyEq.trans_isThetaâ‚“'. -/
@[trans]
theorem Filter.EventuallyEq.trans_isTheta {fâ‚ fâ‚‚ : Î± â†’ E} {g : Î± â†’ F} (hf : fâ‚ =á¶ [l] fâ‚‚)
    (h : fâ‚‚ =Î˜[l] g) : fâ‚ =Î˜[l] g :=
  âŸ¨hf.trans_isBigO h.1, h.2.trans_eventuallyEq hf.symmâŸ©
#align filter.eventually_eq.trans_is_Theta Filter.EventuallyEq.trans_isTheta

/- warning: asymptotics.is_Theta_norm_left -> Asymptotics.isTheta_norm_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {E' : Type.{u3}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u1} Î±}, Iff (Asymptotics.IsTheta.{u1, 0, u2} Î± Real F Real.hasNorm _inst_2 l (fun (x : Î±) => Norm.norm.{u3} E' (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) (f' x)) g) (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l f' g)
but is expected to have type
  forall {Î± : Type.{u3}} {F : Type.{u2}} {E' : Type.{u1}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u1} E'] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u3} Î±}, Iff (Asymptotics.IsTheta.{u3, 0, u2} Î± Real F Real.norm _inst_2 l (fun (x : Î±) => Norm.norm.{u1} E' (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) (f' x)) g) (Asymptotics.IsTheta.{u3, u1, u2} Î± E' F (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) _inst_2 l f' g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_norm_left Asymptotics.isTheta_norm_leftâ‚“'. -/
@[simp]
theorem isTheta_norm_left : (fun x => â€–f' xâ€–) =Î˜[l] g â†” f' =Î˜[l] g := by simp [is_Theta]
#align asymptotics.is_Theta_norm_left Asymptotics.isTheta_norm_left

/- warning: asymptotics.is_Theta_norm_right -> Asymptotics.isTheta_norm_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u1} Î±}, Iff (Asymptotics.IsTheta.{u1, u2, 0} Î± E Real _inst_1 Real.hasNorm l f (fun (x : Î±) => Norm.norm.{u3} F' (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) (g' x))) (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g')
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F' : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u1} F'] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u3} Î±}, Iff (Asymptotics.IsTheta.{u3, u2, 0} Î± E Real _inst_1 Real.norm l f (fun (x : Î±) => Norm.norm.{u1} F' (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) (g' x))) (Asymptotics.IsTheta.{u3, u2, u1} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f g')
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_norm_right Asymptotics.isTheta_norm_rightâ‚“'. -/
@[simp]
theorem isTheta_norm_right : (f =Î˜[l] fun x => â€–g' xâ€–) â†” f =Î˜[l] g' := by simp [is_Theta]
#align asymptotics.is_Theta_norm_right Asymptotics.isTheta_norm_right

/- warning: asymptotics.is_Theta.of_norm_left -> Asymptotics.IsTheta.of_norm_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {E' : Type.{u3}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, 0, u2} Î± Real F Real.hasNorm _inst_2 l (fun (x : Î±) => Norm.norm.{u3} E' (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) (f' x)) g) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l f' g)
but is expected to have type
  forall {Î± : Type.{u3}} {F : Type.{u2}} {E' : Type.{u1}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u1} E'] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, 0, u2} Î± Real F Real.norm _inst_2 l (fun (x : Î±) => Norm.norm.{u1} E' (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) (f' x)) g) -> (Asymptotics.IsTheta.{u3, u1, u2} Î± E' F (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) _inst_2 l f' g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.of_norm_left Asymptotics.IsTheta.of_norm_leftâ‚“'. -/
/- warning: asymptotics.is_Theta.norm_left -> Asymptotics.IsTheta.norm_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {E' : Type.{u3}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l f' g) -> (Asymptotics.IsTheta.{u1, 0, u2} Î± Real F Real.hasNorm _inst_2 l (fun (x : Î±) => Norm.norm.{u3} E' (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) (f' x)) g)
but is expected to have type
  forall {Î± : Type.{u3}} {F : Type.{u2}} {E' : Type.{u1}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u1} E'] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u1, u2} Î± E' F (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) _inst_2 l f' g) -> (Asymptotics.IsTheta.{u3, 0, u2} Î± Real F Real.norm _inst_2 l (fun (x : Î±) => Norm.norm.{u1} E' (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) (f' x)) g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.norm_left Asymptotics.IsTheta.norm_leftâ‚“'. -/
alias is_Theta_norm_left â†” is_Theta.of_norm_left is_Theta.norm_left
#align asymptotics.is_Theta.of_norm_left Asymptotics.IsTheta.of_norm_left
#align asymptotics.is_Theta.norm_left Asymptotics.IsTheta.norm_left

/- warning: asymptotics.is_Theta.of_norm_right -> Asymptotics.IsTheta.of_norm_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, 0} Î± E Real _inst_1 Real.hasNorm l f (fun (x : Î±) => Norm.norm.{u3} F' (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) (g' x))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g')
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F' : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u1} F'] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, 0} Î± E Real _inst_1 Real.norm l f (fun (x : Î±) => Norm.norm.{u1} F' (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) (g' x))) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f g')
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.of_norm_right Asymptotics.IsTheta.of_norm_rightâ‚“'. -/
/- warning: asymptotics.is_Theta.norm_right -> Asymptotics.IsTheta.norm_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g') -> (Asymptotics.IsTheta.{u1, u2, 0} Î± E Real _inst_1 Real.hasNorm l f (fun (x : Î±) => Norm.norm.{u3} F' (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) (g' x)))
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F' : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u1} F'] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f g') -> (Asymptotics.IsTheta.{u3, u2, 0} Î± E Real _inst_1 Real.norm l f (fun (x : Î±) => Norm.norm.{u1} F' (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) (g' x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.norm_right Asymptotics.IsTheta.norm_rightâ‚“'. -/
alias is_Theta_norm_right â†” is_Theta.of_norm_right is_Theta.norm_right
#align asymptotics.is_Theta.of_norm_right Asymptotics.IsTheta.of_norm_right
#align asymptotics.is_Theta.norm_right Asymptotics.IsTheta.norm_right

/- warning: asymptotics.is_Theta_of_norm_eventually_eq -> Asymptotics.isTheta_of_norm_eventuallyEq is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u1} Î±}, (Filter.EventuallyEq.{u1, 0} Î± Real l (fun (x : Î±) => Norm.norm.{u2} E _inst_1 (f x)) (fun (x : Î±) => Norm.norm.{u3} F _inst_2 (g x))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f g)
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u1} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u3} Î±}, (Filter.EventuallyEq.{u3, 0} Î± Real l (fun (x : Î±) => Norm.norm.{u2} E _inst_1 (f x)) (fun (x : Î±) => Norm.norm.{u1} F _inst_2 (g x))) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_of_norm_eventually_eq Asymptotics.isTheta_of_norm_eventuallyEqâ‚“'. -/
theorem isTheta_of_norm_eventuallyEq (h : (fun x => â€–f xâ€–) =á¶ [l] fun x => â€–g xâ€–) : f =Î˜[l] g :=
  âŸ¨IsBigO.of_bound 1 <| by simpa only [one_mul] using h.le,
    IsBigO.of_bound 1 <| by simpa only [one_mul] using h.symm.leâŸ©
#align asymptotics.is_Theta_of_norm_eventually_eq Asymptotics.isTheta_of_norm_eventuallyEq

/- warning: asymptotics.is_Theta_of_norm_eventually_eq' -> Asymptotics.isTheta_of_norm_eventuallyEq' is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E' : Type.{u2}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] {f' : Î± -> E'} {l : Filter.{u1} Î±} {g : Î± -> Real}, (Filter.EventuallyEq.{u1, 0} Î± Real l (fun (x : Î±) => Norm.norm.{u2} E' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (f' x)) g) -> (Asymptotics.IsTheta.{u1, u2, 0} Î± E' Real (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) Real.hasNorm l f' g)
but is expected to have type
  forall {Î± : Type.{u2}} {E' : Type.{u1}} [_inst_4 : SeminormedAddCommGroup.{u1} E'] {f' : Î± -> E'} {l : Filter.{u2} Î±} {g : Î± -> Real}, (Filter.EventuallyEq.{u2, 0} Î± Real l (fun (x : Î±) => Norm.norm.{u1} E' (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) (f' x)) g) -> (Asymptotics.IsTheta.{u2, u1, 0} Î± E' Real (SeminormedAddCommGroup.toNorm.{u1} E' _inst_4) Real.norm l f' g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_of_norm_eventually_eq' Asymptotics.isTheta_of_norm_eventuallyEq'â‚“'. -/
theorem isTheta_of_norm_eventuallyEq' {g : Î± â†’ â„} (h : (fun x => â€–f' xâ€–) =á¶ [l] g) : f' =Î˜[l] g :=
  isTheta_of_norm_eventuallyEq <| h.mono fun x hx => by simp only [â† hx, norm_norm]
#align asymptotics.is_Theta_of_norm_eventually_eq' Asymptotics.isTheta_of_norm_eventuallyEq'

/- warning: asymptotics.is_Theta.is_o_congr_left -> Asymptotics.IsTheta.isLittleO_congr_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {G : Type.{u2}} {E' : Type.{u3}} {F' : Type.{u4}} [_inst_3 : Norm.{u2} G] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_5 : SeminormedAddCommGroup.{u4} F'] {k : Î± -> G} {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u3, u4} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) l f' g') -> (Iff (Asymptotics.IsLittleO.{u1, u3, u2} Î± E' G (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_3 l f' k) (Asymptotics.IsLittleO.{u1, u4, u2} Î± F' G (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) _inst_3 l g' k))
but is expected to have type
  forall {Î± : Type.{u4}} {G : Type.{u1}} {E' : Type.{u3}} {F' : Type.{u2}} [_inst_3 : Norm.{u1} G] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_5 : SeminormedAddCommGroup.{u2} F'] {k : Î± -> G} {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u4} Î±}, (Asymptotics.IsTheta.{u4, u3, u2} Î± E' F' (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l f' g') -> (Iff (Asymptotics.IsLittleO.{u4, u3, u1} Î± E' G (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_3 l f' k) (Asymptotics.IsLittleO.{u4, u2, u1} Î± F' G (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) _inst_3 l g' k))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.is_o_congr_left Asymptotics.IsTheta.isLittleO_congr_leftâ‚“'. -/
theorem IsTheta.isLittleO_congr_left (h : f' =Î˜[l] g') : f' =o[l] k â†” g' =o[l] k :=
  âŸ¨h.symm.trans_isLittleO, h.trans_isLittleOâŸ©
#align asymptotics.is_Theta.is_o_congr_left Asymptotics.IsTheta.isLittleO_congr_left

/- warning: asymptotics.is_Theta.is_o_congr_right -> Asymptotics.IsTheta.isLittleO_congr_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} {G' : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_6 : SeminormedAddCommGroup.{u4} G'] {f : Î± -> E} {g' : Î± -> F'} {k' : Î± -> G'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u3, u4} Î± F' G' (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) (SeminormedAddCommGroup.toHasNorm.{u4} G' _inst_6) l g' k') -> (Iff (Asymptotics.IsLittleO.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g') (Asymptotics.IsLittleO.{u1, u2, u4} Î± E G' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u4} G' _inst_6) l f k'))
but is expected to have type
  forall {Î± : Type.{u4}} {E : Type.{u1}} {F' : Type.{u3}} {G' : Type.{u2}} [_inst_1 : Norm.{u1} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_6 : SeminormedAddCommGroup.{u2} G'] {f : Î± -> E} {g' : Î± -> F'} {k' : Î± -> G'} {l : Filter.{u4} Î±}, (Asymptotics.IsTheta.{u4, u3, u2} Î± F' G' (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) (SeminormedAddCommGroup.toNorm.{u2} G' _inst_6) l g' k') -> (Iff (Asymptotics.IsLittleO.{u4, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f g') (Asymptotics.IsLittleO.{u4, u1, u2} Î± E G' _inst_1 (SeminormedAddCommGroup.toNorm.{u2} G' _inst_6) l f k'))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.is_o_congr_right Asymptotics.IsTheta.isLittleO_congr_rightâ‚“'. -/
theorem IsTheta.isLittleO_congr_right (h : g' =Î˜[l] k') : f =o[l] g' â†” f =o[l] k' :=
  âŸ¨fun H => H.trans_isTheta h, fun H => H.trans_isTheta h.symmâŸ©
#align asymptotics.is_Theta.is_o_congr_right Asymptotics.IsTheta.isLittleO_congr_right

/- warning: asymptotics.is_Theta.is_O_congr_left -> Asymptotics.IsTheta.isBigO_congr_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {G : Type.{u2}} {E' : Type.{u3}} {F' : Type.{u4}} [_inst_3 : Norm.{u2} G] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_5 : SeminormedAddCommGroup.{u4} F'] {k : Î± -> G} {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u3, u4} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) l f' g') -> (Iff (Asymptotics.IsBigO.{u1, u3, u2} Î± E' G (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_3 l f' k) (Asymptotics.IsBigO.{u1, u4, u2} Î± F' G (SeminormedAddCommGroup.toHasNorm.{u4} F' _inst_5) _inst_3 l g' k))
but is expected to have type
  forall {Î± : Type.{u4}} {G : Type.{u1}} {E' : Type.{u3}} {F' : Type.{u2}} [_inst_3 : Norm.{u1} G] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_5 : SeminormedAddCommGroup.{u2} F'] {k : Î± -> G} {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u4} Î±}, (Asymptotics.IsTheta.{u4, u3, u2} Î± E' F' (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l f' g') -> (Iff (Asymptotics.IsBigO.{u4, u3, u1} Î± E' G (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_3 l f' k) (Asymptotics.IsBigO.{u4, u2, u1} Î± F' G (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) _inst_3 l g' k))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.is_O_congr_left Asymptotics.IsTheta.isBigO_congr_leftâ‚“'. -/
theorem IsTheta.isBigO_congr_left (h : f' =Î˜[l] g') : f' =O[l] k â†” g' =O[l] k :=
  âŸ¨h.symm.trans_isBigO, h.trans_isBigOâŸ©
#align asymptotics.is_Theta.is_O_congr_left Asymptotics.IsTheta.isBigO_congr_left

/- warning: asymptotics.is_Theta.is_O_congr_right -> Asymptotics.IsTheta.isBigO_congr_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} {G' : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_6 : SeminormedAddCommGroup.{u4} G'] {f : Î± -> E} {g' : Î± -> F'} {k' : Î± -> G'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u3, u4} Î± F' G' (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) (SeminormedAddCommGroup.toHasNorm.{u4} G' _inst_6) l g' k') -> (Iff (Asymptotics.IsBigO.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g') (Asymptotics.IsBigO.{u1, u2, u4} Î± E G' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u4} G' _inst_6) l f k'))
but is expected to have type
  forall {Î± : Type.{u4}} {E : Type.{u1}} {F' : Type.{u3}} {G' : Type.{u2}} [_inst_1 : Norm.{u1} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_6 : SeminormedAddCommGroup.{u2} G'] {f : Î± -> E} {g' : Î± -> F'} {k' : Î± -> G'} {l : Filter.{u4} Î±}, (Asymptotics.IsTheta.{u4, u3, u2} Î± F' G' (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) (SeminormedAddCommGroup.toNorm.{u2} G' _inst_6) l g' k') -> (Iff (Asymptotics.IsBigO.{u4, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f g') (Asymptotics.IsBigO.{u4, u1, u2} Î± E G' _inst_1 (SeminormedAddCommGroup.toNorm.{u2} G' _inst_6) l f k'))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.is_O_congr_right Asymptotics.IsTheta.isBigO_congr_rightâ‚“'. -/
theorem IsTheta.isBigO_congr_right (h : g' =Î˜[l] k') : f =O[l] g' â†” f =O[l] k' :=
  âŸ¨fun H => H.trans_isTheta h, fun H => H.trans_isTheta h.symmâŸ©
#align asymptotics.is_Theta.is_O_congr_right Asymptotics.IsTheta.isBigO_congr_right

/- warning: asymptotics.is_Theta.mono -> Asymptotics.IsTheta.mono is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u3} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u1} Î±} {l' : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l f g) -> (LE.le.{u1} (Filter.{u1} Î±) (Preorder.toLE.{u1} (Filter.{u1} Î±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Î±) (Filter.partialOrder.{u1} Î±))) l' l) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F _inst_1 _inst_2 l' f g)
but is expected to have type
  forall {Î± : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Norm.{u2} E] [_inst_2 : Norm.{u1} F] {f : Î± -> E} {g : Î± -> F} {l : Filter.{u3} Î±} {l' : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l f g) -> (LE.le.{u3} (Filter.{u3} Î±) (Preorder.toLE.{u3} (Filter.{u3} Î±) (PartialOrder.toPreorder.{u3} (Filter.{u3} Î±) (Filter.instPartialOrderFilter.{u3} Î±))) l' l) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E F _inst_1 _inst_2 l' f g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.mono Asymptotics.IsTheta.monoâ‚“'. -/
theorem IsTheta.mono (h : f =Î˜[l] g) (hl : l' â‰¤ l) : f =Î˜[l'] g :=
  âŸ¨h.1.mono hl, h.2.mono hlâŸ©
#align asymptotics.is_Theta.mono Asymptotics.IsTheta.mono

/- warning: asymptotics.is_Theta.sup -> Asymptotics.IsTheta.sup is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E' : Type.{u2}} {F' : Type.{u3}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u3} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u1} Î±} {l' : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f' g') -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l' f' g') -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) (Sup.sup.{u1} (Filter.{u1} Î±) (SemilatticeSup.toHasSup.{u1} (Filter.{u1} Î±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Î±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))))) l l') f' g')
but is expected to have type
  forall {Î± : Type.{u3}} {E' : Type.{u2}} {F' : Type.{u1}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u1} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u3} Î±} {l' : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f' g') -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l' f' g') -> (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) (Sup.sup.{u3} (Filter.{u3} Î±) (SemilatticeSup.toSup.{u3} (Filter.{u3} Î±) (Lattice.toSemilatticeSup.{u3} (Filter.{u3} Î±) (ConditionallyCompleteLattice.toLattice.{u3} (Filter.{u3} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Filter.{u3} Î±) (Filter.instCompleteLatticeFilter.{u3} Î±))))) l l') f' g')
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.sup Asymptotics.IsTheta.supâ‚“'. -/
theorem IsTheta.sup (h : f' =Î˜[l] g') (h' : f' =Î˜[l'] g') : f' =Î˜[l âŠ” l'] g' :=
  âŸ¨h.1.sup h'.1, h.2.sup h'.2âŸ©
#align asymptotics.is_Theta.sup Asymptotics.IsTheta.sup

/- warning: asymptotics.is_Theta_sup -> Asymptotics.isTheta_sup is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E' : Type.{u2}} {F' : Type.{u3}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u3} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u1} Î±} {l' : Filter.{u1} Î±}, Iff (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) (Sup.sup.{u1} (Filter.{u1} Î±) (SemilatticeSup.toHasSup.{u1} (Filter.{u1} Î±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Î±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Î±) (Filter.completeLattice.{u1} Î±))))) l l') f' g') (And (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f' g') (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l' f' g'))
but is expected to have type
  forall {Î± : Type.{u3}} {E' : Type.{u2}} {F' : Type.{u1}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u1} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u3} Î±} {l' : Filter.{u3} Î±}, Iff (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) (Sup.sup.{u3} (Filter.{u3} Î±) (SemilatticeSup.toSup.{u3} (Filter.{u3} Î±) (Lattice.toSemilatticeSup.{u3} (Filter.{u3} Î±) (ConditionallyCompleteLattice.toLattice.{u3} (Filter.{u3} Î±) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Filter.{u3} Î±) (Filter.instCompleteLatticeFilter.{u3} Î±))))) l l') f' g') (And (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f' g') (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l' f' g'))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_sup Asymptotics.isTheta_supâ‚“'. -/
@[simp]
theorem isTheta_sup : f' =Î˜[l âŠ” l'] g' â†” f' =Î˜[l] g' âˆ§ f' =Î˜[l'] g' :=
  âŸ¨fun h => âŸ¨h.mono le_sup_left, h.mono le_sup_rightâŸ©, fun h => h.1.sup h.2âŸ©
#align asymptotics.is_Theta_sup Asymptotics.isTheta_sup

/- warning: asymptotics.is_Theta.eq_zero_iff -> Asymptotics.IsTheta.eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E'' : Type.{u2}} {F'' : Type.{u3}} [_inst_7 : NormedAddCommGroup.{u2} E''] [_inst_8 : NormedAddCommGroup.{u3} F''] {f'' : Î± -> E''} {g'' : Î± -> F''} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E'' F'' (NormedAddCommGroup.toHasNorm.{u2} E'' _inst_7) (NormedAddCommGroup.toHasNorm.{u3} F'' _inst_8) l f'' g'') -> (Filter.Eventually.{u1} Î± (fun (x : Î±) => Iff (Eq.{succ u2} E'' (f'' x) (OfNat.ofNat.{u2} E'' 0 (OfNat.mk.{u2} E'' 0 (Zero.zero.{u2} E'' (AddZeroClass.toHasZero.{u2} E'' (AddMonoid.toAddZeroClass.{u2} E'' (SubNegMonoid.toAddMonoid.{u2} E'' (AddGroup.toSubNegMonoid.{u2} E'' (NormedAddGroup.toAddGroup.{u2} E'' (NormedAddCommGroup.toNormedAddGroup.{u2} E'' _inst_7)))))))))) (Eq.{succ u3} F'' (g'' x) (OfNat.ofNat.{u3} F'' 0 (OfNat.mk.{u3} F'' 0 (Zero.zero.{u3} F'' (AddZeroClass.toHasZero.{u3} F'' (AddMonoid.toAddZeroClass.{u3} F'' (SubNegMonoid.toAddMonoid.{u3} F'' (AddGroup.toSubNegMonoid.{u3} F'' (NormedAddGroup.toAddGroup.{u3} F'' (NormedAddCommGroup.toNormedAddGroup.{u3} F'' _inst_8))))))))))) l)
but is expected to have type
  forall {Î± : Type.{u3}} {E'' : Type.{u2}} {F'' : Type.{u1}} [_inst_7 : NormedAddCommGroup.{u2} E''] [_inst_8 : NormedAddCommGroup.{u1} F''] {f'' : Î± -> E''} {g'' : Î± -> F''} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E'' F'' (NormedAddCommGroup.toNorm.{u2} E'' _inst_7) (NormedAddCommGroup.toNorm.{u1} F'' _inst_8) l f'' g'') -> (Filter.Eventually.{u3} Î± (fun (x : Î±) => Iff (Eq.{succ u2} E'' (f'' x) (OfNat.ofNat.{u2} E'' 0 (Zero.toOfNat0.{u2} E'' (NegZeroClass.toZero.{u2} E'' (SubNegZeroMonoid.toNegZeroClass.{u2} E'' (SubtractionMonoid.toSubNegZeroMonoid.{u2} E'' (SubtractionCommMonoid.toSubtractionMonoid.{u2} E'' (AddCommGroup.toDivisionAddCommMonoid.{u2} E'' (NormedAddCommGroup.toAddCommGroup.{u2} E'' _inst_7))))))))) (Eq.{succ u1} F'' (g'' x) (OfNat.ofNat.{u1} F'' 0 (Zero.toOfNat0.{u1} F'' (NegZeroClass.toZero.{u1} F'' (SubNegZeroMonoid.toNegZeroClass.{u1} F'' (SubtractionMonoid.toSubNegZeroMonoid.{u1} F'' (SubtractionCommMonoid.toSubtractionMonoid.{u1} F'' (AddCommGroup.toDivisionAddCommMonoid.{u1} F'' (NormedAddCommGroup.toAddCommGroup.{u1} F'' _inst_8)))))))))) l)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.eq_zero_iff Asymptotics.IsTheta.eq_zero_iffâ‚“'. -/
theorem IsTheta.eq_zero_iff (h : f'' =Î˜[l] g'') : âˆ€á¶  x in l, f'' x = 0 â†” g'' x = 0 :=
  h.1.eq_zero_imp.mp <| h.2.eq_zero_imp.mono fun x => Iff.intro
#align asymptotics.is_Theta.eq_zero_iff Asymptotics.IsTheta.eq_zero_iff

/- warning: asymptotics.is_Theta.tendsto_zero_iff -> Asymptotics.IsTheta.tendsto_zero_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E'' : Type.{u2}} {F'' : Type.{u3}} [_inst_7 : NormedAddCommGroup.{u2} E''] [_inst_8 : NormedAddCommGroup.{u3} F''] {f'' : Î± -> E''} {g'' : Î± -> F''} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E'' F'' (NormedAddCommGroup.toHasNorm.{u2} E'' _inst_7) (NormedAddCommGroup.toHasNorm.{u3} F'' _inst_8) l f'' g'') -> (Iff (Filter.Tendsto.{u1, u2} Î± E'' f'' l (nhds.{u2} E'' (UniformSpace.toTopologicalSpace.{u2} E'' (PseudoMetricSpace.toUniformSpace.{u2} E'' (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E'' (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E'' _inst_7)))) (OfNat.ofNat.{u2} E'' 0 (OfNat.mk.{u2} E'' 0 (Zero.zero.{u2} E'' (AddZeroClass.toHasZero.{u2} E'' (AddMonoid.toAddZeroClass.{u2} E'' (SubNegMonoid.toAddMonoid.{u2} E'' (AddGroup.toSubNegMonoid.{u2} E'' (NormedAddGroup.toAddGroup.{u2} E'' (NormedAddCommGroup.toNormedAddGroup.{u2} E'' _inst_7))))))))))) (Filter.Tendsto.{u1, u3} Î± F'' g'' l (nhds.{u3} F'' (UniformSpace.toTopologicalSpace.{u3} F'' (PseudoMetricSpace.toUniformSpace.{u3} F'' (SeminormedAddCommGroup.toPseudoMetricSpace.{u3} F'' (NormedAddCommGroup.toSeminormedAddCommGroup.{u3} F'' _inst_8)))) (OfNat.ofNat.{u3} F'' 0 (OfNat.mk.{u3} F'' 0 (Zero.zero.{u3} F'' (AddZeroClass.toHasZero.{u3} F'' (AddMonoid.toAddZeroClass.{u3} F'' (SubNegMonoid.toAddMonoid.{u3} F'' (AddGroup.toSubNegMonoid.{u3} F'' (NormedAddGroup.toAddGroup.{u3} F'' (NormedAddCommGroup.toNormedAddGroup.{u3} F'' _inst_8))))))))))))
but is expected to have type
  forall {Î± : Type.{u3}} {E'' : Type.{u2}} {F'' : Type.{u1}} [_inst_7 : NormedAddCommGroup.{u2} E''] [_inst_8 : NormedAddCommGroup.{u1} F''] {f'' : Î± -> E''} {g'' : Î± -> F''} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E'' F'' (NormedAddCommGroup.toNorm.{u2} E'' _inst_7) (NormedAddCommGroup.toNorm.{u1} F'' _inst_8) l f'' g'') -> (Iff (Filter.Tendsto.{u3, u2} Î± E'' f'' l (nhds.{u2} E'' (UniformSpace.toTopologicalSpace.{u2} E'' (PseudoMetricSpace.toUniformSpace.{u2} E'' (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E'' (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E'' _inst_7)))) (OfNat.ofNat.{u2} E'' 0 (Zero.toOfNat0.{u2} E'' (NegZeroClass.toZero.{u2} E'' (SubNegZeroMonoid.toNegZeroClass.{u2} E'' (SubtractionMonoid.toSubNegZeroMonoid.{u2} E'' (SubtractionCommMonoid.toSubtractionMonoid.{u2} E'' (AddCommGroup.toDivisionAddCommMonoid.{u2} E'' (NormedAddCommGroup.toAddCommGroup.{u2} E'' _inst_7)))))))))) (Filter.Tendsto.{u3, u1} Î± F'' g'' l (nhds.{u1} F'' (UniformSpace.toTopologicalSpace.{u1} F'' (PseudoMetricSpace.toUniformSpace.{u1} F'' (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} F'' (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} F'' _inst_8)))) (OfNat.ofNat.{u1} F'' 0 (Zero.toOfNat0.{u1} F'' (NegZeroClass.toZero.{u1} F'' (SubNegZeroMonoid.toNegZeroClass.{u1} F'' (SubtractionMonoid.toSubNegZeroMonoid.{u1} F'' (SubtractionCommMonoid.toSubtractionMonoid.{u1} F'' (AddCommGroup.toDivisionAddCommMonoid.{u1} F'' (NormedAddCommGroup.toAddCommGroup.{u1} F'' _inst_8)))))))))))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.tendsto_zero_iff Asymptotics.IsTheta.tendsto_zero_iffâ‚“'. -/
theorem IsTheta.tendsto_zero_iff (h : f'' =Î˜[l] g'') : Tendsto f'' l (ð“ 0) â†” Tendsto g'' l (ð“ 0) :=
  by simp only [â† is_o_one_iff â„, h.is_o_congr_left]
#align asymptotics.is_Theta.tendsto_zero_iff Asymptotics.IsTheta.tendsto_zero_iff

/- warning: asymptotics.is_Theta.tendsto_norm_at_top_iff -> Asymptotics.IsTheta.tendsto_norm_atTop_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E' : Type.{u2}} {F' : Type.{u3}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u3} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f' g') -> (Iff (Filter.Tendsto.{u1, 0} Î± Real (Function.comp.{succ u1, succ u2, 1} Î± E' Real (Norm.norm.{u2} E' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4)) f') l (Filter.atTop.{0} Real Real.preorder)) (Filter.Tendsto.{u1, 0} Î± Real (Function.comp.{succ u1, succ u3, 1} Î± F' Real (Norm.norm.{u3} F' (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5)) g') l (Filter.atTop.{0} Real Real.preorder)))
but is expected to have type
  forall {Î± : Type.{u3}} {E' : Type.{u2}} {F' : Type.{u1}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u1} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f' g') -> (Iff (Filter.Tendsto.{u3, 0} Î± Real (Function.comp.{succ u3, succ u2, 1} Î± E' Real (Norm.norm.{u2} E' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4)) f') l (Filter.atTop.{0} Real Real.instPreorderReal)) (Filter.Tendsto.{u3, 0} Î± Real (Function.comp.{succ u3, succ u1, 1} Î± F' Real (Norm.norm.{u1} F' (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5)) g') l (Filter.atTop.{0} Real Real.instPreorderReal)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.tendsto_norm_at_top_iff Asymptotics.IsTheta.tendsto_norm_atTop_iffâ‚“'. -/
theorem IsTheta.tendsto_norm_atTop_iff (h : f' =Î˜[l] g') :
    Tendsto (norm âˆ˜ f') l atTop â†” Tendsto (norm âˆ˜ g') l atTop := by
  simp only [â† is_o_const_left_of_ne (one_ne_zero' â„), h.is_o_congr_right]
#align asymptotics.is_Theta.tendsto_norm_at_top_iff Asymptotics.IsTheta.tendsto_norm_atTop_iff

/- warning: asymptotics.is_Theta.is_bounded_under_le_iff -> Asymptotics.IsTheta.isBoundedUnder_le_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E' : Type.{u2}} {F' : Type.{u3}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u3} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u1} Î±}, (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f' g') -> (Iff (Filter.IsBoundedUnder.{0, u1} Real Î± (LE.le.{0} Real Real.hasLe) l (Function.comp.{succ u1, succ u2, 1} Î± E' Real (Norm.norm.{u2} E' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4)) f')) (Filter.IsBoundedUnder.{0, u1} Real Î± (LE.le.{0} Real Real.hasLe) l (Function.comp.{succ u1, succ u3, 1} Î± F' Real (Norm.norm.{u3} F' (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5)) g')))
but is expected to have type
  forall {Î± : Type.{u3}} {E' : Type.{u2}} {F' : Type.{u1}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u1} F'] {f' : Î± -> E'} {g' : Î± -> F'} {l : Filter.{u3} Î±}, (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f' g') -> (Iff (Filter.IsBoundedUnder.{0, u3} Real Î± (fun (x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5162 : Real) (x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5164 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5162 x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5164) l (Function.comp.{succ u3, succ u2, 1} Î± E' Real (Norm.norm.{u2} E' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4)) f')) (Filter.IsBoundedUnder.{0, u3} Real Î± (fun (x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5186 : Real) (x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5188 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5186 x._@.Mathlib.Analysis.Asymptotics.Theta._hyg.5188) l (Function.comp.{succ u3, succ u1, 1} Î± F' Real (Norm.norm.{u1} F' (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5)) g')))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.is_bounded_under_le_iff Asymptotics.IsTheta.isBoundedUnder_le_iffâ‚“'. -/
theorem IsTheta.isBoundedUnder_le_iff (h : f' =Î˜[l] g') :
    IsBoundedUnder (Â· â‰¤ Â·) l (norm âˆ˜ f') â†” IsBoundedUnder (Â· â‰¤ Â·) l (norm âˆ˜ g') := by
  simp only [â† is_O_const_of_ne (one_ne_zero' â„), h.is_O_congr_left]
#align asymptotics.is_Theta.is_bounded_under_le_iff Asymptotics.IsTheta.isBoundedUnder_le_iff

/- warning: asymptotics.is_Theta.smul -> Asymptotics.IsTheta.smul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E' : Type.{u2}} {F' : Type.{u3}} {ð•œ : Type.{u4}} {ð•œ' : Type.{u5}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_12 : NormedField.{u4} ð•œ] [_inst_13 : NormedField.{u5} ð•œ'] {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u4, u2} ð•œ E' _inst_12 _inst_4] [_inst_15 : NormedSpace.{u5, u3} ð•œ' F' _inst_13 _inst_5] {fâ‚ : Î± -> ð•œ} {fâ‚‚ : Î± -> ð•œ'} {gâ‚ : Î± -> E'} {gâ‚‚ : Î± -> F'}, (Asymptotics.IsTheta.{u1, u4, u5} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u4} ð•œ _inst_12) (NormedField.toHasNorm.{u5} ð•œ' _inst_13) l fâ‚ fâ‚‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l gâ‚ gâ‚‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l (fun (x : Î±) => SMul.smul.{u4, u2} ð•œ E' (SMulZeroClass.toHasSmul.{u4, u2} ð•œ E' (AddZeroClass.toHasZero.{u2} E' (AddMonoid.toAddZeroClass.{u2} E' (AddCommMonoid.toAddMonoid.{u2} E' (AddCommGroup.toAddCommMonoid.{u2} E' (SeminormedAddCommGroup.toAddCommGroup.{u2} E' _inst_4))))) (SMulWithZero.toSmulZeroClass.{u4, u2} ð•œ E' (MulZeroClass.toHasZero.{u4} ð•œ (MulZeroOneClass.toMulZeroClass.{u4} ð•œ (MonoidWithZero.toMulZeroOneClass.{u4} ð•œ (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))) (AddZeroClass.toHasZero.{u2} E' (AddMonoid.toAddZeroClass.{u2} E' (AddCommMonoid.toAddMonoid.{u2} E' (AddCommGroup.toAddCommMonoid.{u2} E' (SeminormedAddCommGroup.toAddCommGroup.{u2} E' _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u2} ð•œ E' (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12))))) (AddZeroClass.toHasZero.{u2} E' (AddMonoid.toAddZeroClass.{u2} E' (AddCommMonoid.toAddMonoid.{u2} E' (AddCommGroup.toAddCommMonoid.{u2} E' (SeminormedAddCommGroup.toAddCommGroup.{u2} E' _inst_4))))) (Module.toMulActionWithZero.{u4, u2} ð•œ E' (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u2} E' (SeminormedAddCommGroup.toAddCommGroup.{u2} E' _inst_4)) (NormedSpace.toModule.{u4, u2} ð•œ E' _inst_12 _inst_4 _inst_14))))) (fâ‚ x) (gâ‚ x)) (fun (x : Î±) => SMul.smul.{u5, u3} ð•œ' F' (SMulZeroClass.toHasSmul.{u5, u3} ð•œ' F' (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (SMulWithZero.toSmulZeroClass.{u5, u3} ð•œ' F' (MulZeroClass.toHasZero.{u5} ð•œ' (MulZeroOneClass.toMulZeroClass.{u5} ð•œ' (MonoidWithZero.toMulZeroOneClass.{u5} ð•œ' (Semiring.toMonoidWithZero.{u5} ð•œ' (Ring.toSemiring.{u5} ð•œ' (NormedRing.toRing.{u5} ð•œ' (NormedCommRing.toNormedRing.{u5} ð•œ' (NormedField.toNormedCommRing.{u5} ð•œ' _inst_13)))))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (MulActionWithZero.toSMulWithZero.{u5, u3} ð•œ' F' (Semiring.toMonoidWithZero.{u5} ð•œ' (Ring.toSemiring.{u5} ð•œ' (NormedRing.toRing.{u5} ð•œ' (NormedCommRing.toNormedRing.{u5} ð•œ' (NormedField.toNormedCommRing.{u5} ð•œ' _inst_13))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (Module.toMulActionWithZero.{u5, u3} ð•œ' F' (Ring.toSemiring.{u5} ð•œ' (NormedRing.toRing.{u5} ð•œ' (NormedCommRing.toNormedRing.{u5} ð•œ' (NormedField.toNormedCommRing.{u5} ð•œ' _inst_13)))) (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)) (NormedSpace.toModule.{u5, u3} ð•œ' F' _inst_13 _inst_5 _inst_15))))) (fâ‚‚ x) (gâ‚‚ x)))
but is expected to have type
  forall {Î± : Type.{u1}} {E' : Type.{u4}} {F' : Type.{u2}} {ð•œ : Type.{u5}} {ð•œ' : Type.{u3}} [_inst_4 : SeminormedAddCommGroup.{u4} E'] [_inst_5 : SeminormedAddCommGroup.{u2} F'] [_inst_12 : NormedField.{u5} ð•œ] [_inst_13 : NormedField.{u3} ð•œ'] {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u5, u4} ð•œ E' _inst_12 _inst_4] [_inst_15 : NormedSpace.{u3, u2} ð•œ' F' _inst_13 _inst_5] {fâ‚ : Î± -> ð•œ} {fâ‚‚ : Î± -> ð•œ'} {gâ‚ : Î± -> E'} {gâ‚‚ : Î± -> F'}, (Asymptotics.IsTheta.{u1, u5, u3} Î± ð•œ ð•œ' (NormedField.toNorm.{u5} ð•œ _inst_12) (NormedField.toNorm.{u3} ð•œ' _inst_13) l fâ‚ fâ‚‚) -> (Asymptotics.IsTheta.{u1, u4, u2} Î± E' F' (SeminormedAddCommGroup.toNorm.{u4} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l gâ‚ gâ‚‚) -> (Asymptotics.IsTheta.{u1, u4, u2} Î± E' F' (SeminormedAddCommGroup.toNorm.{u4} E' _inst_4) (SeminormedAddCommGroup.toNorm.{u2} F' _inst_5) l (fun (x : Î±) => HSMul.hSMul.{u5, u4, u4} ð•œ E' E' (instHSMul.{u5, u4} ð•œ E' (SMulZeroClass.toSMul.{u5, u4} ð•œ E' (NegZeroClass.toZero.{u4} E' (SubNegZeroMonoid.toNegZeroClass.{u4} E' (SubtractionMonoid.toSubNegZeroMonoid.{u4} E' (SubtractionCommMonoid.toSubtractionMonoid.{u4} E' (AddCommGroup.toDivisionAddCommMonoid.{u4} E' (SeminormedAddCommGroup.toAddCommGroup.{u4} E' _inst_4)))))) (SMulWithZero.toSMulZeroClass.{u5, u4} ð•œ E' (CommMonoidWithZero.toZero.{u5} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u5} ð•œ (Semifield.toCommGroupWithZero.{u5} ð•œ (Field.toSemifield.{u5} ð•œ (NormedField.toField.{u5} ð•œ _inst_12))))) (NegZeroClass.toZero.{u4} E' (SubNegZeroMonoid.toNegZeroClass.{u4} E' (SubtractionMonoid.toSubNegZeroMonoid.{u4} E' (SubtractionCommMonoid.toSubtractionMonoid.{u4} E' (AddCommGroup.toDivisionAddCommMonoid.{u4} E' (SeminormedAddCommGroup.toAddCommGroup.{u4} E' _inst_4)))))) (MulActionWithZero.toSMulWithZero.{u5, u4} ð•œ E' (Semiring.toMonoidWithZero.{u5} ð•œ (DivisionSemiring.toSemiring.{u5} ð•œ (Semifield.toDivisionSemiring.{u5} ð•œ (Field.toSemifield.{u5} ð•œ (NormedField.toField.{u5} ð•œ _inst_12))))) (NegZeroClass.toZero.{u4} E' (SubNegZeroMonoid.toNegZeroClass.{u4} E' (SubtractionMonoid.toSubNegZeroMonoid.{u4} E' (SubtractionCommMonoid.toSubtractionMonoid.{u4} E' (AddCommGroup.toDivisionAddCommMonoid.{u4} E' (SeminormedAddCommGroup.toAddCommGroup.{u4} E' _inst_4)))))) (Module.toMulActionWithZero.{u5, u4} ð•œ E' (DivisionSemiring.toSemiring.{u5} ð•œ (Semifield.toDivisionSemiring.{u5} ð•œ (Field.toSemifield.{u5} ð•œ (NormedField.toField.{u5} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u4} E' (SeminormedAddCommGroup.toAddCommGroup.{u4} E' _inst_4)) (NormedSpace.toModule.{u5, u4} ð•œ E' _inst_12 _inst_4 _inst_14)))))) (fâ‚ x) (gâ‚ x)) (fun (x : Î±) => HSMul.hSMul.{u3, u2, u2} ð•œ' F' F' (instHSMul.{u3, u2} ð•œ' F' (SMulZeroClass.toSMul.{u3, u2} ð•œ' F' (NegZeroClass.toZero.{u2} F' (SubNegZeroMonoid.toNegZeroClass.{u2} F' (SubtractionMonoid.toSubNegZeroMonoid.{u2} F' (SubtractionCommMonoid.toSubtractionMonoid.{u2} F' (AddCommGroup.toDivisionAddCommMonoid.{u2} F' (SeminormedAddCommGroup.toAddCommGroup.{u2} F' _inst_5)))))) (SMulWithZero.toSMulZeroClass.{u3, u2} ð•œ' F' (CommMonoidWithZero.toZero.{u3} ð•œ' (CommGroupWithZero.toCommMonoidWithZero.{u3} ð•œ' (Semifield.toCommGroupWithZero.{u3} ð•œ' (Field.toSemifield.{u3} ð•œ' (NormedField.toField.{u3} ð•œ' _inst_13))))) (NegZeroClass.toZero.{u2} F' (SubNegZeroMonoid.toNegZeroClass.{u2} F' (SubtractionMonoid.toSubNegZeroMonoid.{u2} F' (SubtractionCommMonoid.toSubtractionMonoid.{u2} F' (AddCommGroup.toDivisionAddCommMonoid.{u2} F' (SeminormedAddCommGroup.toAddCommGroup.{u2} F' _inst_5)))))) (MulActionWithZero.toSMulWithZero.{u3, u2} ð•œ' F' (Semiring.toMonoidWithZero.{u3} ð•œ' (DivisionSemiring.toSemiring.{u3} ð•œ' (Semifield.toDivisionSemiring.{u3} ð•œ' (Field.toSemifield.{u3} ð•œ' (NormedField.toField.{u3} ð•œ' _inst_13))))) (NegZeroClass.toZero.{u2} F' (SubNegZeroMonoid.toNegZeroClass.{u2} F' (SubtractionMonoid.toSubNegZeroMonoid.{u2} F' (SubtractionCommMonoid.toSubtractionMonoid.{u2} F' (AddCommGroup.toDivisionAddCommMonoid.{u2} F' (SeminormedAddCommGroup.toAddCommGroup.{u2} F' _inst_5)))))) (Module.toMulActionWithZero.{u3, u2} ð•œ' F' (DivisionSemiring.toSemiring.{u3} ð•œ' (Semifield.toDivisionSemiring.{u3} ð•œ' (Field.toSemifield.{u3} ð•œ' (NormedField.toField.{u3} ð•œ' _inst_13)))) (AddCommGroup.toAddCommMonoid.{u2} F' (SeminormedAddCommGroup.toAddCommGroup.{u2} F' _inst_5)) (NormedSpace.toModule.{u3, u2} ð•œ' F' _inst_13 _inst_5 _inst_15)))))) (fâ‚‚ x) (gâ‚‚ x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.smul Asymptotics.IsTheta.smulâ‚“'. -/
theorem IsTheta.smul [NormedSpace ð•œ E'] [NormedSpace ð•œ' F'] {fâ‚ : Î± â†’ ð•œ} {fâ‚‚ : Î± â†’ ð•œ'} {gâ‚ : Î± â†’ E'}
    {gâ‚‚ : Î± â†’ F'} (hf : fâ‚ =Î˜[l] fâ‚‚) (hg : gâ‚ =Î˜[l] gâ‚‚) :
    (fun x => fâ‚ x â€¢ gâ‚ x) =Î˜[l] fun x => fâ‚‚ x â€¢ gâ‚‚ x :=
  âŸ¨hf.1.smul hg.1, hf.2.smul hg.2âŸ©
#align asymptotics.is_Theta.smul Asymptotics.IsTheta.smul

/- warning: asymptotics.is_Theta.mul -> Asymptotics.IsTheta.mul is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u3}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u3} ð•œ'] {l : Filter.{u1} Î±} {fâ‚ : Î± -> ð•œ} {fâ‚‚ : Î± -> ð•œ} {gâ‚ : Î± -> ð•œ'} {gâ‚‚ : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l fâ‚ gâ‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l fâ‚‚ gâ‚‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l (fun (x : Î±) => HMul.hMul.{u2, u2, u2} ð•œ ð•œ ð•œ (instHMul.{u2} ð•œ (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (NormedRing.toRing.{u2} ð•œ (NormedCommRing.toNormedRing.{u2} ð•œ (NormedField.toNormedCommRing.{u2} ð•œ _inst_12)))))) (fâ‚ x) (fâ‚‚ x)) (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ' ð•œ' ð•œ' (instHMul.{u3} ð•œ' (Distrib.toHasMul.{u3} ð•œ' (Ring.toDistrib.{u3} ð•œ' (NormedRing.toRing.{u3} ð•œ' (NormedCommRing.toNormedRing.{u3} ð•œ' (NormedField.toNormedCommRing.{u3} ð•œ' _inst_13)))))) (gâ‚ x) (gâ‚‚ x)))
but is expected to have type
  forall {Î± : Type.{u3}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u1}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u1} ð•œ'] {l : Filter.{u3} Î±} {fâ‚ : Î± -> ð•œ} {fâ‚‚ : Î± -> ð•œ} {gâ‚ : Î± -> ð•œ'} {gâ‚‚ : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l fâ‚ gâ‚) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l fâ‚‚ gâ‚‚) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l (fun (x : Î±) => HMul.hMul.{u2, u2, u2} ð•œ ð•œ ð•œ (instHMul.{u2} ð•œ (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (NormedRing.toRing.{u2} ð•œ (NormedCommRing.toNormedRing.{u2} ð•œ (NormedField.toNormedCommRing.{u2} ð•œ _inst_12))))))) (fâ‚ x) (fâ‚‚ x)) (fun (x : Î±) => HMul.hMul.{u1, u1, u1} ð•œ' ð•œ' ð•œ' (instHMul.{u1} ð•œ' (NonUnitalNonAssocRing.toMul.{u1} ð•œ' (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ' (Ring.toNonAssocRing.{u1} ð•œ' (NormedRing.toRing.{u1} ð•œ' (NormedCommRing.toNormedRing.{u1} ð•œ' (NormedField.toNormedCommRing.{u1} ð•œ' _inst_13))))))) (gâ‚ x) (gâ‚‚ x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.mul Asymptotics.IsTheta.mulâ‚“'. -/
theorem IsTheta.mul {fâ‚ fâ‚‚ : Î± â†’ ð•œ} {gâ‚ gâ‚‚ : Î± â†’ ð•œ'} (hâ‚ : fâ‚ =Î˜[l] gâ‚) (hâ‚‚ : fâ‚‚ =Î˜[l] gâ‚‚) :
    (fun x => fâ‚ x * fâ‚‚ x) =Î˜[l] fun x => gâ‚ x * gâ‚‚ x :=
  hâ‚.smul hâ‚‚
#align asymptotics.is_Theta.mul Asymptotics.IsTheta.mul

/- warning: asymptotics.is_Theta.inv -> Asymptotics.IsTheta.inv is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u3}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u3} ð•œ'] {l : Filter.{u1} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l f g) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l (fun (x : Î±) => Inv.inv.{u2} ð•œ (DivInvMonoid.toHasInv.{u2} ð•œ (DivisionRing.toDivInvMonoid.{u2} ð•œ (NormedDivisionRing.toDivisionRing.{u2} ð•œ (NormedField.toNormedDivisionRing.{u2} ð•œ _inst_12)))) (f x)) (fun (x : Î±) => Inv.inv.{u3} ð•œ' (DivInvMonoid.toHasInv.{u3} ð•œ' (DivisionRing.toDivInvMonoid.{u3} ð•œ' (NormedDivisionRing.toDivisionRing.{u3} ð•œ' (NormedField.toNormedDivisionRing.{u3} ð•œ' _inst_13)))) (g x)))
but is expected to have type
  forall {Î± : Type.{u3}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u1}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u1} ð•œ'] {l : Filter.{u3} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l f g) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l (fun (x : Î±) => Inv.inv.{u2} ð•œ (Field.toInv.{u2} ð•œ (NormedField.toField.{u2} ð•œ _inst_12)) (f x)) (fun (x : Î±) => Inv.inv.{u1} ð•œ' (Field.toInv.{u1} ð•œ' (NormedField.toField.{u1} ð•œ' _inst_13)) (g x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.inv Asymptotics.IsTheta.invâ‚“'. -/
theorem IsTheta.inv {f : Î± â†’ ð•œ} {g : Î± â†’ ð•œ'} (h : f =Î˜[l] g) :
    (fun x => (f x)â»Â¹) =Î˜[l] fun x => (g x)â»Â¹ :=
  âŸ¨h.2.inv_rev h.1.eq_zero_imp, h.1.inv_rev h.2.eq_zero_impâŸ©
#align asymptotics.is_Theta.inv Asymptotics.IsTheta.inv

/- warning: asymptotics.is_Theta_inv -> Asymptotics.isTheta_inv is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u3}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u3} ð•œ'] {l : Filter.{u1} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, Iff (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l (fun (x : Î±) => Inv.inv.{u2} ð•œ (DivInvMonoid.toHasInv.{u2} ð•œ (DivisionRing.toDivInvMonoid.{u2} ð•œ (NormedDivisionRing.toDivisionRing.{u2} ð•œ (NormedField.toNormedDivisionRing.{u2} ð•œ _inst_12)))) (f x)) (fun (x : Î±) => Inv.inv.{u3} ð•œ' (DivInvMonoid.toHasInv.{u3} ð•œ' (DivisionRing.toDivInvMonoid.{u3} ð•œ' (NormedDivisionRing.toDivisionRing.{u3} ð•œ' (NormedField.toNormedDivisionRing.{u3} ð•œ' _inst_13)))) (g x))) (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l f g)
but is expected to have type
  forall {Î± : Type.{u3}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u1}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u1} ð•œ'] {l : Filter.{u3} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, Iff (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l (fun (x : Î±) => Inv.inv.{u2} ð•œ (Field.toInv.{u2} ð•œ (NormedField.toField.{u2} ð•œ _inst_12)) (f x)) (fun (x : Î±) => Inv.inv.{u1} ð•œ' (Field.toInv.{u1} ð•œ' (NormedField.toField.{u1} ð•œ' _inst_13)) (g x))) (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l f g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_inv Asymptotics.isTheta_invâ‚“'. -/
@[simp]
theorem isTheta_inv {f : Î± â†’ ð•œ} {g : Î± â†’ ð•œ'} :
    ((fun x => (f x)â»Â¹) =Î˜[l] fun x => (g x)â»Â¹) â†” f =Î˜[l] g :=
  âŸ¨fun h => by simpa only [inv_inv] using h.inv, IsTheta.invâŸ©
#align asymptotics.is_Theta_inv Asymptotics.isTheta_inv

/- warning: asymptotics.is_Theta.div -> Asymptotics.IsTheta.div is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u3}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u3} ð•œ'] {l : Filter.{u1} Î±} {fâ‚ : Î± -> ð•œ} {fâ‚‚ : Î± -> ð•œ} {gâ‚ : Î± -> ð•œ'} {gâ‚‚ : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l fâ‚ gâ‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l fâ‚‚ gâ‚‚) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l (fun (x : Î±) => HDiv.hDiv.{u2, u2, u2} ð•œ ð•œ ð•œ (instHDiv.{u2} ð•œ (DivInvMonoid.toHasDiv.{u2} ð•œ (DivisionRing.toDivInvMonoid.{u2} ð•œ (NormedDivisionRing.toDivisionRing.{u2} ð•œ (NormedField.toNormedDivisionRing.{u2} ð•œ _inst_12))))) (fâ‚ x) (fâ‚‚ x)) (fun (x : Î±) => HDiv.hDiv.{u3, u3, u3} ð•œ' ð•œ' ð•œ' (instHDiv.{u3} ð•œ' (DivInvMonoid.toHasDiv.{u3} ð•œ' (DivisionRing.toDivInvMonoid.{u3} ð•œ' (NormedDivisionRing.toDivisionRing.{u3} ð•œ' (NormedField.toNormedDivisionRing.{u3} ð•œ' _inst_13))))) (gâ‚ x) (gâ‚‚ x)))
but is expected to have type
  forall {Î± : Type.{u3}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u1}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u1} ð•œ'] {l : Filter.{u3} Î±} {fâ‚ : Î± -> ð•œ} {fâ‚‚ : Î± -> ð•œ} {gâ‚ : Î± -> ð•œ'} {gâ‚‚ : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l fâ‚ gâ‚) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l fâ‚‚ gâ‚‚) -> (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l (fun (x : Î±) => HDiv.hDiv.{u2, u2, u2} ð•œ ð•œ ð•œ (instHDiv.{u2} ð•œ (Field.toDiv.{u2} ð•œ (NormedField.toField.{u2} ð•œ _inst_12))) (fâ‚ x) (fâ‚‚ x)) (fun (x : Î±) => HDiv.hDiv.{u1, u1, u1} ð•œ' ð•œ' ð•œ' (instHDiv.{u1} ð•œ' (Field.toDiv.{u1} ð•œ' (NormedField.toField.{u1} ð•œ' _inst_13))) (gâ‚ x) (gâ‚‚ x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.div Asymptotics.IsTheta.divâ‚“'. -/
theorem IsTheta.div {fâ‚ fâ‚‚ : Î± â†’ ð•œ} {gâ‚ gâ‚‚ : Î± â†’ ð•œ'} (hâ‚ : fâ‚ =Î˜[l] gâ‚) (hâ‚‚ : fâ‚‚ =Î˜[l] gâ‚‚) :
    (fun x => fâ‚ x / fâ‚‚ x) =Î˜[l] fun x => gâ‚ x / gâ‚‚ x := by
  simpa only [div_eq_mul_inv] using hâ‚.mul hâ‚‚.inv
#align asymptotics.is_Theta.div Asymptotics.IsTheta.div

/- warning: asymptotics.is_Theta.pow -> Asymptotics.IsTheta.pow is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u3}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u3} ð•œ'] {l : Filter.{u1} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l f g) -> (forall (n : Nat), Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l (fun (x : Î±) => HPow.hPow.{u2, 0, u2} ð•œ Nat ð•œ (instHPow.{u2, 0} ð•œ Nat (Monoid.Pow.{u2} ð•œ (Ring.toMonoid.{u2} ð•œ (NormedRing.toRing.{u2} ð•œ (NormedCommRing.toNormedRing.{u2} ð•œ (NormedField.toNormedCommRing.{u2} ð•œ _inst_12)))))) (f x) n) (fun (x : Î±) => HPow.hPow.{u3, 0, u3} ð•œ' Nat ð•œ' (instHPow.{u3, 0} ð•œ' Nat (Monoid.Pow.{u3} ð•œ' (Ring.toMonoid.{u3} ð•œ' (NormedRing.toRing.{u3} ð•œ' (NormedCommRing.toNormedRing.{u3} ð•œ' (NormedField.toNormedCommRing.{u3} ð•œ' _inst_13)))))) (g x) n))
but is expected to have type
  forall {Î± : Type.{u3}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u1}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u1} ð•œ'] {l : Filter.{u3} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l f g) -> (forall (n : Nat), Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l (fun (x : Î±) => HPow.hPow.{u2, 0, u2} ð•œ Nat ð•œ (instHPow.{u2, 0} ð•œ Nat (Monoid.Pow.{u2} ð•œ (MonoidWithZero.toMonoid.{u2} ð•œ (Semiring.toMonoidWithZero.{u2} ð•œ (DivisionSemiring.toSemiring.{u2} ð•œ (Semifield.toDivisionSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ (NormedField.toField.{u2} ð•œ _inst_12)))))))) (f x) n) (fun (x : Î±) => HPow.hPow.{u1, 0, u1} ð•œ' Nat ð•œ' (instHPow.{u1, 0} ð•œ' Nat (Monoid.Pow.{u1} ð•œ' (MonoidWithZero.toMonoid.{u1} ð•œ' (Semiring.toMonoidWithZero.{u1} ð•œ' (DivisionSemiring.toSemiring.{u1} ð•œ' (Semifield.toDivisionSemiring.{u1} ð•œ' (Field.toSemifield.{u1} ð•œ' (NormedField.toField.{u1} ð•œ' _inst_13)))))))) (g x) n))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.pow Asymptotics.IsTheta.powâ‚“'. -/
theorem IsTheta.pow {f : Î± â†’ ð•œ} {g : Î± â†’ ð•œ'} (h : f =Î˜[l] g) (n : â„•) :
    (fun x => f x ^ n) =Î˜[l] fun x => g x ^ n :=
  âŸ¨h.1.pow n, h.2.pow nâŸ©
#align asymptotics.is_Theta.pow Asymptotics.IsTheta.pow

/- warning: asymptotics.is_Theta.zpow -> Asymptotics.IsTheta.zpow is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u3}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u3} ð•œ'] {l : Filter.{u1} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l f g) -> (forall (n : Int), Asymptotics.IsTheta.{u1, u2, u3} Î± ð•œ ð•œ' (NormedField.toHasNorm.{u2} ð•œ _inst_12) (NormedField.toHasNorm.{u3} ð•œ' _inst_13) l (fun (x : Î±) => HPow.hPow.{u2, 0, u2} ð•œ Int ð•œ (instHPow.{u2, 0} ð•œ Int (DivInvMonoid.Pow.{u2} ð•œ (DivisionRing.toDivInvMonoid.{u2} ð•œ (NormedDivisionRing.toDivisionRing.{u2} ð•œ (NormedField.toNormedDivisionRing.{u2} ð•œ _inst_12))))) (f x) n) (fun (x : Î±) => HPow.hPow.{u3, 0, u3} ð•œ' Int ð•œ' (instHPow.{u3, 0} ð•œ' Int (DivInvMonoid.Pow.{u3} ð•œ' (DivisionRing.toDivInvMonoid.{u3} ð•œ' (NormedDivisionRing.toDivisionRing.{u3} ð•œ' (NormedField.toNormedDivisionRing.{u3} ð•œ' _inst_13))))) (g x) n))
but is expected to have type
  forall {Î± : Type.{u3}} {ð•œ : Type.{u2}} {ð•œ' : Type.{u1}} [_inst_12 : NormedField.{u2} ð•œ] [_inst_13 : NormedField.{u1} ð•œ'] {l : Filter.{u3} Î±} {f : Î± -> ð•œ} {g : Î± -> ð•œ'}, (Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l f g) -> (forall (n : Int), Asymptotics.IsTheta.{u3, u2, u1} Î± ð•œ ð•œ' (NormedField.toNorm.{u2} ð•œ _inst_12) (NormedField.toNorm.{u1} ð•œ' _inst_13) l (fun (x : Î±) => HPow.hPow.{u2, 0, u2} ð•œ Int ð•œ (instHPow.{u2, 0} ð•œ Int (DivInvMonoid.Pow.{u2} ð•œ (DivisionRing.toDivInvMonoid.{u2} ð•œ (NormedDivisionRing.toDivisionRing.{u2} ð•œ (NormedField.toNormedDivisionRing.{u2} ð•œ _inst_12))))) (f x) n) (fun (x : Î±) => HPow.hPow.{u1, 0, u1} ð•œ' Int ð•œ' (instHPow.{u1, 0} ð•œ' Int (DivInvMonoid.Pow.{u1} ð•œ' (DivisionRing.toDivInvMonoid.{u1} ð•œ' (NormedDivisionRing.toDivisionRing.{u1} ð•œ' (NormedField.toNormedDivisionRing.{u1} ð•œ' _inst_13))))) (g x) n))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.zpow Asymptotics.IsTheta.zpowâ‚“'. -/
theorem IsTheta.zpow {f : Î± â†’ ð•œ} {g : Î± â†’ ð•œ'} (h : f =Î˜[l] g) (n : â„¤) :
    (fun x => f x ^ n) =Î˜[l] fun x => g x ^ n :=
  by
  cases n
  Â· simpa only [zpow_ofNat] using h.pow _
  Â· simpa only [zpow_negSucc] using (h.pow _).inv
#align asymptotics.is_Theta.zpow Asymptotics.IsTheta.zpow

/- warning: asymptotics.is_Theta_const_const -> Asymptotics.isTheta_const_const is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E'' : Type.{u2}} {F'' : Type.{u3}} [_inst_7 : NormedAddCommGroup.{u2} E''] [_inst_8 : NormedAddCommGroup.{u3} F''] {l : Filter.{u1} Î±} {câ‚ : E''} {câ‚‚ : F''}, (Ne.{succ u2} E'' câ‚ (OfNat.ofNat.{u2} E'' 0 (OfNat.mk.{u2} E'' 0 (Zero.zero.{u2} E'' (AddZeroClass.toHasZero.{u2} E'' (AddMonoid.toAddZeroClass.{u2} E'' (SubNegMonoid.toAddMonoid.{u2} E'' (AddGroup.toSubNegMonoid.{u2} E'' (NormedAddGroup.toAddGroup.{u2} E'' (NormedAddCommGroup.toNormedAddGroup.{u2} E'' _inst_7)))))))))) -> (Ne.{succ u3} F'' câ‚‚ (OfNat.ofNat.{u3} F'' 0 (OfNat.mk.{u3} F'' 0 (Zero.zero.{u3} F'' (AddZeroClass.toHasZero.{u3} F'' (AddMonoid.toAddZeroClass.{u3} F'' (SubNegMonoid.toAddMonoid.{u3} F'' (AddGroup.toSubNegMonoid.{u3} F'' (NormedAddGroup.toAddGroup.{u3} F'' (NormedAddCommGroup.toNormedAddGroup.{u3} F'' _inst_8)))))))))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E'' F'' (NormedAddCommGroup.toHasNorm.{u2} E'' _inst_7) (NormedAddCommGroup.toHasNorm.{u3} F'' _inst_8) l (fun (x : Î±) => câ‚) (fun (x : Î±) => câ‚‚))
but is expected to have type
  forall {Î± : Type.{u1}} {E'' : Type.{u3}} {F'' : Type.{u2}} [_inst_7 : NormedAddCommGroup.{u3} E''] [_inst_8 : NormedAddCommGroup.{u2} F''] {l : Filter.{u1} Î±} {câ‚ : E''} {câ‚‚ : F''}, (Ne.{succ u3} E'' câ‚ (OfNat.ofNat.{u3} E'' 0 (Zero.toOfNat0.{u3} E'' (NegZeroClass.toZero.{u3} E'' (SubNegZeroMonoid.toNegZeroClass.{u3} E'' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E'' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E'' (AddCommGroup.toDivisionAddCommMonoid.{u3} E'' (NormedAddCommGroup.toAddCommGroup.{u3} E'' _inst_7))))))))) -> (Ne.{succ u2} F'' câ‚‚ (OfNat.ofNat.{u2} F'' 0 (Zero.toOfNat0.{u2} F'' (NegZeroClass.toZero.{u2} F'' (SubNegZeroMonoid.toNegZeroClass.{u2} F'' (SubtractionMonoid.toSubNegZeroMonoid.{u2} F'' (SubtractionCommMonoid.toSubtractionMonoid.{u2} F'' (AddCommGroup.toDivisionAddCommMonoid.{u2} F'' (NormedAddCommGroup.toAddCommGroup.{u2} F'' _inst_8))))))))) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± E'' F'' (NormedAddCommGroup.toNorm.{u3} E'' _inst_7) (NormedAddCommGroup.toNorm.{u2} F'' _inst_8) l (fun (x : Î±) => câ‚) (fun (x : Î±) => câ‚‚))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_const_const Asymptotics.isTheta_const_constâ‚“'. -/
theorem isTheta_const_const {câ‚ : E''} {câ‚‚ : F''} (hâ‚ : câ‚ â‰  0) (hâ‚‚ : câ‚‚ â‰  0) :
    (fun x : Î± => câ‚) =Î˜[l] fun x => câ‚‚ :=
  âŸ¨isBigO_const_const _ hâ‚‚ _, isBigO_const_const _ hâ‚ _âŸ©
#align asymptotics.is_Theta_const_const Asymptotics.isTheta_const_const

/- warning: asymptotics.is_Theta_const_const_iff -> Asymptotics.isTheta_const_const_iff is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E'' : Type.{u2}} {F'' : Type.{u3}} [_inst_7 : NormedAddCommGroup.{u2} E''] [_inst_8 : NormedAddCommGroup.{u3} F''] {l : Filter.{u1} Î±} [_inst_14 : Filter.NeBot.{u1} Î± l] {câ‚ : E''} {câ‚‚ : F''}, Iff (Asymptotics.IsTheta.{u1, u2, u3} Î± E'' F'' (NormedAddCommGroup.toHasNorm.{u2} E'' _inst_7) (NormedAddCommGroup.toHasNorm.{u3} F'' _inst_8) l (fun (x : Î±) => câ‚) (fun (x : Î±) => câ‚‚)) (Iff (Eq.{succ u2} E'' câ‚ (OfNat.ofNat.{u2} E'' 0 (OfNat.mk.{u2} E'' 0 (Zero.zero.{u2} E'' (AddZeroClass.toHasZero.{u2} E'' (AddMonoid.toAddZeroClass.{u2} E'' (SubNegMonoid.toAddMonoid.{u2} E'' (AddGroup.toSubNegMonoid.{u2} E'' (NormedAddGroup.toAddGroup.{u2} E'' (NormedAddCommGroup.toNormedAddGroup.{u2} E'' _inst_7)))))))))) (Eq.{succ u3} F'' câ‚‚ (OfNat.ofNat.{u3} F'' 0 (OfNat.mk.{u3} F'' 0 (Zero.zero.{u3} F'' (AddZeroClass.toHasZero.{u3} F'' (AddMonoid.toAddZeroClass.{u3} F'' (SubNegMonoid.toAddMonoid.{u3} F'' (AddGroup.toSubNegMonoid.{u3} F'' (NormedAddGroup.toAddGroup.{u3} F'' (NormedAddCommGroup.toNormedAddGroup.{u3} F'' _inst_8)))))))))))
but is expected to have type
  forall {Î± : Type.{u3}} {E'' : Type.{u2}} {F'' : Type.{u1}} [_inst_7 : NormedAddCommGroup.{u2} E''] [_inst_8 : NormedAddCommGroup.{u1} F''] {l : Filter.{u3} Î±} [_inst_14 : Filter.NeBot.{u3} Î± l] {câ‚ : E''} {câ‚‚ : F''}, Iff (Asymptotics.IsTheta.{u3, u2, u1} Î± E'' F'' (NormedAddCommGroup.toNorm.{u2} E'' _inst_7) (NormedAddCommGroup.toNorm.{u1} F'' _inst_8) l (fun (x : Î±) => câ‚) (fun (x : Î±) => câ‚‚)) (Iff (Eq.{succ u2} E'' câ‚ (OfNat.ofNat.{u2} E'' 0 (Zero.toOfNat0.{u2} E'' (NegZeroClass.toZero.{u2} E'' (SubNegZeroMonoid.toNegZeroClass.{u2} E'' (SubtractionMonoid.toSubNegZeroMonoid.{u2} E'' (SubtractionCommMonoid.toSubtractionMonoid.{u2} E'' (AddCommGroup.toDivisionAddCommMonoid.{u2} E'' (NormedAddCommGroup.toAddCommGroup.{u2} E'' _inst_7))))))))) (Eq.{succ u1} F'' câ‚‚ (OfNat.ofNat.{u1} F'' 0 (Zero.toOfNat0.{u1} F'' (NegZeroClass.toZero.{u1} F'' (SubNegZeroMonoid.toNegZeroClass.{u1} F'' (SubtractionMonoid.toSubNegZeroMonoid.{u1} F'' (SubtractionCommMonoid.toSubtractionMonoid.{u1} F'' (AddCommGroup.toDivisionAddCommMonoid.{u1} F'' (NormedAddCommGroup.toAddCommGroup.{u1} F'' _inst_8))))))))))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_const_const_iff Asymptotics.isTheta_const_const_iffâ‚“'. -/
@[simp]
theorem isTheta_const_const_iff [NeBot l] {câ‚ : E''} {câ‚‚ : F''} :
    ((fun x : Î± => câ‚) =Î˜[l] fun x => câ‚‚) â†” (câ‚ = 0 â†” câ‚‚ = 0) := by
  simpa only [is_Theta, is_O_const_const_iff, â† iff_def] using Iff.comm
#align asymptotics.is_Theta_const_const_iff Asymptotics.isTheta_const_const_iff

/- warning: asymptotics.is_Theta_zero_left -> Asymptotics.isTheta_zero_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E' : Type.{u2}} {F'' : Type.{u3}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_8 : NormedAddCommGroup.{u3} F''] {g'' : Î± -> F''} {l : Filter.{u1} Î±}, Iff (Asymptotics.IsTheta.{u1, u2, u3} Î± E' F'' (SeminormedAddCommGroup.toHasNorm.{u2} E' _inst_4) (NormedAddCommGroup.toHasNorm.{u3} F'' _inst_8) l (fun (x : Î±) => OfNat.ofNat.{u2} E' 0 (OfNat.mk.{u2} E' 0 (Zero.zero.{u2} E' (AddZeroClass.toHasZero.{u2} E' (AddMonoid.toAddZeroClass.{u2} E' (SubNegMonoid.toAddMonoid.{u2} E' (AddGroup.toSubNegMonoid.{u2} E' (SeminormedAddGroup.toAddGroup.{u2} E' (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E' _inst_4))))))))) g'') (Filter.EventuallyEq.{u1, u3} Î± F'' l g'' (OfNat.ofNat.{max u1 u3} (Î± -> F'') 0 (OfNat.mk.{max u1 u3} (Î± -> F'') 0 (Zero.zero.{max u1 u3} (Î± -> F'') (Pi.instZero.{u1, u3} Î± (fun (á¾° : Î±) => F'') (fun (i : Î±) => AddZeroClass.toHasZero.{u3} F'' (AddMonoid.toAddZeroClass.{u3} F'' (SubNegMonoid.toAddMonoid.{u3} F'' (AddGroup.toSubNegMonoid.{u3} F'' (NormedAddGroup.toAddGroup.{u3} F'' (NormedAddCommGroup.toNormedAddGroup.{u3} F'' _inst_8)))))))))))
but is expected to have type
  forall {Î± : Type.{u3}} {E' : Type.{u2}} {F'' : Type.{u1}} [_inst_4 : SeminormedAddCommGroup.{u2} E'] [_inst_8 : NormedAddCommGroup.{u1} F''] {g'' : Î± -> F''} {l : Filter.{u3} Î±}, Iff (Asymptotics.IsTheta.{u3, u2, u1} Î± E' F'' (SeminormedAddCommGroup.toNorm.{u2} E' _inst_4) (NormedAddCommGroup.toNorm.{u1} F'' _inst_8) l (fun (x : Î±) => OfNat.ofNat.{u2} E' 0 (Zero.toOfNat0.{u2} E' (NegZeroClass.toZero.{u2} E' (SubNegZeroMonoid.toNegZeroClass.{u2} E' (SubtractionMonoid.toSubNegZeroMonoid.{u2} E' (SubtractionCommMonoid.toSubtractionMonoid.{u2} E' (AddCommGroup.toDivisionAddCommMonoid.{u2} E' (SeminormedAddCommGroup.toAddCommGroup.{u2} E' _inst_4)))))))) g'') (Filter.EventuallyEq.{u3, u1} Î± F'' l g'' (OfNat.ofNat.{max u3 u1} (Î± -> F'') 0 (Zero.toOfNat0.{max u3 u1} (Î± -> F'') (Pi.instZero.{u3, u1} Î± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19139 : Î±) => F'') (fun (i : Î±) => NegZeroClass.toZero.{u1} F'' (SubNegZeroMonoid.toNegZeroClass.{u1} F'' (SubtractionMonoid.toSubNegZeroMonoid.{u1} F'' (SubtractionCommMonoid.toSubtractionMonoid.{u1} F'' (AddCommGroup.toDivisionAddCommMonoid.{u1} F'' (NormedAddCommGroup.toAddCommGroup.{u1} F'' _inst_8))))))))))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_zero_left Asymptotics.isTheta_zero_leftâ‚“'. -/
@[simp]
theorem isTheta_zero_left : (fun x => (0 : E')) =Î˜[l] g'' â†” g'' =á¶ [l] 0 := by
  simp only [is_Theta, is_O_zero, is_O_zero_right_iff, true_and_iff]
#align asymptotics.is_Theta_zero_left Asymptotics.isTheta_zero_left

/- warning: asymptotics.is_Theta_zero_right -> Asymptotics.isTheta_zero_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F' : Type.{u2}} {E'' : Type.{u3}} [_inst_5 : SeminormedAddCommGroup.{u2} F'] [_inst_7 : NormedAddCommGroup.{u3} E''] {f'' : Î± -> E''} {l : Filter.{u1} Î±}, Iff (Asymptotics.IsTheta.{u1, u3, u2} Î± E'' F' (NormedAddCommGroup.toHasNorm.{u3} E'' _inst_7) (SeminormedAddCommGroup.toHasNorm.{u2} F' _inst_5) l f'' (fun (x : Î±) => OfNat.ofNat.{u2} F' 0 (OfNat.mk.{u2} F' 0 (Zero.zero.{u2} F' (AddZeroClass.toHasZero.{u2} F' (AddMonoid.toAddZeroClass.{u2} F' (SubNegMonoid.toAddMonoid.{u2} F' (AddGroup.toSubNegMonoid.{u2} F' (SeminormedAddGroup.toAddGroup.{u2} F' (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} F' _inst_5)))))))))) (Filter.EventuallyEq.{u1, u3} Î± E'' l f'' (OfNat.ofNat.{max u1 u3} (Î± -> E'') 0 (OfNat.mk.{max u1 u3} (Î± -> E'') 0 (Zero.zero.{max u1 u3} (Î± -> E'') (Pi.instZero.{u1, u3} Î± (fun (á¾° : Î±) => E'') (fun (i : Î±) => AddZeroClass.toHasZero.{u3} E'' (AddMonoid.toAddZeroClass.{u3} E'' (SubNegMonoid.toAddMonoid.{u3} E'' (AddGroup.toSubNegMonoid.{u3} E'' (NormedAddGroup.toAddGroup.{u3} E'' (NormedAddCommGroup.toNormedAddGroup.{u3} E'' _inst_7)))))))))))
but is expected to have type
  forall {Î± : Type.{u3}} {F' : Type.{u1}} {E'' : Type.{u2}} [_inst_5 : SeminormedAddCommGroup.{u1} F'] [_inst_7 : NormedAddCommGroup.{u2} E''] {f'' : Î± -> E''} {l : Filter.{u3} Î±}, Iff (Asymptotics.IsTheta.{u3, u2, u1} Î± E'' F' (NormedAddCommGroup.toNorm.{u2} E'' _inst_7) (SeminormedAddCommGroup.toNorm.{u1} F' _inst_5) l f'' (fun (x : Î±) => OfNat.ofNat.{u1} F' 0 (Zero.toOfNat0.{u1} F' (NegZeroClass.toZero.{u1} F' (SubNegZeroMonoid.toNegZeroClass.{u1} F' (SubtractionMonoid.toSubNegZeroMonoid.{u1} F' (SubtractionCommMonoid.toSubtractionMonoid.{u1} F' (AddCommGroup.toDivisionAddCommMonoid.{u1} F' (SeminormedAddCommGroup.toAddCommGroup.{u1} F' _inst_5))))))))) (Filter.EventuallyEq.{u3, u2} Î± E'' l f'' (OfNat.ofNat.{max u3 u2} (Î± -> E'') 0 (Zero.toOfNat0.{max u3 u2} (Î± -> E'') (Pi.instZero.{u3, u2} Î± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19139 : Î±) => E'') (fun (i : Î±) => NegZeroClass.toZero.{u2} E'' (SubNegZeroMonoid.toNegZeroClass.{u2} E'' (SubtractionMonoid.toSubNegZeroMonoid.{u2} E'' (SubtractionCommMonoid.toSubtractionMonoid.{u2} E'' (AddCommGroup.toDivisionAddCommMonoid.{u2} E'' (NormedAddCommGroup.toAddCommGroup.{u2} E'' _inst_7))))))))))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_zero_right Asymptotics.isTheta_zero_rightâ‚“'. -/
@[simp]
theorem isTheta_zero_right : (f'' =Î˜[l] fun x => (0 : F')) â†” f'' =á¶ [l] 0 :=
  isTheta_comm.trans isTheta_zero_left
#align asymptotics.is_Theta_zero_right Asymptotics.isTheta_zero_right

/- warning: asymptotics.is_Theta_const_smul_left -> Asymptotics.isTheta_const_smul_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {E' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_12 : NormedField.{u4} ð•œ] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ E' _inst_12 _inst_4] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (OfNat.mk.{u4} ð•œ 0 (Zero.zero.{u4} ð•œ (MulZeroClass.toHasZero.{u4} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u4} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u4} ð•œ (Ring.toNonAssocRing.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))))))) -> (Iff (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l (fun (x : Î±) => SMul.smul.{u4, u3} ð•œ E' (SMulZeroClass.toHasSmul.{u4, u3} ð•œ E' (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (SMulWithZero.toSmulZeroClass.{u4, u3} ð•œ E' (MulZeroClass.toHasZero.{u4} ð•œ (MulZeroOneClass.toMulZeroClass.{u4} ð•œ (MonoidWithZero.toMulZeroOneClass.{u4} ð•œ (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))) (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ E' (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12))))) (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (Module.toMulActionWithZero.{u4, u3} ð•œ E' (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)) (NormedSpace.toModule.{u4, u3} ð•œ E' _inst_12 _inst_4 _inst_14))))) c (f' x)) g) (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l f' g))
but is expected to have type
  forall {Î± : Type.{u2}} {F : Type.{u1}} {E' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_2 : Norm.{u1} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_12 : NormedField.{u4} ð•œ] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u2} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ E' _inst_12 _inst_4] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (Zero.toOfNat0.{u4} ð•œ (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))))))) -> (Iff (Asymptotics.IsTheta.{u2, u3, u1} Î± E' F (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_2 l (fun (x : Î±) => HSMul.hSMul.{u4, u3, u3} ð•œ E' E' (instHSMul.{u4, u3} ð•œ E' (SMulZeroClass.toSMul.{u4, u3} ð•œ E' (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (SMulWithZero.toSMulZeroClass.{u4, u3} ð•œ E' (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ E' (Semiring.toMonoidWithZero.{u4} ð•œ (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (Module.toMulActionWithZero.{u4, u3} ð•œ E' (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)) (NormedSpace.toModule.{u4, u3} ð•œ E' _inst_12 _inst_4 _inst_14)))))) c (f' x)) g) (Asymptotics.IsTheta.{u2, u3, u1} Î± E' F (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_2 l f' g))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_const_smul_left Asymptotics.isTheta_const_smul_leftâ‚“'. -/
theorem isTheta_const_smul_left [NormedSpace ð•œ E'] {c : ð•œ} (hc : c â‰  0) :
    (fun x => c â€¢ f' x) =Î˜[l] g â†” f' =Î˜[l] g :=
  and_congr (isBigO_const_smul_left hc) (isBigO_const_smul_right hc)
#align asymptotics.is_Theta_const_smul_left Asymptotics.isTheta_const_smul_left

/- warning: asymptotics.is_Theta.of_const_smul_left -> Asymptotics.IsTheta.of_const_smul_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {E' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_12 : NormedField.{u4} ð•œ] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ E' _inst_12 _inst_4] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (OfNat.mk.{u4} ð•œ 0 (Zero.zero.{u4} ð•œ (MulZeroClass.toHasZero.{u4} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u4} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u4} ð•œ (Ring.toNonAssocRing.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l (fun (x : Î±) => SMul.smul.{u4, u3} ð•œ E' (SMulZeroClass.toHasSmul.{u4, u3} ð•œ E' (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (SMulWithZero.toSmulZeroClass.{u4, u3} ð•œ E' (MulZeroClass.toHasZero.{u4} ð•œ (MulZeroOneClass.toMulZeroClass.{u4} ð•œ (MonoidWithZero.toMulZeroOneClass.{u4} ð•œ (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))) (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ E' (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12))))) (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (Module.toMulActionWithZero.{u4, u3} ð•œ E' (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)) (NormedSpace.toModule.{u4, u3} ð•œ E' _inst_12 _inst_4 _inst_14))))) c (f' x)) g) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l f' g)
but is expected to have type
  forall {Î± : Type.{u2}} {F : Type.{u1}} {E' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_2 : Norm.{u1} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_12 : NormedField.{u4} ð•œ] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u2} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ E' _inst_12 _inst_4] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (Zero.toOfNat0.{u4} ð•œ (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± E' F (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_2 l (fun (x : Î±) => HSMul.hSMul.{u4, u3, u3} ð•œ E' E' (instHSMul.{u4, u3} ð•œ E' (SMulZeroClass.toSMul.{u4, u3} ð•œ E' (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (SMulWithZero.toSMulZeroClass.{u4, u3} ð•œ E' (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ E' (Semiring.toMonoidWithZero.{u4} ð•œ (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (Module.toMulActionWithZero.{u4, u3} ð•œ E' (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)) (NormedSpace.toModule.{u4, u3} ð•œ E' _inst_12 _inst_4 _inst_14)))))) c (f' x)) g) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± E' F (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_2 l f' g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.of_const_smul_left Asymptotics.IsTheta.of_const_smul_leftâ‚“'. -/
/- warning: asymptotics.is_Theta.const_smul_left -> Asymptotics.IsTheta.const_smul_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {E' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_2 : Norm.{u2} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_12 : NormedField.{u4} ð•œ] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ E' _inst_12 _inst_4] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (OfNat.mk.{u4} ð•œ 0 (Zero.zero.{u4} ð•œ (MulZeroClass.toHasZero.{u4} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u4} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u4} ð•œ (Ring.toNonAssocRing.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l f' g) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± E' F (SeminormedAddCommGroup.toHasNorm.{u3} E' _inst_4) _inst_2 l (fun (x : Î±) => SMul.smul.{u4, u3} ð•œ E' (SMulZeroClass.toHasSmul.{u4, u3} ð•œ E' (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (SMulWithZero.toSmulZeroClass.{u4, u3} ð•œ E' (MulZeroClass.toHasZero.{u4} ð•œ (MulZeroOneClass.toMulZeroClass.{u4} ð•œ (MonoidWithZero.toMulZeroOneClass.{u4} ð•œ (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))) (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ E' (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12))))) (AddZeroClass.toHasZero.{u3} E' (AddMonoid.toAddZeroClass.{u3} E' (AddCommMonoid.toAddMonoid.{u3} E' (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4))))) (Module.toMulActionWithZero.{u4, u3} ð•œ E' (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)) (NormedSpace.toModule.{u4, u3} ð•œ E' _inst_12 _inst_4 _inst_14))))) c (f' x)) g)
but is expected to have type
  forall {Î± : Type.{u2}} {F : Type.{u1}} {E' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_2 : Norm.{u1} F] [_inst_4 : SeminormedAddCommGroup.{u3} E'] [_inst_12 : NormedField.{u4} ð•œ] {g : Î± -> F} {f' : Î± -> E'} {l : Filter.{u2} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ E' _inst_12 _inst_4] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (Zero.toOfNat0.{u4} ð•œ (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± E' F (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_2 l f' g) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± E' F (SeminormedAddCommGroup.toNorm.{u3} E' _inst_4) _inst_2 l (fun (x : Î±) => HSMul.hSMul.{u4, u3, u3} ð•œ E' E' (instHSMul.{u4, u3} ð•œ E' (SMulZeroClass.toSMul.{u4, u3} ð•œ E' (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (SMulWithZero.toSMulZeroClass.{u4, u3} ð•œ E' (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ E' (Semiring.toMonoidWithZero.{u4} ð•œ (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} E' (SubNegZeroMonoid.toNegZeroClass.{u3} E' (SubtractionMonoid.toSubNegZeroMonoid.{u3} E' (SubtractionCommMonoid.toSubtractionMonoid.{u3} E' (AddCommGroup.toDivisionAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)))))) (Module.toMulActionWithZero.{u4, u3} ð•œ E' (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} E' (SeminormedAddCommGroup.toAddCommGroup.{u3} E' _inst_4)) (NormedSpace.toModule.{u4, u3} ð•œ E' _inst_12 _inst_4 _inst_14)))))) c (f' x)) g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.const_smul_left Asymptotics.IsTheta.const_smul_leftâ‚“'. -/
alias is_Theta_const_smul_left â†” is_Theta.of_const_smul_left is_Theta.const_smul_left
#align asymptotics.is_Theta.of_const_smul_left Asymptotics.IsTheta.of_const_smul_left
#align asymptotics.is_Theta.const_smul_left Asymptotics.IsTheta.const_smul_left

/- warning: asymptotics.is_Theta_const_smul_right -> Asymptotics.isTheta_const_smul_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_12 : NormedField.{u4} ð•œ] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ F' _inst_12 _inst_5] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (OfNat.mk.{u4} ð•œ 0 (Zero.zero.{u4} ð•œ (MulZeroClass.toHasZero.{u4} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u4} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u4} ð•œ (Ring.toNonAssocRing.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))))))) -> (Iff (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f (fun (x : Î±) => SMul.smul.{u4, u3} ð•œ F' (SMulZeroClass.toHasSmul.{u4, u3} ð•œ F' (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (SMulWithZero.toSmulZeroClass.{u4, u3} ð•œ F' (MulZeroClass.toHasZero.{u4} ð•œ (MulZeroOneClass.toMulZeroClass.{u4} ð•œ (MonoidWithZero.toMulZeroOneClass.{u4} ð•œ (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ F' (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (Module.toMulActionWithZero.{u4, u3} ð•œ F' (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)) (NormedSpace.toModule.{u4, u3} ð•œ F' _inst_12 _inst_5 _inst_14))))) c (g' x))) (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g'))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} {F' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_1 : Norm.{u1} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_12 : NormedField.{u4} ð•œ] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u2} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ F' _inst_12 _inst_5] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (Zero.toOfNat0.{u4} ð•œ (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))))))) -> (Iff (Asymptotics.IsTheta.{u2, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f (fun (x : Î±) => HSMul.hSMul.{u4, u3, u3} ð•œ F' F' (instHSMul.{u4, u3} ð•œ F' (SMulZeroClass.toSMul.{u4, u3} ð•œ F' (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (SMulWithZero.toSMulZeroClass.{u4, u3} ð•œ F' (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ F' (Semiring.toMonoidWithZero.{u4} ð•œ (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (Module.toMulActionWithZero.{u4, u3} ð•œ F' (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)) (NormedSpace.toModule.{u4, u3} ð•œ F' _inst_12 _inst_5 _inst_14)))))) c (g' x))) (Asymptotics.IsTheta.{u2, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f g'))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_const_smul_right Asymptotics.isTheta_const_smul_rightâ‚“'. -/
theorem isTheta_const_smul_right [NormedSpace ð•œ F'] {c : ð•œ} (hc : c â‰  0) :
    (f =Î˜[l] fun x => c â€¢ g' x) â†” f =Î˜[l] g' :=
  and_congr (isBigO_const_smul_right hc) (isBigO_const_smul_left hc)
#align asymptotics.is_Theta_const_smul_right Asymptotics.isTheta_const_smul_right

/- warning: asymptotics.is_Theta.of_const_smul_right -> Asymptotics.IsTheta.of_const_smul_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_12 : NormedField.{u4} ð•œ] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ F' _inst_12 _inst_5] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (OfNat.mk.{u4} ð•œ 0 (Zero.zero.{u4} ð•œ (MulZeroClass.toHasZero.{u4} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u4} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u4} ð•œ (Ring.toNonAssocRing.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f (fun (x : Î±) => SMul.smul.{u4, u3} ð•œ F' (SMulZeroClass.toHasSmul.{u4, u3} ð•œ F' (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (SMulWithZero.toSmulZeroClass.{u4, u3} ð•œ F' (MulZeroClass.toHasZero.{u4} ð•œ (MulZeroOneClass.toMulZeroClass.{u4} ð•œ (MonoidWithZero.toMulZeroOneClass.{u4} ð•œ (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ F' (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (Module.toMulActionWithZero.{u4, u3} ð•œ F' (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)) (NormedSpace.toModule.{u4, u3} ð•œ F' _inst_12 _inst_5 _inst_14))))) c (g' x))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g')
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} {F' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_1 : Norm.{u1} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_12 : NormedField.{u4} ð•œ] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u2} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ F' _inst_12 _inst_5] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (Zero.toOfNat0.{u4} ð•œ (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f (fun (x : Î±) => HSMul.hSMul.{u4, u3, u3} ð•œ F' F' (instHSMul.{u4, u3} ð•œ F' (SMulZeroClass.toSMul.{u4, u3} ð•œ F' (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (SMulWithZero.toSMulZeroClass.{u4, u3} ð•œ F' (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ F' (Semiring.toMonoidWithZero.{u4} ð•œ (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (Module.toMulActionWithZero.{u4, u3} ð•œ F' (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)) (NormedSpace.toModule.{u4, u3} ð•œ F' _inst_12 _inst_5 _inst_14)))))) c (g' x))) -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f g')
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.of_const_smul_right Asymptotics.IsTheta.of_const_smul_rightâ‚“'. -/
/- warning: asymptotics.is_Theta.const_smul_right -> Asymptotics.IsTheta.const_smul_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {F' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_1 : Norm.{u2} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_12 : NormedField.{u4} ð•œ] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u1} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ F' _inst_12 _inst_5] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (OfNat.mk.{u4} ð•œ 0 (Zero.zero.{u4} ð•œ (MulZeroClass.toHasZero.{u4} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u4} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u4} ð•œ (Ring.toNonAssocRing.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f g') -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toHasNorm.{u3} F' _inst_5) l f (fun (x : Î±) => SMul.smul.{u4, u3} ð•œ F' (SMulZeroClass.toHasSmul.{u4, u3} ð•œ F' (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (SMulWithZero.toSmulZeroClass.{u4, u3} ð•œ F' (MulZeroClass.toHasZero.{u4} ð•œ (MulZeroOneClass.toMulZeroClass.{u4} ð•œ (MonoidWithZero.toMulZeroOneClass.{u4} ð•œ (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ F' (Semiring.toMonoidWithZero.{u4} ð•œ (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12))))) (AddZeroClass.toHasZero.{u3} F' (AddMonoid.toAddZeroClass.{u3} F' (AddCommMonoid.toAddMonoid.{u3} F' (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5))))) (Module.toMulActionWithZero.{u4, u3} ð•œ F' (Ring.toSemiring.{u4} ð•œ (NormedRing.toRing.{u4} ð•œ (NormedCommRing.toNormedRing.{u4} ð•œ (NormedField.toNormedCommRing.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)) (NormedSpace.toModule.{u4, u3} ð•œ F' _inst_12 _inst_5 _inst_14))))) c (g' x)))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} {F' : Type.{u3}} {ð•œ : Type.{u4}} [_inst_1 : Norm.{u1} E] [_inst_5 : SeminormedAddCommGroup.{u3} F'] [_inst_12 : NormedField.{u4} ð•œ] {f : Î± -> E} {g' : Î± -> F'} {l : Filter.{u2} Î±} [_inst_14 : NormedSpace.{u4, u3} ð•œ F' _inst_12 _inst_5] {c : ð•œ}, (Ne.{succ u4} ð•œ c (OfNat.ofNat.{u4} ð•œ 0 (Zero.toOfNat0.{u4} ð•œ (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f g') -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E F' _inst_1 (SeminormedAddCommGroup.toNorm.{u3} F' _inst_5) l f (fun (x : Î±) => HSMul.hSMul.{u4, u3, u3} ð•œ F' F' (instHSMul.{u4, u3} ð•œ F' (SMulZeroClass.toSMul.{u4, u3} ð•œ F' (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (SMulWithZero.toSMulZeroClass.{u4, u3} ð•œ F' (CommMonoidWithZero.toZero.{u4} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u4} ð•œ (Semifield.toCommGroupWithZero.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (MulActionWithZero.toSMulWithZero.{u4, u3} ð•œ F' (Semiring.toMonoidWithZero.{u4} ð•œ (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12))))) (NegZeroClass.toZero.{u3} F' (SubNegZeroMonoid.toNegZeroClass.{u3} F' (SubtractionMonoid.toSubNegZeroMonoid.{u3} F' (SubtractionCommMonoid.toSubtractionMonoid.{u3} F' (AddCommGroup.toDivisionAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)))))) (Module.toMulActionWithZero.{u4, u3} ð•œ F' (DivisionSemiring.toSemiring.{u4} ð•œ (Semifield.toDivisionSemiring.{u4} ð•œ (Field.toSemifield.{u4} ð•œ (NormedField.toField.{u4} ð•œ _inst_12)))) (AddCommGroup.toAddCommMonoid.{u3} F' (SeminormedAddCommGroup.toAddCommGroup.{u3} F' _inst_5)) (NormedSpace.toModule.{u4, u3} ð•œ F' _inst_12 _inst_5 _inst_14)))))) c (g' x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.const_smul_right Asymptotics.IsTheta.const_smul_rightâ‚“'. -/
alias is_Theta_const_smul_right â†” is_Theta.of_const_smul_right is_Theta.const_smul_right
#align asymptotics.is_Theta.of_const_smul_right Asymptotics.IsTheta.of_const_smul_right
#align asymptotics.is_Theta.const_smul_right Asymptotics.IsTheta.const_smul_right

/- warning: asymptotics.is_Theta_const_mul_left -> Asymptotics.isTheta_const_mul_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {ð•œ : Type.{u3}} [_inst_2 : Norm.{u2} F] [_inst_12 : NormedField.{u3} ð•œ] {g : Î± -> F} {l : Filter.{u1} Î±} {c : ð•œ} {f : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (OfNat.mk.{u3} ð•œ 0 (Zero.zero.{u3} ð•œ (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))))))))) -> (Iff (Asymptotics.IsTheta.{u1, u3, u2} Î± ð•œ F (NormedField.toHasNorm.{u3} ð•œ _inst_12) _inst_2 l (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))) c (f x)) g) (Asymptotics.IsTheta.{u1, u3, u2} Î± ð•œ F (NormedField.toHasNorm.{u3} ð•œ _inst_12) _inst_2 l f g))
but is expected to have type
  forall {Î± : Type.{u2}} {F : Type.{u1}} {ð•œ : Type.{u3}} [_inst_2 : Norm.{u1} F] [_inst_12 : NormedField.{u3} ð•œ] {g : Î± -> F} {l : Filter.{u2} Î±} {c : ð•œ} {f : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (Zero.toOfNat0.{u3} ð•œ (CommMonoidWithZero.toZero.{u3} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u3} ð•œ (Semifield.toCommGroupWithZero.{u3} ð•œ (Field.toSemifield.{u3} ð•œ (NormedField.toField.{u3} ð•œ _inst_12)))))))) -> (Iff (Asymptotics.IsTheta.{u2, u3, u1} Î± ð•œ F (NormedField.toNorm.{u3} ð•œ _inst_12) _inst_2 l (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (NonUnitalNonAssocRing.toMul.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12))))))) c (f x)) g) (Asymptotics.IsTheta.{u2, u3, u1} Î± ð•œ F (NormedField.toNorm.{u3} ð•œ _inst_12) _inst_2 l f g))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_const_mul_left Asymptotics.isTheta_const_mul_leftâ‚“'. -/
theorem isTheta_const_mul_left {c : ð•œ} {f : Î± â†’ ð•œ} (hc : c â‰  0) :
    (fun x => c * f x) =Î˜[l] g â†” f =Î˜[l] g := by
  simpa only [â† smul_eq_mul] using is_Theta_const_smul_left hc
#align asymptotics.is_Theta_const_mul_left Asymptotics.isTheta_const_mul_left

/- warning: asymptotics.is_Theta.of_const_mul_left -> Asymptotics.IsTheta.of_const_mul_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {ð•œ : Type.{u3}} [_inst_2 : Norm.{u2} F] [_inst_12 : NormedField.{u3} ð•œ] {g : Î± -> F} {l : Filter.{u1} Î±} {c : ð•œ} {f : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (OfNat.mk.{u3} ð•œ 0 (Zero.zero.{u3} ð•œ (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± ð•œ F (NormedField.toHasNorm.{u3} ð•œ _inst_12) _inst_2 l (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))) c (f x)) g) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± ð•œ F (NormedField.toHasNorm.{u3} ð•œ _inst_12) _inst_2 l f g)
but is expected to have type
  forall {Î± : Type.{u2}} {F : Type.{u1}} {ð•œ : Type.{u3}} [_inst_2 : Norm.{u1} F] [_inst_12 : NormedField.{u3} ð•œ] {g : Î± -> F} {l : Filter.{u2} Î±} {c : ð•œ} {f : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (Zero.toOfNat0.{u3} ð•œ (CommMonoidWithZero.toZero.{u3} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u3} ð•œ (Semifield.toCommGroupWithZero.{u3} ð•œ (Field.toSemifield.{u3} ð•œ (NormedField.toField.{u3} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± ð•œ F (NormedField.toNorm.{u3} ð•œ _inst_12) _inst_2 l (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (NonUnitalNonAssocRing.toMul.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12))))))) c (f x)) g) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± ð•œ F (NormedField.toNorm.{u3} ð•œ _inst_12) _inst_2 l f g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.of_const_mul_left Asymptotics.IsTheta.of_const_mul_leftâ‚“'. -/
/- warning: asymptotics.is_Theta.const_mul_left -> Asymptotics.IsTheta.const_mul_left is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {F : Type.{u2}} {ð•œ : Type.{u3}} [_inst_2 : Norm.{u2} F] [_inst_12 : NormedField.{u3} ð•œ] {g : Î± -> F} {l : Filter.{u1} Î±} {c : ð•œ} {f : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (OfNat.mk.{u3} ð•œ 0 (Zero.zero.{u3} ð•œ (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± ð•œ F (NormedField.toHasNorm.{u3} ð•œ _inst_12) _inst_2 l f g) -> (Asymptotics.IsTheta.{u1, u3, u2} Î± ð•œ F (NormedField.toHasNorm.{u3} ð•œ _inst_12) _inst_2 l (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))) c (f x)) g)
but is expected to have type
  forall {Î± : Type.{u2}} {F : Type.{u1}} {ð•œ : Type.{u3}} [_inst_2 : Norm.{u1} F] [_inst_12 : NormedField.{u3} ð•œ] {g : Î± -> F} {l : Filter.{u2} Î±} {c : ð•œ} {f : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (Zero.toOfNat0.{u3} ð•œ (CommMonoidWithZero.toZero.{u3} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u3} ð•œ (Semifield.toCommGroupWithZero.{u3} ð•œ (Field.toSemifield.{u3} ð•œ (NormedField.toField.{u3} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± ð•œ F (NormedField.toNorm.{u3} ð•œ _inst_12) _inst_2 l f g) -> (Asymptotics.IsTheta.{u2, u3, u1} Î± ð•œ F (NormedField.toNorm.{u3} ð•œ _inst_12) _inst_2 l (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (NonUnitalNonAssocRing.toMul.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12))))))) c (f x)) g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.const_mul_left Asymptotics.IsTheta.const_mul_leftâ‚“'. -/
alias is_Theta_const_mul_left â†” is_Theta.of_const_mul_left is_Theta.const_mul_left
#align asymptotics.is_Theta.of_const_mul_left Asymptotics.IsTheta.of_const_mul_left
#align asymptotics.is_Theta.const_mul_left Asymptotics.IsTheta.const_mul_left

/- warning: asymptotics.is_Theta_const_mul_right -> Asymptotics.isTheta_const_mul_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {ð•œ : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_12 : NormedField.{u3} ð•œ] {f : Î± -> E} {l : Filter.{u1} Î±} {c : ð•œ} {g : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (OfNat.mk.{u3} ð•œ 0 (Zero.zero.{u3} ð•œ (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))))))))) -> (Iff (Asymptotics.IsTheta.{u1, u2, u3} Î± E ð•œ _inst_1 (NormedField.toHasNorm.{u3} ð•œ _inst_12) l f (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))) c (g x))) (Asymptotics.IsTheta.{u1, u2, u3} Î± E ð•œ _inst_1 (NormedField.toHasNorm.{u3} ð•œ _inst_12) l f g))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} {ð•œ : Type.{u3}} [_inst_1 : Norm.{u1} E] [_inst_12 : NormedField.{u3} ð•œ] {f : Î± -> E} {l : Filter.{u2} Î±} {c : ð•œ} {g : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (Zero.toOfNat0.{u3} ð•œ (CommMonoidWithZero.toZero.{u3} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u3} ð•œ (Semifield.toCommGroupWithZero.{u3} ð•œ (Field.toSemifield.{u3} ð•œ (NormedField.toField.{u3} ð•œ _inst_12)))))))) -> (Iff (Asymptotics.IsTheta.{u2, u1, u3} Î± E ð•œ _inst_1 (NormedField.toNorm.{u3} ð•œ _inst_12) l f (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (NonUnitalNonAssocRing.toMul.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12))))))) c (g x))) (Asymptotics.IsTheta.{u2, u1, u3} Î± E ð•œ _inst_1 (NormedField.toNorm.{u3} ð•œ _inst_12) l f g))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta_const_mul_right Asymptotics.isTheta_const_mul_rightâ‚“'. -/
theorem isTheta_const_mul_right {c : ð•œ} {g : Î± â†’ ð•œ} (hc : c â‰  0) :
    (f =Î˜[l] fun x => c * g x) â†” f =Î˜[l] g := by
  simpa only [â† smul_eq_mul] using is_Theta_const_smul_right hc
#align asymptotics.is_Theta_const_mul_right Asymptotics.isTheta_const_mul_right

/- warning: asymptotics.is_Theta.of_const_mul_right -> Asymptotics.IsTheta.of_const_mul_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {ð•œ : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_12 : NormedField.{u3} ð•œ] {f : Î± -> E} {l : Filter.{u1} Î±} {c : ð•œ} {g : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (OfNat.mk.{u3} ð•œ 0 (Zero.zero.{u3} ð•œ (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E ð•œ _inst_1 (NormedField.toHasNorm.{u3} ð•œ _inst_12) l f (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))) c (g x))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E ð•œ _inst_1 (NormedField.toHasNorm.{u3} ð•œ _inst_12) l f g)
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} {ð•œ : Type.{u3}} [_inst_1 : Norm.{u1} E] [_inst_12 : NormedField.{u3} ð•œ] {f : Î± -> E} {l : Filter.{u2} Î±} {c : ð•œ} {g : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (Zero.toOfNat0.{u3} ð•œ (CommMonoidWithZero.toZero.{u3} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u3} ð•œ (Semifield.toCommGroupWithZero.{u3} ð•œ (Field.toSemifield.{u3} ð•œ (NormedField.toField.{u3} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E ð•œ _inst_1 (NormedField.toNorm.{u3} ð•œ _inst_12) l f (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (NonUnitalNonAssocRing.toMul.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12))))))) c (g x))) -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E ð•œ _inst_1 (NormedField.toNorm.{u3} ð•œ _inst_12) l f g)
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.of_const_mul_right Asymptotics.IsTheta.of_const_mul_rightâ‚“'. -/
/- warning: asymptotics.is_Theta.const_mul_right -> Asymptotics.IsTheta.const_mul_right is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} {E : Type.{u2}} {ð•œ : Type.{u3}} [_inst_1 : Norm.{u2} E] [_inst_12 : NormedField.{u3} ð•œ] {f : Î± -> E} {l : Filter.{u1} Î±} {c : ð•œ} {g : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (OfNat.mk.{u3} ð•œ 0 (Zero.zero.{u3} ð•œ (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))))))))) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E ð•œ _inst_1 (NormedField.toHasNorm.{u3} ð•œ _inst_12) l f g) -> (Asymptotics.IsTheta.{u1, u2, u3} Î± E ð•œ _inst_1 (NormedField.toHasNorm.{u3} ð•œ _inst_12) l f (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12)))))) c (g x)))
but is expected to have type
  forall {Î± : Type.{u2}} {E : Type.{u1}} {ð•œ : Type.{u3}} [_inst_1 : Norm.{u1} E] [_inst_12 : NormedField.{u3} ð•œ] {f : Î± -> E} {l : Filter.{u2} Î±} {c : ð•œ} {g : Î± -> ð•œ}, (Ne.{succ u3} ð•œ c (OfNat.ofNat.{u3} ð•œ 0 (Zero.toOfNat0.{u3} ð•œ (CommMonoidWithZero.toZero.{u3} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u3} ð•œ (Semifield.toCommGroupWithZero.{u3} ð•œ (Field.toSemifield.{u3} ð•œ (NormedField.toField.{u3} ð•œ _inst_12)))))))) -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E ð•œ _inst_1 (NormedField.toNorm.{u3} ð•œ _inst_12) l f g) -> (Asymptotics.IsTheta.{u2, u1, u3} Î± E ð•œ _inst_1 (NormedField.toNorm.{u3} ð•œ _inst_12) l f (fun (x : Î±) => HMul.hMul.{u3, u3, u3} ð•œ ð•œ ð•œ (instHMul.{u3} ð•œ (NonUnitalNonAssocRing.toMul.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (NormedRing.toRing.{u3} ð•œ (NormedCommRing.toNormedRing.{u3} ð•œ (NormedField.toNormedCommRing.{u3} ð•œ _inst_12))))))) c (g x)))
Case conversion may be inaccurate. Consider using '#align asymptotics.is_Theta.const_mul_right Asymptotics.IsTheta.const_mul_rightâ‚“'. -/
alias is_Theta_const_mul_right â†” is_Theta.of_const_mul_right is_Theta.const_mul_right
#align asymptotics.is_Theta.of_const_mul_right Asymptotics.IsTheta.of_const_mul_right
#align asymptotics.is_Theta.const_mul_right Asymptotics.IsTheta.const_mul_right

end Asymptotics

