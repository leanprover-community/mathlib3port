/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel, Johannes HÃ¶lzl, Yury G. Kudryashov, Patrick Massot

! This file was ported from Lean 3 source module analysis.specific_limits.basic
! leanprover-community/mathlib commit 19cb3751e5e9b3d97adb51023949c50c13b5fdfd
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GeomSum
import Mathbin.Order.Filter.Archimedean
import Mathbin.Order.Iterate
import Mathbin.Topology.Instances.Ennreal
import Mathbin.Topology.Algebra.Algebra

/-!
# A collection of specific limit computations

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file, by design, is independent of `normed_space` in the import hierarchy.  It contains
important specific limit computations in metric spaces, in ordered rings/fields, and in specific
instances of these such as `â„`, `â„â‰¥0` and `â„â‰¥0âˆ`.
-/


noncomputable section

open Classical Set Function Filter Finset Metric

open Classical Topology Nat BigOperators uniformity NNReal ENNReal

variable {Î± : Type _} {Î² : Type _} {Î¹ : Type _}

/- warning: tendsto_inverse_at_top_nhds_0_nat -> tendsto_inverse_atTop_nhds_0_nat is a dubious translation:
lean 3 declaration is
  Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => Inv.inv.{0} Real Real.hasInv ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCâ‚“.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => Inv.inv.{0} Real Real.instInvReal (Nat.cast.{0} Real Real.natCast n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align tendsto_inverse_at_top_nhds_0_nat tendsto_inverse_atTop_nhds_0_natâ‚“'. -/
theorem tendsto_inverse_atTop_nhds_0_nat : Tendsto (fun n : â„• => (n : â„)â»Â¹) atTop (ğ“ 0) :=
  tendsto_inv_atTop_zero.comp tendsto_nat_cast_atTop_atTop
#align tendsto_inverse_at_top_nhds_0_nat tendsto_inverse_atTop_nhds_0_nat

/- warning: tendsto_const_div_at_top_nhds_0_nat -> tendsto_const_div_atTop_nhds_0_nat is a dubious translation:
lean 3 declaration is
  forall (C : Real), Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) C ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCâ‚“.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall (C : Real), Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) C (Nat.cast.{0} Real Real.natCast n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align tendsto_const_div_at_top_nhds_0_nat tendsto_const_div_atTop_nhds_0_natâ‚“'. -/
theorem tendsto_const_div_atTop_nhds_0_nat (C : â„) : Tendsto (fun n : â„• => C / n) atTop (ğ“ 0) := by
  simpa only [MulZeroClass.mul_zero] using tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_0_nat
#align tendsto_const_div_at_top_nhds_0_nat tendsto_const_div_atTop_nhds_0_nat

/- warning: nnreal.tendsto_inverse_at_top_nhds_0_nat -> NNReal.tendsto_inverse_atTop_nhds_0_nat is a dubious translation:
lean 3 declaration is
  Filter.Tendsto.{0, 0} Nat NNReal (fun (n : Nat) => Inv.inv.{0} NNReal (DivInvMonoid.toHasInv.{0} NNReal (GroupWithZero.toDivInvMonoid.{0} NNReal (DivisionSemiring.toGroupWithZero.{0} NNReal (Semifield.toDivisionSemiring.{0} NNReal (LinearOrderedSemifield.toSemifield.{0} NNReal (CanonicallyLinearOrderedSemifield.toLinearOrderedSemifield.{0} NNReal NNReal.canonicallyLinearOrderedSemifield)))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat NNReal (HasLiftT.mk.{1, 1} Nat NNReal (CoeTCâ‚“.coe.{1, 1} Nat NNReal (Nat.castCoe.{0} NNReal (AddMonoidWithOne.toNatCast.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} NNReal NNReal.topologicalSpace (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))))
but is expected to have type
  Filter.Tendsto.{0, 0} Nat NNReal (fun (n : Nat) => Inv.inv.{0} NNReal (CanonicallyLinearOrderedSemifield.toInv.{0} NNReal NNReal.instCanonicallyLinearOrderedSemifieldNNReal) (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} NNReal NNReal.instTopologicalSpaceNNReal (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)))
Case conversion may be inaccurate. Consider using '#align nnreal.tendsto_inverse_at_top_nhds_0_nat NNReal.tendsto_inverse_atTop_nhds_0_natâ‚“'. -/
theorem NNReal.tendsto_inverse_atTop_nhds_0_nat : Tendsto (fun n : â„• => (n : â„â‰¥0)â»Â¹) atTop (ğ“ 0) :=
  by rw [â† NNReal.tendsto_coe]; exact tendsto_inverse_atTop_nhds_0_nat
#align nnreal.tendsto_inverse_at_top_nhds_0_nat NNReal.tendsto_inverse_atTop_nhds_0_nat

/- warning: nnreal.tendsto_const_div_at_top_nhds_0_nat -> NNReal.tendsto_const_div_atTop_nhds_0_nat is a dubious translation:
lean 3 declaration is
  forall (C : NNReal), Filter.Tendsto.{0, 0} Nat NNReal (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} NNReal NNReal NNReal (instHDiv.{0} NNReal NNReal.hasDiv) C ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat NNReal (HasLiftT.mk.{1, 1} Nat NNReal (CoeTCâ‚“.coe.{1, 1} Nat NNReal (Nat.castCoe.{0} NNReal (AddMonoidWithOne.toNatCast.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} NNReal NNReal.topologicalSpace (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))))
but is expected to have type
  forall (C : NNReal), Filter.Tendsto.{0, 0} Nat NNReal (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} NNReal NNReal NNReal (instHDiv.{0} NNReal (CanonicallyLinearOrderedSemifield.toDiv.{0} NNReal NNReal.instCanonicallyLinearOrderedSemifieldNNReal)) C (Nat.cast.{0} NNReal (CanonicallyOrderedCommSemiring.toNatCast.{0} NNReal instNNRealCanonicallyOrderedCommSemiring) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} NNReal NNReal.instTopologicalSpaceNNReal (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)))
Case conversion may be inaccurate. Consider using '#align nnreal.tendsto_const_div_at_top_nhds_0_nat NNReal.tendsto_const_div_atTop_nhds_0_natâ‚“'. -/
theorem NNReal.tendsto_const_div_atTop_nhds_0_nat (C : â„â‰¥0) :
    Tendsto (fun n : â„• => C / n) atTop (ğ“ 0) := by
  simpa using tendsto_const_nhds.mul NNReal.tendsto_inverse_atTop_nhds_0_nat
#align nnreal.tendsto_const_div_at_top_nhds_0_nat NNReal.tendsto_const_div_atTop_nhds_0_nat

/- warning: tendsto_one_div_add_at_top_nhds_0_nat -> tendsto_one_div_add_atTop_nhds_0_nat is a dubious translation:
lean 3 declaration is
  Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCâ‚“.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align tendsto_one_div_add_at_top_nhds_0_nat tendsto_one_div_add_atTop_nhds_0_natâ‚“'. -/
theorem tendsto_one_div_add_atTop_nhds_0_nat :
    Tendsto (fun n : â„• => 1 / ((n : â„) + 1)) atTop (ğ“ 0) :=
  suffices Tendsto (fun n : â„• => 1 / (â†‘(n + 1) : â„)) atTop (ğ“ 0) by simpa
  (tendsto_add_atTop_iff_nat 1).2 (tendsto_const_div_atTop_nhds_0_nat 1)
#align tendsto_one_div_add_at_top_nhds_0_nat tendsto_one_div_add_atTop_nhds_0_nat

/- warning: tendsto_coe_nat_div_add_at_top -> tendsto_coe_nat_div_add_atTop is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : DivisionRing.{u1} ğ•œ] [_inst_2 : TopologicalSpace.{u1} ğ•œ] [_inst_3 : CharZero.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1))))] [_inst_4 : Algebra.{0, u1} Real ğ•œ Real.commSemiring (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1))] [_inst_5 : ContinuousSMul.{0, u1} Real ğ•œ (SMulZeroClass.toHasSmul.{0, u1} Real ğ•œ (AddZeroClass.toHasZero.{u1} ğ•œ (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))))))) (SMulWithZero.toSmulZeroClass.{0, u1} Real ğ•œ (MulZeroClass.toHasZero.{0} Real (MulZeroOneClass.toMulZeroClass.{0} Real (MonoidWithZero.toMulZeroOneClass.{0} Real (Semiring.toMonoidWithZero.{0} Real (CommSemiring.toSemiring.{0} Real Real.commSemiring))))) (AddZeroClass.toHasZero.{u1} ğ•œ (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))))))) (MulActionWithZero.toSMulWithZero.{0, u1} Real ğ•œ (Semiring.toMonoidWithZero.{0} Real (CommSemiring.toSemiring.{0} Real Real.commSemiring)) (AddZeroClass.toHasZero.{u1} ğ•œ (AddMonoid.toAddZeroClass.{u1} ğ•œ (AddCommMonoid.toAddMonoid.{u1} ğ•œ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))))))) (Module.toMulActionWithZero.{0, u1} Real ğ•œ (CommSemiring.toSemiring.{0} Real Real.commSemiring) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1))))) (Algebra.toModule.{0, u1} Real ğ•œ Real.commSemiring (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)) _inst_4))))) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_2] [_inst_6 : TopologicalDivisionRing.{u1} ğ•œ _inst_1 _inst_2] (x : ğ•œ), Filter.Tendsto.{0, u1} Nat ğ•œ (fun (n : Nat) => HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (DivisionRing.toDivInvMonoid.{u1} ğ•œ _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u1} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u1} Nat ğ•œ (Nat.castCoe.{u1} ğ•œ (AddMonoidWithOne.toNatCast.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))))))) n) (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat ğ•œ (HasLiftT.mk.{1, succ u1} Nat ğ•œ (CoeTCâ‚“.coe.{1, succ u1} Nat ğ•œ (Nat.castCoe.{u1} ğ•œ (AddMonoidWithOne.toNatCast.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))))))) n) x)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} ğ•œ _inst_2 (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : DivisionRing.{u1} ğ•œ] [_inst_2 : TopologicalSpace.{u1} ğ•œ] [_inst_3 : CharZero.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (Ring.toAddGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1)))] [_inst_4 : Algebra.{0, u1} Real ğ•œ Real.instCommSemiringReal (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ _inst_1))] [_inst_5 : ContinuousSMul.{0, u1} Real ğ•œ (Algebra.toSMul.{0, u1} Real ğ•œ Real.instCommSemiringReal (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ _inst_1)) _inst_4) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_2] [_inst_6 : TopologicalDivisionRing.{u1} ğ•œ _inst_1 _inst_2] (x : ğ•œ), Filter.Tendsto.{0, u1} Nat ğ•œ (fun (n : Nat) => HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivisionRing.toDiv.{u1} ğ•œ _inst_1)) (Nat.cast.{u1} ğ•œ (Semiring.toNatCast.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ _inst_1))) n) (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ _inst_1))))))) (Nat.cast.{u1} ğ•œ (Semiring.toNatCast.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ _inst_1))) n) x)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} ğ•œ _inst_2 (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (DivisionRing.toDivisionSemiring.{u1} ğ•œ _inst_1))))))
Case conversion may be inaccurate. Consider using '#align tendsto_coe_nat_div_add_at_top tendsto_coe_nat_div_add_atTopâ‚“'. -/
/-- The limit of `n / (n + x)` is 1, for any constant `x` (valid in `â„` or any topological division
algebra over `â„`, e.g., `â„‚`).

TODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this
statement simultaneously on `â„š`, `â„` and `â„‚`. -/
theorem tendsto_coe_nat_div_add_atTop {ğ•œ : Type _} [DivisionRing ğ•œ] [TopologicalSpace ğ•œ]
    [CharZero ğ•œ] [Algebra â„ ğ•œ] [ContinuousSMul â„ ğ•œ] [TopologicalDivisionRing ğ•œ] (x : ğ•œ) :
    Tendsto (fun n : â„• => (n : ğ•œ) / (n + x)) atTop (ğ“ 1) :=
  by
  refine' tendsto.congr' ((eventually_ne_at_top 0).mp (eventually_of_forall fun n hn => _)) _
  Â· exact fun n : â„• => 1 / (1 + x / n)
  Â· field_simp [nat.cast_ne_zero.mpr hn]
  Â· have : ğ“ (1 : ğ•œ) = ğ“ (1 / (1 + x * â†‘(0 : â„))) := by
      rw [algebraMap.coe_zero, MulZeroClass.mul_zero, add_zero, div_one]
    rw [this]
    refine' tendsto_const_nhds.div (tendsto_const_nhds.add _) (by simp)
    simp_rw [div_eq_mul_inv]
    refine' tendsto_const_nhds.mul _
    have : (fun n : â„• => (n : ğ•œ)â»Â¹) = fun n : â„• => â†‘(n : â„)â»Â¹ :=
      by
      ext1 n
      rw [â† map_natCast (algebraMap â„ ğ•œ) n, â† map_invâ‚€ (algebraMap â„ ğ•œ)]
      rfl
    rw [this]
    exact ((continuous_algebraMap â„ ğ•œ).Tendsto _).comp tendsto_inverse_atTop_nhds_0_nat
#align tendsto_coe_nat_div_add_at_top tendsto_coe_nat_div_add_atTop

/-! ### Powers -/


/- warning: tendsto_add_one_pow_at_top_at_top_of_pos -> tendsto_add_one_pow_atTop_atTop_of_pos is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} Î±] [_inst_2 : Archimedean.{u1} Î± (OrderedSemiring.toOrderedAddCommMonoid.{u1} Î± (StrictOrderedSemiring.toOrderedSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))] {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))) (OfNat.ofNat.{u1} Î± 0 (OfNat.mk.{u1} Î± 0 (Zero.zero.{u1} Î± (MulZeroClass.toHasZero.{u1} Î± (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))))) r) -> (Filter.Tendsto.{0, u1} Nat Î± (fun (n : Nat) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toHasAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} Î± (NonAssocSemiring.toAddCommMonoidWithOne.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))))))) n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î± (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} Î±] [_inst_2 : Archimedean.{u1} Î± (OrderedSemiring.toOrderedAddCommMonoid.{u1} Î± (StrictOrderedSemiring.toOrderedSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))] {r : Î±}, (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 0 (Zero.toOfNat0.{u1} Î± (MonoidWithZero.toZero.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))) r) -> (Filter.Tendsto.{0, u1} Nat Î± (fun (n : Nat) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))) (HAdd.hAdd.{u1, u1, u1} Î± Î± Î± (instHAdd.{u1} Î± (Distrib.toAdd.{u1} Î± (NonUnitalNonAssocSemiring.toDistrib.{u1} Î± (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} Î± (Semiring.toNonAssocSemiring.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1))))))) r (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))) n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedSemiring.toPartialOrder.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± _inst_1)))))
Case conversion may be inaccurate. Consider using '#align tendsto_add_one_pow_at_top_at_top_of_pos tendsto_add_one_pow_atTop_atTop_of_posâ‚“'. -/
theorem tendsto_add_one_pow_atTop_atTop_of_pos [LinearOrderedSemiring Î±] [Archimedean Î±] {r : Î±}
    (h : 0 < r) : Tendsto (fun n : â„• => (r + 1) ^ n) atTop atTop :=
  (tendsto_atTop_atTop_of_monotone' fun n m => pow_le_pow (le_add_of_nonneg_left (le_of_lt h))) <|
    not_bddAbove_iff.2 fun x => Set.exists_range_iff.2 <| add_one_pow_unbounded_of_pos _ h
#align tendsto_add_one_pow_at_top_at_top_of_pos tendsto_add_one_pow_atTop_atTop_of_pos

/- warning: tendsto_pow_at_top_at_top_of_one_lt -> tendsto_pow_atTop_atTop_of_one_lt is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : Archimedean.{u1} Î± (OrderedSemiring.toOrderedAddCommMonoid.{u1} Î± (StrictOrderedSemiring.toOrderedSemiring.{u1} Î± (StrictOrderedRing.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))] {r : Î±}, (LT.lt.{u1} Î± (Preorder.toHasLt.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) (OfNat.ofNat.{u1} Î± 1 (OfNat.mk.{u1} Î± 1 (One.one.{u1} Î± (AddMonoidWithOne.toOne.{u1} Î± (AddGroupWithOne.toAddMonoidWithOne.{u1} Î± (AddCommGroupWithOne.toAddGroupWithOne.{u1} Î± (Ring.toAddCommGroupWithOne.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))))) r) -> (Filter.Tendsto.{0, u1} Nat Î± (fun (n : Nat) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (Ring.toMonoid.{u1} Î± (StrictOrderedRing.toRing.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (OrderedAddCommGroup.toPartialOrder.{u1} Î± (StrictOrderedRing.toOrderedAddCommGroup.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1))))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} Î±] [_inst_2 : Archimedean.{u1} Î± (OrderedSemiring.toOrderedAddCommMonoid.{u1} Î± (StrictOrderedSemiring.toOrderedSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))] {r : Î±}, (LT.lt.{u1} Î± (Preorder.toLT.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))) (OfNat.ofNat.{u1} Î± 1 (One.toOfNat1.{u1} Î± (Semiring.toOne.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1)))))) r) -> (Filter.Tendsto.{0, u1} Nat Î± (fun (n : Nat) => HPow.hPow.{u1, 0, u1} Î± Nat Î± (instHPow.{u1, 0} Î± Nat (Monoid.Pow.{u1} Î± (MonoidWithZero.toMonoid.{u1} Î± (Semiring.toMonoidWithZero.{u1} Î± (StrictOrderedSemiring.toSemiring.{u1} Î± (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} Î± (LinearOrderedRing.toLinearOrderedSemiring.{u1} Î± _inst_1))))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atTop.{u1} Î± (PartialOrder.toPreorder.{u1} Î± (StrictOrderedRing.toPartialOrder.{u1} Î± (LinearOrderedRing.toStrictOrderedRing.{u1} Î± _inst_1)))))
Case conversion may be inaccurate. Consider using '#align tendsto_pow_at_top_at_top_of_one_lt tendsto_pow_atTop_atTop_of_one_ltâ‚“'. -/
theorem tendsto_pow_atTop_atTop_of_one_lt [LinearOrderedRing Î±] [Archimedean Î±] {r : Î±}
    (h : 1 < r) : Tendsto (fun n : â„• => r ^ n) atTop atTop :=
  sub_add_cancel r 1 â–¸ tendsto_add_one_pow_atTop_atTop_of_pos (sub_pos.2 h)
#align tendsto_pow_at_top_at_top_of_one_lt tendsto_pow_atTop_atTop_of_one_lt

#print Nat.tendsto_pow_atTop_atTop_of_one_lt /-
theorem Nat.tendsto_pow_atTop_atTop_of_one_lt {m : â„•} (h : 1 < m) :
    Tendsto (fun n : â„• => m ^ n) atTop atTop :=
  tsub_add_cancel_of_le (le_of_lt h) â–¸ tendsto_add_one_pow_atTop_atTop_of_pos (tsub_pos_of_lt h)
#align nat.tendsto_pow_at_top_at_top_of_one_lt Nat.tendsto_pow_atTop_atTop_of_one_lt
-/

/- warning: tendsto_pow_at_top_nhds_0_of_lt_1 -> tendsto_pow_atTop_nhds_0_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : Archimedean.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))] [_inst_3 : TopologicalSpace.{u1} ğ•œ] [_inst_4 : OrderTopology.{u1} ğ•œ _inst_3 (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))] {r : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))))))))) r) -> (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) r (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))))))))) -> (Filter.Tendsto.{0, u1} Nat ğ•œ (fun (n : Nat) => HPow.hPow.{u1, 0, u1} ğ•œ Nat ğ•œ (instHPow.{u1, 0} ğ•œ Nat (Monoid.Pow.{u1} ğ•œ (Ring.toMonoid.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} ğ•œ _inst_3 (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))))))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : Archimedean.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))] [_inst_3 : TopologicalSpace.{u1} ğ•œ] [_inst_4 : OrderTopology.{u1} ğ•œ _inst_3 (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))] {r : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) r) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) r (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))))) -> (Filter.Tendsto.{0, u1} Nat ğ•œ (fun (n : Nat) => HPow.hPow.{u1, 0, u1} ğ•œ Nat ğ•œ (instHPow.{u1, 0} ğ•œ Nat (Monoid.Pow.{u1} ğ•œ (MonoidWithZero.toMonoid.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} ğ•œ _inst_3 (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_pow_at_top_nhds_0_of_lt_1 tendsto_pow_atTop_nhds_0_of_lt_1â‚“'. -/
theorem tendsto_pow_atTop_nhds_0_of_lt_1 {ğ•œ : Type _} [LinearOrderedField ğ•œ] [Archimedean ğ•œ]
    [TopologicalSpace ğ•œ] [OrderTopology ğ•œ] {r : ğ•œ} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) :
    Tendsto (fun n : â„• => r ^ n) atTop (ğ“ 0) :=
  hâ‚.eq_or_lt.elim
    (fun this : 0 = r =>
      (tendsto_add_atTop_iff_nat 1).mp <| by simp [pow_succ, â† this, tendsto_const_nhds])
    fun this : 0 < r =>
    have : Tendsto (fun n => (râ»Â¹ ^ n)â»Â¹) atTop (ğ“ 0) :=
      tendsto_inv_atTop_zero.comp (tendsto_pow_atTop_atTop_of_one_lt <| one_lt_inv this hâ‚‚)
    this.congr fun n => by simp
#align tendsto_pow_at_top_nhds_0_of_lt_1 tendsto_pow_atTop_nhds_0_of_lt_1

/- warning: tendsto_pow_at_top_nhds_within_0_of_lt_1 -> tendsto_pow_atTop_nhdsWithin_0_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : Archimedean.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))] [_inst_3 : TopologicalSpace.{u1} ğ•œ] [_inst_4 : OrderTopology.{u1} ğ•œ _inst_3 (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))] {r : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))))))))) r) -> (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) r (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))))))))) -> (Filter.Tendsto.{0, u1} Nat ğ•œ (fun (n : Nat) => HPow.hPow.{u1, 0, u1} ğ•œ Nat ğ•œ (instHPow.{u1, 0} ğ•œ Nat (Monoid.Pow.{u1} ğ•œ (Ring.toMonoid.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhdsWithin.{u1} ğ•œ _inst_3 (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))))))))) (Set.Ioi.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))))))))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : Archimedean.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))] [_inst_3 : TopologicalSpace.{u1} ğ•œ] [_inst_4 : OrderTopology.{u1} ğ•œ _inst_3 (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))] {r : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) r) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) r (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))))) -> (Filter.Tendsto.{0, u1} Nat ğ•œ (fun (n : Nat) => HPow.hPow.{u1, 0, u1} ğ•œ Nat ğ•œ (instHPow.{u1, 0} ğ•œ Nat (Monoid.Pow.{u1} ğ•œ (MonoidWithZero.toMonoid.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhdsWithin.{u1} ğ•œ _inst_3 (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) (Set.Ioi.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_pow_at_top_nhds_within_0_of_lt_1 tendsto_pow_atTop_nhdsWithin_0_of_lt_1â‚“'. -/
theorem tendsto_pow_atTop_nhdsWithin_0_of_lt_1 {ğ•œ : Type _} [LinearOrderedField ğ•œ] [Archimedean ğ•œ]
    [TopologicalSpace ğ•œ] [OrderTopology ğ•œ] {r : ğ•œ} (hâ‚ : 0 < r) (hâ‚‚ : r < 1) :
    Tendsto (fun n : â„• => r ^ n) atTop (ğ“[>] 0) :=
  tendsto_inf.2
    âŸ¨tendsto_pow_atTop_nhds_0_of_lt_1 hâ‚.le hâ‚‚,
      tendsto_principal.2 <| eventually_of_forall fun n => pow_pos hâ‚ _âŸ©
#align tendsto_pow_at_top_nhds_within_0_of_lt_1 tendsto_pow_atTop_nhdsWithin_0_of_lt_1

/- warning: uniformity_basis_dist_pow_of_lt_1 -> uniformity_basis_dist_pow_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] {r : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Filter.HasBasis.{u1, 1} (Prod.{u1, u1} Î± Î±) Nat (uniformity.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) (fun (k : Nat) => True) (fun (k : Nat) => setOf.{u1} (Prod.{u1, u1} Î± Î±) (fun (p : Prod.{u1, u1} Î± Î±) => LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (Prod.fst.{u1, u1} Î± Î± p) (Prod.snd.{u1, u1} Î± Î± p)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r k))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] {r : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Filter.HasBasis.{u1, 1} (Prod.{u1, u1} Î± Î±) Nat (uniformity.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) (fun (k : Nat) => True) (fun (k : Nat) => setOf.{u1} (Prod.{u1, u1} Î± Î±) (fun (p : Prod.{u1, u1} Î± Î±) => LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (Prod.fst.{u1, u1} Î± Î± p) (Prod.snd.{u1, u1} Î± Î± p)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r k))))
Case conversion may be inaccurate. Consider using '#align uniformity_basis_dist_pow_of_lt_1 uniformity_basis_dist_pow_of_lt_1â‚“'. -/
theorem uniformity_basis_dist_pow_of_lt_1 {Î± : Type _} [PseudoMetricSpace Î±] {r : â„} (hâ‚€ : 0 < r)
    (hâ‚ : r < 1) :
    (ğ“¤ Î±).HasBasis (fun k : â„• => True) fun k => { p : Î± Ã— Î± | dist p.1 p.2 < r ^ k } :=
  Metric.mk_uniformity_basis (fun i _ => pow_pos hâ‚€ _) fun Îµ Îµ0 =>
    (exists_pow_lt_of_lt_one Îµ0 hâ‚).imp fun k hk => âŸ¨trivial, hk.leâŸ©
#align uniformity_basis_dist_pow_of_lt_1 uniformity_basis_dist_pow_of_lt_1

/- warning: geom_lt -> geom_lt is a dubious translation:
lean 3 declaration is
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) -> (forall {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LT.lt.{0} Real Real.hasLt (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (u k)) (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) k (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) -> (LT.lt.{0} Real Real.hasLt (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) c n) (u (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) (u n)))
but is expected to have type
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) -> (forall {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LT.lt.{0} Real Real.instLTReal (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (u k)) (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) -> (LT.lt.{0} Real Real.instLTReal (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) c n) (u (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) (u n)))
Case conversion may be inaccurate. Consider using '#align geom_lt geom_ltâ‚“'. -/
theorem geom_lt {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) {n : â„•} (hn : 0 < n)
    (h : âˆ€ k < n, c * u k < u (k + 1)) : c ^ n * u 0 < u n :=
  by
  refine' (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h
  Â· simp
  Â· simp [pow_succ, mul_assoc, le_refl]
#align geom_lt geom_lt

/- warning: geom_le -> geom_le is a dubious translation:
lean 3 declaration is
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) -> (forall (n : Nat), (forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LE.le.{0} Real Real.hasLe (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (u k)) (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) k (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) -> (LE.le.{0} Real Real.hasLe (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) c n) (u (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) (u n)))
but is expected to have type
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) -> (forall (n : Nat), (forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LE.le.{0} Real Real.instLEReal (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (u k)) (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) -> (LE.le.{0} Real Real.instLEReal (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) c n) (u (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) (u n)))
Case conversion may be inaccurate. Consider using '#align geom_le geom_leâ‚“'. -/
theorem geom_le {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) (n : â„•) (h : âˆ€ k < n, c * u k â‰¤ u (k + 1)) :
    c ^ n * u 0 â‰¤ u n := by
  refine' (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h <;>
    simp [pow_succ, mul_assoc, le_refl]
#align geom_le geom_le

/- warning: lt_geom -> lt_geom is a dubious translation:
lean 3 declaration is
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) -> (forall {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LT.lt.{0} Real Real.hasLt (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) k (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (u k)))) -> (LT.lt.{0} Real Real.hasLt (u n) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) c n) (u (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))))))
but is expected to have type
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) -> (forall {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LT.lt.{0} Real Real.instLTReal (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (u k)))) -> (LT.lt.{0} Real Real.instLTReal (u n) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) c n) (u (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align lt_geom lt_geomâ‚“'. -/
theorem lt_geom {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) {n : â„•} (hn : 0 < n)
    (h : âˆ€ k < n, u (k + 1) < c * u k) : u n < c ^ n * u 0 :=
  by
  refine' (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _
  Â· simp
  Â· simp [pow_succ, mul_assoc, le_refl]
#align lt_geom lt_geom

/- warning: le_geom -> le_geom is a dubious translation:
lean 3 declaration is
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) c) -> (forall (n : Nat), (forall (k : Nat), (LT.lt.{0} Nat Nat.hasLt k n) -> (LE.le.{0} Real Real.hasLe (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) k (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (u k)))) -> (LE.le.{0} Real Real.hasLe (u n) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) c n) (u (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))))))
but is expected to have type
  forall {u : Nat -> Real} {c : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) c) -> (forall (n : Nat), (forall (k : Nat), (LT.lt.{0} Nat instLTNat k n) -> (LE.le.{0} Real Real.instLEReal (u (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (u k)))) -> (LE.le.{0} Real Real.instLEReal (u n) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) c n) (u (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align le_geom le_geomâ‚“'. -/
theorem le_geom {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) (n : â„•) (h : âˆ€ k < n, u (k + 1) â‰¤ c * u k) :
    u n â‰¤ c ^ n * u 0 := by
  refine' (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _ <;>
    simp [pow_succ, mul_assoc, le_refl]
#align le_geom le_geom

/- warning: tendsto_at_top_of_geom_le -> tendsto_atTop_of_geom_le is a dubious translation:
lean 3 declaration is
  forall {v : Nat -> Real} {c : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (v (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) -> (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) c) -> (forall (n : Nat), LE.le.{0} Real Real.hasLe (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) c (v n)) (v (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) -> (Filter.Tendsto.{0, 0} Nat Real v (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (Filter.atTop.{0} Real Real.preorder))
but is expected to have type
  forall {v : Nat -> Real} {c : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (v (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) -> (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) c) -> (forall (n : Nat), LE.le.{0} Real Real.instLEReal (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) c (v n)) (v (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) -> (Filter.Tendsto.{0, 0} Nat Real v (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (Filter.atTop.{0} Real Real.instPreorderReal))
Case conversion may be inaccurate. Consider using '#align tendsto_at_top_of_geom_le tendsto_atTop_of_geom_leâ‚“'. -/
/-- If a sequence `v` of real numbers satisfies `k * v n â‰¤ v (n+1)` with `1 < k`,
then it goes to +âˆ. -/
theorem tendsto_atTop_of_geom_le {v : â„• â†’ â„} {c : â„} (hâ‚€ : 0 < v 0) (hc : 1 < c)
    (hu : âˆ€ n, c * v n â‰¤ v (n + 1)) : Tendsto v atTop atTop :=
  (tendsto_atTop_mono fun n => geom_le (zero_le_one.trans hc.le) n fun k hk => hu k) <|
    (tendsto_pow_atTop_atTop_of_one_lt hc).atTop_mul_const hâ‚€
#align tendsto_at_top_of_geom_le tendsto_atTop_of_geom_le

/- warning: nnreal.tendsto_pow_at_top_nhds_0_of_lt_1 -> NNReal.tendsto_pow_atTop_nhds_0_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) r (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))) -> (Filter.Tendsto.{0, 0} Nat NNReal (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} NNReal NNReal.topologicalSpace (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))))
but is expected to have type
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) r (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne))) -> (Filter.Tendsto.{0, 0} Nat NNReal (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal instNNRealSemiring)))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} NNReal NNReal.instTopologicalSpaceNNReal (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero))))
Case conversion may be inaccurate. Consider using '#align nnreal.tendsto_pow_at_top_nhds_0_of_lt_1 NNReal.tendsto_pow_atTop_nhds_0_of_lt_1â‚“'. -/
theorem NNReal.tendsto_pow_atTop_nhds_0_of_lt_1 {r : â„â‰¥0} (hr : r < 1) :
    Tendsto (fun n : â„• => r ^ n) atTop (ğ“ 0) :=
  NNReal.tendsto_coe.1 <| by
    simp only [NNReal.coe_pow, NNReal.coe_zero, tendsto_pow_atTop_nhds_0_of_lt_1 r.coe_nonneg hr]
#align nnreal.tendsto_pow_at_top_nhds_0_of_lt_1 NNReal.tendsto_pow_atTop_nhds_0_of_lt_1

/- warning: ennreal.tendsto_pow_at_top_nhds_0_of_lt_1 -> ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {r : ENNReal}, (LT.lt.{0} ENNReal (Preorder.toHasLt.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) r (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) -> (Filter.Tendsto.{0, 0} Nat ENNReal (fun (n : Nat) => HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} ENNReal ENNReal.topologicalSpace (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {r : ENNReal}, (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) r (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) -> (Filter.Tendsto.{0, 0} Nat ENNReal (fun (n : Nat) => HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) r n) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} ENNReal ENNReal.instTopologicalSpaceENNReal (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align ennreal.tendsto_pow_at_top_nhds_0_of_lt_1 ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1â‚“'. -/
theorem ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1 {r : â„â‰¥0âˆ} (hr : r < 1) :
    Tendsto (fun n : â„• => r ^ n) atTop (ğ“ 0) :=
  by
  rcases ENNReal.lt_iff_exists_coe.1 hr with âŸ¨r, rfl, hr'âŸ©
  rw [â† ENNReal.coe_zero]
  norm_cast  at *
  apply NNReal.tendsto_pow_atTop_nhds_0_of_lt_1 hr
#align ennreal.tendsto_pow_at_top_nhds_0_of_lt_1 ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1

/-! ### Geometric series-/


section Geometric

/- warning: has_sum_geometric_of_lt_1 -> hasSum_geometric_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (HasSum.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n) (Inv.inv.{0} Real Real.hasInv (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) r)))
but is expected to have type
  forall {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (HasSum.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n) (Inv.inv.{0} Real Real.instInvReal (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) r)))
Case conversion may be inaccurate. Consider using '#align has_sum_geometric_of_lt_1 hasSum_geometric_of_lt_1â‚“'. -/
theorem hasSum_geometric_of_lt_1 {r : â„} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) :
    HasSum (fun n : â„• => r ^ n) (1 - r)â»Â¹ :=
  have : r â‰  1 := ne_of_lt hâ‚‚
  have : Tendsto (fun n => (r ^ n - 1) * (r - 1)â»Â¹) atTop (ğ“ ((0 - 1) * (r - 1)â»Â¹)) :=
    ((tendsto_pow_atTop_nhds_0_of_lt_1 hâ‚ hâ‚‚).sub tendsto_const_nhds).mul tendsto_const_nhds
  (hasSum_iff_tendsto_nat_of_nonneg (pow_nonneg hâ‚) _).mpr <| by
    simp_all [neg_inv, geom_sum_eq, div_eq_mul_inv]
#align has_sum_geometric_of_lt_1 hasSum_geometric_of_lt_1

/- warning: summable_geometric_of_lt_1 -> summable_geometric_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Summable.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n))
but is expected to have type
  forall {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Summable.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n))
Case conversion may be inaccurate. Consider using '#align summable_geometric_of_lt_1 summable_geometric_of_lt_1â‚“'. -/
theorem summable_geometric_of_lt_1 {r : â„} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) :
    Summable fun n : â„• => r ^ n :=
  âŸ¨_, hasSum_geometric_of_lt_1 hâ‚ hâ‚‚âŸ©
#align summable_geometric_of_lt_1 summable_geometric_of_lt_1

/- warning: tsum_geometric_of_lt_1 -> tsum_geometric_of_lt_1 is a dubious translation:
lean 3 declaration is
  forall {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (Eq.{1} Real (tsum.{0, 0} Real Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n)) (Inv.inv.{0} Real Real.hasInv (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) r)))
but is expected to have type
  forall {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (Eq.{1} Real (tsum.{0, 0} Real Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n)) (Inv.inv.{0} Real Real.instInvReal (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) r)))
Case conversion may be inaccurate. Consider using '#align tsum_geometric_of_lt_1 tsum_geometric_of_lt_1â‚“'. -/
theorem tsum_geometric_of_lt_1 {r : â„} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) : (âˆ‘' n : â„•, r ^ n) = (1 - r)â»Â¹ :=
  (hasSum_geometric_of_lt_1 hâ‚ hâ‚‚).tsum_eq
#align tsum_geometric_of_lt_1 tsum_geometric_of_lt_1

/- warning: has_sum_geometric_two -> hasSum_geometric_two is a dubious translation:
lean 3 declaration is
  HasSum.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) n) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))
but is expected to have type
  HasSum.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) n) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align has_sum_geometric_two hasSum_geometric_twoâ‚“'. -/
theorem hasSum_geometric_two : HasSum (fun n : â„• => ((1 : â„) / 2) ^ n) 2 := by
  convert hasSum_geometric_of_lt_1 _ _ <;> norm_num
#align has_sum_geometric_two hasSum_geometric_two

/- warning: summable_geometric_two -> summable_geometric_two is a dubious translation:
lean 3 declaration is
  Summable.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) n)
but is expected to have type
  Summable.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) n)
Case conversion may be inaccurate. Consider using '#align summable_geometric_two summable_geometric_twoâ‚“'. -/
theorem summable_geometric_two : Summable fun n : â„• => ((1 : â„) / 2) ^ n :=
  âŸ¨_, hasSum_geometric_twoâŸ©
#align summable_geometric_two summable_geometric_two

/- warning: summable_geometric_two_encode -> summable_geometric_two_encode is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} [_inst_1 : Encodable.{u1} Î¹], Summable.{0, u1} Real Î¹ Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (i : Î¹) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (Encodable.encode.{u1} Î¹ _inst_1 i))
but is expected to have type
  forall {Î¹ : Type.{u1}} [_inst_1 : Encodable.{u1} Î¹], Summable.{0, u1} Real Î¹ Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (i : Î¹) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Encodable.encode.{u1} Î¹ _inst_1 i))
Case conversion may be inaccurate. Consider using '#align summable_geometric_two_encode summable_geometric_two_encodeâ‚“'. -/
theorem summable_geometric_two_encode {Î¹ : Type _} [Encodable Î¹] :
    Summable fun i : Î¹ => (1 / 2 : â„) ^ Encodable.encode i :=
  summable_geometric_two.comp_injective Encodable.encode_injective
#align summable_geometric_two_encode summable_geometric_two_encode

/- warning: tsum_geometric_two -> tsum_geometric_two is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (tsum.{0, 0} Real Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) n)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))
but is expected to have type
  Eq.{1} Real (tsum.{0, 0} Real Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) n)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align tsum_geometric_two tsum_geometric_twoâ‚“'. -/
theorem tsum_geometric_two : (âˆ‘' n : â„•, ((1 : â„) / 2) ^ n) = 2 :=
  hasSum_geometric_two.tsum_eq
#align tsum_geometric_two tsum_geometric_two

/- warning: sum_geometric_two_le -> sum_geometric_two_le is a dubious translation:
lean 3 declaration is
  forall (n : Nat), LE.le.{0} Real Real.hasLe (Finset.sum.{0, 0} Real Nat Real.addCommMonoid (Finset.range n) (fun (i : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) i)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall (n : Nat), LE.le.{0} Real Real.instLEReal (Finset.sum.{0, 0} Real Nat Real.instAddCommMonoidReal (Finset.range n) (fun (i : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) i)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align sum_geometric_two_le sum_geometric_two_leâ‚“'. -/
theorem sum_geometric_two_le (n : â„•) : (âˆ‘ i : â„• in range n, (1 / (2 : â„)) ^ i) â‰¤ 2 :=
  by
  have : âˆ€ i, 0 â‰¤ (1 / (2 : â„)) ^ i := by intro i; apply pow_nonneg; norm_num
  convert sum_le_tsum (range n) (fun i _ => this i) summable_geometric_two
  exact tsum_geometric_two.symm
#align sum_geometric_two_le sum_geometric_two_le

/- warning: tsum_geometric_inv_two -> tsum_geometric_inv_two is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (tsum.{0, 0} Real Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Inv.inv.{0} Real Real.hasInv (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) n)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))
but is expected to have type
  Eq.{1} Real (tsum.{0, 0} Real Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Inv.inv.{0} Real Real.instInvReal (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) n)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align tsum_geometric_inv_two tsum_geometric_inv_twoâ‚“'. -/
theorem tsum_geometric_inv_two : (âˆ‘' n : â„•, (2 : â„)â»Â¹ ^ n) = 2 :=
  (inv_eq_one_div (2 : â„)).symm â–¸ tsum_geometric_two
#align tsum_geometric_inv_two tsum_geometric_inv_two

/- warning: tsum_geometric_inv_two_ge -> tsum_geometric_inv_two_ge is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Real (tsum.{0, 0} Real Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (i : Nat) => ite.{1} Real (LE.le.{0} Nat Nat.hasLe n i) (Nat.decidableLe n i) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Inv.inv.{0} Real Real.hasInv (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) i) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Inv.inv.{0} Real Real.hasInv (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) n))
but is expected to have type
  forall (n : Nat), Eq.{1} Real (tsum.{0, 0} Real Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (i : Nat) => ite.{1} Real (LE.le.{0} Nat instLENat n i) (Nat.decLe n i) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Inv.inv.{0} Real Real.instInvReal (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) i) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Inv.inv.{0} Real Real.instInvReal (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) n))
Case conversion may be inaccurate. Consider using '#align tsum_geometric_inv_two_ge tsum_geometric_inv_two_geâ‚“'. -/
/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/
theorem tsum_geometric_inv_two_ge (n : â„•) : (âˆ‘' i, ite (n â‰¤ i) ((2 : â„)â»Â¹ ^ i) 0) = 2 * 2â»Â¹ ^ n :=
  by
  have A : Summable fun i : â„• => ite (n â‰¤ i) ((2â»Â¹ : â„) ^ i) 0 := by
    apply summable_of_nonneg_of_le _ _ summable_geometric_two <;>
      Â· intro i; by_cases hi : n â‰¤ i <;> simp [hi]
  have B : ((Finset.range n).Sum fun i : â„• => ite (n â‰¤ i) ((2â»Â¹ : â„) ^ i) 0) = 0 :=
    Finset.sum_eq_zero fun i hi =>
      ite_eq_right_iff.2 fun h => (lt_irrefl _ ((Finset.mem_range.1 hi).trans_le h)).elim
  simp only [â† sum_add_tsum_nat_add n A, B, if_true, zero_add, zero_le', le_add_iff_nonneg_left,
    pow_add, tsum_mul_right, tsum_geometric_inv_two]
#align tsum_geometric_inv_two_ge tsum_geometric_inv_two_ge

/- warning: has_sum_geometric_two' -> hasSum_geometric_two' is a dubious translation:
lean 3 declaration is
  forall (a : Real), HasSum.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) a (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n)) a
but is expected to have type
  forall (a : Real), HasSum.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) a (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n)) a
Case conversion may be inaccurate. Consider using '#align has_sum_geometric_two' hasSum_geometric_two'â‚“'. -/
theorem hasSum_geometric_two' (a : â„) : HasSum (fun n : â„• => a / 2 / 2 ^ n) a :=
  by
  convert HasSum.mul_left (a / 2) (hasSum_geometric_of_lt_1 (le_of_lt one_half_pos) one_half_lt_one)
  Â· funext n; simp; rfl
  Â· norm_num
#align has_sum_geometric_two' hasSum_geometric_two'

/- warning: summable_geometric_two' -> summable_geometric_two' is a dubious translation:
lean 3 declaration is
  forall (a : Real), Summable.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) a (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))
but is expected to have type
  forall (a : Real), Summable.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) a (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))
Case conversion may be inaccurate. Consider using '#align summable_geometric_two' summable_geometric_two'â‚“'. -/
theorem summable_geometric_two' (a : â„) : Summable fun n : â„• => a / 2 / 2 ^ n :=
  âŸ¨a, hasSum_geometric_two' aâŸ©
#align summable_geometric_two' summable_geometric_two'

/- warning: tsum_geometric_two' -> tsum_geometric_two' is a dubious translation:
lean 3 declaration is
  forall (a : Real), Eq.{1} Real (tsum.{0, 0} Real Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) a (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))) a
but is expected to have type
  forall (a : Real), Eq.{1} Real (tsum.{0, 0} Real Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Nat (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) a (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))) a
Case conversion may be inaccurate. Consider using '#align tsum_geometric_two' tsum_geometric_two'â‚“'. -/
theorem tsum_geometric_two' (a : â„) : (âˆ‘' n : â„•, a / 2 / 2 ^ n) = a :=
  (hasSum_geometric_two' a).tsum_eq
#align tsum_geometric_two' tsum_geometric_two'

/- warning: nnreal.has_sum_geometric -> NNReal.hasSum_geometric is a dubious translation:
lean 3 declaration is
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) r (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))) -> (HasSum.{0, 0} NNReal Nat (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) NNReal.topologicalSpace (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) r n) (Inv.inv.{0} NNReal (DivInvMonoid.toHasInv.{0} NNReal (GroupWithZero.toDivInvMonoid.{0} NNReal (DivisionSemiring.toGroupWithZero.{0} NNReal (Semifield.toDivisionSemiring.{0} NNReal (LinearOrderedSemifield.toSemifield.{0} NNReal (CanonicallyLinearOrderedSemifield.toLinearOrderedSemifield.{0} NNReal NNReal.canonicallyLinearOrderedSemifield)))))) (HSub.hSub.{0, 0, 0} NNReal NNReal NNReal (instHSub.{0} NNReal NNReal.hasSub) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) r)))
but is expected to have type
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) r (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne))) -> (HasSum.{0, 0} NNReal Nat (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) NNReal.instTopologicalSpaceNNReal (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal instNNRealSemiring)))) r n) (Inv.inv.{0} NNReal (CanonicallyLinearOrderedSemifield.toInv.{0} NNReal NNReal.instCanonicallyLinearOrderedSemifieldNNReal) (HSub.hSub.{0, 0, 0} NNReal NNReal NNReal (instHSub.{0} NNReal NNReal.instSubNNReal) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) r)))
Case conversion may be inaccurate. Consider using '#align nnreal.has_sum_geometric NNReal.hasSum_geometricâ‚“'. -/
/-- **Sum of a Geometric Series** -/
theorem NNReal.hasSum_geometric {r : â„â‰¥0} (hr : r < 1) : HasSum (fun n : â„• => r ^ n) (1 - r)â»Â¹ :=
  by
  apply NNReal.hasSum_coe.1
  push_cast
  rw [NNReal.coe_sub (le_of_lt hr)]
  exact hasSum_geometric_of_lt_1 r.coe_nonneg hr
#align nnreal.has_sum_geometric NNReal.hasSum_geometric

/- warning: nnreal.summable_geometric -> NNReal.summable_geometric is a dubious translation:
lean 3 declaration is
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) r (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))) -> (Summable.{0, 0} NNReal Nat (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) NNReal.topologicalSpace (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) r n))
but is expected to have type
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) r (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne))) -> (Summable.{0, 0} NNReal Nat (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) NNReal.instTopologicalSpaceNNReal (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal instNNRealSemiring)))) r n))
Case conversion may be inaccurate. Consider using '#align nnreal.summable_geometric NNReal.summable_geometricâ‚“'. -/
theorem NNReal.summable_geometric {r : â„â‰¥0} (hr : r < 1) : Summable fun n : â„• => r ^ n :=
  âŸ¨_, NNReal.hasSum_geometric hrâŸ©
#align nnreal.summable_geometric NNReal.summable_geometric

/- warning: tsum_geometric_nnreal -> tsum_geometric_nNReal is a dubious translation:
lean 3 declaration is
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) r (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))) -> (Eq.{1} NNReal (tsum.{0, 0} NNReal (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) NNReal.topologicalSpace Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) r n)) (Inv.inv.{0} NNReal (DivInvMonoid.toHasInv.{0} NNReal (GroupWithZero.toDivInvMonoid.{0} NNReal (DivisionSemiring.toGroupWithZero.{0} NNReal (Semifield.toDivisionSemiring.{0} NNReal (LinearOrderedSemifield.toSemifield.{0} NNReal (CanonicallyLinearOrderedSemifield.toLinearOrderedSemifield.{0} NNReal NNReal.canonicallyLinearOrderedSemifield)))))) (HSub.hSub.{0, 0, 0} NNReal NNReal NNReal (instHSub.{0} NNReal NNReal.hasSub) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) r)))
but is expected to have type
  forall {r : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) r (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne))) -> (Eq.{1} NNReal (tsum.{0, 0} NNReal (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) NNReal.instTopologicalSpaceNNReal Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} NNReal Nat NNReal (instHPow.{0, 0} NNReal Nat (Monoid.Pow.{0} NNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal instNNRealSemiring)))) r n)) (Inv.inv.{0} NNReal (CanonicallyLinearOrderedSemifield.toInv.{0} NNReal NNReal.instCanonicallyLinearOrderedSemifieldNNReal) (HSub.hSub.{0, 0, 0} NNReal NNReal NNReal (instHSub.{0} NNReal NNReal.instSubNNReal) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) r)))
Case conversion may be inaccurate. Consider using '#align tsum_geometric_nnreal tsum_geometric_nNRealâ‚“'. -/
theorem tsum_geometric_nNReal {r : â„â‰¥0} (hr : r < 1) : (âˆ‘' n : â„•, r ^ n) = (1 - r)â»Â¹ :=
  (NNReal.hasSum_geometric hr).tsum_eq
#align tsum_geometric_nnreal tsum_geometric_nNReal

/- warning: ennreal.tsum_geometric -> ENNReal.tsum_geometric is a dubious translation:
lean 3 declaration is
  forall (r : ENNReal), Eq.{1} ENNReal (tsum.{0, 0} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) r n)) (Inv.inv.{0} ENNReal ENNReal.hasInv (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) r))
but is expected to have type
  forall (r : ENNReal), Eq.{1} ENNReal (tsum.{0, 0} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Nat (fun (n : Nat) => HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) r n)) (Inv.inv.{0} ENNReal ENNReal.instInvENNReal (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSub) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) r))
Case conversion may be inaccurate. Consider using '#align ennreal.tsum_geometric ENNReal.tsum_geometricâ‚“'. -/
/-- The series `pow r` converges to `(1-r)â»Â¹`. For `r < 1` the RHS is a finite number,
and for `1 â‰¤ r` the RHS equals `âˆ`. -/
@[simp]
theorem ENNReal.tsum_geometric (r : â„â‰¥0âˆ) : (âˆ‘' n : â„•, r ^ n) = (1 - r)â»Â¹ :=
  by
  cases' lt_or_le r 1 with hr hr
  Â· rcases ENNReal.lt_iff_exists_coe.1 hr with âŸ¨r, rfl, hr'âŸ©
    norm_cast  at *
    convert ENNReal.tsum_coe_eq (NNReal.hasSum_geometric hr)
    rw [ENNReal.coe_inv <| ne_of_gt <| tsub_pos_iff_lt.2 hr]
  Â· rw [tsub_eq_zero_iff_le.mpr hr, ENNReal.inv_zero, ENNReal.tsum_eq_iSup_nat, iSup_eq_top]
    refine' fun a ha =>
      (ENNReal.exists_nat_gt (lt_top_iff_ne_top.1 ha)).imp fun n hn => lt_of_lt_of_le hn _
    calc
      (n : â„â‰¥0âˆ) = âˆ‘ i in range n, 1 := by rw [sum_const, nsmul_one, card_range]
      _ â‰¤ âˆ‘ i in range n, r ^ i := sum_le_sum fun k _ => one_le_pow_of_one_le' hr k
      
#align ennreal.tsum_geometric ENNReal.tsum_geometric

end Geometric

/-!
### Sequences with geometrically decaying distance in metric spaces

In this paragraph, we discuss sequences in metric spaces or emetric spaces for which the distance
between two consecutive terms decays geometrically. We show that such sequences are Cauchy
sequences, and bound their distances to the limit. We also discuss series with geometrically
decaying terms.
-/


section EdistLeGeometric

variable [PseudoEMetricSpace Î±] (r C : â„â‰¥0âˆ) (hr : r < 1) (hC : C â‰  âŠ¤) {f : â„• â†’ Î±}
  (hu : âˆ€ n, edist (f n) (f (n + 1)) â‰¤ C * r ^ n)

include hr hC hu

/- warning: cauchy_seq_of_edist_le_geometric -> cauchySeq_of_edist_le_geometric is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (r : ENNReal) (C : ENNReal), (LT.lt.{0} ENNReal (Preorder.toHasLt.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) r (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) -> (Ne.{1} ENNReal C (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) r n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{0} Nat Nat.canonicallyLinearOrderedAddMonoid) f))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (r : ENNReal) (C : ENNReal), (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) r (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) -> (Ne.{1} ENNReal C (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) r n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1) (Lattice.toSemilatticeSup.{0} Nat Nat.instLatticeNat) f))
Case conversion may be inaccurate. Consider using '#align cauchy_seq_of_edist_le_geometric cauchySeq_of_edist_le_geometricâ‚“'. -/
/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, `C â‰  âˆ`, `r < 1`,
then `f` is a Cauchy sequence.-/
theorem cauchySeq_of_edist_le_geometric : CauchySeq f :=
  by
  refine' cauchySeq_of_edist_le_of_tsum_ne_top _ hu _
  rw [ENNReal.tsum_mul_left, ENNReal.tsum_geometric]
  refine' ENNReal.mul_ne_top hC (ENNReal.inv_ne_top.2 _)
  exact (tsub_pos_iff_lt.2 hr).ne'
#align cauchy_seq_of_edist_le_geometric cauchySeq_of_edist_le_geometric

omit hr hC

/- warning: edist_le_of_edist_le_geometric_of_tendsto -> edist_le_of_edist_le_geometric_of_tendsto is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (r : ENNReal) (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) r n)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) r))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (r : ENNReal) (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) r n)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSub) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) r))))
Case conversion may be inaccurate. Consider using '#align edist_le_of_edist_le_geometric_of_tendsto edist_le_of_edist_le_geometric_of_tendstoâ‚“'. -/
/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from
`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/
theorem edist_le_of_edist_le_geometric_of_tendsto {a : Î±} (ha : Tendsto f atTop (ğ“ a)) (n : â„•) :
    edist (f n) a â‰¤ C * r ^ n / (1 - r) :=
  by
  convert edist_le_tsum_of_edist_le_of_tendsto _ hu ha _
  simp only [pow_add, ENNReal.tsum_mul_left, ENNReal.tsum_geometric, div_eq_mul_inv, mul_assoc]
#align edist_le_of_edist_le_geometric_of_tendsto edist_le_of_edist_le_geometric_of_tendsto

/- warning: edist_le_of_edist_le_geometric_of_tendstoâ‚€ -> edist_le_of_edist_le_geometric_of_tendstoâ‚€ is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (r : ENNReal) (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) a) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) C (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) r))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (r : ENNReal) (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) a) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) C (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSub) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) r))))
Case conversion may be inaccurate. Consider using '#align edist_le_of_edist_le_geometric_of_tendstoâ‚€ edist_le_of_edist_le_geometric_of_tendstoâ‚€â‚“'. -/
/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from
`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/
theorem edist_le_of_edist_le_geometric_of_tendstoâ‚€ {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :
    edist (f 0) a â‰¤ C / (1 - r) := by
  simpa only [pow_zero, mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0
#align edist_le_of_edist_le_geometric_of_tendstoâ‚€ edist_le_of_edist_le_geometric_of_tendstoâ‚€

end EdistLeGeometric

section EdistLeGeometricTwo

variable [PseudoEMetricSpace Î±] (C : â„â‰¥0âˆ) (hC : C â‰  âŠ¤) {f : â„• â†’ Î±}
  (hu : âˆ€ n, edist (f n) (f (n + 1)) â‰¤ C / 2 ^ n) {a : Î±} (ha : Tendsto f atTop (ğ“ a))

include hC hu

/- warning: cauchy_seq_of_edist_le_geometric_two -> cauchySeq_of_edist_le_geometric_two is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (C : ENNReal), (Ne.{1} ENNReal C (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{0} Nat Nat.canonicallyLinearOrderedAddMonoid) f))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (C : ENNReal), (Ne.{1} ENNReal C (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1) (Lattice.toSemilatticeSup.{0} Nat Nat.instLatticeNat) f))
Case conversion may be inaccurate. Consider using '#align cauchy_seq_of_edist_le_geometric_two cauchySeq_of_edist_le_geometric_twoâ‚“'. -/
/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then `f` is a Cauchy sequence.-/
theorem cauchySeq_of_edist_le_geometric_two : CauchySeq f :=
  by
  simp only [div_eq_mul_inv, ENNReal.inv_pow] at hu
  refine' cauchySeq_of_edist_le_geometric 2â»Â¹ C _ hC hu
  simp [ENNReal.one_lt_two]
#align cauchy_seq_of_edist_le_geometric_two cauchySeq_of_edist_le_geometric_two

omit hC

include ha

/- warning: edist_le_of_edist_le_geometric_two_of_tendsto -> edist_le_of_edist_le_geometric_two_of_tendsto is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) C) (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) n))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) C) (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))))
Case conversion may be inaccurate. Consider using '#align edist_le_of_edist_le_geometric_two_of_tendsto edist_le_of_edist_le_geometric_two_of_tendstoâ‚“'. -/
/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from
`f n` to the limit of `f` is bounded above by `2 * C * 2^-n`. -/
theorem edist_le_of_edist_le_geometric_two_of_tendsto (n : â„•) : edist (f n) a â‰¤ 2 * C / 2 ^ n :=
  by
  simp only [div_eq_mul_inv, ENNReal.inv_pow] at *
  rw [mul_assoc, mul_comm]
  convert edist_le_of_edist_le_geometric_of_tendsto 2â»Â¹ C hu ha n
  rw [ENNReal.one_sub_inv_two, inv_inv]
#align edist_le_of_edist_le_geometric_two_of_tendsto edist_le_of_edist_le_geometric_two_of_tendsto

/- warning: edist_le_of_edist_le_geometric_two_of_tendstoâ‚€ -> edist_le_of_edist_le_geometric_two_of_tendstoâ‚€ is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toHasDiv.{0} ENNReal ENNReal.divInvMonoid)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} ENNReal (Preorder.toHasLe.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toHasEdist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) a) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (OfNat.ofNat.{0} ENNReal 2 (OfNat.mk.{0} ENNReal 2 (bit0.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) C)))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoEMetricSpace.{u1} Î±] (C : ENNReal) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HDiv.hDiv.{0, 0, 0} ENNReal ENNReal ENNReal (instHDiv.{0} ENNReal (DivInvMonoid.toDiv.{0} ENNReal ENNReal.instDivInvMonoidENNReal)) C (HPow.hPow.{0, 0, 0} ENNReal Nat ENNReal (instHPow.{0, 0} ENNReal Nat (Monoid.Pow.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))) (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoEMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (EDist.edist.{u1} Î± (PseudoEMetricSpace.toEDist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) a) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (OfNat.ofNat.{0} ENNReal 2 (instOfNat.{0} ENNReal 2 (CanonicallyOrderedCommSemiring.toNatCast.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) C)))
Case conversion may be inaccurate. Consider using '#align edist_le_of_edist_le_geometric_two_of_tendstoâ‚€ edist_le_of_edist_le_geometric_two_of_tendstoâ‚€â‚“'. -/
/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from
`f 0` to the limit of `f` is bounded above by `2 * C`. -/
theorem edist_le_of_edist_le_geometric_two_of_tendstoâ‚€ : edist (f 0) a â‰¤ 2 * C := by
  simpa only [pow_zero, div_eq_mul_inv, inv_one, mul_one] using
    edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0
#align edist_le_of_edist_le_geometric_two_of_tendstoâ‚€ edist_le_of_edist_le_geometric_two_of_tendstoâ‚€

end EdistLeGeometricTwo

section LeGeometric

variable [PseudoMetricSpace Î±] {r C : â„} (hr : r < 1) {f : â„• â†’ Î±}
  (hu : âˆ€ n, dist (f n) (f (n + 1)) â‰¤ C * r ^ n)

include hr hu

/- warning: aux_has_sum_of_le_geometric -> aux_hasSum_of_le_geometric is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] {r : Real} {C : Real}, (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n))) -> (HasSum.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) C (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) r))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] {r : Real} {C : Real}, (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n))) -> (HasSum.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (n : Nat) => HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) C (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) r))))
Case conversion may be inaccurate. Consider using '#align aux_has_sum_of_le_geometric aux_hasSum_of_le_geometricâ‚“'. -/
theorem aux_hasSum_of_le_geometric : HasSum (fun n : â„• => C * r ^ n) (C / (1 - r)) :=
  by
  rcases sign_cases_of_C_mul_pow_nonneg fun n => dist_nonneg.trans (hu n) with (rfl | âŸ¨Câ‚€, râ‚€âŸ©)
  Â· simp [hasSum_zero]
  Â· refine' HasSum.mul_left C _
    simpa using hasSum_geometric_of_lt_1 râ‚€ hr
#align aux_has_sum_of_le_geometric aux_hasSum_of_le_geometric

variable (r C)

/- warning: cauchy_seq_of_le_geometric -> cauchySeq_of_le_geometric is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (r : Real) (C : Real), (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{0} Nat Nat.canonicallyLinearOrderedAddMonoid) f))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (r : Real) (C : Real), (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1) (Lattice.toSemilatticeSup.{0} Nat Nat.instLatticeNat) f))
Case conversion may be inaccurate. Consider using '#align cauchy_seq_of_le_geometric cauchySeq_of_le_geometricâ‚“'. -/
/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then `f` is a Cauchy sequence.
Note that this lemma does not assume `0 â‰¤ C` or `0 â‰¤ r`. -/
theorem cauchySeq_of_le_geometric : CauchySeq f :=
  cauchySeq_of_dist_le_of_summable _ hu âŸ¨_, aux_hasSum_of_le_geometric hr huâŸ©
#align cauchy_seq_of_le_geometric cauchySeq_of_le_geometric

/- warning: dist_le_of_le_geometric_of_tendstoâ‚€ -> dist_le_of_le_geometric_of_tendstoâ‚€ is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (r : Real) (C : Real), (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) a) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) C (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) r)))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (r : Real) (C : Real), (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) a) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) C (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) r)))))
Case conversion may be inaccurate. Consider using '#align dist_le_of_le_geometric_of_tendstoâ‚€ dist_le_of_le_geometric_of_tendstoâ‚€â‚“'. -/
/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from
`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/
theorem dist_le_of_le_geometric_of_tendstoâ‚€ {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :
    dist (f 0) a â‰¤ C / (1 - r) :=
  (aux_hasSum_of_le_geometric hr hu).tsum_eq â–¸
    dist_le_tsum_of_dist_le_of_tendstoâ‚€ _ hu âŸ¨_, aux_hasSum_of_le_geometric hr huâŸ© ha
#align dist_le_of_le_geometric_of_tendstoâ‚€ dist_le_of_le_geometric_of_tendstoâ‚€

/- warning: dist_le_of_le_geometric_of_tendsto -> dist_le_of_le_geometric_of_tendsto is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (r : Real) (C : Real), (LT.lt.{0} Real Real.hasLt r (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) r)))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (r : Real) (C : Real), (LT.lt.{0} Real Real.instLTReal r (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) -> (forall {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) r)))))
Case conversion may be inaccurate. Consider using '#align dist_le_of_le_geometric_of_tendsto dist_le_of_le_geometric_of_tendstoâ‚“'. -/
/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from
`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/
theorem dist_le_of_le_geometric_of_tendsto {a : Î±} (ha : Tendsto f atTop (ğ“ a)) (n : â„•) :
    dist (f n) a â‰¤ C * r ^ n / (1 - r) :=
  by
  have := aux_hasSum_of_le_geometric hr hu
  convert dist_le_tsum_of_dist_le_of_tendsto _ hu âŸ¨_, thisâŸ© ha n
  simp only [pow_add, mul_left_comm C, mul_div_right_comm]
  rw [mul_comm]
  exact (this.mul_left _).tsum_eq.symm
#align dist_le_of_le_geometric_of_tendsto dist_le_of_le_geometric_of_tendsto

omit hr hu

variable (huâ‚‚ : âˆ€ n, dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n)

/- warning: cauchy_seq_of_le_geometric_two -> cauchySeq_of_le_geometric_two is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (C : Real) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) C (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{0} Nat Nat.canonicallyLinearOrderedAddMonoid) f)
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (C : Real) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) C (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))) -> (CauchySeq.{u1, 0} Î± Nat (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1) (Lattice.toSemilatticeSup.{0} Nat Nat.instLatticeNat) f)
Case conversion may be inaccurate. Consider using '#align cauchy_seq_of_le_geometric_two cauchySeq_of_le_geometric_twoâ‚“'. -/
/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/
theorem cauchySeq_of_le_geometric_two : CauchySeq f :=
  cauchySeq_of_dist_le_of_summable _ huâ‚‚ <| âŸ¨_, hasSum_geometric_two' CâŸ©
#align cauchy_seq_of_le_geometric_two cauchySeq_of_le_geometric_two

/- warning: dist_le_of_le_geometric_two_of_tendstoâ‚€ -> dist_le_of_le_geometric_two_of_tendstoâ‚€ is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (C : Real) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) C (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) a) C))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (C : Real) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) C (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) a) C))
Case conversion may be inaccurate. Consider using '#align dist_le_of_le_geometric_two_of_tendstoâ‚€ dist_le_of_le_geometric_two_of_tendstoâ‚€â‚“'. -/
/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from
`f 0` to the limit of `f` is bounded above by `C`. -/
theorem dist_le_of_le_geometric_two_of_tendstoâ‚€ {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :
    dist (f 0) a â‰¤ C :=
  tsum_geometric_two' C â–¸ dist_le_tsum_of_dist_le_of_tendstoâ‚€ _ huâ‚‚ (summable_geometric_two' C) ha
#align dist_le_of_le_geometric_two_of_tendstoâ‚€ dist_le_of_le_geometric_two_of_tendstoâ‚€

include huâ‚‚

/- warning: dist_le_of_le_geometric_two_of_tendsto -> dist_le_of_le_geometric_two_of_tendsto is a dubious translation:
lean 3 declaration is
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (C : Real) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) C (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{u1} Î± (PseudoMetricSpace.toHasDist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))))
but is expected to have type
  forall {Î± : Type.{u1}} [_inst_1 : PseudoMetricSpace.{u1} Î±] (C : Real) {f : Nat -> Î±}, (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) (f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) C (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))) -> (forall {a : Î±}, (Filter.Tendsto.{0, u1} Nat Î± f (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Î± (UniformSpace.toTopologicalSpace.{u1} Î± (PseudoMetricSpace.toUniformSpace.{u1} Î± _inst_1)) a)) -> (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} Î± (PseudoMetricSpace.toDist.{u1} Î± _inst_1) (f n) a) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) C (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))))
Case conversion may be inaccurate. Consider using '#align dist_le_of_le_geometric_two_of_tendsto dist_le_of_le_geometric_two_of_tendstoâ‚“'. -/
/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from
`f n` to the limit of `f` is bounded above by `C / 2^n`. -/
theorem dist_le_of_le_geometric_two_of_tendsto {a : Î±} (ha : Tendsto f atTop (ğ“ a)) (n : â„•) :
    dist (f n) a â‰¤ C / 2 ^ n :=
  by
  convert dist_le_tsum_of_dist_le_of_tendsto _ huâ‚‚ (summable_geometric_two' C) ha n
  simp only [add_comm n, pow_add, â† div_div]
  symm
  exact ((hasSum_geometric_two' C).div_const _).tsum_eq
#align dist_le_of_le_geometric_two_of_tendsto dist_le_of_le_geometric_two_of_tendsto

end LeGeometric

/-! ### Summability tests based on comparison with geometric series -/


/- warning: summable_one_div_pow_of_le -> summable_one_div_pow_of_le is a dubious translation:
lean 3 declaration is
  forall {m : Real} {f : Nat -> Nat}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) m) -> (forall (i : Nat), LE.le.{0} Nat Nat.hasLe i (f i)) -> (Summable.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (i : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) m (f i))))
but is expected to have type
  forall {m : Real} {f : Nat -> Nat}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) m) -> (forall (i : Nat), LE.le.{0} Nat instLENat i (f i)) -> (Summable.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (i : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) m (f i))))
Case conversion may be inaccurate. Consider using '#align summable_one_div_pow_of_le summable_one_div_pow_of_leâ‚“'. -/
/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/
theorem summable_one_div_pow_of_le {m : â„} {f : â„• â†’ â„•} (hm : 1 < m) (fi : âˆ€ i, i â‰¤ f i) :
    Summable fun i => 1 / m ^ f i :=
  by
  refine'
    summable_of_nonneg_of_le (fun a => one_div_nonneg.mpr (pow_nonneg (zero_le_one.trans hm.le) _))
      (fun a => _)
      (summable_geometric_of_lt_1 (one_div_nonneg.mpr (zero_le_one.trans hm.le))
        ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))
  rw [div_pow, one_pow]
  refine' (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a)) <;>
    exact pow_pos (zero_lt_one.trans hm) _
#align summable_one_div_pow_of_le summable_one_div_pow_of_le

/-! ### Positive sequences with small sums on countable types -/


/- warning: pos_sum_of_encodable -> posSumOfEncodable is a dubious translation:
lean 3 declaration is
  forall {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Encodable.{u1} Î¹], Subtype.{succ u1} (Î¹ -> Real) (fun (Îµ' : Î¹ -> Real) => And (forall (i : Î¹), LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Îµ' i)) (Exists.{1} Real (fun (c : Real) => And (HasSum.{0, u1} Real Î¹ Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Îµ' c) (LE.le.{0} Real Real.hasLe c Îµ)))))
but is expected to have type
  forall {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Encodable.{u1} Î¹], Subtype.{succ u1} (Î¹ -> Real) (fun (Îµ' : Î¹ -> Real) => And (forall (i : Î¹), LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Îµ' i)) (Exists.{1} Real (fun (c : Real) => And (HasSum.{0, u1} Real Î¹ Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Îµ' c) (LE.le.{0} Real Real.instLEReal c Îµ)))))
Case conversion may be inaccurate. Consider using '#align pos_sum_of_encodable posSumOfEncodableâ‚“'. -/
/-- For any positive `Îµ`, define on an encodable type a positive sequence with sum less than `Îµ` -/
def posSumOfEncodable {Îµ : â„} (hÎµ : 0 < Îµ) (Î¹) [Encodable Î¹] :
    { Îµ' : Î¹ â†’ â„ // (âˆ€ i, 0 < Îµ' i) âˆ§ âˆƒ c, HasSum Îµ' c âˆ§ c â‰¤ Îµ } :=
  by
  let f n := Îµ / 2 / 2 ^ n
  have hf : HasSum f Îµ := hasSum_geometric_two' _
  have f0 : âˆ€ n, 0 < f n := fun n => div_pos (half_pos hÎµ) (pow_pos zero_lt_two _)
  refine' âŸ¨f âˆ˜ Encodable.encode, fun i => f0 _, _âŸ©
  rcases hf.summable.comp_injective (@Encodable.encode_injective Î¹ _) with âŸ¨c, hgâŸ©
  refine' âŸ¨c, hg, hasSum_le_inj _ (@Encodable.encode_injective Î¹ _) _ _ hg hfâŸ©
  Â· intro i _; exact le_of_lt (f0 _)
  Â· intro n; exact le_rfl
#align pos_sum_of_encodable posSumOfEncodable

/- warning: set.countable.exists_pos_has_sum_le -> Set.Countable.exists_pos_hasSum_le is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {s : Set.{u1} Î¹}, (Set.Countable.{u1} Î¹ s) -> (forall {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (Exists.{succ u1} (Î¹ -> Real) (fun (Îµ' : Î¹ -> Real) => And (forall (i : Î¹), LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Îµ' i)) (Exists.{1} Real (fun (c : Real) => And (HasSum.{0, u1} Real (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î¹) Type.{u1} (Set.hasCoeToSort.{u1} Î¹) s) Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î¹) Type.{u1} (Set.hasCoeToSort.{u1} Î¹) s) => Îµ' ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î¹) Type.{u1} (Set.hasCoeToSort.{u1} Î¹) s) Î¹ (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î¹) Type.{u1} (Set.hasCoeToSort.{u1} Î¹) s) Î¹ (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î¹) Type.{u1} (Set.hasCoeToSort.{u1} Î¹) s) Î¹ (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Î¹) Type.{u1} (Set.hasCoeToSort.{u1} Î¹) s) Î¹ (coeSubtype.{succ u1} Î¹ (fun (x : Î¹) => Membership.Mem.{u1, u1} Î¹ (Set.{u1} Î¹) (Set.hasMem.{u1} Î¹) x s))))) i)) c) (LE.le.{0} Real Real.hasLe c Îµ))))))
but is expected to have type
  forall {Î¹ : Type.{u1}} {s : Set.{u1} Î¹}, (Set.Countable.{u1} Î¹ s) -> (forall {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (Exists.{succ u1} (Î¹ -> Real) (fun (Îµ' : Î¹ -> Real) => And (forall (i : Î¹), LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Îµ' i)) (Exists.{1} Real (fun (c : Real) => And (HasSum.{0, u1} Real (Set.Elem.{u1} Î¹ s) Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (i : Set.Elem.{u1} Î¹ s) => Îµ' (Subtype.val.{succ u1} Î¹ (fun (x : Î¹) => Membership.mem.{u1, u1} Î¹ (Set.{u1} Î¹) (Set.instMembershipSet.{u1} Î¹) x s) i)) c) (LE.le.{0} Real Real.instLEReal c Îµ))))))
Case conversion may be inaccurate. Consider using '#align set.countable.exists_pos_has_sum_le Set.Countable.exists_pos_hasSum_leâ‚“'. -/
theorem Set.Countable.exists_pos_hasSum_le {Î¹ : Type _} {s : Set Î¹} (hs : s.Countable) {Îµ : â„}
    (hÎµ : 0 < Îµ) : âˆƒ Îµ' : Î¹ â†’ â„, (âˆ€ i, 0 < Îµ' i) âˆ§ âˆƒ c, HasSum (fun i : s => Îµ' i) c âˆ§ c â‰¤ Îµ :=
  by
  haveI := hs.to_encodable
  rcases posSumOfEncodable hÎµ s with âŸ¨f, hf0, âŸ¨c, hfc, hcÎµâŸ©âŸ©
  refine' âŸ¨fun i => if h : i âˆˆ s then f âŸ¨i, hâŸ© else 1, fun i => _, âŸ¨c, _, hcÎµâŸ©âŸ©
  Â· split_ifs; exacts[hf0 _, zero_lt_one]
  Â· simpa only [Subtype.coe_prop, dif_pos, Subtype.coe_eta]
#align set.countable.exists_pos_has_sum_le Set.Countable.exists_pos_hasSum_le

/- warning: set.countable.exists_pos_forall_sum_le -> Set.Countable.exists_pos_forall_sum_le is a dubious translation:
lean 3 declaration is
  forall {Î¹ : Type.{u1}} {s : Set.{u1} Î¹}, (Set.Countable.{u1} Î¹ s) -> (forall {Îµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Îµ) -> (Exists.{succ u1} (Î¹ -> Real) (fun (Îµ' : Î¹ -> Real) => And (forall (i : Î¹), LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Îµ' i)) (forall (t : Finset.{u1} Î¹), (HasSubset.Subset.{u1} (Set.{u1} Î¹) (Set.hasSubset.{u1} Î¹) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} Î¹) (Set.{u1} Î¹) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} Î¹) (Set.{u1} Î¹) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} Î¹) (Set.{u1} Î¹) (Finset.Set.hasCoeT.{u1} Î¹))) t) s) -> (LE.le.{0} Real Real.hasLe (Finset.sum.{0, u1} Real Î¹ Real.addCommMonoid t (fun (i : Î¹) => Îµ' i)) Îµ)))))
but is expected to have type
  forall {Î¹ : Type.{u1}} {s : Set.{u1} Î¹}, (Set.Countable.{u1} Î¹ s) -> (forall {Îµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Îµ) -> (Exists.{succ u1} (Î¹ -> Real) (fun (Îµ' : Î¹ -> Real) => And (forall (i : Î¹), LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Îµ' i)) (forall (t : Finset.{u1} Î¹), (HasSubset.Subset.{u1} (Set.{u1} Î¹) (Set.instHasSubsetSet.{u1} Î¹) (Finset.toSet.{u1} Î¹ t) s) -> (LE.le.{0} Real Real.instLEReal (Finset.sum.{0, u1} Real Î¹ Real.instAddCommMonoidReal t (fun (i : Î¹) => Îµ' i)) Îµ)))))
Case conversion may be inaccurate. Consider using '#align set.countable.exists_pos_forall_sum_le Set.Countable.exists_pos_forall_sum_leâ‚“'. -/
theorem Set.Countable.exists_pos_forall_sum_le {Î¹ : Type _} {s : Set Î¹} (hs : s.Countable) {Îµ : â„}
    (hÎµ : 0 < Îµ) : âˆƒ Îµ' : Î¹ â†’ â„, (âˆ€ i, 0 < Îµ' i) âˆ§ âˆ€ t : Finset Î¹, â†‘t âŠ† s â†’ (âˆ‘ i in t, Îµ' i) â‰¤ Îµ :=
  by
  rcases hs.exists_pos_has_sum_le hÎµ with âŸ¨Îµ', hpos, c, hÎµ'c, hcÎµâŸ©
  refine' âŸ¨Îµ', hpos, fun t ht => _âŸ©
  rw [â† sum_subtype_of_mem _ ht]
  refine' (sum_le_hasSum _ _ hÎµ'c).trans hcÎµ
  exact fun _ _ => (hpos _).le
#align set.countable.exists_pos_forall_sum_le Set.Countable.exists_pos_forall_sum_le

namespace NNReal

/- warning: nnreal.exists_pos_sum_of_countable -> NNReal.exists_pos_sum_of_countable is a dubious translation:
lean 3 declaration is
  forall {Îµ : NNReal}, (Ne.{1} NNReal Îµ (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Countable.{succ u1} Î¹], Exists.{succ u1} (Î¹ -> NNReal) (fun (Îµ' : Î¹ -> NNReal) => And (forall (i : Î¹), LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Îµ' i)) (Exists.{1} NNReal (fun (c : NNReal) => And (HasSum.{0, u1} NNReal Î¹ (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)) NNReal.topologicalSpace Îµ' c) (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) c Îµ)))))
but is expected to have type
  forall {Îµ : NNReal}, (Ne.{1} NNReal Îµ (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero))) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Countable.{succ u1} Î¹], Exists.{succ u1} (Î¹ -> NNReal) (fun (Îµ' : Î¹ -> NNReal) => And (forall (i : Î¹), LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)) (Îµ' i)) (Exists.{1} NNReal (fun (c : NNReal) => And (HasSum.{0, u1} NNReal Î¹ (OrderedCancelAddCommMonoid.toAddCommMonoid.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal instNNRealStrictOrderedSemiring)) NNReal.instTopologicalSpaceNNReal Îµ' c) (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) c Îµ)))))
Case conversion may be inaccurate. Consider using '#align nnreal.exists_pos_sum_of_countable NNReal.exists_pos_sum_of_countableâ‚“'. -/
theorem exists_pos_sum_of_countable {Îµ : â„â‰¥0} (hÎµ : Îµ â‰  0) (Î¹) [Countable Î¹] :
    âˆƒ Îµ' : Î¹ â†’ â„â‰¥0, (âˆ€ i, 0 < Îµ' i) âˆ§ âˆƒ c, HasSum Îµ' c âˆ§ c < Îµ :=
  by
  cases nonempty_encodable Î¹
  obtain âŸ¨a, a0, aÎµâŸ© := exists_between (pos_iff_ne_zero.2 hÎµ)
  obtain âŸ¨Îµ', hÎµ', c, hc, hcÎµâŸ© := posSumOfEncodable a0 Î¹
  exact
    âŸ¨fun i => âŸ¨Îµ' i, (hÎµ' i).leâŸ©, fun i => NNReal.coe_lt_coe.1 <| hÎµ' i,
      âŸ¨c, hasSum_le (fun i => (hÎµ' i).le) hasSum_zero hcâŸ©, NNReal.hasSum_coe.1 hc,
      aÎµ.trans_le' <| NNReal.coe_le_coe.1 hcÎµâŸ©
#align nnreal.exists_pos_sum_of_countable NNReal.exists_pos_sum_of_countable

end NNReal

namespace ENNReal

/- warning: ennreal.exists_pos_sum_of_countable -> ENNReal.exists_pos_sum_of_countable is a dubious translation:
lean 3 declaration is
  forall {Îµ : ENNReal}, (Ne.{1} ENNReal Îµ (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Countable.{succ u1} Î¹], Exists.{succ u1} (Î¹ -> NNReal) (fun (Îµ' : Î¹ -> NNReal) => And (forall (i : Î¹), LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Îµ' i)) (LT.lt.{0} ENNReal (Preorder.toHasLt.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Î¹ (fun (i : Î¹) => (fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTCâ‚“.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) (Îµ' i))) Îµ)))
but is expected to have type
  forall {Îµ : ENNReal}, (Ne.{1} ENNReal Îµ (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Countable.{succ u1} Î¹], Exists.{succ u1} (Î¹ -> NNReal) (fun (Îµ' : Î¹ -> NNReal) => And (forall (i : Î¹), LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)) (Îµ' i)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Î¹ (fun (i : Î¹) => ENNReal.some (Îµ' i))) Îµ)))
Case conversion may be inaccurate. Consider using '#align ennreal.exists_pos_sum_of_countable ENNReal.exists_pos_sum_of_countableâ‚“'. -/
theorem exists_pos_sum_of_countable {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) (Î¹) [Countable Î¹] :
    âˆƒ Îµ' : Î¹ â†’ â„â‰¥0, (âˆ€ i, 0 < Îµ' i) âˆ§ (âˆ‘' i, (Îµ' i : â„â‰¥0âˆ)) < Îµ :=
  by
  rcases exists_between (pos_iff_ne_zero.2 hÎµ) with âŸ¨r, h0r, hrÎµâŸ©
  rcases lt_iff_exists_coe.1 hrÎµ with âŸ¨x, rfl, hxâŸ©
  rcases NNReal.exists_pos_sum_of_countable (coe_pos.1 h0r).ne' Î¹ with âŸ¨Îµ', hp, c, hc, hcrâŸ©
  exact âŸ¨Îµ', hp, (ENNReal.tsum_coe_eq hc).symm â–¸ lt_trans (coe_lt_coe.2 hcr) hrÎµâŸ©
#align ennreal.exists_pos_sum_of_countable ENNReal.exists_pos_sum_of_countable

/- warning: ennreal.exists_pos_sum_of_countable' -> ENNReal.exists_pos_sum_of_countable' is a dubious translation:
lean 3 declaration is
  forall {Îµ : ENNReal}, (Ne.{1} ENNReal Îµ (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Countable.{succ u1} Î¹], Exists.{succ u1} (Î¹ -> ENNReal) (fun (Îµ' : Î¹ -> ENNReal) => And (forall (i : Î¹), LT.lt.{0} ENNReal (Preorder.toHasLt.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (Îµ' i)) (LT.lt.{0} ENNReal (Preorder.toHasLt.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Î¹ (fun (i : Î¹) => Îµ' i)) Îµ)))
but is expected to have type
  forall {Îµ : ENNReal}, (Ne.{1} ENNReal Îµ (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (forall (Î¹ : Type.{u1}) [_inst_1 : Countable.{succ u1} Î¹], Exists.{succ u1} (Î¹ -> ENNReal) (fun (Îµ' : Î¹ -> ENNReal) => And (forall (i : Î¹), LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (Îµ' i)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Î¹ (fun (i : Î¹) => Îµ' i)) Îµ)))
Case conversion may be inaccurate. Consider using '#align ennreal.exists_pos_sum_of_countable' ENNReal.exists_pos_sum_of_countable'â‚“'. -/
theorem exists_pos_sum_of_countable' {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) (Î¹) [Countable Î¹] :
    âˆƒ Îµ' : Î¹ â†’ â„â‰¥0âˆ, (âˆ€ i, 0 < Îµ' i) âˆ§ (âˆ‘' i, Îµ' i) < Îµ :=
  let âŸ¨Î´, Î´pos, hÎ´âŸ© := exists_pos_sum_of_countable hÎµ Î¹
  âŸ¨fun i => Î´ i, fun i => ENNReal.coe_pos.2 (Î´pos i), hÎ´âŸ©
#align ennreal.exists_pos_sum_of_countable' ENNReal.exists_pos_sum_of_countable'

/- warning: ennreal.exists_pos_tsum_mul_lt_of_countable -> ENNReal.exists_pos_tsum_mul_lt_of_countable is a dubious translation:
lean 3 declaration is
  forall {Îµ : ENNReal}, (Ne.{1} ENNReal Îµ (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (forall {Î¹ : Type.{u1}} [_inst_1 : Countable.{succ u1} Î¹] (w : Î¹ -> ENNReal), (forall (i : Î¹), Ne.{1} ENNReal (w i) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Exists.{succ u1} (Î¹ -> NNReal) (fun (Î´ : Î¹ -> NNReal) => And (forall (i : Î¹), LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (Î´ i)) (LT.lt.{0} ENNReal (Preorder.toHasLt.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Î¹ (fun (i : Î¹) => HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (w i) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTCâ‚“.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) (Î´ i)))) Îµ))))
but is expected to have type
  forall {Îµ : ENNReal}, (Ne.{1} ENNReal Îµ (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (forall {Î¹ : Type.{u1}} [_inst_1 : Countable.{succ u1} Î¹] (w : Î¹ -> ENNReal), (forall (i : Î¹), Ne.{1} ENNReal (w i) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Exists.{succ u1} (Î¹ -> NNReal) (fun (Î´ : Î¹ -> NNReal) => And (forall (i : Î¹), LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)) (Î´ i)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Î¹ (fun (i : Î¹) => HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (w i) (ENNReal.some (Î´ i)))) Îµ))))
Case conversion may be inaccurate. Consider using '#align ennreal.exists_pos_tsum_mul_lt_of_countable ENNReal.exists_pos_tsum_mul_lt_of_countableâ‚“'. -/
theorem exists_pos_tsum_mul_lt_of_countable {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) {Î¹} [Countable Î¹] (w : Î¹ â†’ â„â‰¥0âˆ)
    (hw : âˆ€ i, w i â‰  âˆ) : âˆƒ Î´ : Î¹ â†’ â„â‰¥0, (âˆ€ i, 0 < Î´ i) âˆ§ (âˆ‘' i, (w i * Î´ i : â„â‰¥0âˆ)) < Îµ :=
  by
  lift w to Î¹ â†’ â„â‰¥0 using hw
  rcases exists_pos_sum_of_countable hÎµ Î¹ with âŸ¨Î´', Hpos, HsumâŸ©
  have : âˆ€ i, 0 < max 1 (w i) := fun i => zero_lt_one.trans_le (le_max_left _ _)
  refine' âŸ¨fun i => Î´' i / max 1 (w i), fun i => div_pos (Hpos _) (this i), _âŸ©
  refine' lt_of_le_of_lt (ENNReal.tsum_le_tsum fun i => _) Hsum
  rw [coe_div (this i).ne']
  refine' mul_le_of_le_div' (mul_le_mul_left' (ENNReal.inv_le_inv.2 _) _)
  exact coe_le_coe.2 (le_max_right _ _)
#align ennreal.exists_pos_tsum_mul_lt_of_countable ENNReal.exists_pos_tsum_mul_lt_of_countable

end ENNReal

/-!
### Factorial
-/


#print factorial_tendsto_atTop /-
theorem factorial_tendsto_atTop : Tendsto Nat.factorial atTop atTop :=
  tendsto_atTop_atTop_of_monotone Nat.monotone_factorial fun n => âŸ¨n, n.self_le_factorialâŸ©
#align factorial_tendsto_at_top factorial_tendsto_atTop
-/

/- warning: tendsto_factorial_div_pow_self_at_top -> tendsto_factorial_div_pow_self_atTop is a dubious translation:
lean 3 declaration is
  Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCâ‚“.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Nat.factorial n)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCâ‚“.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Nat.cast.{0} Real Real.natCast (Nat.factorial n)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Nat.cast.{0} Real Real.natCast n) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align tendsto_factorial_div_pow_self_at_top tendsto_factorial_div_pow_self_atTopâ‚“'. -/
theorem tendsto_factorial_div_pow_self_atTop : Tendsto (fun n => n ! / n ^ n : â„• â†’ â„) atTop (ğ“ 0) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
    (tendsto_const_div_atTop_nhds_0_nat 1)
    (eventually_of_forall fun n =>
      div_nonneg (by exact_mod_cast n.factorial_pos.le)
        (pow_nonneg (by exact_mod_cast n.zero_le) _))
    (by
      refine' (eventually_gt_at_top 0).mono fun n hn => _
      rcases Nat.exists_eq_succ_of_ne_zero hn.ne.symm with âŸ¨k, rflâŸ©
      rw [â† prod_range_add_one_eq_factorial, pow_eq_prod_const, div_eq_mul_inv, â† inv_eq_one_div,
        prod_nat_cast, Nat.cast_succ, â† prod_inv_distrib, â† prod_mul_distrib,
        Finset.prod_range_succ']
      simp only [prod_range_succ', one_mul, Nat.cast_add, zero_add, Nat.cast_one]
      refine'
            mul_le_of_le_one_left (inv_nonneg.mpr <| by exact_mod_cast hn.le) (prod_le_one _ _) <;>
          intro x hx <;>
        rw [Finset.mem_range] at hx
      Â· refine' mul_nonneg _ (inv_nonneg.mpr _) <;> norm_cast <;> linarith
      Â· refine' (div_le_one <| by exact_mod_cast hn).mpr _; norm_cast; linarith)
#align tendsto_factorial_div_pow_self_at_top tendsto_factorial_div_pow_self_atTop

/-!
### Ceil and floor
-/


section

#print tendsto_nat_floor_atTop /-
theorem tendsto_nat_floor_atTop {Î± : Type _} [LinearOrderedSemiring Î±] [FloorSemiring Î±] :
    Tendsto (fun x : Î± => âŒŠxâŒ‹â‚Š) atTop atTop :=
  Nat.floor_mono.tendsto_atTop_atTop fun x => âŸ¨max 0 (x + 1), by simp [Nat.le_floor_iff]âŸ©
#align tendsto_nat_floor_at_top tendsto_nat_floor_atTop
-/

variable {R : Type _} [TopologicalSpace R] [LinearOrderedField R] [OrderTopology R] [FloorRing R]

/- warning: tendsto_nat_floor_mul_div_at_top -> tendsto_nat_floor_mul_div_atTop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))] {a : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))))))))) a) -> (Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (DivInvMonoid.toHasDiv.{u1} R (DivisionRing.toDivInvMonoid.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_2))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCâ‚“.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))))))) (Nat.floor.{u1} R (StrictOrderedSemiring.toOrderedSemiring.{u1} R (StrictOrderedRing.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) a x))) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) (nhds.{u1} R _inst_1 a))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommGroupWithZero.toCommMonoidWithZero.{u1} R (Semifield.toCommGroupWithZero.{u1} R (LinearOrderedSemifield.toSemifield.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2))))))) a) -> (Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (LinearOrderedField.toDiv.{u1} R _inst_2)) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2)))))) (Nat.floor.{u1} R (OrderedCommSemiring.toOrderedSemiring.{u1} R (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} R (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))))) a x))) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))) (nhds.{u1} R _inst_1 a))
Case conversion may be inaccurate. Consider using '#align tendsto_nat_floor_mul_div_at_top tendsto_nat_floor_mul_div_atTopâ‚“'. -/
theorem tendsto_nat_floor_mul_div_atTop {a : R} (ha : 0 â‰¤ a) :
    Tendsto (fun x => (âŒŠa * xâŒ‹â‚Š : R) / x) atTop (ğ“ a) :=
  by
  have A : tendsto (fun x : R => a - xâ»Â¹) at_top (ğ“ (a - 0)) :=
    tendsto_const_nhds.sub tendsto_inv_atTop_zero
  rw [sub_zero] at A
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' A tendsto_const_nhds
  Â· refine' eventually_at_top.2 âŸ¨1, fun x hx => _âŸ©
    simp only [le_div_iff (zero_lt_one.trans_le hx), sub_mul,
      inv_mul_cancel (zero_lt_one.trans_le hx).ne']
    have := Nat.lt_floor_add_one (a * x)
    linarith
  Â· refine' eventually_at_top.2 âŸ¨1, fun x hx => _âŸ©
    rw [div_le_iff (zero_lt_one.trans_le hx)]
    simp [Nat.floor_le (mul_nonneg ha (zero_le_one.trans hx))]
#align tendsto_nat_floor_mul_div_at_top tendsto_nat_floor_mul_div_atTop

/- warning: tendsto_nat_floor_div_at_top -> tendsto_nat_floor_div_atTop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))], Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (DivInvMonoid.toHasDiv.{u1} R (DivisionRing.toDivInvMonoid.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_2))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCâ‚“.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))))))) (Nat.floor.{u1} R (StrictOrderedSemiring.toOrderedSemiring.{u1} R (StrictOrderedRing.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) x)) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) (nhds.{u1} R _inst_1 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))], Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (LinearOrderedField.toDiv.{u1} R _inst_2)) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2)))))) (Nat.floor.{u1} R (OrderedCommSemiring.toOrderedSemiring.{u1} R (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} R (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) x)) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))) (nhds.{u1} R _inst_1 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_nat_floor_div_at_top tendsto_nat_floor_div_atTopâ‚“'. -/
theorem tendsto_nat_floor_div_atTop : Tendsto (fun x => (âŒŠxâŒ‹â‚Š : R) / x) atTop (ğ“ 1) := by
  simpa using tendsto_nat_floor_mul_div_atTop (zero_le_one' R)
#align tendsto_nat_floor_div_at_top tendsto_nat_floor_div_atTop

/- warning: tendsto_nat_ceil_mul_div_at_top -> tendsto_nat_ceil_mul_div_atTop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))] {a : R}, (LE.le.{u1} R (Preorder.toHasLe.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))))))))) a) -> (Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (DivInvMonoid.toHasDiv.{u1} R (DivisionRing.toDivInvMonoid.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_2))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCâ‚“.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))))))) (Nat.ceil.{u1} R (StrictOrderedSemiring.toOrderedSemiring.{u1} R (StrictOrderedRing.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) a x))) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) (nhds.{u1} R _inst_1 a))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommGroupWithZero.toCommMonoidWithZero.{u1} R (Semifield.toCommGroupWithZero.{u1} R (LinearOrderedSemifield.toSemifield.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2))))))) a) -> (Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (LinearOrderedField.toDiv.{u1} R _inst_2)) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2)))))) (Nat.ceil.{u1} R (OrderedCommSemiring.toOrderedSemiring.{u1} R (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} R (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))))) a x))) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))) (nhds.{u1} R _inst_1 a))
Case conversion may be inaccurate. Consider using '#align tendsto_nat_ceil_mul_div_at_top tendsto_nat_ceil_mul_div_atTopâ‚“'. -/
theorem tendsto_nat_ceil_mul_div_atTop {a : R} (ha : 0 â‰¤ a) :
    Tendsto (fun x => (âŒˆa * xâŒ‰â‚Š : R) / x) atTop (ğ“ a) :=
  by
  have A : tendsto (fun x : R => a + xâ»Â¹) at_top (ğ“ (a + 0)) :=
    tendsto_const_nhds.add tendsto_inv_atTop_zero
  rw [add_zero] at A
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds A
  Â· refine' eventually_at_top.2 âŸ¨1, fun x hx => _âŸ©
    rw [le_div_iff (zero_lt_one.trans_le hx)]
    exact Nat.le_ceil _
  Â· refine' eventually_at_top.2 âŸ¨1, fun x hx => _âŸ©
    simp [div_le_iff (zero_lt_one.trans_le hx), inv_mul_cancel (zero_lt_one.trans_le hx).ne',
      (Nat.ceil_lt_add_one (mul_nonneg ha (zero_le_one.trans hx))).le, add_mul]
#align tendsto_nat_ceil_mul_div_at_top tendsto_nat_ceil_mul_div_atTop

/- warning: tendsto_nat_ceil_div_at_top -> tendsto_nat_ceil_div_atTop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))], Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (DivInvMonoid.toHasDiv.{u1} R (DivisionRing.toDivInvMonoid.{u1} R (Field.toDivisionRing.{u1} R (LinearOrderedField.toField.{u1} R _inst_2))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCâ‚“.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))))))) (Nat.ceil.{u1} R (StrictOrderedSemiring.toOrderedSemiring.{u1} R (StrictOrderedRing.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) x)) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))) (nhds.{u1} R _inst_1 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} R] [_inst_2 : LinearOrderedField.{u1} R] [_inst_3 : OrderTopology.{u1} R _inst_1 (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))] [_inst_4 : FloorRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2))], Filter.Tendsto.{u1, u1} R R (fun (x : R) => HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (LinearOrderedField.toDiv.{u1} R _inst_2)) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2)))))) (Nat.ceil.{u1} R (OrderedCommSemiring.toOrderedSemiring.{u1} R (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} R (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2))))) (FloorRing.toFloorSemiring.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)) _inst_4) x)) x) (Filter.atTop.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R (LinearOrderedCommRing.toLinearOrderedRing.{u1} R (LinearOrderedField.toLinearOrderedCommRing.{u1} R _inst_2)))))) (nhds.{u1} R _inst_1 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} R (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} R (LinearOrderedField.toLinearOrderedSemifield.{u1} R _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align tendsto_nat_ceil_div_at_top tendsto_nat_ceil_div_atTopâ‚“'. -/
theorem tendsto_nat_ceil_div_atTop : Tendsto (fun x => (âŒˆxâŒ‰â‚Š : R) / x) atTop (ğ“ 1) := by
  simpa using tendsto_nat_ceil_mul_div_atTop (zero_le_one' R)
#align tendsto_nat_ceil_div_at_top tendsto_nat_ceil_div_atTop

end

