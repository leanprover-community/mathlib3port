/-
Copyright (c) 2020 Yury Kudriashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudriashov, YaÃ«l Dillies

! This file was ported from Lean 3 source module analysis.convex.hull
! leanprover-community/mathlib commit 31ca6f9cf5f90a6206092cd7f84b359dcb6d52e0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Basic
import Mathbin.Order.Closure

/-!
# Convex hull

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the convex hull of a set `s` in a module. `convex_hull ğ•œ s` is the smallest convex
set containing `s`. In order theory speak, this is a closure operator.

## Implementation notes

`convex_hull` is defined as a closure operator. This gives access to the `closure_operator` API
while the impact on writing code is minimal as `convex_hull ğ•œ s` is automatically elaborated as
`â‡‘(convex_hull ğ•œ) s`.
-/


open Set

open Pointwise

variable {ğ•œ E F : Type _}

section convexHull

section OrderedSemiring

variable [OrderedSemiring ğ•œ]

section AddCommMonoid

variable (ğ•œ) [AddCommMonoid E] [AddCommMonoid F] [Module ğ•œ E] [Module ğ•œ F]

/- warning: convex_hull -> convexHull is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2], ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2], ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E)))))))
Case conversion may be inaccurate. Consider using '#align convex_hull convexHullâ‚“'. -/
/-- The convex hull of a set `s` is the minimal convex set that includes `s`. -/
def convexHull : ClosureOperator (Set E) :=
  ClosureOperator.mkâ‚ƒ (fun s => â‹‚ (t : Set E) (hst : s âŠ† t) (ht : Convex ğ•œ t), t) (Convex ğ•œ)
    (fun s =>
      Set.subset_interáµ¢ fun t => Set.subset_interáµ¢ fun hst => Set.subset_interáµ¢ fun ht => hst)
    (fun s => convex_interáµ¢ fun t => convex_interáµ¢ fun ht => convex_interáµ¢ id) fun s t hst ht =>
    Set.interáµ¢_subset_of_subset t <| Set.interáµ¢_subset_of_subset hst <| Set.interáµ¢_subset _ ht
#align convex_hull convexHull

variable (s : Set E)

#print subset_convexHull /-
theorem subset_convexHull : s âŠ† convexHull ğ•œ s :=
  (convexHull ğ•œ).le_closure s
#align subset_convex_hull subset_convexHull
-/

/- warning: convex_convex_hull -> convex_convexHull is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (s : Set.{u2} E), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) s)
but is expected to have type
  forall (ğ•œ : Type.{u2}) {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] (s : Set.{u1} E), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (OrderHom.toFun.{u1, u1} (Set.{u1} E) (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (ClosureOperator.toOrderHom.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (convexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4)) s)
Case conversion may be inaccurate. Consider using '#align convex_convex_hull convex_convexHullâ‚“'. -/
theorem convex_convexHull : Convex ğ•œ (convexHull ğ•œ s) :=
  ClosureOperator.closure_mem_mkâ‚ƒ s
#align convex_convex_hull convex_convexHull

#print convexHull_eq_interáµ¢ /-
theorem convexHull_eq_interáµ¢ : convexHull ğ•œ s = â‹‚ (t : Set E) (hst : s âŠ† t) (ht : Convex ğ•œ t), t :=
  rfl
#align convex_hull_eq_Inter convexHull_eq_interáµ¢
-/

variable {ğ•œ s} {t : Set E} {x y : E}

#print mem_convexHull_iff /-
theorem mem_convexHull_iff : x âˆˆ convexHull ğ•œ s â†” âˆ€ t, s âŠ† t â†’ Convex ğ•œ t â†’ x âˆˆ t := by
  simp_rw [convexHull_eq_interáµ¢, mem_Inter]
#align mem_convex_hull_iff mem_convexHull_iff
-/

#print convexHull_min /-
theorem convexHull_min (hst : s âŠ† t) (ht : Convex ğ•œ t) : convexHull ğ•œ s âŠ† t :=
  ClosureOperator.closure_le_mkâ‚ƒ_iff (show s â‰¤ t from hst) ht
#align convex_hull_min convexHull_min
-/

/- warning: convex.convex_hull_subset_iff -> Convex.convexHull_subset_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E} {t : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) t) -> (Iff (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) s) t) (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) s t))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E} {t : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) t) -> (Iff (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (OrderHom.toFun.{u1, u1} (Set.{u1} E) (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (ClosureOperator.toOrderHom.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (convexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4)) s) t) (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) s t))
Case conversion may be inaccurate. Consider using '#align convex.convex_hull_subset_iff Convex.convexHull_subset_iffâ‚“'. -/
theorem Convex.convexHull_subset_iff (ht : Convex ğ•œ t) : convexHull ğ•œ s âŠ† t â†” s âŠ† t :=
  âŸ¨(subset_convexHull _ _).trans, fun h => convexHull_min h htâŸ©
#align convex.convex_hull_subset_iff Convex.convexHull_subset_iff

#print convexHull_mono /-
@[mono]
theorem convexHull_mono (hst : s âŠ† t) : convexHull ğ•œ s âŠ† convexHull ğ•œ t :=
  (convexHull ğ•œ).Monotone hst
#align convex_hull_mono convexHull_mono
-/

/- warning: convex.convex_hull_eq -> Convex.convexHull_eq is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (Eq.{succ u2} (Set.{u2} E) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) s) s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (Eq.{succ u1} (Set.{u1} E) (OrderHom.toFun.{u1, u1} (Set.{u1} E) (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (ClosureOperator.toOrderHom.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (convexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4)) s) s)
Case conversion may be inaccurate. Consider using '#align convex.convex_hull_eq Convex.convexHull_eqâ‚“'. -/
theorem Convex.convexHull_eq (hs : Convex ğ•œ s) : convexHull ğ•œ s = s :=
  ClosureOperator.mem_mkâ‚ƒ_closed hs
#align convex.convex_hull_eq Convex.convexHull_eq

#print convexHull_univ /-
@[simp]
theorem convexHull_univ : convexHull ğ•œ (univ : Set E) = univ :=
  ClosureOperator.closure_top (convexHull ğ•œ)
#align convex_hull_univ convexHull_univ
-/

#print convexHull_empty /-
@[simp]
theorem convexHull_empty : convexHull ğ•œ (âˆ… : Set E) = âˆ… :=
  convex_empty.convexHull_eq
#align convex_hull_empty convexHull_empty
-/

#print convexHull_empty_iff /-
@[simp]
theorem convexHull_empty_iff : convexHull ğ•œ s = âˆ… â†” s = âˆ… :=
  by
  constructor
  Â· intro h
    rw [â† Set.subset_empty_iff, â† h]
    exact subset_convexHull ğ•œ _
  Â· rintro rfl
    exact convexHull_empty
#align convex_hull_empty_iff convexHull_empty_iff
-/

#print convexHull_nonempty_iff /-
@[simp]
theorem convexHull_nonempty_iff : (convexHull ğ•œ s).Nonempty â†” s.Nonempty :=
  by
  rw [nonempty_iff_ne_empty, nonempty_iff_ne_empty, Ne.def, Ne.def]
  exact not_congr convexHull_empty_iff
#align convex_hull_nonempty_iff convexHull_nonempty_iff
-/

alias convexHull_nonempty_iff â†” _ Set.Nonempty.convexHull
#align set.nonempty.convex_hull Set.Nonempty.convexHull

attribute [protected] Set.Nonempty.convexHull

#print segment_subset_convexHull /-
theorem segment_subset_convexHull (hx : x âˆˆ s) (hy : y âˆˆ s) : segment ğ•œ x y âŠ† convexHull ğ•œ s :=
  (convex_convexHull _ _).segment_subset (subset_convexHull _ _ hx) (subset_convexHull _ _ hy)
#align segment_subset_convex_hull segment_subset_convexHull
-/

#print convexHull_singleton /-
@[simp]
theorem convexHull_singleton (x : E) : convexHull ğ•œ ({x} : Set E) = {x} :=
  (convex_singleton x).convexHull_eq
#align convex_hull_singleton convexHull_singleton
-/

#print convexHull_pair /-
@[simp]
theorem convexHull_pair (x y : E) : convexHull ğ•œ {x, y} = segment ğ•œ x y :=
  by
  refine'
    (convexHull_min _ <| convex_segment _ _).antisymm
      (segment_subset_convexHull (mem_insert _ _) <| mem_insert_of_mem _ <| mem_singleton _)
  rw [insert_subset, singleton_subset_iff]
  exact âŸ¨left_mem_segment _ _ _, right_mem_segment _ _ _âŸ©
#align convex_hull_pair convexHull_pair
-/

/- warning: convex_hull_convex_hull_union_left -> convexHull_convexHull_union_left is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (s : Set.{u2} E) (t : Set.{u2} E), Eq.{succ u2} (Set.{u2} E) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) (Union.union.{u2} (Set.{u2} E) (Set.hasUnion.{u2} E) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) s) t)) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) (Union.union.{u2} (Set.{u2} E) (Set.hasUnion.{u2} E) s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (s : Set.{u2} E) (t : Set.{u2} E), Eq.{succ u2} (Set.{u2} E) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) (Union.union.{u2} (Set.{u2} E) (Set.instUnionSet.{u2} E) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) s) t)) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) (Union.union.{u2} (Set.{u2} E) (Set.instUnionSet.{u2} E) s t))
Case conversion may be inaccurate. Consider using '#align convex_hull_convex_hull_union_left convexHull_convexHull_union_leftâ‚“'. -/
theorem convexHull_convexHull_union_left (s t : Set E) :
    convexHull ğ•œ (convexHull ğ•œ s âˆª t) = convexHull ğ•œ (s âˆª t) :=
  ClosureOperator.closure_sup_closure_left _ _ _
#align convex_hull_convex_hull_union_left convexHull_convexHull_union_left

/- warning: convex_hull_convex_hull_union_right -> convexHull_convexHull_union_right is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (s : Set.{u2} E) (t : Set.{u2} E), Eq.{succ u2} (Set.{u2} E) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) (Union.union.{u2} (Set.{u2} E) (Set.hasUnion.{u2} E) s (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) t))) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) (Union.union.{u2} (Set.{u2} E) (Set.hasUnion.{u2} E) s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (s : Set.{u2} E) (t : Set.{u2} E), Eq.{succ u2} (Set.{u2} E) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) (Union.union.{u2} (Set.{u2} E) (Set.instUnionSet.{u2} E) s (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) t))) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) (Union.union.{u2} (Set.{u2} E) (Set.instUnionSet.{u2} E) s t))
Case conversion may be inaccurate. Consider using '#align convex_hull_convex_hull_union_right convexHull_convexHull_union_rightâ‚“'. -/
theorem convexHull_convexHull_union_right (s t : Set E) :
    convexHull ğ•œ (s âˆª convexHull ğ•œ t) = convexHull ğ•œ (s âˆª t) :=
  ClosureOperator.closure_sup_closure_right _ _ _
#align convex_hull_convex_hull_union_right convexHull_convexHull_union_right

/- warning: convex.convex_remove_iff_not_mem_convex_hull_remove -> Convex.convex_remove_iff_not_mem_convexHull_remove is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (x : E), Iff (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SDiff.sdiff.{u2} (Set.{u2} E) (BooleanAlgebra.toHasSdiff.{u2} (Set.{u2} E) (Set.booleanAlgebra.{u2} E)) s (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x))) (Not (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) (SDiff.sdiff.{u2} (Set.{u2} E) (BooleanAlgebra.toHasSdiff.{u2} (Set.{u2} E) (Set.booleanAlgebra.{u2} E)) s (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (x : E), Iff (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SDiff.sdiff.{u2} (Set.{u2} E) (Set.instSDiffSet.{u2} E) s (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.instSingletonSet.{u2} E) x))) (Not (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) (SDiff.sdiff.{u2} (Set.{u2} E) (Set.instSDiffSet.{u2} E) s (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.instSingletonSet.{u2} E) x))))))
Case conversion may be inaccurate. Consider using '#align convex.convex_remove_iff_not_mem_convex_hull_remove Convex.convex_remove_iff_not_mem_convexHull_removeâ‚“'. -/
theorem Convex.convex_remove_iff_not_mem_convexHull_remove {s : Set E} (hs : Convex ğ•œ s) (x : E) :
    Convex ğ•œ (s \ {x}) â†” x âˆ‰ convexHull ğ•œ (s \ {x}) :=
  by
  constructor
  Â· rintro hsx hx
    rw [hsx.convex_hull_eq] at hx
    exact hx.2 (mem_singleton _)
  rintro hx
  suffices h : s \ {x} = convexHull ğ•œ (s \ {x}); Â· convert convex_convexHull ğ•œ _
  exact
    subset.antisymm (subset_convexHull ğ•œ _) fun y hy =>
      âŸ¨convexHull_min (diff_subset _ _) hs hy,
        by
        rintro (rfl : y = x)
        exact hx hyâŸ©
#align convex.convex_remove_iff_not_mem_convex_hull_remove Convex.convex_remove_iff_not_mem_convexHull_remove

/- warning: is_linear_map.convex_hull_image -> IsLinearMap.convexHull_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {f : E -> F}, (IsLinearMap.{u1, u2, u3} ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (forall (s : Set.{u2} E), Eq.{succ u3} (Set.{u3} F) (coeFn.{succ u3, succ u3} (ClosureOperator.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) (fun (_x : ClosureOperator.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) => (Set.{u3} F) -> (Set.{u3} F)) (ClosureOperator.hasCoeToFun.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) (convexHull.{u1, u3} ğ•œ F _inst_1 _inst_3 _inst_5) (Set.image.{u2, u3} E F f s)) (Set.image.{u2, u3} E F f (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) s)))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3] {f : E -> F}, (IsLinearMap.{u3, u2, u1} ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (forall (s : Set.{u2} E), Eq.{succ u1} (Set.{u1} F) (OrderHom.toFun.{u1, u1} (Set.{u1} F) (Set.{u1} F) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (ClosureOperator.toOrderHom.{u1} (Set.{u1} F) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (convexHull.{u3, u1} ğ•œ F _inst_1 _inst_3 _inst_5)) (Set.image.{u2, u1} E F f s)) (Set.image.{u2, u1} E F f (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u3, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) s)))
Case conversion may be inaccurate. Consider using '#align is_linear_map.convex_hull_image IsLinearMap.convexHull_imageâ‚“'. -/
theorem IsLinearMap.convexHull_image {f : E â†’ F} (hf : IsLinearMap ğ•œ f) (s : Set E) :
    convexHull ğ•œ (f '' s) = f '' convexHull ğ•œ s :=
  Set.Subset.antisymm
    (convexHull_min (image_subset _ (subset_convexHull ğ•œ s)) <|
      (convex_convexHull ğ•œ s).is_linear_image hf)
    (image_subset_iff.2 <|
      convexHull_min (image_subset_iff.1 <| subset_convexHull ğ•œ _)
        ((convex_convexHull ğ•œ _).is_linear_preimage hf))
#align is_linear_map.convex_hull_image IsLinearMap.convexHull_image

/- warning: linear_map.convex_hull_image -> LinearMap.convexHull_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (f : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (s : Set.{u2} E), Eq.{succ u3} (Set.{u3} F) (coeFn.{succ u3, succ u3} (ClosureOperator.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) (fun (_x : ClosureOperator.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) => (Set.{u3} F) -> (Set.{u3} F)) (ClosureOperator.hasCoeToFun.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) (convexHull.{u1, u3} ğ•œ F _inst_1 _inst_3 _inst_5) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f) s)) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3] (f : LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (s : Set.{u2} E), Eq.{succ u1} (Set.{u1} F) (OrderHom.toFun.{u1, u1} (Set.{u1} F) (Set.{u1} F) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (ClosureOperator.toOrderHom.{u1} (Set.{u1} F) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (convexHull.{u3, u1} ğ•œ F _inst_1 _inst_3 _inst_5)) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)))) f) s)) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)))) f) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u3, u2} ğ•œ E _inst_1 _inst_2 _inst_4)) s))
Case conversion may be inaccurate. Consider using '#align linear_map.convex_hull_image LinearMap.convexHull_imageâ‚“'. -/
theorem LinearMap.convexHull_image (f : E â†’â‚—[ğ•œ] F) (s : Set E) :
    convexHull ğ•œ (f '' s) = f '' convexHull ğ•œ s :=
  f.isLinear.convexHull_image s
#align linear_map.convex_hull_image LinearMap.convexHull_image

end AddCommMonoid

end OrderedSemiring

section OrderedCommSemiring

variable [OrderedCommSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E]

#print convexHull_smul /-
theorem convexHull_smul (a : ğ•œ) (s : Set E) : convexHull ğ•œ (a â€¢ s) = a â€¢ convexHull ğ•œ s :=
  (LinearMap.lsmul _ _ a).convexHull_image _
#align convex_hull_smul convexHull_smul
-/

end OrderedCommSemiring

section OrderedRing

variable [OrderedRing ğ•œ]

section AddCommGroup

variable [AddCommGroup E] [AddCommGroup F] [Module ğ•œ E] [Module ğ•œ F] (s : Set E)

/- warning: affine_map.image_convex_hull -> AffineMap.image_convexHull is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] (s : Set.{u2} E) (f : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))), Eq.{succ u3} (Set.{u3} F) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4) s)) (coeFn.{succ u3, succ u3} (ClosureOperator.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) (fun (_x : ClosureOperator.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) => (Set.{u3} F) -> (Set.{u3} F)) (ClosureOperator.hasCoeToFun.{u3} (Set.{u3} F) (PartialOrder.toPreorder.{u3} (Set.{u3} F) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} F) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} F) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} F) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} F) (Set.completeBooleanAlgebra.{u3} F)))))))) (convexHull.{u1, u3} ğ•œ F (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_5) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedRing.{u3} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] (s : Set.{u2} E) (f : AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))), Eq.{succ u1} (Set.{u1} F) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u3, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)) s)) (OrderHom.toFun.{u1, u1} (Set.{u1} F) (Set.{u1} F) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (ClosureOperator.toOrderHom.{u1} (Set.{u1} F) (PartialOrder.toPreorder.{u1} (Set.{u1} F) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} F) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} F) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} F) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} F) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} F) (Set.instCompleteBooleanAlgebraSet.{u1} F))))))) (convexHull.{u3, u1} ğ•œ F (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3) _inst_5)) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) s))
Case conversion may be inaccurate. Consider using '#align affine_map.image_convex_hull AffineMap.image_convexHullâ‚“'. -/
theorem AffineMap.image_convexHull (f : E â†’áµƒ[ğ•œ] F) : f '' convexHull ğ•œ s = convexHull ğ•œ (f '' s) :=
  by
  apply Set.Subset.antisymm
  Â· rw [Set.image_subset_iff]
    refine' convexHull_min _ ((convex_convexHull ğ•œ (â‡‘f '' s)).affine_preimage f)
    rw [â† Set.image_subset_iff]
    exact subset_convexHull ğ•œ (f '' s)
  Â·
    exact
      convexHull_min (Set.image_subset _ (subset_convexHull ğ•œ s))
        ((convex_convexHull ğ•œ s).affine_image f)
#align affine_map.image_convex_hull AffineMap.image_convexHull

#print convexHull_subset_affineSpan /-
theorem convexHull_subset_affineSpan : convexHull ğ•œ s âŠ† (affineSpan ğ•œ s : Set E) :=
  convexHull_min (subset_affineSpan ğ•œ s) (affineSpan ğ•œ s).Convex
#align convex_hull_subset_affine_span convexHull_subset_affineSpan
-/

#print affineSpan_convexHull /-
@[simp]
theorem affineSpan_convexHull : affineSpan ğ•œ (convexHull ğ•œ s) = affineSpan ğ•œ s :=
  by
  refine' le_antisymm _ (affineSpan_mono ğ•œ (subset_convexHull ğ•œ s))
  rw [affineSpan_le]
  exact convexHull_subset_affineSpan s
#align affine_span_convex_hull affineSpan_convexHull
-/

/- warning: convex_hull_neg -> convexHull_neg is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (s : Set.{u2} E), Eq.{succ u2} (Set.{u2} E) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4) (Neg.neg.{u2} (Set.{u2} E) (Set.neg.{u2} E (SubNegMonoid.toHasNeg.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) s)) (Neg.neg.{u2} (Set.{u2} E) (Set.neg.{u2} E (SubNegMonoid.toHasNeg.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (s : Set.{u2} E), Eq.{succ u2} (Set.{u2} E) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)) (Neg.neg.{u2} (Set.{u2} E) (Set.neg.{u2} E (NegZeroClass.toNeg.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))) s)) (Neg.neg.{u2} (Set.{u2} E) (Set.neg.{u2} E (NegZeroClass.toNeg.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)) s))
Case conversion may be inaccurate. Consider using '#align convex_hull_neg convexHull_negâ‚“'. -/
theorem convexHull_neg (s : Set E) : convexHull ğ•œ (-s) = -convexHull ğ•œ s :=
  by
  simp_rw [â† image_neg]
  exact (AffineMap.image_convexHull _ <| -1).symm
#align convex_hull_neg convexHull_neg

end AddCommGroup

end OrderedRing

end convexHull

