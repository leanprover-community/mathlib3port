/-
Copyright (c) 2021 YaÃ«l Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: YaÃ«l Dillies

! This file was ported from Lean 3 source module analysis.convex.star
! leanprover-community/mathlib commit cb3ceec8485239a61ed51d944cb9a95b68c6bafc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Segment

/-!
# Star-convex sets

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This files defines star-convex sets (aka star domains, star-shaped set, radially convex set).

A set is star-convex at `x` if every segment from `x` to a point in the set is contained in the set.

This is the prototypical example of a contractible set in homotopy theory (by scaling every point
towards `x`), but has wider uses.

Note that this has nothing to do with star rings, `has_star` and co.

## Main declarations

* `star_convex ğ•œ x s`: `s` is star-convex at `x` with scalars `ğ•œ`.

## Implementation notes

Instead of saying that a set is star-convex, we say a set is star-convex *at a point*. This has the
advantage of allowing us to talk about convexity as being "everywhere star-convexity" and of making
the union of star-convex sets be star-convex.

Incidentally, this choice means we don't need to assume a set is nonempty for it to be star-convex.
Concretely, the empty set is star-convex at every point.

## TODO

Balanced sets are star-convex.

The closure of a star-convex set is star-convex.

Star-convex sets are contractible.

A nonempty open star-convex set in `â„^n` is diffeomorphic to the entire space.
-/


open Set

open Convex Pointwise

variable {ğ•œ E F : Type _}

section OrderedSemiring

variable [OrderedSemiring ğ•œ]

section AddCommMonoid

variable [AddCommMonoid E] [AddCommMonoid F]

section SMul

variable (ğ•œ) [SMul ğ•œ E] [SMul ğ•œ F] (x : E) (s : Set E)

#print StarConvex /-
/-- Star-convexity of sets. `s` is star-convex at `x` if every segment from `x` to a point in `s` is
contained in `s`. -/
def StarConvex : Prop :=
  âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s
#align star_convex StarConvex
-/

variable {ğ•œ x s} {t : Set E}

/- warning: star_convex_iff_segment_subset -> starConvex_iff_segment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {x : E} {s : Set.{u2} E}, Iff (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s) (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {x : E} {s : Set.{u1} E}, Iff (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x s) (forall {{y : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (segment.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
Case conversion may be inaccurate. Consider using '#align star_convex_iff_segment_subset starConvex_iff_segment_subsetâ‚“'. -/
theorem starConvex_iff_segment_subset : StarConvex ğ•œ x s â†” âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ [x -[ğ•œ] y] âŠ† s :=
  by
  constructor
  Â· rintro h y hy z âŸ¨a, b, ha, hb, hab, rflâŸ©
    exact h hy ha hb hab
  Â· rintro h y hy a b ha hb hab
    exact h hy âŸ¨a, b, ha, hb, hab, rflâŸ©
#align star_convex_iff_segment_subset starConvex_iff_segment_subset

/- warning: star_convex.segment_subset -> StarConvex.segment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (forall {y : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (forall {y : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (segment.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
Case conversion may be inaccurate. Consider using '#align star_convex.segment_subset StarConvex.segment_subsetâ‚“'. -/
theorem StarConvex.segment_subset (h : StarConvex ğ•œ x s) {y : E} (hy : y âˆˆ s) : [x -[ğ•œ] y] âŠ† s :=
  starConvex_iff_segment_subset.1 h hy
#align star_convex.segment_subset StarConvex.segment_subset

/- warning: star_convex.open_segment_subset -> StarConvex.openSegment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (forall {y : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (forall {y : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (openSegment.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
Case conversion may be inaccurate. Consider using '#align star_convex.open_segment_subset StarConvex.openSegment_subsetâ‚“'. -/
theorem StarConvex.openSegment_subset (h : StarConvex ğ•œ x s) {y : E} (hy : y âˆˆ s) :
    openSegment ğ•œ x y âŠ† s :=
  (openSegment_subset_segment ğ•œ x y).trans (h.segment_subset hy)
#align star_convex.open_segment_subset StarConvex.openSegment_subset

/- warning: star_convex_iff_pointwise_add_subset -> starConvex_iff_pointwise_add_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {x : E} {s : Set.{u2} E}, Iff (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s) (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_4) a (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x)) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_4) b s)) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {x : E} {s : Set.{u1} E}, Iff (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x s) (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) b) -> (Eq.{succ u2} ğ•œ (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E _inst_4)) a (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x)) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E _inst_4)) b s)) s))
Case conversion may be inaccurate. Consider using '#align star_convex_iff_pointwise_add_subset starConvex_iff_pointwise_add_subsetâ‚“'. -/
/-- Alternative definition of star-convexity, in terms of pointwise set operations. -/
theorem starConvex_iff_pointwise_add_subset :
    StarConvex ğ•œ x s â†” âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ {x} + b â€¢ s âŠ† s :=
  by
  refine'
    âŸ¨_, fun h y hy a b ha hb hab =>
      h ha hb hab (add_mem_add (smul_mem_smul_set <| mem_singleton _) âŸ¨_, hy, rflâŸ©)âŸ©
  rintro hA a b ha hb hab w âŸ¨au, bv, âŸ¨u, rfl : u = x, rflâŸ©, âŸ¨v, hv, rflâŸ©, rflâŸ©
  exact hA hv ha hb hab
#align star_convex_iff_pointwise_add_subset starConvex_iff_pointwise_add_subset

/- warning: star_convex_empty -> starConvex_empty is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] (x : E), StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x (EmptyCollection.emptyCollection.{u2} (Set.{u2} E) (Set.hasEmptyc.{u2} E))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] (x : E), StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x (EmptyCollection.emptyCollection.{u1} (Set.{u1} E) (Set.instEmptyCollectionSet.{u1} E))
Case conversion may be inaccurate. Consider using '#align star_convex_empty starConvex_emptyâ‚“'. -/
theorem starConvex_empty (x : E) : StarConvex ğ•œ x âˆ… := fun y hy => hy.elim
#align star_convex_empty starConvex_empty

/- warning: star_convex_univ -> starConvex_univ is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] (x : E), StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x (Set.univ.{u2} E)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] (x : E), StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x (Set.univ.{u1} E)
Case conversion may be inaccurate. Consider using '#align star_convex_univ starConvex_univâ‚“'. -/
theorem starConvex_univ (x : E) : StarConvex ğ•œ x univ := fun _ _ _ _ _ _ _ => trivial
#align star_convex_univ starConvex_univ

/- warning: star_convex.inter -> StarConvex.inter is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {x : E} {s : Set.{u2} E} {t : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x t) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) s t))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {x : E} {s : Set.{u1} E} {t : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x t) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x (Inter.inter.{u1} (Set.{u1} E) (Set.instInterSet.{u1} E) s t))
Case conversion may be inaccurate. Consider using '#align star_convex.inter StarConvex.interâ‚“'. -/
theorem StarConvex.inter (hs : StarConvex ğ•œ x s) (ht : StarConvex ğ•œ x t) : StarConvex ğ•œ x (s âˆ© t) :=
  fun y hy a b ha hb hab => âŸ¨hs hy.left ha hb hab, ht hy.right ha hb habâŸ©
#align star_convex.inter StarConvex.inter

#print starConvex_interâ‚› /-
theorem starConvex_interâ‚› {S : Set (Set E)} (h : âˆ€ s âˆˆ S, StarConvex ğ•œ x s) :
    StarConvex ğ•œ x (â‹‚â‚€ S) := fun y hy a b ha hb hab s hs => h s hs (hy s hs) ha hb hab
#align star_convex_sInter starConvex_interâ‚›
-/

#print starConvex_interáµ¢ /-
theorem starConvex_interáµ¢ {Î¹ : Sort _} {s : Î¹ â†’ Set E} (h : âˆ€ i, StarConvex ğ•œ x (s i)) :
    StarConvex ğ•œ x (â‹‚ i, s i) :=
  interâ‚›_range s â–¸ starConvex_interâ‚› <| forall_range_iff.2 h
#align star_convex_Inter starConvex_interáµ¢
-/

/- warning: star_convex.union -> StarConvex.union is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {x : E} {s : Set.{u2} E} {t : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x t) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x (Union.union.{u2} (Set.{u2} E) (Set.hasUnion.{u2} E) s t))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {x : E} {s : Set.{u1} E} {t : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x t) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x (Union.union.{u1} (Set.{u1} E) (Set.instUnionSet.{u1} E) s t))
Case conversion may be inaccurate. Consider using '#align star_convex.union StarConvex.unionâ‚“'. -/
theorem StarConvex.union (hs : StarConvex ğ•œ x s) (ht : StarConvex ğ•œ x t) : StarConvex ğ•œ x (s âˆª t) :=
  by
  rintro y (hy | hy) a b ha hb hab
  Â· exact Or.inl (hs hy ha hb hab)
  Â· exact Or.inr (ht hy ha hb hab)
#align star_convex.union StarConvex.union

#print starConvex_unionáµ¢ /-
theorem starConvex_unionáµ¢ {Î¹ : Sort _} {s : Î¹ â†’ Set E} (hs : âˆ€ i, StarConvex ğ•œ x (s i)) :
    StarConvex ğ•œ x (â‹ƒ i, s i) := by
  rintro y hy a b ha hb hab
  rw [mem_Union] at hyâŠ¢
  obtain âŸ¨i, hyâŸ© := hy
  exact âŸ¨i, hs i hy ha hb habâŸ©
#align star_convex_Union starConvex_unionáµ¢
-/

#print starConvex_unionâ‚› /-
theorem starConvex_unionâ‚› {S : Set (Set E)} (hS : âˆ€ s âˆˆ S, StarConvex ğ•œ x s) :
    StarConvex ğ•œ x (â‹ƒâ‚€ S) := by
  rw [sUnion_eq_Union]
  exact starConvex_unionáµ¢ fun s => hS _ s.2
#align star_convex_sUnion starConvex_unionâ‚›
-/

/- warning: star_convex.prod -> StarConvex.prod is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : SMul.{u1, u2} ğ•œ E] [_inst_5 : SMul.{u1, u3} ğ•œ F] {x : E} {y : F} {s : Set.{u2} E} {t : Set.{u3} F}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (StarConvex.{u1, u3} ğ•œ F _inst_1 _inst_3 _inst_5 y t) -> (StarConvex.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F _inst_4 _inst_5) (Prod.mk.{u2, u3} E F x y) (Set.prod.{u2, u3} E F s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : SMul.{u1, u3} ğ•œ E] [_inst_5 : SMul.{u1, u2} ğ•œ F] {x : E} {y : F} {s : Set.{u3} E} {t : Set.{u2} F}, (StarConvex.{u1, u3} ğ•œ E _inst_1 _inst_2 _inst_4 x s) -> (StarConvex.{u1, u2} ğ•œ F _inst_1 _inst_3 _inst_5 y t) -> (StarConvex.{u1, max u2 u3} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F _inst_4 _inst_5) (Prod.mk.{u3, u2} E F x y) (Set.prod.{u3, u2} E F s t))
Case conversion may be inaccurate. Consider using '#align star_convex.prod StarConvex.prodâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem StarConvex.prod {y : F} {s : Set E} {t : Set F} (hs : StarConvex ğ•œ x s)
    (ht : StarConvex ğ•œ y t) : StarConvex ğ•œ (x, y) (s Ã—Ë¢ t) := fun y hy a b ha hb hab =>
  âŸ¨hs hy.1 ha hb hab, ht hy.2 ha hb habâŸ©
#align star_convex.prod StarConvex.prod

/- warning: star_convex_pi -> starConvex_pi is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] {Î¹ : Type.{u2}} {E : Î¹ -> Type.{u3}} [_inst_6 : forall (i : Î¹), AddCommMonoid.{u3} (E i)] [_inst_7 : forall (i : Î¹), SMul.{u1, u3} ğ•œ (E i)] {x : forall (i : Î¹), E i} {s : Set.{u2} Î¹} {t : forall (i : Î¹), Set.{u3} (E i)}, (forall {{i : Î¹}}, (Membership.Mem.{u2, u2} Î¹ (Set.{u2} Î¹) (Set.hasMem.{u2} Î¹) i s) -> (StarConvex.{u1, u3} ğ•œ (E i) _inst_1 (_inst_6 i) (_inst_7 i) (x i) (t i))) -> (StarConvex.{u1, max u2 u3} ğ•œ (forall (i : Î¹), E i) _inst_1 (Pi.addCommMonoid.{u2, u3} Î¹ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_6 i)) (Pi.instSMul.{u2, u3, u1} Î¹ ğ•œ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_7 i)) x (Set.pi.{u2, u3} Î¹ (fun (i : Î¹) => E i) s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] {Î¹ : Type.{u3}} {E : Î¹ -> Type.{u2}} [_inst_6 : forall (i : Î¹), AddCommMonoid.{u2} (E i)] [_inst_7 : forall (i : Î¹), SMul.{u1, u2} ğ•œ (E i)] {x : forall (i : Î¹), E i} {s : Set.{u3} Î¹} {t : forall (i : Î¹), Set.{u2} (E i)}, (forall {{i : Î¹}}, (Membership.mem.{u3, u3} Î¹ (Set.{u3} Î¹) (Set.instMembershipSet.{u3} Î¹) i s) -> (StarConvex.{u1, u2} ğ•œ (E i) _inst_1 (_inst_6 i) (_inst_7 i) (x i) (t i))) -> (StarConvex.{u1, max u3 u2} ğ•œ (forall (i : Î¹), E i) _inst_1 (Pi.addCommMonoid.{u3, u2} Î¹ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_6 i)) (Pi.instSMul.{u3, u2, u1} Î¹ ğ•œ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_7 i)) x (Set.pi.{u3, u2} Î¹ (fun (i : Î¹) => E i) s t))
Case conversion may be inaccurate. Consider using '#align star_convex_pi starConvex_piâ‚“'. -/
theorem starConvex_pi {Î¹ : Type _} {E : Î¹ â†’ Type _} [âˆ€ i, AddCommMonoid (E i)] [âˆ€ i, SMul ğ•œ (E i)]
    {x : âˆ€ i, E i} {s : Set Î¹} {t : âˆ€ i, Set (E i)} (ht : âˆ€ â¦ƒiâ¦„, i âˆˆ s â†’ StarConvex ğ•œ (x i) (t i)) :
    StarConvex ğ•œ x (s.pi t) := fun y hy a b ha hb hab i hi => ht hi (hy i hi) ha hb hab
#align star_convex_pi starConvex_pi

end SMul

section Module

variable [Module ğ•œ E] [Module ğ•œ F] {x y z : E} {s : Set E}

/- warning: star_convex.mem -> StarConvex.mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (Set.Nonempty.{u2} E s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (Set.Nonempty.{u1} E s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s)
Case conversion may be inaccurate. Consider using '#align star_convex.mem StarConvex.memâ‚“'. -/
theorem StarConvex.mem (hs : StarConvex ğ•œ x s) (h : s.Nonempty) : x âˆˆ s :=
  by
  obtain âŸ¨y, hyâŸ© := h
  convert hs hy zero_le_one le_rfl (add_zero 1)
  rw [one_smul, zero_smul, add_zero]
#align star_convex.mem StarConvex.mem

/- warning: star_convex_iff_forall_pos -> starConvex_iff_forall_pos is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u2} E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (Iff (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) a x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) b y)) s))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u2} E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x s) -> (Iff (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) (forall {{y : E}}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4))))) a x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4))))) b y)) s))))
Case conversion may be inaccurate. Consider using '#align star_convex_iff_forall_pos starConvex_iff_forall_posâ‚“'. -/
theorem starConvex_iff_forall_pos (hx : x âˆˆ s) :
    StarConvex ğ•œ x s â†” âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=
  by
  refine' âŸ¨fun h y hy a b ha hb hab => h hy ha.le hb.le hab, _âŸ©
  intro h y hy a b ha hb hab
  obtain rfl | ha := ha.eq_or_lt
  Â· rw [zero_add] at hab
    rwa [hab, one_smul, zero_smul, zero_add]
  obtain rfl | hb := hb.eq_or_lt
  Â· rw [add_zero] at hab
    rwa [hab, one_smul, zero_smul, add_zero]
  exact h hy ha hb hab
#align star_convex_iff_forall_pos starConvex_iff_forall_pos

/- warning: star_convex_iff_forall_ne_pos -> starConvex_iff_forall_ne_pos is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u2} E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (Iff (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (Ne.{succ u2} E x y) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) a x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) b y)) s))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u2} E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x s) -> (Iff (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) (forall {{y : E}}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) y s) -> (Ne.{succ u2} E x y) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4))))) a x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4))))) b y)) s))))
Case conversion may be inaccurate. Consider using '#align star_convex_iff_forall_ne_pos starConvex_iff_forall_ne_posâ‚“'. -/
theorem starConvex_iff_forall_ne_pos (hx : x âˆˆ s) :
    StarConvex ğ•œ x s â†”
      âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ x â‰  y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=
  by
  refine' âŸ¨fun h y hy _ a b ha hb hab => h hy ha.le hb.le hab, _âŸ©
  intro h y hy a b ha hb hab
  obtain rfl | ha' := ha.eq_or_lt
  Â· rw [zero_add] at hab
    rwa [hab, zero_smul, one_smul, zero_add]
  obtain rfl | hb' := hb.eq_or_lt
  Â· rw [add_zero] at hab
    rwa [hab, zero_smul, one_smul, add_zero]
  obtain rfl | hxy := eq_or_ne x y
  Â· rwa [Convex.combo_self hab]
  exact h hy hxy ha' hb' hab
#align star_convex_iff_forall_ne_pos starConvex_iff_forall_ne_pos

#print starConvex_iff_openSegment_subset /-
theorem starConvex_iff_openSegment_subset (hx : x âˆˆ s) :
    StarConvex ğ•œ x s â†” âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ openSegment ğ•œ x y âŠ† s :=
  starConvex_iff_segment_subset.trans <|
    forallâ‚‚_congr fun y hy => (openSegment_subset_iff_segment_subset hx hy).symm
#align star_convex_iff_open_segment_subset starConvex_iff_openSegment_subset
-/

/- warning: star_convex_singleton -> starConvex_singleton is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (x : E), StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] (x : E), StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x)
Case conversion may be inaccurate. Consider using '#align star_convex_singleton starConvex_singletonâ‚“'. -/
theorem starConvex_singleton (x : E) : StarConvex ğ•œ x {x} :=
  by
  rintro y (rfl : y = x) a b ha hb hab
  exact Convex.combo_self hab _
#align star_convex_singleton starConvex_singleton

/- warning: star_convex.linear_image -> StarConvex.linear_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall (f : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), StarConvex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f x) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u2} E}, (StarConvex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall (f : LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), StarConvex.{u3, u1} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_1 _inst_3 (SMulZeroClass.toSMul.{u3, u1} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_3)) (Module.toMulActionWithZero.{u3, u1} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3 _inst_5)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)))) f x) (Set.image.{u2, u1} E ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)))) f) s))
Case conversion may be inaccurate. Consider using '#align star_convex.linear_image StarConvex.linear_imageâ‚“'. -/
theorem StarConvex.linear_image (hs : StarConvex ğ•œ x s) (f : E â†’â‚—[ğ•œ] F) :
    StarConvex ğ•œ (f x) (s.image f) :=
  by
  intro y hy a b ha hb hab
  obtain âŸ¨y', hy', rflâŸ© := hy
  exact âŸ¨a â€¢ x + b â€¢ y', hs hy' ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]âŸ©
#align star_convex.linear_image StarConvex.linear_image

/- warning: star_convex.is_linear_image -> StarConvex.is_linear_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall {f : E -> F}, (IsLinearMap.{u1, u2, u3} ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (StarConvex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (f x) (Set.image.{u2, u3} E F f s)))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u2} E}, (StarConvex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall {f : E -> F}, (IsLinearMap.{u3, u2, u1} ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (StarConvex.{u3, u1} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u3, u1} ğ•œ F (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ F (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ F (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (Module.toMulActionWithZero.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3 _inst_5)))) (f x) (Set.image.{u2, u1} E F f s)))
Case conversion may be inaccurate. Consider using '#align star_convex.is_linear_image StarConvex.is_linear_imageâ‚“'. -/
theorem StarConvex.is_linear_image (hs : StarConvex ğ•œ x s) {f : E â†’ F} (hf : IsLinearMap ğ•œ f) :
    StarConvex ğ•œ (f x) (f '' s) :=
  hs.linear_image <| hf.mk' f
#align star_convex.is_linear_image StarConvex.is_linear_image

/- warning: star_convex.linear_preimage -> StarConvex.linear_preimage is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u3} F} (f : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), (StarConvex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f x) s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u3} F} (f : LinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), (StarConvex.{u2, u3} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_1 _inst_3 (SMulZeroClass.toSMul.{u2, u3} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) _inst_3)) (Module.toMulActionWithZero.{u2, u3} ğ•œ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) x) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3 _inst_5)))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))) f x) s) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u1, u3} E F (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))) f) s))
Case conversion may be inaccurate. Consider using '#align star_convex.linear_preimage StarConvex.linear_preimageâ‚“'. -/
theorem StarConvex.linear_preimage {s : Set F} (f : E â†’â‚—[ğ•œ] F) (hs : StarConvex ğ•œ (f x) s) :
    StarConvex ğ•œ x (s.Preimage f) := by
  intro y hy a b ha hb hab
  rw [mem_preimage, f.map_add, f.map_smul, f.map_smul]
  exact hs hy ha hb hab
#align star_convex.linear_preimage StarConvex.linear_preimage

/- warning: star_convex.is_linear_preimage -> StarConvex.is_linear_preimage is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u3} F} {f : E -> F}, (StarConvex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (f x) s) -> (IsLinearMap.{u1, u2, u3} ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u2, u3} E F f s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3] {x : E} {s : Set.{u3} F} {f : E -> F}, (StarConvex.{u2, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u2, u3} ğ•œ F (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} ğ•œ F (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} ğ•œ F (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (Module.toMulActionWithZero.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3 _inst_5)))) (f x) s) -> (IsLinearMap.{u2, u1, u3} ğ•œ E F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u1, u3} E F f s))
Case conversion may be inaccurate. Consider using '#align star_convex.is_linear_preimage StarConvex.is_linear_preimageâ‚“'. -/
theorem StarConvex.is_linear_preimage {s : Set F} {f : E â†’ F} (hs : StarConvex ğ•œ (f x) s)
    (hf : IsLinearMap ğ•œ f) : StarConvex ğ•œ x (preimage f s) :=
  hs.linear_preimage <| hf.mk' f
#align star_convex.is_linear_preimage StarConvex.is_linear_preimage

/- warning: star_convex.add -> StarConvex.add is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {y : E} {s : Set.{u2} E} {t : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) y t) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) x y) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {y : E} {s : Set.{u2} E} {t : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) y t) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) x y) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) s t))
Case conversion may be inaccurate. Consider using '#align star_convex.add StarConvex.addâ‚“'. -/
theorem StarConvex.add {t : Set E} (hs : StarConvex ğ•œ x s) (ht : StarConvex ğ•œ y t) :
    StarConvex ğ•œ (x + y) (s + t) := by
  rw [â† add_image_prod]
  exact (hs.prod ht).is_linear_image IsLinearMap.isLinearMap_add
#align star_convex.add StarConvex.add

/- warning: star_convex.add_left -> StarConvex.add_left is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall (z : E), StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z x) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z x) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall (z : E), StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z x) (Set.image.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z x) s))
Case conversion may be inaccurate. Consider using '#align star_convex.add_left StarConvex.add_leftâ‚“'. -/
theorem StarConvex.add_left (hs : StarConvex ğ•œ x s) (z : E) :
    StarConvex ğ•œ (z + x) ((fun x => z + x) '' s) :=
  by
  intro y hy a b ha hb hab
  obtain âŸ¨y', hy', rflâŸ© := hy
  refine' âŸ¨a â€¢ x + b â€¢ y', hs hy' ha hb hab, _âŸ©
  rw [smul_add, smul_add, add_add_add_comm, â† add_smul, hab, one_smul]
#align star_convex.add_left StarConvex.add_left

/- warning: star_convex.add_right -> StarConvex.add_right is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall (z : E), StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) x z) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) x z) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) -> (forall (z : E), StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) x z) (Set.image.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) x z) s))
Case conversion may be inaccurate. Consider using '#align star_convex.add_right StarConvex.add_rightâ‚“'. -/
theorem StarConvex.add_right (hs : StarConvex ğ•œ x s) (z : E) :
    StarConvex ğ•œ (x + z) ((fun x => x + z) '' s) :=
  by
  intro y hy a b ha hb hab
  obtain âŸ¨y', hy', rflâŸ© := hy
  refine' âŸ¨a â€¢ x + b â€¢ y', hs hy' ha hb hab, _âŸ©
  rw [smul_add, smul_add, add_add_add_comm, â† add_smul, hab, one_smul]
#align star_convex.add_right StarConvex.add_right

/- warning: star_convex.preimage_add_right -> StarConvex.preimage_add_right is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {z : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z x) s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z x) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {x : E} {z : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z x) s) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z x) s))
Case conversion may be inaccurate. Consider using '#align star_convex.preimage_add_right StarConvex.preimage_add_rightâ‚“'. -/
/-- The translation of a star-convex set is also star-convex. -/
theorem StarConvex.preimage_add_right (hs : StarConvex ğ•œ (z + x) s) :
    StarConvex ğ•œ x ((fun x => z + x) â»Â¹' s) :=
  by
  intro y hy a b ha hb hab
  have h := hs hy ha hb hab
  rwa [smul_add, smul_add, add_add_add_comm, â† add_smul, hab, one_smul] at h
#align star_convex.preimage_add_right StarConvex.preimage_add_right

/- warning: star_convex.preimage_add_left -> StarConvex.preimage_add_left is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {x : E} {z : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) x z) s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) x z) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {x : E} {z : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) x z) s) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x (Set.preimage.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) x z) s))
Case conversion may be inaccurate. Consider using '#align star_convex.preimage_add_left StarConvex.preimage_add_leftâ‚“'. -/
/-- The translation of a star-convex set is also star-convex. -/
theorem StarConvex.preimage_add_left (hs : StarConvex ğ•œ (x + z) s) :
    StarConvex ğ•œ x ((fun x => x + z) â»Â¹' s) :=
  by
  rw [add_comm] at hs
  simpa only [add_comm] using hs.preimage_add_right
#align star_convex.preimage_add_left StarConvex.preimage_add_left

end Module

end AddCommMonoid

section AddCommGroup

variable [AddCommGroup E] [Module ğ•œ E] {x y : E}

/- warning: star_convex.sub' -> StarConvex.sub' is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {s : Set.{u2} (Prod.{u2, u2} E E)}, (StarConvex.{u1, u2} ğ•œ (Prod.{u2, u2} E E) _inst_1 (Prod.addCommMonoid.{u2, u2} E E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)) (Prod.smul.{u1, u2, u2} ğ•œ E E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (Prod.mk.{u2, u2} E E x y) s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y) (Set.image.{u2, u2} (Prod.{u2, u2} E E) E (fun (x : Prod.{u2, u2} E E) => HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) (Prod.fst.{u2, u2} E E x) (Prod.snd.{u2, u2} E E x)) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {s : Set.{u2} (Prod.{u2, u2} E E)}, (StarConvex.{u1, u2} ğ•œ (Prod.{u2, u2} E E) _inst_1 (Prod.instAddCommMonoidSum.{u2, u2} E E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)) (Prod.smul.{u1, u2, u2} ğ•œ E E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (Prod.mk.{u2, u2} E E x y) s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y) (Set.image.{u2, u2} (Prod.{u2, u2} E E) E (fun (x : Prod.{u2, u2} E E) => HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) (Prod.fst.{u2, u2} E E x) (Prod.snd.{u2, u2} E E x)) s))
Case conversion may be inaccurate. Consider using '#align star_convex.sub' StarConvex.sub'â‚“'. -/
theorem StarConvex.sub' {s : Set (E Ã— E)} (hs : StarConvex ğ•œ (x, y) s) :
    StarConvex ğ•œ (x - y) ((fun x : E Ã— E => x.1 - x.2) '' s) :=
  hs.is_linear_image IsLinearMap.isLinearMap_sub
#align star_convex.sub' StarConvex.sub'

end AddCommGroup

end OrderedSemiring

section OrderedCommSemiring

variable [OrderedCommSemiring ğ•œ]

section AddCommMonoid

variable [AddCommMonoid E] [AddCommMonoid F] [Module ğ•œ E] [Module ğ•œ F] {x : E} {s : Set E}

/- warning: star_convex.smul -> StarConvex.smul is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) x s) -> (forall (c : ğ•œ), StarConvex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) c x) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4))))) c s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedCommSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) x s) -> (forall (c : ğ•œ), StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4))))) c x) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))))) c s))
Case conversion may be inaccurate. Consider using '#align star_convex.smul StarConvex.smulâ‚“'. -/
theorem StarConvex.smul (hs : StarConvex ğ•œ x s) (c : ğ•œ) : StarConvex ğ•œ (c â€¢ x) (c â€¢ s) :=
  hs.linear_image <| LinearMap.lsmul _ _ c
#align star_convex.smul StarConvex.smul

/- warning: star_convex.preimage_smul -> StarConvex.preimage_smul is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2] {x : E} {s : Set.{u2} E} {c : ğ•œ}, (StarConvex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) c x) s) -> (StarConvex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) x (Set.preimage.{u2, u2} E E (fun (z : E) => SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) c z) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedCommSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2] {x : E} {s : Set.{u1} E} {c : ğ•œ}, (StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4))))) c x) s) -> (StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) x (Set.preimage.{u1, u1} E E (fun (z : E) => HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4))))) c z) s))
Case conversion may be inaccurate. Consider using '#align star_convex.preimage_smul StarConvex.preimage_smulâ‚“'. -/
theorem StarConvex.preimage_smul {c : ğ•œ} (hs : StarConvex ğ•œ (c â€¢ x) s) :
    StarConvex ğ•œ x ((fun z => c â€¢ z) â»Â¹' s) :=
  hs.linear_preimage (LinearMap.lsmul _ _ c)
#align star_convex.preimage_smul StarConvex.preimage_smul

/- warning: star_convex.affinity -> StarConvex.affinity is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) x s) -> (forall (z : E) (c : ğ•œ), StarConvex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) c x)) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) c x)) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedCommSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) x s) -> (forall (z : E) (c : ğ•œ), StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4))))) c x)) (Set.image.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4))))) c x)) s))
Case conversion may be inaccurate. Consider using '#align star_convex.affinity StarConvex.affinityâ‚“'. -/
theorem StarConvex.affinity (hs : StarConvex ğ•œ x s) (z : E) (c : ğ•œ) :
    StarConvex ğ•œ (z + c â€¢ x) ((fun x => z + c â€¢ x) '' s) :=
  by
  have h := (hs.smul c).add_left z
  rwa [â† image_smul, image_image] at h
#align star_convex.affinity StarConvex.affinity

end AddCommMonoid

end OrderedCommSemiring

section OrderedRing

variable [OrderedRing ğ•œ]

section AddCommMonoid

variable [AddCommMonoid E] [SMulWithZero ğ•œ E] {s : Set E}

/- warning: star_convex_zero_iff -> starConvex_zero_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMulWithZero.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))] {s : Set.{u2} E}, Iff (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) _inst_3)) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))))) s) (forall {{x : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {{a : ğ•œ}}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) a (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) _inst_3)) a x) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMulWithZero.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))] {s : Set.{u1} E}, Iff (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3)) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) s) (forall {{x : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {{a : ğ•œ}}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) a (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3))) a x) s)))
Case conversion may be inaccurate. Consider using '#align star_convex_zero_iff starConvex_zero_iffâ‚“'. -/
theorem starConvex_zero_iff :
    StarConvex ğ•œ 0 s â†” âˆ€ â¦ƒx : Eâ¦„, x âˆˆ s â†’ âˆ€ â¦ƒa : ğ•œâ¦„, 0 â‰¤ a â†’ a â‰¤ 1 â†’ a â€¢ x âˆˆ s :=
  by
  refine'
    forall_congr' fun x => forall_congr' fun hx => âŸ¨fun h a haâ‚€ haâ‚ => _, fun h a b ha hb hab => _âŸ©
  Â·
    simpa only [sub_add_cancel, eq_self_iff_true, forall_true_left, zero_add, smul_zero] using
      h (sub_nonneg_of_le haâ‚) haâ‚€
  Â· rw [smul_zero, zero_add]
    exact
      h hb
        (by
          rw [â† hab]
          exact le_add_of_nonneg_left ha)
#align star_convex_zero_iff starConvex_zero_iff

end AddCommMonoid

section AddCommGroup

variable [AddCommGroup E] [AddCommGroup F] [Module ğ•œ E] [Module ğ•œ F] {x y : E} {s t : Set E}

/- warning: star_convex.add_smul_mem -> StarConvex.add_smul_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x y) s) -> (forall {t : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) t) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) t (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) t y)) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {y : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) x s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x y) s) -> (forall {t : ğ•œ}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) t) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) t (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) t y)) s))
Case conversion may be inaccurate. Consider using '#align star_convex.add_smul_mem StarConvex.add_smul_memâ‚“'. -/
theorem StarConvex.add_smul_mem (hs : StarConvex ğ•œ x s) (hy : x + y âˆˆ s) {t : ğ•œ} (htâ‚€ : 0 â‰¤ t)
    (htâ‚ : t â‰¤ 1) : x + t â€¢ y âˆˆ s :=
  by
  have h : x + t â€¢ y = (1 - t) â€¢ x + t â€¢ (x + y) := by
    rw [smul_add, â† add_assoc, â† add_smul, sub_add_cancel, one_smul]
  rw [h]
  exact hs hy (sub_nonneg_of_le htâ‚) htâ‚€ (sub_add_cancel _ _)
#align star_convex.add_smul_mem StarConvex.add_smul_mem

/- warning: star_convex.smul_mem -> StarConvex.smul_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {t : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) t) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) t (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) t x) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))))) s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {t : ğ•œ}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) t) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) t (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) t x) s))
Case conversion may be inaccurate. Consider using '#align star_convex.smul_mem StarConvex.smul_memâ‚“'. -/
theorem StarConvex.smul_mem (hs : StarConvex ğ•œ 0 s) (hx : x âˆˆ s) {t : ğ•œ} (htâ‚€ : 0 â‰¤ t)
    (htâ‚ : t â‰¤ 1) : t â€¢ x âˆˆ s := by simpa using hs.add_smul_mem (by simpa using hx) htâ‚€ htâ‚
#align star_convex.smul_mem StarConvex.smul_mem

/- warning: star_convex.add_smul_sub_mem -> StarConvex.add_smul_sub_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (forall {t : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) t) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1)))) t (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) t (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) y x))) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {y : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) x s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (forall {t : ğ•œ}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) t) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1))) t (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) t (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))) y x))) s))
Case conversion may be inaccurate. Consider using '#align star_convex.add_smul_sub_mem StarConvex.add_smul_sub_memâ‚“'. -/
theorem StarConvex.add_smul_sub_mem (hs : StarConvex ğ•œ x s) (hy : y âˆˆ s) {t : ğ•œ} (htâ‚€ : 0 â‰¤ t)
    (htâ‚ : t â‰¤ 1) : x + t â€¢ (y - x) âˆˆ s :=
  by
  apply hs.segment_subset hy
  rw [segment_eq_image']
  exact mem_image_of_mem _ âŸ¨htâ‚€, htâ‚âŸ©
#align star_convex.add_smul_sub_mem StarConvex.add_smul_sub_mem

/- warning: star_convex.affine_preimage -> StarConvex.affine_preimage is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] {x : E} (f : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) {s : Set.{u3} F}, (StarConvex.{u1, u3} ğ•œ F (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_5)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f x) s) -> (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x (Set.preimage.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedRing.{u3} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] {x : E} (f : AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) {s : Set.{u1} F}, (StarConvex.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3) (SMulZeroClass.toSMul.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3))))) (Module.toMulActionWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3) _inst_5)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f x) s) -> (StarConvex.{u3, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x (Set.preimage.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) s))
Case conversion may be inaccurate. Consider using '#align star_convex.affine_preimage StarConvex.affine_preimageâ‚“'. -/
/-- The preimage of a star-convex set under an affine map is star-convex. -/
theorem StarConvex.affine_preimage (f : E â†’áµƒ[ğ•œ] F) {s : Set F} (hs : StarConvex ğ•œ (f x) s) :
    StarConvex ğ•œ x (f â»Â¹' s) := by
  intro y hy a b ha hb hab
  rw [mem_preimage, Convex.combo_affine_apply hab]
  exact hs hy ha hb hab
#align star_convex.affine_preimage StarConvex.affine_preimage

/- warning: star_convex.affine_image -> StarConvex.affine_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] {x : E} (f : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x s) -> (StarConvex.{u1, u3} ğ•œ F (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_5)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f x) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedRing.{u3} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] {x : E} (f : AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) {s : Set.{u2} E}, (StarConvex.{u3, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x s) -> (StarConvex.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3) (SMulZeroClass.toSMul.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3))))) (Module.toMulActionWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) _inst_3) _inst_5)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f x) (Set.image.{u2, u1} E ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) s))
Case conversion may be inaccurate. Consider using '#align star_convex.affine_image StarConvex.affine_imageâ‚“'. -/
/-- The image of a star-convex set under an affine map is star-convex. -/
theorem StarConvex.affine_image (f : E â†’áµƒ[ğ•œ] F) {s : Set E} (hs : StarConvex ğ•œ x s) :
    StarConvex ğ•œ (f x) (f '' s) :=
  by
  rintro y âŸ¨y', âŸ¨hy', hy'fâŸ©âŸ© a b ha hb hab
  refine' âŸ¨a â€¢ x + b â€¢ y', âŸ¨hs hy' ha hb hab, _âŸ©âŸ©
  rw [Convex.combo_affine_apply hab, hy'f]
#align star_convex.affine_image StarConvex.affine_image

/- warning: star_convex.neg -> StarConvex.neg is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x s) -> (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (Neg.neg.{u2} E (SubNegMonoid.toHasNeg.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) x) (Neg.neg.{u2} (Set.{u2} E) (Set.neg.{u2} E (SubNegMonoid.toHasNeg.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) x s) -> (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) (Neg.neg.{u1} E (NegZeroClass.toNeg.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) x) (Neg.neg.{u1} (Set.{u1} E) (Set.neg.{u1} E (NegZeroClass.toNeg.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2)))))) s))
Case conversion may be inaccurate. Consider using '#align star_convex.neg StarConvex.negâ‚“'. -/
theorem StarConvex.neg (hs : StarConvex ğ•œ x s) : StarConvex ğ•œ (-x) (-s) :=
  by
  rw [â† image_neg]
  exact hs.is_linear_image IsLinearMap.isLinearMap_neg
#align star_convex.neg StarConvex.neg

/- warning: star_convex.sub -> StarConvex.sub is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {s : Set.{u2} E} {t : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) x s) -> (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) y t) -> (StarConvex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y) (HSub.hSub.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHSub.{u2} (Set.{u2} E) (Set.sub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) s t))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {y : E} {s : Set.{u1} E} {t : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) x s) -> (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) y t) -> (StarConvex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))) x y) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2))))) s t))
Case conversion may be inaccurate. Consider using '#align star_convex.sub StarConvex.subâ‚“'. -/
theorem StarConvex.sub (hs : StarConvex ğ•œ x s) (ht : StarConvex ğ•œ y t) :
    StarConvex ğ•œ (x - y) (s - t) := by
  simp_rw [sub_eq_add_neg]
  exact hs.add ht.neg
#align star_convex.sub StarConvex.sub

end AddCommGroup

end OrderedRing

section LinearOrderedField

variable [LinearOrderedField ğ•œ]

section AddCommGroup

variable [AddCommGroup E] [Module ğ•œ E] {x : E} {s : Set E}

/- warning: star_convex_iff_div -> starConvex_iff_div is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {s : Set.{u2} E}, Iff (StarConvex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x s) (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) b) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b)) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (DivisionRing.toDivInvMonoid.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) a (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b)) x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (DivisionRing.toDivInvMonoid.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) b (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b)) y)) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {s : Set.{u1} E}, Iff (StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) x s) (forall {{y : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) b) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_1))))))))) a b)) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) (HDiv.hDiv.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHDiv.{u2} ğ•œ (LinearOrderedField.toDiv.{u2} ğ•œ _inst_1)) a (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_1))))))))) a b)) x) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) (HDiv.hDiv.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHDiv.{u2} ğ•œ (LinearOrderedField.toDiv.{u2} ğ•œ _inst_1)) b (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (DivisionRing.toRing.{u2} ğ•œ (Field.toDivisionRing.{u2} ğ•œ (LinearOrderedField.toField.{u2} ğ•œ _inst_1))))))))) a b)) y)) s)))
Case conversion may be inaccurate. Consider using '#align star_convex_iff_div starConvex_iff_divâ‚“'. -/
/-- Alternative definition of star-convexity, using division. -/
theorem starConvex_iff_div :
    StarConvex ğ•œ x s â†”
      âˆ€ â¦ƒyâ¦„,
        y âˆˆ s â†’
          âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s :=
  âŸ¨fun h y hy a b ha hb hab => by
    apply h hy
    Â· have ha' := mul_le_mul_of_nonneg_left ha (inv_pos.2 hab).le
      rwa [MulZeroClass.mul_zero, â† div_eq_inv_mul] at ha'
    Â· have hb' := mul_le_mul_of_nonneg_left hb (inv_pos.2 hab).le
      rwa [MulZeroClass.mul_zero, â† div_eq_inv_mul] at hb'
    Â· rw [â† add_div]
      exact div_self hab.ne', fun h y hy a b ha hb hab =>
    by
    have h' := h hy ha hb
    rw [hab, div_one, div_one] at h'
    exact h' zero_lt_oneâŸ©
#align star_convex_iff_div starConvex_iff_div

/- warning: star_convex.mem_smul -> StarConvex.mem_smul is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {s : Set.{u2} E}, (StarConvex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {t : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))))) t) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) t s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {s : Set.{u1} E}, (StarConvex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))))) s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {t : ğ•œ}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) t) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (DivisionSemiring.toSemiring.{u2} ğ•œ (Semifield.toDivisionSemiring.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))))) t s)))
Case conversion may be inaccurate. Consider using '#align star_convex.mem_smul StarConvex.mem_smulâ‚“'. -/
theorem StarConvex.mem_smul (hs : StarConvex ğ•œ 0 s) (hx : x âˆˆ s) {t : ğ•œ} (ht : 1 â‰¤ t) : x âˆˆ t â€¢ s :=
  by
  rw [mem_smul_set_iff_inv_smul_memâ‚€ (zero_lt_one.trans_le ht).ne']
  exact hs.smul_mem hx (inv_nonneg.2 <| zero_le_one.trans ht) (inv_le_one ht)
#align star_convex.mem_smul StarConvex.mem_smul

end AddCommGroup

end LinearOrderedField

/-!
#### Star-convex sets in an ordered space

Relates `star_convex` and `set.ord_connected`.
-/


section OrdConnected

/- warning: set.ord_connected.star_convex -> Set.OrdConnected.starConvex is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : OrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3))] {x : E} {s : Set.{u2} E}, (Set.OrdConnected.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2)) s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall (y : E), (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (Or (LE.le.{u2} E (Preorder.toLE.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2))) x y) (LE.le.{u2} E (Preorder.toLE.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2))) y x))) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : OrderedAddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : OrderedSMul.{u2, u1} ğ•œ E _inst_1 _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))] {x : E} {s : Set.{u1} E}, (Set.OrdConnected.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E _inst_2)) s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall (y : E), (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (Or (LE.le.{u1} E (Preorder.toLE.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E _inst_2))) x y) (LE.le.{u1} E (Preorder.toLE.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E _inst_2))) y x))) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) x s)
Case conversion may be inaccurate. Consider using '#align set.ord_connected.star_convex Set.OrdConnected.starConvexâ‚“'. -/
theorem Set.OrdConnected.starConvex [OrderedSemiring ğ•œ] [OrderedAddCommMonoid E] [Module ğ•œ E]
    [OrderedSMul ğ•œ E] {x : E} {s : Set E} (hs : s.OrdConnected) (hx : x âˆˆ s)
    (h : âˆ€ y âˆˆ s, x â‰¤ y âˆ¨ y â‰¤ x) : StarConvex ğ•œ x s :=
  by
  intro y hy a b ha hb hab
  obtain hxy | hyx := h _ hy
  Â· refine' hs.out hx hy (mem_Icc.2 âŸ¨_, _âŸ©)
    calc
      x = a â€¢ x + b â€¢ x := (Convex.combo_self hab _).symm
      _ â‰¤ a â€¢ x + b â€¢ y := add_le_add_left (smul_le_smul_of_nonneg hxy hb) _
      
    calc
      a â€¢ x + b â€¢ y â‰¤ a â€¢ y + b â€¢ y := add_le_add_right (smul_le_smul_of_nonneg hxy ha) _
      _ = y := Convex.combo_self hab _
      
  Â· refine' hs.out hy hx (mem_Icc.2 âŸ¨_, _âŸ©)
    calc
      y = a â€¢ y + b â€¢ y := (Convex.combo_self hab _).symm
      _ â‰¤ a â€¢ x + b â€¢ y := add_le_add_right (smul_le_smul_of_nonneg hyx ha) _
      
    calc
      a â€¢ x + b â€¢ y â‰¤ a â€¢ x + b â€¢ x := add_le_add_left (smul_le_smul_of_nonneg hyx hb) _
      _ = x := Convex.combo_self hab _
      
#align set.ord_connected.star_convex Set.OrdConnected.starConvex

/- warning: star_convex_iff_ord_connected -> starConvex_iff_ordConnected is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {s : Set.{u1} ğ•œ}, (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) x s) -> (Iff (StarConvex.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x s) (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {s : Set.{u1} ğ•œ}, (Membership.mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.instMembershipSet.{u1} ğ•œ) x s) -> (Iff (StarConvex.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x s) (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) s))
Case conversion may be inaccurate. Consider using '#align star_convex_iff_ord_connected starConvex_iff_ordConnectedâ‚“'. -/
theorem starConvex_iff_ordConnected [LinearOrderedField ğ•œ] {x : ğ•œ} {s : Set ğ•œ} (hx : x âˆˆ s) :
    StarConvex ğ•œ x s â†” s.OrdConnected := by
  simp_rw [ord_connected_iff_uIcc_subset_left hx, starConvex_iff_segment_subset, segment_eq_uIcc]
#align star_convex_iff_ord_connected starConvex_iff_ordConnected

/- warning: star_convex.ord_connected -> StarConvex.ordConnected is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {s : Set.{u1} ğ•œ}, (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) x s) -> (StarConvex.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x s) -> (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) s)
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {s : Set.{u1} ğ•œ}, (Membership.mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.instMembershipSet.{u1} ğ•œ) x s) -> (StarConvex.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x s) -> (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) s)
Case conversion may be inaccurate. Consider using '#align star_convex.ord_connected StarConvex.ordConnectedâ‚“'. -/
alias starConvex_iff_ordConnected â†” StarConvex.ordConnected _
#align star_convex.ord_connected StarConvex.ordConnected

end OrdConnected

