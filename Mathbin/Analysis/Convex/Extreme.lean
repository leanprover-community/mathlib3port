/-
Copyright (c) 2021 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: YaÃ«l Dillies, Bhavik Mehta

! This file was ported from Lean 3 source module analysis.convex.extreme
! leanprover-community/mathlib commit c5773405394e073885e2a144c9ca14637e8eb963
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Hull

/-!
# Extreme sets

This file defines extreme sets and extreme points for sets in a module.

An extreme set of `A` is a subset of `A` that is as far as it can get in any outward direction: If
point `x` is in it and point `y âˆˆ A`, then the line passing through `x` and `y` leaves `A` at `x`.
This is an analytic notion of "being on the side of". It is weaker than being exposed (see
`is_exposed.is_extreme`).

## Main declarations

* `is_extreme ğ•œ A B`: States that `B` is an extreme set of `A` (in the literature, `A` is often
  implicit).
* `set.extreme_points ğ•œ A`: Set of extreme points of `A` (corresponding to extreme singletons).
* `convex.mem_extreme_points_iff_convex_diff`: A useful equivalent condition to being an extreme
  point: `x` is an extreme point iff `A \ {x}` is convex.

## Implementation notes

The exact definition of extremeness has been carefully chosen so as to make as many lemmas
unconditional (in particular, the Krein-Milman theorem doesn't need the set to be convex!).
In practice, `A` is often assumed to be a convex set.

## References

See chapter 8 of [Barry Simon, *Convexity*][simon2011]

## TODO

Prove lemmas relating extreme sets and points to the intrinsic frontier.

More not-yet-PRed stuff is available on the branch `sperner_again`.
-/


open Function Set

open Affine Classical

variable {ğ•œ E F Î¹ : Type _} {Ï€ : Î¹ â†’ Type _}

section SMul

variable (ğ•œ) [OrderedSemiring ğ•œ] [AddCommMonoid E] [SMul ğ•œ E]

#print IsExtreme /-
/-- A set `B` is an extreme subset of `A` if `B âŠ† A` and all points of `B` only belong to open
segments whose ends are in `B`. -/
def IsExtreme (A B : Set E) : Prop :=
  B âŠ† A âˆ§ âˆ€ â¦ƒxâ‚â¦„, xâ‚ âˆˆ A â†’ âˆ€ â¦ƒxâ‚‚â¦„, xâ‚‚ âˆˆ A â†’ âˆ€ â¦ƒxâ¦„, x âˆˆ B â†’ x âˆˆ openSegment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ âˆˆ B âˆ§ xâ‚‚ âˆˆ B
#align is_extreme IsExtreme
-/

#print Set.extremePoints /-
/-- A point `x` is an extreme point of a set `A` if `x` belongs to no open segment with ends in
`A`, except for the obvious `open_segment x x`. -/
def Set.extremePoints (A : Set E) : Set E :=
  { x âˆˆ A | âˆ€ â¦ƒxâ‚â¦„, xâ‚ âˆˆ A â†’ âˆ€ â¦ƒxâ‚‚â¦„, xâ‚‚ âˆˆ A â†’ x âˆˆ openSegment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ§ xâ‚‚ = x }
#align set.extreme_points Set.extremePoints
-/

#print IsExtreme.refl /-
@[refl]
protected theorem IsExtreme.refl (A : Set E) : IsExtreme ğ•œ A A :=
  âŸ¨Subset.rfl, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxA hx => âŸ¨hxâ‚A, hxâ‚‚AâŸ©âŸ©
#align is_extreme.refl IsExtreme.refl
-/

variable {ğ•œ} {A B C : Set E} {x : E}

/- warning: is_extreme.rfl -> IsExtreme.rfl is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E}, IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A A
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMul.{u2, u1} ğ•œ E] {A : Set.{u1} E}, IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A A
Case conversion may be inaccurate. Consider using '#align is_extreme.rfl IsExtreme.rflâ‚“'. -/
protected theorem IsExtreme.rfl : IsExtreme ğ•œ A A :=
  IsExtreme.refl ğ•œ A
#align is_extreme.rfl IsExtreme.rfl

/- warning: is_extreme.trans -> IsExtreme.trans is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E} {B : Set.{u2} E} {C : Set.{u2} E}, (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 B C) -> (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A C)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMul.{u2, u1} ğ•œ E] {A : Set.{u1} E} {B : Set.{u1} E} {C : Set.{u1} E}, (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 B C) -> (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A C)
Case conversion may be inaccurate. Consider using '#align is_extreme.trans IsExtreme.transâ‚“'. -/
@[trans]
protected theorem IsExtreme.trans (hAB : IsExtreme ğ•œ A B) (hBC : IsExtreme ğ•œ B C) :
    IsExtreme ğ•œ A C :=
  by
  refine' âŸ¨subset.trans hBC.1 hAB.1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxC hx => _âŸ©
  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A (hBC.1 hxC) hx
  exact hBC.2 hxâ‚B hxâ‚‚B hxC hx
#align is_extreme.trans IsExtreme.trans

#print IsExtreme.antisymm /-
protected theorem IsExtreme.antisymm : AntiSymmetric (IsExtreme ğ•œ : Set E â†’ Set E â†’ Prop) :=
  fun A B hAB hBA => Subset.antisymm hBA.1 hAB.1
#align is_extreme.antisymm IsExtreme.antisymm
-/

instance : IsPartialOrder (Set E) (IsExtreme ğ•œ)
    where
  refl := IsExtreme.refl ğ•œ
  trans A B C := IsExtreme.trans
  antisymm := IsExtreme.antisymm

/- warning: is_extreme.inter -> IsExtreme.inter is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E} {B : Set.{u2} E} {C : Set.{u2} E}, (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A C) -> (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) B C))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMul.{u2, u1} ğ•œ E] {A : Set.{u1} E} {B : Set.{u1} E} {C : Set.{u1} E}, (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A C) -> (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A (Inter.inter.{u1} (Set.{u1} E) (Set.instInterSet.{u1} E) B C))
Case conversion may be inaccurate. Consider using '#align is_extreme.inter IsExtreme.interâ‚“'. -/
theorem IsExtreme.inter (hAB : IsExtreme ğ•œ A B) (hAC : IsExtreme ğ•œ A C) : IsExtreme ğ•œ A (B âˆ© C) :=
  by
  use subset.trans (inter_subset_left _ _) hAB.1
  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x âŸ¨hxB, hxCâŸ© hx
  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A hxB hx
  obtain âŸ¨hxâ‚C, hxâ‚‚CâŸ© := hAC.2 hxâ‚A hxâ‚‚A hxC hx
  exact âŸ¨âŸ¨hxâ‚B, hxâ‚CâŸ©, hxâ‚‚B, hxâ‚‚CâŸ©
#align is_extreme.inter IsExtreme.inter

/- warning: is_extreme.mono -> IsExtreme.mono is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E} {B : Set.{u2} E} {C : Set.{u2} E}, (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A C) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) B A) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) C B) -> (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 B C)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMul.{u2, u1} ğ•œ E] {A : Set.{u1} E} {B : Set.{u1} E} {C : Set.{u1} E}, (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A C) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) B A) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) C B) -> (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 B C)
Case conversion may be inaccurate. Consider using '#align is_extreme.mono IsExtreme.monoâ‚“'. -/
protected theorem IsExtreme.mono (hAC : IsExtreme ğ•œ A C) (hBA : B âŠ† A) (hCB : C âŠ† B) :
    IsExtreme ğ•œ B C :=
  âŸ¨hCB, fun xâ‚ hxâ‚B xâ‚‚ hxâ‚‚B x hxC hx => hAC.2 (hBA hxâ‚B) (hBA hxâ‚‚B) hxC hxâŸ©
#align is_extreme.mono IsExtreme.mono

#print isExtreme_interáµ¢ /-
theorem isExtreme_interáµ¢ {Î¹ : Sort _} [Nonempty Î¹] {F : Î¹ â†’ Set E}
    (hAF : âˆ€ i : Î¹, IsExtreme ğ•œ A (F i)) : IsExtreme ğ•œ A (â‹‚ i : Î¹, F i) :=
  by
  obtain i := Classical.arbitrary Î¹
  refine' âŸ¨Inter_subset_of_subset i (hAF i).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx => _âŸ©
  simp_rw [mem_Inter] at hxFâŠ¢
  have h := fun i => (hAF i).2 hxâ‚A hxâ‚‚A (hxF i) hx
  exact âŸ¨fun i => (h i).1, fun i => (h i).2âŸ©
#align is_extreme_Inter isExtreme_interáµ¢
-/

#print isExtreme_binteráµ¢ /-
theorem isExtreme_binteráµ¢ {F : Set (Set E)} (hF : F.Nonempty) (hA : âˆ€ B âˆˆ F, IsExtreme ğ•œ A B) :
    IsExtreme ğ•œ A (â‹‚ B âˆˆ F, B) := by
  haveI := hF.to_subtype
  simpa only [Inter_subtype] using isExtreme_interáµ¢ fun i : F => hA _ i.2
#align is_extreme_bInter isExtreme_binteráµ¢
-/

#print isExtreme_interâ‚› /-
theorem isExtreme_interâ‚› {F : Set (Set E)} (hF : F.Nonempty) (hAF : âˆ€ B âˆˆ F, IsExtreme ğ•œ A B) :
    IsExtreme ğ•œ A (â‹‚â‚€ F) := by
  obtain âŸ¨B, hBâŸ© := hF
  refine' âŸ¨(sInter_subset_of_mem hB).trans (hAF B hB).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx => _âŸ©
  simp_rw [mem_sInter] at hxFâŠ¢
  have h := fun B hB => (hAF B hB).2 hxâ‚A hxâ‚‚A (hxF B hB) hx
  exact âŸ¨fun B hB => (h B hB).1, fun B hB => (h B hB).2âŸ©
#align is_extreme_sInter isExtreme_interâ‚›
-/

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (xâ‚ xâ‚‚ Â«expr âˆˆ Â» A) -/
#print mem_extremePoints /-
theorem mem_extremePoints :
    x âˆˆ A.extremePoints ğ•œ â†”
      x âˆˆ A âˆ§ âˆ€ (xâ‚) (_ : xâ‚ âˆˆ A) (xâ‚‚) (_ : xâ‚‚ âˆˆ A), x âˆˆ openSegment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ§ xâ‚‚ = x :=
  Iff.rfl
#align mem_extreme_points mem_extremePoints
-/

#print mem_extremePoints_iff_extreme_singleton /-
/-- x is an extreme point to A iff {x} is an extreme set of A. -/
theorem mem_extremePoints_iff_extreme_singleton : x âˆˆ A.extremePoints ğ•œ â†” IsExtreme ğ•œ A {x} :=
  by
  refine' âŸ¨_, fun hx => âŸ¨singleton_subset_iff.1 hx.1, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ => hx.2 hxâ‚ hxâ‚‚ rflâŸ©âŸ©
  rintro âŸ¨hxA, hAxâŸ©
  use singleton_subset_iff.2 hxA
  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A y (rfl : y = x)
  exact hAx hxâ‚A hxâ‚‚A
#align mem_extreme_points_iff_extreme_singleton mem_extremePoints_iff_extreme_singleton
-/

#print extremePoints_subset /-
theorem extremePoints_subset : A.extremePoints ğ•œ âŠ† A := fun x hx => hx.1
#align extreme_points_subset extremePoints_subset
-/

#print extremePoints_empty /-
@[simp]
theorem extremePoints_empty : (âˆ… : Set E).extremePoints ğ•œ = âˆ… :=
  subset_empty_iff.1 extremePoints_subset
#align extreme_points_empty extremePoints_empty
-/

#print extremePoints_singleton /-
@[simp]
theorem extremePoints_singleton : ({x} : Set E).extremePoints ğ•œ = {x} :=
  extremePoints_subset.antisymm <|
    singleton_subset_iff.2 âŸ¨mem_singleton x, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ _ => âŸ¨hxâ‚, hxâ‚‚âŸ©âŸ©
#align extreme_points_singleton extremePoints_singleton
-/

/- warning: inter_extreme_points_subset_extreme_points_of_subset -> inter_extremePoints_subset_extremePoints_of_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E} {B : Set.{u2} E}, (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) B A) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) B (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A)) (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 B))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E} {B : Set.{u2} E}, (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) B A) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Inter.inter.{u2} (Set.{u2} E) (Set.instInterSet.{u2} E) B (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A)) (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 B))
Case conversion may be inaccurate. Consider using '#align inter_extreme_points_subset_extreme_points_of_subset inter_extremePoints_subset_extremePoints_of_subsetâ‚“'. -/
theorem inter_extremePoints_subset_extremePoints_of_subset (hBA : B âŠ† A) :
    B âˆ© A.extremePoints ğ•œ âŠ† B.extremePoints ğ•œ := fun x âŸ¨hxB, hxAâŸ© =>
  âŸ¨hxB, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx => hxA.2 (hBA hxâ‚) (hBA hxâ‚‚) hxâŸ©
#align inter_extreme_points_subset_extreme_points_of_subset inter_extremePoints_subset_extremePoints_of_subset

/- warning: is_extreme.extreme_points_subset_extreme_points -> IsExtreme.extremePoints_subset_extremePoints is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 B) (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMul.{u2, u1} ğ•œ E] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (Set.extremePoints.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 B) (Set.extremePoints.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A))
Case conversion may be inaccurate. Consider using '#align is_extreme.extreme_points_subset_extreme_points IsExtreme.extremePoints_subset_extremePointsâ‚“'. -/
theorem IsExtreme.extremePoints_subset_extremePoints (hAB : IsExtreme ğ•œ A B) :
    B.extremePoints ğ•œ âŠ† A.extremePoints ğ•œ := fun x hx =>
  mem_extremePoints_iff_extreme_singleton.2
    (hAB.trans (mem_extremePoints_iff_extreme_singleton.1 hx))
#align is_extreme.extreme_points_subset_extreme_points IsExtreme.extremePoints_subset_extremePoints

/- warning: is_extreme.extreme_points_eq -> IsExtreme.extremePoints_eq is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExtreme.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (Eq.{succ u2} (Set.{u2} E) (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 B) (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) B (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 A)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMul.{u2, u1} ğ•œ E] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExtreme.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A B) -> (Eq.{succ u1} (Set.{u1} E) (Set.extremePoints.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 B) (Inter.inter.{u1} (Set.{u1} E) (Set.instInterSet.{u1} E) B (Set.extremePoints.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 A)))
Case conversion may be inaccurate. Consider using '#align is_extreme.extreme_points_eq IsExtreme.extremePoints_eqâ‚“'. -/
theorem IsExtreme.extremePoints_eq (hAB : IsExtreme ğ•œ A B) :
    B.extremePoints ğ•œ = B âˆ© A.extremePoints ğ•œ :=
  Subset.antisymm (fun x hx => âŸ¨hx.1, hAB.extremePoints_subset_extremePoints hxâŸ©)
    (inter_extremePoints_subset_extremePoints_of_subset hAB.1)
#align is_extreme.extreme_points_eq IsExtreme.extremePoints_eq

end SMul

section OrderedSemiring

variable [OrderedSemiring ğ•œ] [AddCommGroup E] [AddCommGroup F] [âˆ€ i, AddCommGroup (Ï€ i)]
  [Module ğ•œ E] [Module ğ•œ F] [âˆ€ i, Module ğ•œ (Ï€ i)] {A B : Set E} {x : E}

/- warning: is_extreme.convex_diff -> IsExtreme.convex_diff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {A : Set.{u2} E} {B : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) A) -> (IsExtreme.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) A B) -> (Convex.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (SDiff.sdiff.{u2} (Set.{u2} E) (BooleanAlgebra.toHasSdiff.{u2} (Set.{u2} E) (Set.booleanAlgebra.{u2} E)) A B))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {A : Set.{u1} E} {B : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_5)))) A) -> (IsExtreme.{u2, u1} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_5)))) A B) -> (Convex.{u2, u1} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_5)))) (SDiff.sdiff.{u1} (Set.{u1} E) (Set.instSDiffSet.{u1} E) A B))
Case conversion may be inaccurate. Consider using '#align is_extreme.convex_diff IsExtreme.convex_diffâ‚“'. -/
theorem IsExtreme.convex_diff (hA : Convex ğ•œ A) (hAB : IsExtreme ğ•œ A B) : Convex ğ•œ (A \ B) :=
  convex_iff_openSegment_subset.2 fun xâ‚ âŸ¨hxâ‚A, hxâ‚BâŸ© xâ‚‚ âŸ¨hxâ‚‚A, hxâ‚‚BâŸ© x hx =>
    âŸ¨hA.openSegment_subset hxâ‚A hxâ‚‚A hx, fun hxB => hxâ‚B (hAB.2 hxâ‚A hxâ‚‚A hxB hx).1âŸ©
#align is_extreme.convex_diff IsExtreme.convex_diff

/- warning: extreme_points_prod -> extremePoints_prod is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_6 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] (s : Set.{u2} E) (t : Set.{u3} F), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (Prod.{u2, u3} E F)) (Set.extremePoints.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)) (Prod.smul.{u1, u2, u3} ğ•œ E F (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_6))))) (Set.prod.{u2, u3} E F s t)) (Set.prod.{u2, u3} E F (Set.extremePoints.{u1, u2} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) s) (Set.extremePoints.{u1, u3} ğ•œ F _inst_1 (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_6)))) t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : AddCommGroup.{u2} F] [_inst_5 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] [_inst_6 : Module.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_3)] (s : Set.{u3} E) (t : Set.{u2} F), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} E F)) (Set.extremePoints.{u1, max u3 u2} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_3)) (Prod.smul.{u1, u3, u2} ğ•œ E F (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_5)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_3))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_3) _inst_6))))) (Set.prod.{u3, u2} E F s t)) (Set.prod.{u3, u2} E F (Set.extremePoints.{u1, u3} ğ•œ E _inst_1 (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_5)))) s) (Set.extremePoints.{u1, u2} ğ•œ F _inst_1 (AddCommGroup.toAddCommMonoid.{u2} F _inst_3) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_3))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_3) _inst_6)))) t))
Case conversion may be inaccurate. Consider using '#align extreme_points_prod extremePoints_prodâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem extremePoints_prod (s : Set E) (t : Set F) :
    (s Ã—Ë¢ t).extremePoints ğ•œ = s.extremePoints ğ•œ Ã—Ë¢ t.extremePoints ğ•œ :=
  by
  ext
  refine' (and_congr_right fun hx => âŸ¨fun h => _, fun h => _âŸ©).trans (and_and_and_comm _ _ _ _)
  constructor
  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx_fst
    refine'
      (h (mk_mem_prod hxâ‚ hx.2) (mk_mem_prod hxâ‚‚ hx.2) _).imp (congr_arg Prod.fst)
        (congr_arg Prod.fst)
    rw [â† Prod.image_mk_openSegment_left]
    exact âŸ¨_, hx_fst, Prod.mk.etaâŸ©
  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx_snd
    refine'
      (h (mk_mem_prod hx.1 hxâ‚) (mk_mem_prod hx.1 hxâ‚‚) _).imp (congr_arg Prod.snd)
        (congr_arg Prod.snd)
    rw [â† Prod.image_mk_openSegment_right]
    exact âŸ¨_, hx_snd, Prod.mk.etaâŸ©
  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ âŸ¨a, b, ha, hb, hab, hx'âŸ©
    simp_rw [Prod.ext_iff]
    exact
      (and_and_and_comm _ _ _ _).1
        âŸ¨h.1 hxâ‚.1 hxâ‚‚.1 âŸ¨a, b, ha, hb, hab, congr_arg Prod.fst hx'âŸ©,
          h.2 hxâ‚.2 hxâ‚‚.2 âŸ¨a, b, ha, hb, hab, congr_arg Prod.snd hx'âŸ©âŸ©
#align extreme_points_prod extremePoints_prod

#print extremePoints_pi /-
@[simp]
theorem extremePoints_pi (s : âˆ€ i, Set (Ï€ i)) :
    (univ.pi s).extremePoints ğ•œ = univ.pi fun i => (s i).extremePoints ğ•œ :=
  by
  ext
  simp only [mem_extremePoints, mem_pi, mem_univ, true_imp_iff, @forall_and Î¹]
  refine' and_congr_right fun hx => âŸ¨fun h i => _, fun h => _âŸ©
  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hi
    refine'
      (h (update x i xâ‚) _ (update x i xâ‚‚) _ _).imp (fun hâ‚ => by rw [â† hâ‚, update_same]) fun hâ‚‚ =>
        by rw [â† hâ‚‚, update_same]
    iterate 2 
      rintro j
      obtain rfl | hji := eq_or_ne j i
      Â· rwa [update_same]
      Â· rw [update_noteq hji]
        exact hx _
    rw [â† Pi.image_update_openSegment]
    exact âŸ¨_, hi, update_eq_self _ _âŸ©
  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ âŸ¨a, b, ha, hb, hab, hx'âŸ©
    simp_rw [funext_iff, â† forall_and]
    exact fun i => h _ _ (hxâ‚ _) _ (hxâ‚‚ _) âŸ¨a, b, ha, hb, hab, congr_fun hx' _âŸ©
#align extreme_points_pi extremePoints_pi
-/

end OrderedSemiring

section LinearOrderedRing

variable {ğ•œ} [LinearOrderedRing ğ•œ] [AddCommGroup E] [Module ğ•œ E]

variable [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] {A B : Set E} {x : E}

/- warning: mem_extreme_points_iff_forall_segment -> mem_extremePoints_iff_forall_segment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))] {A : Set.{u2} E} {x : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (Set.extremePoints.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) A)) (And (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x A) (forall (xâ‚ : E), (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) xâ‚ A) -> (forall (xâ‚‚ : E), (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) xâ‚‚ A) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) xâ‚ xâ‚‚)) -> (Or (Eq.{succ u2} E xâ‚ x) (Eq.{succ u2} E xâ‚‚ x)))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))] {A : Set.{u2} E} {x : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (Set.extremePoints.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) A)) (And (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x A) (forall (xâ‚ : E), (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) xâ‚ A) -> (forall (xâ‚‚ : E), (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) xâ‚‚ A) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) xâ‚ xâ‚‚)) -> (Or (Eq.{succ u2} E xâ‚ x) (Eq.{succ u2} E xâ‚‚ x)))))
Case conversion may be inaccurate. Consider using '#align mem_extreme_points_iff_forall_segment mem_extremePoints_iff_forall_segmentâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (xâ‚ xâ‚‚ Â«expr âˆˆ Â» A) -/
/-- A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments
that contain it are those with `x` as one of their endpoints. -/
theorem mem_extremePoints_iff_forall_segment :
    x âˆˆ A.extremePoints ğ•œ â†”
      x âˆˆ A âˆ§ âˆ€ (xâ‚) (_ : xâ‚ âˆˆ A) (xâ‚‚) (_ : xâ‚‚ âˆˆ A), x âˆˆ segment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x :=
  by
  refine' and_congr_right fun hxA => forallâ‚„_congr fun xâ‚ hâ‚ xâ‚‚ hâ‚‚ => _
  constructor
  Â· rw [â† insert_endpoints_openSegment]
    rintro H (rfl | rfl | hx)
    exacts[Or.inl rfl, Or.inr rfl, Or.inl <| (H hx).1]
  Â· intro H hx
    rcases H (openSegment_subset_segment _ _ _ hx) with (rfl | rfl)
    exacts[âŸ¨rfl, (left_mem_openSegment_iff.1 hx).symmâŸ©, âŸ¨right_mem_openSegment_iff.1 hx, rflâŸ©]
#align mem_extreme_points_iff_forall_segment mem_extremePoints_iff_forall_segment

/- warning: convex.mem_extreme_points_iff_convex_diff -> Convex.mem_extremePoints_iff_convex_diff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))] {A : Set.{u2} E} {x : E}, (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) A) -> (Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (Set.extremePoints.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) A)) (And (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x A) (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (SDiff.sdiff.{u2} (Set.{u2} E) (BooleanAlgebra.toHasSdiff.{u2} (Set.{u2} E) (Set.booleanAlgebra.{u2} E)) A (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x)))))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : DenselyOrdered.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1))))] [_inst_5 : NoZeroSMulDivisors.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))] {A : Set.{u1} E} {x : E}, (Convex.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) A) -> (Iff (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Set.extremePoints.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) A)) (And (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x A) (Convex.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (SDiff.sdiff.{u1} (Set.{u1} E) (Set.instSDiffSet.{u1} E) A (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x)))))
Case conversion may be inaccurate. Consider using '#align convex.mem_extreme_points_iff_convex_diff Convex.mem_extremePoints_iff_convex_diffâ‚“'. -/
theorem Convex.mem_extremePoints_iff_convex_diff (hA : Convex ğ•œ A) :
    x âˆˆ A.extremePoints ğ•œ â†” x âˆˆ A âˆ§ Convex ğ•œ (A \ {x}) :=
  by
  use fun hx => âŸ¨hx.1, (mem_extremePoints_iff_extreme_singleton.1 hx).convex_diff hAâŸ©
  rintro âŸ¨hxA, hAxâŸ©
  refine' mem_extremePoints_iff_forall_segment.2 âŸ¨hxA, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx => _âŸ©
  rw [convex_iff_segment_subset] at hAx
  by_contra' h
  exact
    (hAx âŸ¨hxâ‚, fun hxâ‚ => h.1 (mem_singleton_iff.2 hxâ‚)âŸ©
          âŸ¨hxâ‚‚, fun hxâ‚‚ => h.2 (mem_singleton_iff.2 hxâ‚‚)âŸ© hx).2
      rfl
#align convex.mem_extreme_points_iff_convex_diff Convex.mem_extremePoints_iff_convex_diff

/- warning: convex.mem_extreme_points_iff_mem_diff_convex_hull_diff -> Convex.mem_extremePoints_iff_mem_diff_convexHull_diff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))] {A : Set.{u2} E} {x : E}, (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) A) -> (Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (Set.extremePoints.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) A)) (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (SDiff.sdiff.{u2} (Set.{u2} E) (BooleanAlgebra.toHasSdiff.{u2} (Set.{u2} E) (Set.booleanAlgebra.{u2} E)) A (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SDiff.sdiff.{u2} (Set.{u2} E) (BooleanAlgebra.toHasSdiff.{u2} (Set.{u2} E) (Set.booleanAlgebra.{u2} E)) A (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x))))))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : DenselyOrdered.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1))))] [_inst_5 : NoZeroSMulDivisors.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))] {A : Set.{u1} E} {x : E}, (Convex.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) A) -> (Iff (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (Set.extremePoints.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) A)) (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (SDiff.sdiff.{u1} (Set.{u1} E) (Set.instSDiffSet.{u1} E) A (OrderHom.toFun.{u1, u1} (Set.{u1} E) (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (ClosureOperator.toOrderHom.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.instCompleteBooleanAlgebraSet.{u1} E))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)) (SDiff.sdiff.{u1} (Set.{u1} E) (Set.instSDiffSet.{u1} E) A (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x))))))
Case conversion may be inaccurate. Consider using '#align convex.mem_extreme_points_iff_mem_diff_convex_hull_diff Convex.mem_extremePoints_iff_mem_diff_convexHull_diffâ‚“'. -/
theorem Convex.mem_extremePoints_iff_mem_diff_convexHull_diff (hA : Convex ğ•œ A) :
    x âˆˆ A.extremePoints ğ•œ â†” x âˆˆ A \ convexHull ğ•œ (A \ {x}) := by
  rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove,
    mem_diff]
#align convex.mem_extreme_points_iff_mem_diff_convex_hull_diff Convex.mem_extremePoints_iff_mem_diff_convexHull_diff

/- warning: extreme_points_convex_hull_subset -> extremePoints_convexHull_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))] {A : Set.{u2} E}, HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (Set.extremePoints.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (coeFn.{succ u2, succ u2} (ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (fun (_x : ClosureOperator.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) => (Set.{u2} E) -> (Set.{u2} E)) (ClosureOperator.hasCoeToFun.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.completeBooleanAlgebra.{u2} E)))))))) (convexHull.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) A)) A
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))] {A : Set.{u2} E}, HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Set.extremePoints.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) A)) A
Case conversion may be inaccurate. Consider using '#align extreme_points_convex_hull_subset extremePoints_convexHull_subsetâ‚“'. -/
theorem extremePoints_convexHull_subset : (convexHull ğ•œ A).extremePoints ğ•œ âŠ† A :=
  by
  rintro x hx
  rw [(convex_convexHull ğ•œ _).mem_extremePoints_iff_convex_diff] at hx
  by_contra
  exact
    (convexHull_min (subset_diff.2 âŸ¨subset_convexHull ğ•œ _, disjoint_singleton_right.2 hâŸ©) hx.2
          hx.1).2
      rfl
  infer_instance
#align extreme_points_convex_hull_subset extremePoints_convexHull_subset

end LinearOrderedRing

