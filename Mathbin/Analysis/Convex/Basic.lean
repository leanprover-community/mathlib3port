/-
Copyright (c) 2019 Alexander Bentkamp. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alexander Bentkamp, Yury Kudriashov, YaÃ«l Dillies

! This file was ported from Lean 3 source module analysis.convex.basic
! leanprover-community/mathlib commit 31ca6f9cf5f90a6206092cd7f84b359dcb6d52e0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Module
import Mathbin.Analysis.Convex.Star
import Mathbin.LinearAlgebra.AffineSpace.AffineSubspace

/-!
# Convex sets and functions in vector spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In a ğ•œ-vector space, we define the following objects and properties.
* `convex ğ•œ s`: A set `s` is convex if for any two points `x y âˆˆ s` it includes `segment ğ•œ x y`.
* `std_simplex ğ•œ Î¹`: The standard simplex in `Î¹ â†’ ğ•œ` (currently requires `fintype Î¹`). It is the
  intersection of the positive quadrant with the hyperplane `s.sum = 1`.

We also provide various equivalent versions of the definitions above, prove that some specific sets
are convex.

## TODO

Generalize all this file to affine spaces.
-/


variable {ğ•œ E F Î² : Type _}

open LinearMap Set

open BigOperators Classical Convex Pointwise

/-! ### Convexity of sets -/


section OrderedSemiring

variable [OrderedSemiring ğ•œ]

section AddCommMonoid

variable [AddCommMonoid E] [AddCommMonoid F]

section SMul

variable (ğ•œ) [SMul ğ•œ E] [SMul ğ•œ F] (s : Set E) {x : E}

#print Convex /-
/-- Convexity of sets. -/
def Convex : Prop :=
  âˆ€ â¦ƒx : Eâ¦„, x âˆˆ s â†’ StarConvex ğ•œ x s
#align convex Convex
-/

variable {ğ•œ s}

/- warning: convex.star_convex -> Convex.starConvex is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E} {x : E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x s)
Case conversion may be inaccurate. Consider using '#align convex.star_convex Convex.starConvexâ‚“'. -/
theorem Convex.starConvex (hs : Convex ğ•œ s) (hx : x âˆˆ s) : StarConvex ğ•œ x s :=
  hs hx
#align convex.star_convex Convex.starConvex

/- warning: convex_iff_segment_subset -> convex_iff_segment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E}, Iff (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) (forall {{x : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E}, Iff (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 s) (forall {{x : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {{y : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (segment.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s)))
Case conversion may be inaccurate. Consider using '#align convex_iff_segment_subset convex_iff_segment_subsetâ‚“'. -/
theorem convex_iff_segment_subset : Convex ğ•œ s â†” âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ [x -[ğ•œ] y] âŠ† s :=
  forallâ‚‚_congr fun x hx => starConvex_iff_segment_subset
#align convex_iff_segment_subset convex_iff_segment_subset

/- warning: convex.segment_subset -> Convex.segment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (forall {x : E} {y : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (forall {x : E} {y : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (segment.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
Case conversion may be inaccurate. Consider using '#align convex.segment_subset Convex.segment_subsetâ‚“'. -/
theorem Convex.segment_subset (h : Convex ğ•œ s) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) :
    [x -[ğ•œ] y] âŠ† s :=
  convex_iff_segment_subset.1 h hx hy
#align convex.segment_subset Convex.segment_subset

/- warning: convex.open_segment_subset -> Convex.openSegment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (forall {x : E} {y : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (forall {x : E} {y : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (openSegment.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 x y) s))
Case conversion may be inaccurate. Consider using '#align convex.open_segment_subset Convex.openSegment_subsetâ‚“'. -/
theorem Convex.openSegment_subset (h : Convex ğ•œ s) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) :
    openSegment ğ•œ x y âŠ† s :=
  (openSegment_subset_segment ğ•œ x y).trans (h.segment_subset hx hy)
#align convex.open_segment_subset Convex.openSegment_subset

/- warning: convex_iff_pointwise_add_subset -> convex_iff_pointwise_add_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E}, Iff (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_4) a s) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_4) b s)) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E}, Iff (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 s) (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) b) -> (Eq.{succ u2} ğ•œ (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E _inst_4)) a s) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E _inst_4)) b s)) s))
Case conversion may be inaccurate. Consider using '#align convex_iff_pointwise_add_subset convex_iff_pointwise_add_subsetâ‚“'. -/
/-- Alternative definition of set convexity, in terms of pointwise set operations. -/
theorem convex_iff_pointwise_add_subset :
    Convex ğ•œ s â†” âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s :=
  Iff.intro
    (by
      rintro hA a b ha hb hab w âŸ¨au, bv, âŸ¨u, hu, rflâŸ©, âŸ¨v, hv, rflâŸ©, rflâŸ©
      exact hA hu hv ha hb hab)
    fun h x hx y hy a b ha hb hab => (h ha hb hab) (Set.add_mem_add âŸ¨_, hx, rflâŸ© âŸ¨_, hy, rflâŸ©)
#align convex_iff_pointwise_add_subset convex_iff_pointwise_add_subset

/- warning: convex.set_combo_subset -> Convex.set_combo_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_4) a s) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E _inst_4) b s)) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) b) -> (Eq.{succ u2} ğ•œ (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E _inst_4)) a s) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E _inst_4)) b s)) s))
Case conversion may be inaccurate. Consider using '#align convex.set_combo_subset Convex.set_combo_subsetâ‚“'. -/
alias convex_iff_pointwise_add_subset â†” Convex.set_combo_subset _
#align convex.set_combo_subset Convex.set_combo_subset

/- warning: convex_empty -> convex_empty is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E], Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} E) (Set.hasEmptyc.{u2} E))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E], Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 (EmptyCollection.emptyCollection.{u1} (Set.{u1} E) (Set.instEmptyCollectionSet.{u1} E))
Case conversion may be inaccurate. Consider using '#align convex_empty convex_emptyâ‚“'. -/
theorem convex_empty : Convex ğ•œ (âˆ… : Set E) := fun x => False.elim
#align convex_empty convex_empty

/- warning: convex_univ -> convex_univ is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E], Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (Set.univ.{u2} E)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : SMul.{u2, u1} ğ•œ E], Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_4 (Set.univ.{u1} E)
Case conversion may be inaccurate. Consider using '#align convex_univ convex_univâ‚“'. -/
theorem convex_univ : Convex ğ•œ (Set.univ : Set E) := fun _ _ => starConvex_univ _
#align convex_univ convex_univ

/- warning: convex.inter -> Convex.inter is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {t : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 t) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {t : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 t) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (Inter.inter.{u2} (Set.{u2} E) (Set.instInterSet.{u2} E) s t))
Case conversion may be inaccurate. Consider using '#align convex.inter Convex.interâ‚“'. -/
theorem Convex.inter {t : Set E} (hs : Convex ğ•œ s) (ht : Convex ğ•œ t) : Convex ğ•œ (s âˆ© t) :=
  fun x hx => (hs hx.1).inter (ht hx.2)
#align convex.inter Convex.inter

#print convex_sInter /-
theorem convex_sInter {S : Set (Set E)} (h : âˆ€ s âˆˆ S, Convex ğ•œ s) : Convex ğ•œ (â‹‚â‚€ S) := fun x hx =>
  starConvex_sInter fun s hs => h _ hs <| hx _ hs
#align convex_sInter convex_sInter
-/

#print convex_iInter /-
theorem convex_iInter {Î¹ : Sort _} {s : Î¹ â†’ Set E} (h : âˆ€ i, Convex ğ•œ (s i)) :
    Convex ğ•œ (â‹‚ i, s i) :=
  sInter_range s â–¸ convex_sInter <| forall_range_iff.2 h
#align convex_Inter convex_iInter
-/

/- warning: convex_Interâ‚‚ -> convex_iInterâ‚‚ is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {Î¹ : Sort.{u3}} {Îº : Î¹ -> Sort.{u4}} {s : forall (i : Î¹), (Îº i) -> (Set.{u2} E)}, (forall (i : Î¹) (j : Îº i), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (s i j)) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (Set.iInter.{u2, u3} E Î¹ (fun (i : Î¹) => Set.iInter.{u2, u4} E (Îº i) (fun (j : Îº i) => s i j))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : SMul.{u1, u2} ğ•œ E] {Î¹ : Sort.{u4}} {Îº : Î¹ -> Sort.{u3}} {s : forall (i : Î¹), (Îº i) -> (Set.{u2} E)}, (forall (i : Î¹) (j : Îº i), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (s i j)) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 (Set.iInter.{u2, u4} E Î¹ (fun (i : Î¹) => Set.iInter.{u2, u3} E (Îº i) (fun (j : Îº i) => s i j))))
Case conversion may be inaccurate. Consider using '#align convex_Interâ‚‚ convex_iInterâ‚‚â‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
theorem convex_iInterâ‚‚ {Î¹ : Sort _} {Îº : Î¹ â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set E}
    (h : âˆ€ i j, Convex ğ•œ (s i j)) : Convex ğ•œ (â‹‚ (i) (j), s i j) :=
  convex_iInter fun i => convex_iInter <| h i
#align convex_Interâ‚‚ convex_iInterâ‚‚

/- warning: convex.prod -> Convex.prod is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : SMul.{u1, u2} ğ•œ E] [_inst_5 : SMul.{u1, u3} ğ•œ F] {s : Set.{u2} E} {t : Set.{u3} F}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (Convex.{u1, u3} ğ•œ F _inst_1 _inst_3 _inst_5 t) -> (Convex.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F _inst_4 _inst_5) (Set.prod.{u2, u3} E F s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : SMul.{u1, u3} ğ•œ E] [_inst_5 : SMul.{u1, u2} ğ•œ F] {s : Set.{u3} E} {t : Set.{u2} F}, (Convex.{u1, u3} ğ•œ E _inst_1 _inst_2 _inst_4 s) -> (Convex.{u1, u2} ğ•œ F _inst_1 _inst_3 _inst_5 t) -> (Convex.{u1, max u2 u3} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F _inst_4 _inst_5) (Set.prod.{u3, u2} E F s t))
Case conversion may be inaccurate. Consider using '#align convex.prod Convex.prodâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem Convex.prod {s : Set E} {t : Set F} (hs : Convex ğ•œ s) (ht : Convex ğ•œ t) :
    Convex ğ•œ (s Ã—Ë¢ t) := fun x hx => (hs hx.1).Prod (ht hx.2)
#align convex.prod Convex.prod

/- warning: convex_pi -> convex_pi is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] {Î¹ : Type.{u2}} {E : Î¹ -> Type.{u3}} [_inst_6 : forall (i : Î¹), AddCommMonoid.{u3} (E i)] [_inst_7 : forall (i : Î¹), SMul.{u1, u3} ğ•œ (E i)] {s : Set.{u2} Î¹} {t : forall (i : Î¹), Set.{u3} (E i)}, (forall {{i : Î¹}}, (Membership.Mem.{u2, u2} Î¹ (Set.{u2} Î¹) (Set.hasMem.{u2} Î¹) i s) -> (Convex.{u1, u3} ğ•œ (E i) _inst_1 (_inst_6 i) (_inst_7 i) (t i))) -> (Convex.{u1, max u2 u3} ğ•œ (forall (i : Î¹), E i) _inst_1 (Pi.addCommMonoid.{u2, u3} Î¹ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_6 i)) (Pi.instSMul.{u2, u3, u1} Î¹ ğ•œ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_7 i)) (Set.pi.{u2, u3} Î¹ (fun (i : Î¹) => E i) s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] {Î¹ : Type.{u3}} {E : Î¹ -> Type.{u2}} [_inst_6 : forall (i : Î¹), AddCommMonoid.{u2} (E i)] [_inst_7 : forall (i : Î¹), SMul.{u1, u2} ğ•œ (E i)] {s : Set.{u3} Î¹} {t : forall (i : Î¹), Set.{u2} (E i)}, (forall {{i : Î¹}}, (Membership.mem.{u3, u3} Î¹ (Set.{u3} Î¹) (Set.instMembershipSet.{u3} Î¹) i s) -> (Convex.{u1, u2} ğ•œ (E i) _inst_1 (_inst_6 i) (_inst_7 i) (t i))) -> (Convex.{u1, max u3 u2} ğ•œ (forall (i : Î¹), E i) _inst_1 (Pi.addCommMonoid.{u3, u2} Î¹ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_6 i)) (Pi.instSMul.{u3, u2, u1} Î¹ ğ•œ (fun (i : Î¹) => E i) (fun (i : Î¹) => _inst_7 i)) (Set.pi.{u3, u2} Î¹ (fun (i : Î¹) => E i) s t))
Case conversion may be inaccurate. Consider using '#align convex_pi convex_piâ‚“'. -/
theorem convex_pi {Î¹ : Type _} {E : Î¹ â†’ Type _} [âˆ€ i, AddCommMonoid (E i)] [âˆ€ i, SMul ğ•œ (E i)]
    {s : Set Î¹} {t : âˆ€ i, Set (E i)} (ht : âˆ€ â¦ƒiâ¦„, i âˆˆ s â†’ Convex ğ•œ (t i)) : Convex ğ•œ (s.pi t) :=
  fun x hx => starConvex_pi fun i hi => ht hi <| hx _ hi
#align convex_pi convex_pi

#print Directed.convex_iUnion /-
theorem Directed.convex_iUnion {Î¹ : Sort _} {s : Î¹ â†’ Set E} (hdir : Directed (Â· âŠ† Â·) s)
    (hc : âˆ€ â¦ƒi : Î¹â¦„, Convex ğ•œ (s i)) : Convex ğ•œ (â‹ƒ i, s i) :=
  by
  rintro x hx y hy a b ha hb hab
  rw [mem_Union] at hx hyâŠ¢
  obtain âŸ¨i, hxâŸ© := hx
  obtain âŸ¨j, hyâŸ© := hy
  obtain âŸ¨k, hik, hjkâŸ© := hdir i j
  exact âŸ¨k, hc (hik hx) (hjk hy) ha hb habâŸ©
#align directed.convex_Union Directed.convex_iUnion
-/

#print DirectedOn.convex_sUnion /-
theorem DirectedOn.convex_sUnion {c : Set (Set E)} (hdir : DirectedOn (Â· âŠ† Â·) c)
    (hc : âˆ€ â¦ƒA : Set Eâ¦„, A âˆˆ c â†’ Convex ğ•œ A) : Convex ğ•œ (â‹ƒâ‚€ c) :=
  by
  rw [sUnion_eq_Union]
  exact (directedOn_iff_directed.1 hdir).convex_iUnion fun A => hc A.2
#align directed_on.convex_sUnion DirectedOn.convex_sUnion
-/

end SMul

section Module

variable [Module ğ•œ E] [Module ğ•œ F] {s : Set E} {x : E}

/- warning: convex_iff_open_segment_subset -> convex_iff_openSegment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, Iff (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) (forall {{x : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x y) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, Iff (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) (forall {{x : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {{y : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) (openSegment.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x y) s)))
Case conversion may be inaccurate. Consider using '#align convex_iff_open_segment_subset convex_iff_openSegment_subsetâ‚“'. -/
theorem convex_iff_openSegment_subset :
    Convex ğ•œ s â†” âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ openSegment ğ•œ x y âŠ† s :=
  forallâ‚‚_congr fun x => starConvex_iff_openSegment_subset
#align convex_iff_open_segment_subset convex_iff_openSegment_subset

/- warning: convex_iff_forall_pos -> convex_iff_forall_pos is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, Iff (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) (forall {{x : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) a x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) b y)) s))))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, Iff (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) (forall {{x : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {{y : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) a) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) b) -> (Eq.{succ u2} ğ•œ (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4))))) a x) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4))))) b y)) s))))
Case conversion may be inaccurate. Consider using '#align convex_iff_forall_pos convex_iff_forall_posâ‚“'. -/
theorem convex_iff_forall_pos :
    Convex ğ•œ s â†”
      âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=
  forallâ‚‚_congr fun x => starConvex_iff_forall_pos
#align convex_iff_forall_pos convex_iff_forall_pos

/- warning: convex_iff_pairwise_pos -> convex_iff_pairwise_pos is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, Iff (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) (Set.Pairwise.{u2} E s (fun (x : E) (y : E) => forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) a x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) b y)) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, Iff (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) (Set.Pairwise.{u1} E s (fun (x : E) (y : E) => forall {{a : ğ•œ}} {{b : ğ•œ}}, (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) a) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) b) -> (Eq.{succ u2} ğ•œ (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4))))) a x) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4))))) b y)) s)))
Case conversion may be inaccurate. Consider using '#align convex_iff_pairwise_pos convex_iff_pairwise_posâ‚“'. -/
theorem convex_iff_pairwise_pos :
    Convex ğ•œ s â†” s.Pairwise fun x y => âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=
  by
  refine' convex_iff_forall_pos.trans âŸ¨fun h x hx y hy _ => h hx hy, _âŸ©
  intro h x hx y hy a b ha hb hab
  obtain rfl | hxy := eq_or_ne x y
  Â· rwa [Convex.combo_self hab]
  Â· exact h hx hy hxy ha hb hab
#align convex_iff_pairwise_pos convex_iff_pairwise_pos

/- warning: convex.star_convex_iff -> Convex.starConvex_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E} {x : E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (Set.Nonempty.{u2} E s) -> (Iff (StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E} {x : E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (Set.Nonempty.{u1} E s) -> (Iff (StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x s) (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s))
Case conversion may be inaccurate. Consider using '#align convex.star_convex_iff Convex.starConvex_iffâ‚“'. -/
theorem Convex.starConvex_iff (hs : Convex ğ•œ s) (h : s.Nonempty) : StarConvex ğ•œ x s â†” x âˆˆ s :=
  âŸ¨fun hxs => hxs.Mem h, hs.StarConvexâŸ©
#align convex.star_convex_iff Convex.starConvex_iff

#print Set.Subsingleton.convex /-
protected theorem Set.Subsingleton.convex {s : Set E} (h : s.Subsingleton) : Convex ğ•œ s :=
  convex_iff_pairwise_pos.mpr (h.Pairwise _)
#align set.subsingleton.convex Set.Subsingleton.convex
-/

/- warning: convex_singleton -> convex_singleton is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (c : E), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) c)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] (c : E), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) c)
Case conversion may be inaccurate. Consider using '#align convex_singleton convex_singletonâ‚“'. -/
theorem convex_singleton (c : E) : Convex ğ•œ ({c} : Set E) :=
  subsingleton_singleton.Convex
#align convex_singleton convex_singleton

/- warning: convex_segment -> convex_segment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (x : E) (y : E), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) x y)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] (x : E) (y : E), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (segment.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) x y)
Case conversion may be inaccurate. Consider using '#align convex_segment convex_segmentâ‚“'. -/
theorem convex_segment (x y : E) : Convex ğ•œ [x -[ğ•œ] y] :=
  by
  rintro p âŸ¨ap, bp, hap, hbp, habp, rflâŸ© q âŸ¨aq, bq, haq, hbq, habq, rflâŸ© a b ha hb hab
  refine'
    âŸ¨a * ap + b * aq, a * bp + b * bq, add_nonneg (mul_nonneg ha hap) (mul_nonneg hb haq),
      add_nonneg (mul_nonneg ha hbp) (mul_nonneg hb hbq), _, _âŸ©
  Â· rw [add_add_add_comm, â† mul_add, â† mul_add, habp, habq, mul_one, mul_one, hab]
  Â· simp_rw [add_smul, mul_smul, smul_add]
    exact add_add_add_comm _ _ _ _
#align convex_segment convex_segment

/- warning: convex.linear_image -> Convex.linear_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (f : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), Convex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3] {s : Set.{u2} E}, (Convex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (f : LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), Convex.{u3, u1} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u3, u1} ğ•œ F (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ F (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ F (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (Module.toMulActionWithZero.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3 _inst_5)))) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u3} ğ•œ (Semiring.toNonAssocSemiring.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)))) f) s))
Case conversion may be inaccurate. Consider using '#align convex.linear_image Convex.linear_imageâ‚“'. -/
theorem Convex.linear_image (hs : Convex ğ•œ s) (f : E â†’â‚—[ğ•œ] F) : Convex ğ•œ (f '' s) :=
  by
  intro x hx y hy a b ha hb hab
  obtain âŸ¨x', hx', rflâŸ© := mem_image_iff_bex.1 hx
  obtain âŸ¨y', hy', rflâŸ© := mem_image_iff_bex.1 hy
  exact âŸ¨a â€¢ x' + b â€¢ y', hs hx' hy' ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]âŸ©
#align convex.linear_image Convex.linear_image

/- warning: convex.is_linear_image -> Convex.is_linear_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall {f : E -> F}, (IsLinearMap.{u1, u2, u3} ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (Convex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (Set.image.{u2, u3} E F f s)))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3] {s : Set.{u2} E}, (Convex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall {f : E -> F}, (IsLinearMap.{u3, u2, u1} ğ•œ E F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (Convex.{u3, u1} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u3, u1} ğ•œ F (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ F (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ F (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} F (AddCommMonoid.toAddMonoid.{u1} F _inst_3)) (Module.toMulActionWithZero.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_3 _inst_5)))) (Set.image.{u2, u1} E F f s)))
Case conversion may be inaccurate. Consider using '#align convex.is_linear_image Convex.is_linear_imageâ‚“'. -/
theorem Convex.is_linear_image (hs : Convex ğ•œ s) {f : E â†’ F} (hf : IsLinearMap ğ•œ f) :
    Convex ğ•œ (f '' s) :=
  hs.linear_image <| hf.mk' f
#align convex.is_linear_image Convex.is_linear_image

/- warning: convex.linear_preimage -> Convex.linear_preimage is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {s : Set.{u3} F}, (Convex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) s) -> (forall (f : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3] {s : Set.{u3} F}, (Convex.{u2, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u2, u3} ğ•œ F (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} ğ•œ F (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} ğ•œ F (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (Module.toMulActionWithZero.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3 _inst_5)))) s) -> (forall (f : LinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u1, u3} E F (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) E F _inst_2 _inst_3 _inst_4 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} ğ•œ ğ•œ E F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 (RingHom.id.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))) f) s))
Case conversion may be inaccurate. Consider using '#align convex.linear_preimage Convex.linear_preimageâ‚“'. -/
theorem Convex.linear_preimage {s : Set F} (hs : Convex ğ•œ s) (f : E â†’â‚—[ğ•œ] F) : Convex ğ•œ (f â»Â¹' s) :=
  by
  intro x hx y hy a b ha hb hab
  rw [mem_preimage, f.map_add, f.map_smul, f.map_smul]
  exact hs hx hy ha hb hab
#align convex.linear_preimage Convex.linear_preimage

/- warning: convex.is_linear_preimage -> Convex.is_linear_preimage is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] {s : Set.{u3} F}, (Convex.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) s) -> (forall {f : E -> F}, (IsLinearMap.{u1, u2, u3} ğ•œ E F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u2, u3} E F f s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3] {s : Set.{u3} F}, (Convex.{u2, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u2, u3} ğ•œ F (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} ğ•œ F (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} ğ•œ F (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3)) (Module.toMulActionWithZero.{u2, u3} ğ•œ F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_3 _inst_5)))) s) -> (forall {f : E -> F}, (IsLinearMap.{u2, u1, u3} ğ•œ E F (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3 _inst_4 _inst_5 f) -> (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u1, u3} E F f s)))
Case conversion may be inaccurate. Consider using '#align convex.is_linear_preimage Convex.is_linear_preimageâ‚“'. -/
theorem Convex.is_linear_preimage {s : Set F} (hs : Convex ğ•œ s) {f : E â†’ F} (hf : IsLinearMap ğ•œ f) :
    Convex ğ•œ (f â»Â¹' s) :=
  hs.linear_preimage <| hf.mk' f
#align convex.is_linear_preimage Convex.is_linear_preimage

/- warning: convex.add -> Convex.add is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E} {t : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) t) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) s t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E} {t : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) t) -> (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) s t))
Case conversion may be inaccurate. Consider using '#align convex.add Convex.addâ‚“'. -/
theorem Convex.add {t : Set E} (hs : Convex ğ•œ s) (ht : Convex ğ•œ t) : Convex ğ•œ (s + t) :=
  by
  rw [â† add_image_prod]
  exact (hs.prod ht).is_linear_image IsLinearMap.isLinearMap_add
#align convex.add Convex.add

/- warning: convex.vadd -> Convex.vadd is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (VAdd.vadd.{u2, u2} E (Set.{u2} E) (Set.vaddSet.{u2, u2} E E (Add.toVAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))))) z s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (HVAdd.hVAdd.{u1, u1, u1} E (Set.{u1} E) (Set.{u1} E) (instHVAdd.{u1, u1} E (Set.{u1} E) (Set.vaddSet.{u1, u1} E E (AddAction.toVAdd.{u1, u1} E E (AddCommMonoid.toAddMonoid.{u1} E _inst_2) (AddMonoid.toAddAction.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))))) z s))
Case conversion may be inaccurate. Consider using '#align convex.vadd Convex.vaddâ‚“'. -/
theorem Convex.vadd (hs : Convex ğ•œ s) (z : E) : Convex ğ•œ (z +áµ¥ s) :=
  by
  simp_rw [â† image_vadd, vadd_eq_add, â† singleton_add]
  exact (convex_singleton _).add hs
#align convex.vadd Convex.vadd

/- warning: convex.translate -> Convex.translate is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z x) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.image.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z x) s))
Case conversion may be inaccurate. Consider using '#align convex.translate Convex.translateâ‚“'. -/
theorem Convex.translate (hs : Convex ğ•œ s) (z : E) : Convex ğ•œ ((fun x => z + x) '' s) :=
  hs.vadd _
#align convex.translate Convex.translate

/- warning: convex.translate_preimage_right -> Convex.translate_preimage_right is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z x) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z x) s))
Case conversion may be inaccurate. Consider using '#align convex.translate_preimage_right Convex.translate_preimage_rightâ‚“'. -/
/-- The translation of a convex set is also convex. -/
theorem Convex.translate_preimage_right (hs : Convex ğ•œ s) (z : E) :
    Convex ğ•œ ((fun x => z + x) â»Â¹' s) :=
  by
  intro x hx y hy a b ha hb hab
  have h := hs hx hy ha hb hab
  rwa [smul_add, smul_add, add_add_add_comm, â† add_smul, hab, one_smul] at h
#align convex.translate_preimage_right Convex.translate_preimage_right

/- warning: convex.translate_preimage_left -> Convex.translate_preimage_left is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) x z) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) s) -> (forall (z : E), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_4)))) (Set.preimage.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) x z) s))
Case conversion may be inaccurate. Consider using '#align convex.translate_preimage_left Convex.translate_preimage_leftâ‚“'. -/
/-- The translation of a convex set is also convex. -/
theorem Convex.translate_preimage_left (hs : Convex ğ•œ s) (z : E) :
    Convex ğ•œ ((fun x => x + z) â»Â¹' s) := by
  simpa only [add_comm] using hs.translate_preimage_right z
#align convex.translate_preimage_left Convex.translate_preimage_left

section OrderedAddCommMonoid

variable [OrderedAddCommMonoid Î²] [Module ğ•œ Î²] [OrderedSMul ğ•œ Î²]

/- warning: convex_Iic -> convex_Iic is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Iic.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Iic.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r)
Case conversion may be inaccurate. Consider using '#align convex_Iic convex_Iicâ‚“'. -/
theorem convex_Iic (r : Î²) : Convex ğ•œ (Iic r) := fun x hx y hy a b ha hb hab =>
  calc
    a â€¢ x + b â€¢ y â‰¤ a â€¢ r + b â€¢ r :=
      add_le_add (smul_le_smul_of_nonneg hx ha) (smul_le_smul_of_nonneg hy hb)
    _ = r := Convex.combo_self hab _
    
#align convex_Iic convex_Iic

/- warning: convex_Ici -> convex_Ici is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Ici.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Ici.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r)
Case conversion may be inaccurate. Consider using '#align convex_Ici convex_Iciâ‚“'. -/
theorem convex_Ici (r : Î²) : Convex ğ•œ (Ici r) :=
  @convex_Iic ğ•œ Î²áµ’áµˆ _ _ _ _ r
#align convex_Ici convex_Ici

/- warning: convex_Icc -> convex_Icc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Icc.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Icc.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r s)
Case conversion may be inaccurate. Consider using '#align convex_Icc convex_Iccâ‚“'. -/
theorem convex_Icc (r s : Î²) : Convex ğ•œ (Icc r s) :=
  Ici_inter_Iic.subst ((convex_Ici r).inter <| convex_Iic s)
#align convex_Icc convex_Icc

/- warning: convex_halfspace_le -> convex_halfspace_le is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedAddCommMonoid.{u3} Î²] [_inst_7 : Module.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u3} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} Î² (AddMonoid.toAddZeroClass.{u3} Î² (AddCommMonoid.toAddMonoid.{u3} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u1, u2, u3} ğ•œ E Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_6))) (f w) r)))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u3, u1} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u3, u2, u1} ğ•œ E Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_6))) (f w) r)))
Case conversion may be inaccurate. Consider using '#align convex_halfspace_le convex_halfspace_leâ‚“'. -/
theorem convex_halfspace_le {f : E â†’ Î²} (h : IsLinearMap ğ•œ f) (r : Î²) : Convex ğ•œ { w | f w â‰¤ r } :=
  (convex_Iic r).is_linear_preimage h
#align convex_halfspace_le convex_halfspace_le

/- warning: convex_halfspace_ge -> convex_halfspace_ge is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedAddCommMonoid.{u3} Î²] [_inst_7 : Module.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u3} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} Î² (AddMonoid.toAddZeroClass.{u3} Î² (AddCommMonoid.toAddMonoid.{u3} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u1, u2, u3} ğ•œ E Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_6))) r (f w))))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u3, u1} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u3, u2, u1} ğ•œ E Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LE.le.{u1} Î² (Preorder.toLE.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedAddCommMonoid.toPartialOrder.{u1} Î² _inst_6))) r (f w))))
Case conversion may be inaccurate. Consider using '#align convex_halfspace_ge convex_halfspace_geâ‚“'. -/
theorem convex_halfspace_ge {f : E â†’ Î²} (h : IsLinearMap ğ•œ f) (r : Î²) : Convex ğ•œ { w | r â‰¤ f w } :=
  (convex_Ici r).is_linear_preimage h
#align convex_halfspace_ge convex_halfspace_ge

/- warning: convex_hyperplane -> convex_hyperplane is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedAddCommMonoid.{u3} Î²] [_inst_7 : Module.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u3} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} Î² (AddMonoid.toAddZeroClass.{u3} Î² (AddCommMonoid.toAddMonoid.{u3} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u1, u2, u3} ğ•œ E Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => Eq.{succ u3} Î² (f w) r)))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u3, u1} ğ•œ Î² _inst_1 _inst_6 (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u3, u2, u1} ğ•œ E Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => Eq.{succ u1} Î² (f w) r)))
Case conversion may be inaccurate. Consider using '#align convex_hyperplane convex_hyperplaneâ‚“'. -/
theorem convex_hyperplane {f : E â†’ Î²} (h : IsLinearMap ğ•œ f) (r : Î²) : Convex ğ•œ { w | f w = r } :=
  by
  simp_rw [le_antisymm_iff]
  exact (convex_halfspace_le h r).inter (convex_halfspace_ge h r)
#align convex_hyperplane convex_hyperplane

end OrderedAddCommMonoid

section OrderedCancelAddCommMonoid

variable [OrderedCancelAddCommMonoid Î²] [Module ğ•œ Î²] [OrderedSMul ğ•œ Î²]

/- warning: convex_Iio -> convex_Iio is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Iio.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Iio.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r)
Case conversion may be inaccurate. Consider using '#align convex_Iio convex_Iioâ‚“'. -/
theorem convex_Iio (r : Î²) : Convex ğ•œ (Iio r) :=
  by
  intro x hx y hy a b ha hb hab
  obtain rfl | ha' := ha.eq_or_lt
  Â· rw [zero_add] at hab
    rwa [zero_smul, zero_add, hab, one_smul]
  rw [mem_Iio] at hx hy
  calc
    a â€¢ x + b â€¢ y < a â€¢ r + b â€¢ r :=
      add_lt_add_of_lt_of_le (smul_lt_smul_of_pos hx ha') (smul_le_smul_of_nonneg hy.le hb)
    _ = r := Convex.combo_self hab _
    
#align convex_Iio convex_Iio

/- warning: convex_Ioi -> convex_Ioi is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Ioi.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Ioi.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r)
Case conversion may be inaccurate. Consider using '#align convex_Ioi convex_Ioiâ‚“'. -/
theorem convex_Ioi (r : Î²) : Convex ğ•œ (Ioi r) :=
  @convex_Iio ğ•œ Î²áµ’áµˆ _ _ _ _ r
#align convex_Ioi convex_Ioi

/- warning: convex_Ioo -> convex_Ioo is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Ioo.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Ioo.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r s)
Case conversion may be inaccurate. Consider using '#align convex_Ioo convex_Iooâ‚“'. -/
theorem convex_Ioo (r s : Î²) : Convex ğ•œ (Ioo r s) :=
  Ioi_inter_Iio.subst ((convex_Ioi r).inter <| convex_Iio s)
#align convex_Ioo convex_Ioo

/- warning: convex_Ico -> convex_Ico is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Ico.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Ico.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r s)
Case conversion may be inaccurate. Consider using '#align convex_Ico convex_Icoâ‚“'. -/
theorem convex_Ico (r s : Î²) : Convex ğ•œ (Ico r s) :=
  Ici_inter_Iio.subst ((convex_Ici r).inter <| convex_Iio s)
#align convex_Ico convex_Ico

/- warning: convex_Ioc -> convex_Ioc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} Î² _inst_6) _inst_7)))) (Set.Ioc.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u2} Î² _inst_6)) r s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : OrderedCancelAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddRightCancelMonoid.toZero.{u1} Î² (AddCancelMonoid.toAddRightCancelMonoid.{u1} Î² (AddCancelCommMonoid.toAddCancelMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.Ioc.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_6)) r s)
Case conversion may be inaccurate. Consider using '#align convex_Ioc convex_Iocâ‚“'. -/
theorem convex_Ioc (r s : Î²) : Convex ğ•œ (Ioc r s) :=
  Ioi_inter_Iic.subst ((convex_Ioi r).inter <| convex_Iic s)
#align convex_Ioc convex_Ioc

/- warning: convex_halfspace_lt -> convex_halfspace_lt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedCancelAddCommMonoid.{u3} Î²] [_inst_7 : Module.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u3} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} Î² (AddMonoid.toAddZeroClass.{u3} Î² (AddCommMonoid.toAddMonoid.{u3} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u1, u2, u3} ğ•œ E Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u3} Î² _inst_6))) (f w) r)))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedCancelAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u3, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u3, u2, u1} ğ•œ E Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_6))) (f w) r)))
Case conversion may be inaccurate. Consider using '#align convex_halfspace_lt convex_halfspace_ltâ‚“'. -/
theorem convex_halfspace_lt {f : E â†’ Î²} (h : IsLinearMap ğ•œ f) (r : Î²) : Convex ğ•œ { w | f w < r } :=
  (convex_Iio r).is_linear_preimage h
#align convex_halfspace_lt convex_halfspace_lt

/- warning: convex_halfspace_gt -> convex_halfspace_gt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedCancelAddCommMonoid.{u3} Î²] [_inst_7 : Module.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6)] [_inst_8 : OrderedSMul.{u1, u3} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} Î² (AddMonoid.toAddZeroClass.{u3} Î² (AddCommMonoid.toAddMonoid.{u3} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u3} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u3} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u1, u2, u3} ğ•œ E Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u3} Î² _inst_6))) r (f w))))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u3} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2] [_inst_6 : OrderedCancelAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u3, u1} ğ•œ Î² _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u3, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] {f : E -> Î²}, (IsLinearMap.{u3, u2, u1} ğ•œ E Î² (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_4 _inst_7 f) -> (forall (r : Î²), Convex.{u3, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ _inst_1) _inst_2 _inst_4)))) (setOf.{u2} E (fun (w : E) => LT.lt.{u1} Î² (Preorder.toLT.{u1} Î² (PartialOrder.toPreorder.{u1} Î² (OrderedCancelAddCommMonoid.toPartialOrder.{u1} Î² _inst_6))) r (f w))))
Case conversion may be inaccurate. Consider using '#align convex_halfspace_gt convex_halfspace_gtâ‚“'. -/
theorem convex_halfspace_gt {f : E â†’ Î²} (h : IsLinearMap ğ•œ f) (r : Î²) : Convex ğ•œ { w | r < f w } :=
  (convex_Ioi r).is_linear_preimage h
#align convex_halfspace_gt convex_halfspace_gt

end OrderedCancelAddCommMonoid

section LinearOrderedAddCommMonoid

variable [LinearOrderedAddCommMonoid Î²] [Module ğ•œ Î²] [OrderedSMul ğ•œ Î²]

/- warning: convex_uIcc -> convex_uIcc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_6 : LinearOrderedAddCommMonoid.{u2} Î²] [_inst_7 : Module.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))] [_inst_8 : OrderedSMul.{u1, u2} ğ•œ Î² _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6)) _inst_7))] (r : Î²) (s : Î²), Convex.{u1, u2} ğ•œ Î² _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ Î² (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ Î² (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ Î² (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} Î² (AddMonoid.toAddZeroClass.{u2} Î² (AddCommMonoid.toAddMonoid.{u2} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ Î² (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Î² _inst_6)) _inst_7)))) (Set.uIcc.{u2} Î² (LinearOrder.toLattice.{u2} Î² (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Î² _inst_6)) r s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {Î² : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_6 : LinearOrderedAddCommMonoid.{u1} Î²] [_inst_7 : Module.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6)] [_inst_8 : OrderedSMul.{u2, u1} ğ•œ Î² _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (OrderedAddCommMonoid.toAddCommMonoid.{u1} Î² (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} Î² _inst_6)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7))] (r : Î²) (s : Î²), Convex.{u2, u1} ğ•œ Î² _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) (SMulZeroClass.toSMul.{u2, u1} ğ•œ Î² (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ Î² (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ Î² (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} Î² (AddCommMonoid.toAddMonoid.{u1} Î² (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6))) (Module.toMulActionWithZero.{u2, u1} ğ•œ Î² (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Î² _inst_6) _inst_7)))) (Set.uIcc.{u1} Î² (DistribLattice.toLattice.{u1} Î² (instDistribLattice.{u1} Î² (LinearOrderedAddCommMonoid.toLinearOrder.{u1} Î² _inst_6))) r s)
Case conversion may be inaccurate. Consider using '#align convex_uIcc convex_uIccâ‚“'. -/
theorem convex_uIcc (r s : Î²) : Convex ğ•œ (uIcc r s) :=
  convex_Icc _ _
#align convex_uIcc convex_uIcc

end LinearOrderedAddCommMonoid

end Module

end AddCommMonoid

section LinearOrderedAddCommMonoid

variable [LinearOrderedAddCommMonoid E] [OrderedAddCommMonoid Î²] [Module ğ•œ E] [OrderedSMul ğ•œ E]
  {s : Set E} {f : E â†’ Î²}

/- warning: monotone_on.convex_le -> MonotoneOn.convex_le is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (MonotoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (MonotoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r))))
Case conversion may be inaccurate. Consider using '#align monotone_on.convex_le MonotoneOn.convex_leâ‚“'. -/
theorem MonotoneOn.convex_le (hf : MonotoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | f x â‰¤ r }) := fun x hx y hy a b ha hb hab =>
  âŸ¨hs hx.1 hy.1 ha hb hab,
    (hf (hs hx.1 hy.1 ha hb hab) (max_rec' s hx.1 hy.1) (Convex.combo_le_max x y ha hb hab)).trans
      (max_rec' _ hx.2 hy.2)âŸ©
#align monotone_on.convex_le MonotoneOn.convex_le

/- warning: monotone_on.convex_lt -> MonotoneOn.convex_lt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (MonotoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (MonotoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r))))
Case conversion may be inaccurate. Consider using '#align monotone_on.convex_lt MonotoneOn.convex_ltâ‚“'. -/
theorem MonotoneOn.convex_lt (hf : MonotoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | f x < r }) := fun x hx y hy a b ha hb hab =>
  âŸ¨hs hx.1 hy.1 ha hb hab,
    (hf (hs hx.1 hy.1 ha hb hab) (max_rec' s hx.1 hy.1)
          (Convex.combo_le_max x y ha hb hab)).trans_lt
      (max_rec' _ hx.2 hy.2)âŸ©
#align monotone_on.convex_lt MonotoneOn.convex_lt

/- warning: monotone_on.convex_ge -> MonotoneOn.convex_ge is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (MonotoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) r (f x)) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (MonotoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) r (f x)))))
Case conversion may be inaccurate. Consider using '#align monotone_on.convex_ge MonotoneOn.convex_geâ‚“'. -/
theorem MonotoneOn.convex_ge (hf : MonotoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | r â‰¤ f x }) :=
  @MonotoneOn.convex_le ğ•œ Eáµ’áµˆ Î²áµ’áµˆ _ _ _ _ _ _ _ hf.dual hs r
#align monotone_on.convex_ge MonotoneOn.convex_ge

/- warning: monotone_on.convex_gt -> MonotoneOn.convex_gt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (MonotoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) r (f x)) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (MonotoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) r (f x)))))
Case conversion may be inaccurate. Consider using '#align monotone_on.convex_gt MonotoneOn.convex_gtâ‚“'. -/
theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | r < f x }) :=
  @MonotoneOn.convex_lt ğ•œ Eáµ’áµˆ Î²áµ’áµˆ _ _ _ _ _ _ _ hf.dual hs r
#align monotone_on.convex_gt MonotoneOn.convex_gt

/- warning: antitone_on.convex_le -> AntitoneOn.convex_le is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (AntitoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (AntitoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r))))
Case conversion may be inaccurate. Consider using '#align antitone_on.convex_le AntitoneOn.convex_leâ‚“'. -/
theorem AntitoneOn.convex_le (hf : AntitoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | f x â‰¤ r }) :=
  @MonotoneOn.convex_ge ğ•œ E Î²áµ’áµˆ _ _ _ _ _ _ _ hf hs r
#align antitone_on.convex_le AntitoneOn.convex_le

/- warning: antitone_on.convex_lt -> AntitoneOn.convex_lt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (AntitoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (AntitoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r))))
Case conversion may be inaccurate. Consider using '#align antitone_on.convex_lt AntitoneOn.convex_ltâ‚“'. -/
theorem AntitoneOn.convex_lt (hf : AntitoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | f x < r }) :=
  @MonotoneOn.convex_gt ğ•œ E Î²áµ’áµˆ _ _ _ _ _ _ _ hf hs r
#align antitone_on.convex_lt AntitoneOn.convex_lt

/- warning: antitone_on.convex_ge -> AntitoneOn.convex_ge is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (AntitoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) r (f x)) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (AntitoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) r (f x)))))
Case conversion may be inaccurate. Consider using '#align antitone_on.convex_ge AntitoneOn.convex_geâ‚“'. -/
theorem AntitoneOn.convex_ge (hf : AntitoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | r â‰¤ f x }) :=
  @MonotoneOn.convex_le ğ•œ E Î²áµ’áµˆ _ _ _ _ _ _ _ hf hs r
#align antitone_on.convex_ge AntitoneOn.convex_ge

/- warning: antitone_on.convex_gt -> AntitoneOn.convex_gt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {s : Set.{u2} E} {f : E -> Î²}, (AntitoneOn.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) r (f x)) s))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {s : Set.{u3} E} {f : E -> Î²}, (AntitoneOn.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f s) -> (Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) s) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => And (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) x s) (LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) r (f x)))))
Case conversion may be inaccurate. Consider using '#align antitone_on.convex_gt AntitoneOn.convex_gtâ‚“'. -/
theorem AntitoneOn.convex_gt (hf : AntitoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | r < f x }) :=
  @MonotoneOn.convex_lt ğ•œ E Î²áµ’áµˆ _ _ _ _ _ _ _ hf hs r
#align antitone_on.convex_gt AntitoneOn.convex_gt

/- warning: monotone.convex_le -> Monotone.convex_le is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Monotone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Monotone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r)))
Case conversion may be inaccurate. Consider using '#align monotone.convex_le Monotone.convex_leâ‚“'. -/
theorem Monotone.convex_le (hf : Monotone f) (r : Î²) : Convex ğ•œ { x | f x â‰¤ r } :=
  Set.sep_univ.subst ((hf.MonotoneOn univ).convex_le convex_univ r)
#align monotone.convex_le Monotone.convex_le

/- warning: monotone.convex_lt -> Monotone.convex_lt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Monotone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Monotone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r)))
Case conversion may be inaccurate. Consider using '#align monotone.convex_lt Monotone.convex_ltâ‚“'. -/
theorem Monotone.convex_lt (hf : Monotone f) (r : Î²) : Convex ğ•œ { x | f x â‰¤ r } :=
  Set.sep_univ.subst ((hf.MonotoneOn univ).convex_le convex_univ r)
#align monotone.convex_lt Monotone.convex_lt

/- warning: monotone.convex_ge -> Monotone.convex_ge is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Monotone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) r (f x))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Monotone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) r (f x))))
Case conversion may be inaccurate. Consider using '#align monotone.convex_ge Monotone.convex_geâ‚“'. -/
theorem Monotone.convex_ge (hf : Monotone f) (r : Î²) : Convex ğ•œ { x | r â‰¤ f x } :=
  Set.sep_univ.subst ((hf.MonotoneOn univ).convex_ge convex_univ r)
#align monotone.convex_ge Monotone.convex_ge

/- warning: monotone.convex_gt -> Monotone.convex_gt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Monotone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Monotone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r)))
Case conversion may be inaccurate. Consider using '#align monotone.convex_gt Monotone.convex_gtâ‚“'. -/
theorem Monotone.convex_gt (hf : Monotone f) (r : Î²) : Convex ğ•œ { x | f x â‰¤ r } :=
  Set.sep_univ.subst ((hf.MonotoneOn univ).convex_le convex_univ r)
#align monotone.convex_gt Monotone.convex_gt

/- warning: antitone.convex_le -> Antitone.convex_le is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Antitone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Antitone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r)))
Case conversion may be inaccurate. Consider using '#align antitone.convex_le Antitone.convex_leâ‚“'. -/
theorem Antitone.convex_le (hf : Antitone f) (r : Î²) : Convex ğ•œ { x | f x â‰¤ r } :=
  Set.sep_univ.subst ((hf.AntitoneOn univ).convex_le convex_univ r)
#align antitone.convex_le Antitone.convex_le

/- warning: antitone.convex_lt -> Antitone.convex_lt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Antitone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) (f x) r)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Antitone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) (f x) r)))
Case conversion may be inaccurate. Consider using '#align antitone.convex_lt Antitone.convex_ltâ‚“'. -/
theorem Antitone.convex_lt (hf : Antitone f) (r : Î²) : Convex ğ•œ { x | f x < r } :=
  Set.sep_univ.subst ((hf.AntitoneOn univ).convex_lt convex_univ r)
#align antitone.convex_lt Antitone.convex_lt

/- warning: antitone.convex_ge -> Antitone.convex_ge is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Antitone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LE.le.{u3} Î² (Preorder.toHasLe.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) r (f x))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Antitone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LE.le.{u2} Î² (Preorder.toLE.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) r (f x))))
Case conversion may be inaccurate. Consider using '#align antitone.convex_ge Antitone.convex_geâ‚“'. -/
theorem Antitone.convex_ge (hf : Antitone f) (r : Î²) : Convex ğ•œ { x | r â‰¤ f x } :=
  Set.sep_univ.subst ((hf.AntitoneOn univ).convex_ge convex_univ r)
#align antitone.convex_ge Antitone.convex_ge

/- warning: antitone.convex_gt -> Antitone.convex_gt is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {Î² : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : OrderedAddCommMonoid.{u3} Î²] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_5 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4))] {f : E -> Î²}, (Antitone.{u2, u3} E Î² (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_4)))) (setOf.{u2} E (fun (x : E) => LT.lt.{u3} Î² (Preorder.toHasLt.{u3} Î² (PartialOrder.toPreorder.{u3} Î² (OrderedAddCommMonoid.toPartialOrder.{u3} Î² _inst_3))) r (f x))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {Î² : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u3} E] [_inst_3 : OrderedAddCommMonoid.{u2} Î²] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2)] [_inst_5 : OrderedSMul.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (OrderedAddCommMonoid.toAddCommMonoid.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4))] {f : E -> Î²}, (Antitone.{u3, u2} E Î² (PartialOrder.toPreorder.{u3} E (OrderedAddCommMonoid.toPartialOrder.{u3} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} E _inst_2))) (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3)) f) -> (forall (r : Î²), Convex.{u1, u3} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2))) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} E _inst_2) _inst_4)))) (setOf.{u3} E (fun (x : E) => LT.lt.{u2} Î² (Preorder.toLT.{u2} Î² (PartialOrder.toPreorder.{u2} Î² (OrderedAddCommMonoid.toPartialOrder.{u2} Î² _inst_3))) r (f x))))
Case conversion may be inaccurate. Consider using '#align antitone.convex_gt Antitone.convex_gtâ‚“'. -/
theorem Antitone.convex_gt (hf : Antitone f) (r : Î²) : Convex ğ•œ { x | r < f x } :=
  Set.sep_univ.subst ((hf.AntitoneOn univ).convex_gt convex_univ r)
#align antitone.convex_gt Antitone.convex_gt

end LinearOrderedAddCommMonoid

end OrderedSemiring

section OrderedCommSemiring

variable [OrderedCommSemiring ğ•œ]

section AddCommMonoid

variable [AddCommMonoid E] [AddCommMonoid F] [Module ğ•œ E] [Module ğ•œ F] {s : Set E}

/- warning: convex.smul -> Convex.smul is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) s) -> (forall (c : ğ•œ), Convex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4))))) c s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedCommSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) s) -> (forall (c : ğ•œ), Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))))) c s))
Case conversion may be inaccurate. Consider using '#align convex.smul Convex.smulâ‚“'. -/
theorem Convex.smul (hs : Convex ğ•œ s) (c : ğ•œ) : Convex ğ•œ (c â€¢ s) :=
  hs.linear_image (LinearMap.lsmul _ _ c)
#align convex.smul Convex.smul

/- warning: convex.smul_preimage -> Convex.smul_preimage is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) s) -> (forall (c : ğ•œ), Convex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) (Set.preimage.{u2, u2} E E (fun (z : E) => SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) c z) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedCommSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) s) -> (forall (c : ğ•œ), Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) (Set.preimage.{u1, u1} E E (fun (z : E) => HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4))))) c z) s))
Case conversion may be inaccurate. Consider using '#align convex.smul_preimage Convex.smul_preimageâ‚“'. -/
theorem Convex.smul_preimage (hs : Convex ğ•œ s) (c : ğ•œ) : Convex ğ•œ ((fun z => c â€¢ z) â»Â¹' s) :=
  hs.linear_preimage (LinearMap.lsmul _ _ c)
#align convex.smul_preimage Convex.smul_preimage

/- warning: convex.affinity -> Convex.affinity is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) s) -> (forall (z : E) (c : ğ•œ), Convex.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) z (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ _inst_1)) _inst_2 _inst_4)))) c x)) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedCommSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) s) -> (forall (z : E) (c : ğ•œ), Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1) _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4)))) (Set.image.{u1, u1} E E (fun (x : E) => HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) z (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (OrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ _inst_1)) _inst_2 _inst_4))))) c x)) s))
Case conversion may be inaccurate. Consider using '#align convex.affinity Convex.affinityâ‚“'. -/
theorem Convex.affinity (hs : Convex ğ•œ s) (z : E) (c : ğ•œ) : Convex ğ•œ ((fun x => z + c â€¢ x) '' s) :=
  by simpa only [â† image_smul, â† image_vadd, image_image] using (hs.smul c).vadd z
#align convex.affinity Convex.affinity

end AddCommMonoid

end OrderedCommSemiring

section StrictOrderedCommSemiring

variable [StrictOrderedCommSemiring ğ•œ] [AddCommGroup E] [Module ğ•œ E]

/- warning: convex_open_segment -> convex_openSegment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : StrictOrderedCommSemiring.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E), Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (openSegment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) a b)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : StrictOrderedCommSemiring.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] (a : E) (b : E), Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (StrictOrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (openSegment.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (StrictOrderedCommSemiring.toCommSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) a b)
Case conversion may be inaccurate. Consider using '#align convex_open_segment convex_openSegmentâ‚“'. -/
theorem convex_openSegment (a b : E) : Convex ğ•œ (openSegment ğ•œ a b) :=
  by
  rw [convex_iff_openSegment_subset]
  rintro p âŸ¨ap, bp, hap, hbp, habp, rflâŸ© q âŸ¨aq, bq, haq, hbq, habq, rflâŸ© z âŸ¨a, b, ha, hb, hab, rflâŸ©
  refine' âŸ¨a * ap + b * aq, a * bp + b * bq, by positivity, by positivity, _, _âŸ©
  Â· rw [add_add_add_comm, â† mul_add, â† mul_add, habp, habq, mul_one, mul_one, hab]
  Â· simp_rw [add_smul, mul_smul, smul_add, add_add_add_comm]
#align convex_open_segment convex_openSegment

end StrictOrderedCommSemiring

section OrderedRing

variable [OrderedRing ğ•œ]

section AddCommGroup

variable [AddCommGroup E] [AddCommGroup F] [Module ğ•œ E] [Module ğ•œ F] {s t : Set E}

/- warning: convex.add_smul_mem -> Convex.add_smul_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (forall {x : E} {y : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x y) s) -> (forall {t : ğ•œ}, (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) t (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) t y)) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) -> (forall {x : E} {y : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x y) s) -> (forall {t : ğ•œ}, (Membership.mem.{u2, u2} ğ•œ (Set.{u2} ğ•œ) (Set.instMembershipSet.{u2} ğ•œ) t (Set.Icc.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1)) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) t y)) s)))
Case conversion may be inaccurate. Consider using '#align convex.add_smul_mem Convex.add_smul_memâ‚“'. -/
theorem Convex.add_smul_mem (hs : Convex ğ•œ s) {x y : E} (hx : x âˆˆ s) (hy : x + y âˆˆ s) {t : ğ•œ}
    (ht : t âˆˆ Icc (0 : ğ•œ) 1) : x + t â€¢ y âˆˆ s :=
  by
  have h : x + t â€¢ y = (1 - t) â€¢ x + t â€¢ (x + y) := by
    rw [smul_add, â† add_assoc, â† add_smul, sub_add_cancel, one_smul]
  rw [h]
  exact hs hx hy (sub_nonneg_of_le ht.2) ht.1 (sub_add_cancel _ _)
#align convex.add_smul_mem Convex.add_smul_mem

/- warning: convex.smul_mem_of_zero_mem -> Convex.smul_mem_of_zero_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (forall {x : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {t : ğ•œ}, (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) t (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) t x) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) -> (forall {x : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))))) s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {t : ğ•œ}, (Membership.mem.{u2, u2} ğ•œ (Set.{u2} ğ•œ) (Set.instMembershipSet.{u2} ğ•œ) t (Set.Icc.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1)) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) t x) s)))
Case conversion may be inaccurate. Consider using '#align convex.smul_mem_of_zero_mem Convex.smul_mem_of_zero_memâ‚“'. -/
theorem Convex.smul_mem_of_zero_mem (hs : Convex ğ•œ s) {x : E} (zero_mem : (0 : E) âˆˆ s) (hx : x âˆˆ s)
    {t : ğ•œ} (ht : t âˆˆ Icc (0 : ğ•œ) 1) : t â€¢ x âˆˆ s := by
  simpa using hs.add_smul_mem zero_mem (by simpa using hx) ht
#align convex.smul_mem_of_zero_mem Convex.smul_mem_of_zero_mem

/- warning: convex.add_smul_sub_mem -> Convex.add_smul_sub_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (forall {x : E} {y : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (forall {t : ğ•œ}, (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) t (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) t (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) y x))) s)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) -> (forall {x : E} {y : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (forall {t : ğ•œ}, (Membership.mem.{u2, u2} ğ•œ (Set.{u2} ğ•œ) (Set.instMembershipSet.{u2} ğ•œ) t (Set.Icc.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_1)) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))))))) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) t (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))) y x))) s)))
Case conversion may be inaccurate. Consider using '#align convex.add_smul_sub_mem Convex.add_smul_sub_memâ‚“'. -/
theorem Convex.add_smul_sub_mem (h : Convex ğ•œ s) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) {t : ğ•œ}
    (ht : t âˆˆ Icc (0 : ğ•œ) 1) : x + t â€¢ (y - x) âˆˆ s :=
  by
  apply h.segment_subset hx hy
  rw [segment_eq_image']
  exact mem_image_of_mem _ ht
#align convex.add_smul_sub_mem Convex.add_smul_sub_mem

/- warning: affine_subspace.convex -> AffineSubspace.convex is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (Q : AffineSubspace.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))), Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AffineSubspace.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (Set.{u2} E) (HasLiftT.mk.{succ u2, succ u2} (AffineSubspace.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (Set.{u2} E) (CoeTCâ‚“.coe.{succ u2, succ u2} (AffineSubspace.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (Set.{u2} E) (SetLike.Set.hasCoeT.{u2, u2} (AffineSubspace.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) E (AffineSubspace.setLike.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) Q)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] (Q : AffineSubspace.{u2, u1, u1} ğ•œ E E (OrderedRing.toRing.{u2} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2))), Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) (SetLike.coe.{u1, u1} (AffineSubspace.{u2, u1, u1} ğ•œ E E (OrderedRing.toRing.{u2} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2))) E (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u1} ğ•œ E E (OrderedRing.toRing.{u2} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2))) Q)
Case conversion may be inaccurate. Consider using '#align affine_subspace.convex AffineSubspace.convexâ‚“'. -/
/-- Affine subspaces are convex. -/
theorem AffineSubspace.convex (Q : AffineSubspace ğ•œ E) : Convex ğ•œ (Q : Set E) :=
  by
  intro x hx y hy a b ha hb hab
  rw [eq_sub_of_add_eq hab, â† AffineMap.lineMap_apply_module]
  exact AffineMap.lineMap_mem b hx hy
#align affine_subspace.convex AffineSubspace.convex

/- warning: convex.affine_preimage -> Convex.affine_preimage is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] (f : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) {s : Set.{u3} F}, (Convex.{u1, u3} ğ•œ F (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_5)))) s) -> (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (Set.preimage.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedRing.{u3} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] (f : AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) {s : Set.{u1} F}, (Convex.{u3, u1} ğ•œ F (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3) (SMulZeroClass.toSMul.{u3, u1} ğ•œ F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ F (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ F (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (Module.toMulActionWithZero.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3) _inst_5)))) s) -> (Convex.{u3, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (Set.preimage.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) s))
Case conversion may be inaccurate. Consider using '#align convex.affine_preimage Convex.affine_preimageâ‚“'. -/
/-- The preimage of a convex set under an affine map is convex. -/
theorem Convex.affine_preimage (f : E â†’áµƒ[ğ•œ] F) {s : Set F} (hs : Convex ğ•œ s) : Convex ğ•œ (f â»Â¹' s) :=
  fun x hx => (hs hx).affine_preimage _
#align convex.affine_preimage Convex.affine_preimage

/- warning: convex.affine_image -> Convex.affine_image is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] {s : Set.{u2} E} (f : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))), (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (Convex.{u1, u3} ğ•œ F (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_5)))) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) s))
but is expected to have type
  forall {ğ•œ : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedRing.{u3} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_4 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] {s : Set.{u2} E} (f : AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))), (Convex.{u3, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (Convex.{u3, u1} ğ•œ F (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3) (SMulZeroClass.toSMul.{u3, u1} ğ•œ F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ F (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ F (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (Module.toMulActionWithZero.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3) _inst_5)))) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) s))
Case conversion may be inaccurate. Consider using '#align convex.affine_image Convex.affine_imageâ‚“'. -/
/-- The image of a convex set under an affine map is convex. -/
theorem Convex.affine_image (f : E â†’áµƒ[ğ•œ] F) (hs : Convex ğ•œ s) : Convex ğ•œ (f '' s) :=
  by
  rintro _ âŸ¨x, hx, rflâŸ©
  exact (hs hx).affine_image _
#align convex.affine_image Convex.affine_image

/- warning: convex.neg -> Convex.neg is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (Neg.neg.{u2} (Set.{u2} E) (Set.neg.{u2} E (SubNegMonoid.toHasNeg.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) s))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) -> (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) (Neg.neg.{u1} (Set.{u1} E) (Set.neg.{u1} E (NegZeroClass.toNeg.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2)))))) s))
Case conversion may be inaccurate. Consider using '#align convex.neg Convex.negâ‚“'. -/
theorem Convex.neg (hs : Convex ğ•œ s) : Convex ğ•œ (-s) :=
  hs.is_linear_preimage IsLinearMap.isLinearMap_neg
#align convex.neg Convex.neg

/- warning: convex.sub -> Convex.sub is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {t : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) t) -> (Convex.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (HSub.hSub.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHSub.{u2} (Set.{u2} E) (Set.sub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) s t))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {t : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) -> (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) t) -> (Convex.{u2, u1} ğ•œ E (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) (HSub.hSub.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHSub.{u1} (Set.{u1} E) (Set.sub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2))))) s t))
Case conversion may be inaccurate. Consider using '#align convex.sub Convex.subâ‚“'. -/
theorem Convex.sub (hs : Convex ğ•œ s) (ht : Convex ğ•œ t) : Convex ğ•œ (s - t) :=
  by
  rw [sub_eq_add_neg]
  exact hs.add ht.neg
#align convex.sub Convex.sub

end AddCommGroup

end OrderedRing

section LinearOrderedField

variable [LinearOrderedField ğ•œ]

section AddCommGroup

variable [AddCommGroup E] [AddCommGroup F] [Module ğ•œ E] [Module ğ•œ F] {s : Set E}

/- warning: convex_iff_div -> convex_iff_div is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, Iff (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) (forall {{x : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {{y : E}}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) b) -> (LT.lt.{u1} ğ•œ (Preorder.toHasLt.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b)) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (DivisionRing.toDivInvMonoid.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) a (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b)) x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (DivisionRing.toDivInvMonoid.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) b (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b)) y)) s))))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, Iff (Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) (forall {{x : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {{y : E}}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y s) -> (forall {{a : ğ•œ}} {{b : ğ•œ}}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) b) -> (LT.lt.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))))))) a b)) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) (HDiv.hDiv.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHDiv.{u2} ğ•œ (LinearOrderedField.toDiv.{u2} ğ•œ _inst_1)) a (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))))))) a b)) x) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4))))) (HDiv.hDiv.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHDiv.{u2} ğ•œ (LinearOrderedField.toDiv.{u2} ğ•œ _inst_1)) b (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))))))) a b)) y)) s))))
Case conversion may be inaccurate. Consider using '#align convex_iff_div convex_iff_divâ‚“'. -/
/-- Alternative definition of set convexity, using division. -/
theorem convex_iff_div :
    Convex ğ•œ s â†”
      âˆ€ â¦ƒxâ¦„,
        x âˆˆ s â†’
          âˆ€ â¦ƒyâ¦„,
            y âˆˆ s â†’
              âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s :=
  forallâ‚‚_congr fun x hx => starConvex_iff_div
#align convex_iff_div convex_iff_div

/- warning: convex.mem_smul_of_zero_mem -> Convex.mem_smul_of_zero_mem is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (forall {x : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))))) s) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x s) -> (forall {t : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))))) t) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4))))) t s))))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) -> (forall {x : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))))) s) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x s) -> (forall {t : ğ•œ}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))))) t) -> (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))))) t s))))
Case conversion may be inaccurate. Consider using '#align convex.mem_smul_of_zero_mem Convex.mem_smul_of_zero_memâ‚“'. -/
theorem Convex.mem_smul_of_zero_mem (h : Convex ğ•œ s) {x : E} (zero_mem : (0 : E) âˆˆ s) (hx : x âˆˆ s)
    {t : ğ•œ} (ht : 1 â‰¤ t) : x âˆˆ t â€¢ s :=
  by
  rw [mem_smul_set_iff_inv_smul_memâ‚€ (zero_lt_one.trans_le ht).ne']
  exact h.smul_mem_of_zero_mem zero_mem hx âŸ¨inv_nonneg.2 (zero_le_one.trans ht), inv_le_one htâŸ©
#align convex.mem_smul_of_zero_mem Convex.mem_smul_of_zero_mem

/- warning: convex.add_smul -> Convex.add_smul is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) s) -> (forall {p : ğ•œ} {q : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) p) -> (LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) q) -> (Eq.{succ u2} (Set.{u2} E) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4))))) (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) p q) s) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} E) (Set.{u2} E) (Set.{u2} E) (instHAdd.{u2} (Set.{u2} E) (Set.add.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4))))) p s) (SMul.smul.{u1, u2} ğ•œ (Set.{u2} E) (Set.smulSet.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4))))) q s))))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_4 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, (Convex.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))) s) -> (forall {p : ğ•œ} {q : ğ•œ}, (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) p) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))))) q) -> (Eq.{succ u1} (Set.{u1} E) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))))) (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))))))) p q) s) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} E) (Set.{u1} E) (Set.{u1} E) (instHAdd.{u1} (Set.{u1} E) (Set.add.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2))))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))))) p s) (HSMul.hSMul.{u2, u1, u1} ğ•œ (Set.{u1} E) (Set.{u1} E) (instHSMul.{u2, u1} ğ•œ (Set.{u1} E) (Set.smulSet.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ğ•œ (Semifield.toCommGroupWithZero.{u2} ğ•œ (LinearOrderedSemifield.toSemifield.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_4)))))) q s))))
Case conversion may be inaccurate. Consider using '#align convex.add_smul Convex.add_smulâ‚“'. -/
theorem Convex.add_smul (h_conv : Convex ğ•œ s) {p q : ğ•œ} (hp : 0 â‰¤ p) (hq : 0 â‰¤ q) :
    (p + q) â€¢ s = p â€¢ s + q â€¢ s :=
  by
  obtain rfl | hs := s.eq_empty_or_nonempty
  Â· simp_rw [smul_set_empty, add_empty]
  obtain rfl | hp' := hp.eq_or_lt
  Â· rw [zero_add, zero_smul_set hs, zero_add]
  obtain rfl | hq' := hq.eq_or_lt
  Â· rw [add_zero, zero_smul_set hs, add_zero]
  ext
  constructor
  Â· rintro âŸ¨v, hv, rflâŸ©
    exact âŸ¨p â€¢ v, q â€¢ v, smul_mem_smul_set hv, smul_mem_smul_set hv, (add_smul _ _ _).symmâŸ©
  Â· rintro âŸ¨vâ‚, vâ‚‚, âŸ¨vâ‚â‚, hâ‚â‚‚, rflâŸ©, âŸ¨vâ‚‚â‚, hâ‚‚â‚‚, rflâŸ©, rflâŸ©
    have hpq := add_pos hp' hq'
    refine'
        mem_smul_set.2
          âŸ¨_,
            h_conv hâ‚â‚‚ hâ‚‚â‚‚ _ _
              (by rw [â† div_self hpq.ne', add_div] : p / (p + q) + q / (p + q) = 1),
            by simp only [â† mul_smul, smul_add, mul_div_cancel' _ hpq.ne']âŸ© <;>
      positivity
#align convex.add_smul Convex.add_smul

end AddCommGroup

end LinearOrderedField

/-!
#### Convex sets in an ordered space
Relates `convex` and `ord_connected`.
-/


section

/- warning: set.ord_connected.convex_of_chain -> Set.OrdConnected.convex_of_chain is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : OrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3))] {s : Set.{u2} E}, (Set.OrdConnected.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2)) s) -> (IsChain.{u2} E (LE.le.{u2} E (Preorder.toHasLe.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2)))) s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : OrderedAddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : OrderedSMul.{u2, u1} ğ•œ E _inst_1 _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))] {s : Set.{u1} E}, (Set.OrdConnected.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E _inst_2)) s) -> (IsChain.{u1} E (fun (x._@.Mathlib.Analysis.Convex.Basic._hyg.6965 : E) (x._@.Mathlib.Analysis.Convex.Basic._hyg.6967 : E) => LE.le.{u1} E (Preorder.toLE.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E _inst_2))) x._@.Mathlib.Analysis.Convex.Basic._hyg.6965 x._@.Mathlib.Analysis.Convex.Basic._hyg.6967) s) -> (Convex.{u2, u1} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) s)
Case conversion may be inaccurate. Consider using '#align set.ord_connected.convex_of_chain Set.OrdConnected.convex_of_chainâ‚“'. -/
theorem Set.OrdConnected.convex_of_chain [OrderedSemiring ğ•œ] [OrderedAddCommMonoid E] [Module ğ•œ E]
    [OrderedSMul ğ•œ E] {s : Set E} (hs : s.OrdConnected) (h : IsChain (Â· â‰¤ Â·) s) : Convex ğ•œ s :=
  by
  refine' convex_iff_segment_subset.mpr fun x hx y hy => _
  obtain hxy | hyx := h.total hx hy
  Â· exact (segment_subset_Icc hxy).trans (hs.out hx hy)
  Â· rw [segment_symm]
    exact (segment_subset_Icc hyx).trans (hs.out hy hx)
#align set.ord_connected.convex_of_chain Set.OrdConnected.convex_of_chain

/- warning: set.ord_connected.convex -> Set.OrdConnected.convex is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3))] {s : Set.{u2} E}, (Set.OrdConnected.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))) s) -> (Convex.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3)))) s)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : OrderedSMul.{u2, u1} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))] {s : Set.{u1} E}, (Set.OrdConnected.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2))) s) -> (Convex.{u2, u1} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) s)
Case conversion may be inaccurate. Consider using '#align set.ord_connected.convex Set.OrdConnected.convexâ‚“'. -/
theorem Set.OrdConnected.convex [OrderedSemiring ğ•œ] [LinearOrderedAddCommMonoid E] [Module ğ•œ E]
    [OrderedSMul ğ•œ E] {s : Set E} (hs : s.OrdConnected) : Convex ğ•œ s :=
  hs.convex_of_chain <| isChain_of_trichotomous s
#align set.ord_connected.convex Set.OrdConnected.convex

/- warning: convex_iff_ord_connected -> convex_iff_ordConnected is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {s : Set.{u1} ğ•œ}, Iff (Convex.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) s) (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) s)
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {s : Set.{u1} ğ•œ}, Iff (Convex.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (StrictOrderedCommSemiring.toCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (Algebra.id.{u1} ğ•œ (StrictOrderedCommSemiring.toCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))))) s) (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) s)
Case conversion may be inaccurate. Consider using '#align convex_iff_ord_connected convex_iff_ordConnectedâ‚“'. -/
theorem convex_iff_ordConnected [LinearOrderedField ğ•œ] {s : Set ğ•œ} : Convex ğ•œ s â†” s.OrdConnected :=
  by simp_rw [convex_iff_segment_subset, segment_eq_uIcc, ord_connected_iff_uIcc_subset]
#align convex_iff_ord_connected convex_iff_ordConnected

/- warning: convex.ord_connected -> Convex.ordConnected is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {s : Set.{u1} ğ•œ}, (Convex.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) s) -> (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) s)
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {s : Set.{u1} ğ•œ}, (Convex.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (StrictOrderedCommSemiring.toCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (Algebra.id.{u1} ğ•œ (StrictOrderedCommSemiring.toCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))))) s) -> (Set.OrdConnected.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) s)
Case conversion may be inaccurate. Consider using '#align convex.ord_connected Convex.ordConnectedâ‚“'. -/
alias convex_iff_ordConnected â†” Convex.ordConnected _
#align convex.ord_connected Convex.ordConnected

end

/-! #### Convexity of submodules/subspaces -/


namespace Submodule

variable [OrderedSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E]

/- warning: submodule.convex -> Submodule.convex is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (K : Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3), Convex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3)))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) (Set.{u2} E) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) (Set.{u2} E) (CoeTCâ‚“.coe.{succ u2, succ u2} (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) (Set.{u2} E) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) E (Submodule.setLike.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3)))) K)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] (K : Submodule.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3), Convex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3)))) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3) E (Submodule.setLike.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3) K)
Case conversion may be inaccurate. Consider using '#align submodule.convex Submodule.convexâ‚“'. -/
protected theorem convex (K : Submodule ğ•œ E) : Convex ğ•œ (â†‘K : Set E) :=
  by
  repeat' intro
  refine' add_mem (smul_mem _ _ _) (smul_mem _ _ _) <;> assumption
#align submodule.convex Submodule.convex

/- warning: submodule.star_convex -> Submodule.starConvex is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] (K : Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3), StarConvex.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3)))) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) (Set.{u2} E) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) (Set.{u2} E) (CoeTCâ‚“.coe.{succ u2, succ u2} (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) (Set.{u2} E) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3) E (Submodule.setLike.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_3)))) K)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2] (K : Submodule.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3), StarConvex.{u2, u1} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3)))) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3) E (Submodule.setLike.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) _inst_2 _inst_3) K)
Case conversion may be inaccurate. Consider using '#align submodule.star_convex Submodule.starConvexâ‚“'. -/
protected theorem starConvex (K : Submodule ğ•œ E) : StarConvex ğ•œ (0 : E) K :=
  K.Convex K.zero_mem
#align submodule.star_convex Submodule.starConvex

end Submodule

/-! ### Simplex -/


section Simplex

variable (ğ•œ) (Î¹ : Type _) [OrderedSemiring ğ•œ] [Fintype Î¹]

#print stdSimplex /-
/-- The standard simplex in the space of functions `Î¹ â†’ ğ•œ` is the set of vectors with non-negative
coordinates with total sum `1`. This is the free object in the category of convex spaces. -/
def stdSimplex : Set (Î¹ â†’ ğ•œ) :=
  { f | (âˆ€ x, 0 â‰¤ f x) âˆ§ (âˆ‘ x, f x) = 1 }
#align std_simplex stdSimplex
-/

/- warning: std_simplex_eq_inter -> stdSimplex_eq_inter is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (Î¹ : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : Fintype.{u2} Î¹], Eq.{succ (max u2 u1)} (Set.{max u2 u1} (Î¹ -> ğ•œ)) (stdSimplex.{u1, u2} ğ•œ Î¹ _inst_1 _inst_2) (Inter.inter.{max u2 u1} (Set.{max u2 u1} (Î¹ -> ğ•œ)) (Set.hasInter.{max u2 u1} (Î¹ -> ğ•œ)) (Set.iInter.{max u2 u1, succ u2} (Î¹ -> ğ•œ) Î¹ (fun (x : Î¹) => setOf.{max u2 u1} (Î¹ -> ğ•œ) (fun (f : Î¹ -> ğ•œ) => LE.le.{u1} ğ•œ (Preorder.toHasLe.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) (f x)))) (setOf.{max u2 u1} (Î¹ -> ğ•œ) (fun (f : Î¹ -> ğ•œ) => Eq.{succ u1} ğ•œ (Finset.sum.{u1, u2} ğ•œ Î¹ (OrderedAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)) (Finset.univ.{u2} Î¹ _inst_2) (fun (x : Î¹) => f x)) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u2}) (Î¹ : Type.{u1}) [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : Fintype.{u1} Î¹], Eq.{max (succ u2) (succ u1)} (Set.{max u2 u1} (Î¹ -> ğ•œ)) (stdSimplex.{u2, u1} ğ•œ Î¹ _inst_1 _inst_2) (Inter.inter.{max u2 u1} (Set.{max u2 u1} (Î¹ -> ğ•œ)) (Set.instInterSet.{max u2 u1} (Î¹ -> ğ•œ)) (Set.iInter.{max u2 u1, succ u1} (Î¹ -> ğ•œ) Î¹ (fun (x : Î¹) => setOf.{max u2 u1} (Î¹ -> ğ•œ) (fun (f : Î¹ -> ğ•œ) => LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) (f x)))) (setOf.{max u2 u1} (Î¹ -> ğ•œ) (fun (f : Î¹ -> ğ•œ) => Eq.{succ u2} ğ•œ (Finset.sum.{u2, u1} ğ•œ Î¹ (OrderedAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u2} ğ•œ _inst_1)) (Finset.univ.{u1} Î¹ _inst_2) (fun (x : Î¹) => f x)) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align std_simplex_eq_inter stdSimplex_eq_interâ‚“'. -/
theorem stdSimplex_eq_inter : stdSimplex ğ•œ Î¹ = (â‹‚ x, { f | 0 â‰¤ f x }) âˆ© { f | (âˆ‘ x, f x) = 1 } :=
  by
  ext f
  simp only [stdSimplex, Set.mem_inter_iff, Set.mem_iInter, Set.mem_setOf_eq]
#align std_simplex_eq_inter stdSimplex_eq_inter

/- warning: convex_std_simplex -> convex_stdSimplex is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) (Î¹ : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : Fintype.{u2} Î¹], Convex.{u1, max u2 u1} ğ•œ (Î¹ -> ğ•œ) _inst_1 (Pi.addCommMonoid.{u2, u1} Î¹ (fun (á¾° : Î¹) => ğ•œ) (fun (i : Î¹) => OrderedAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1))) (Function.hasSMul.{u2, u1, u1} Î¹ ğ•œ ğ•œ (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))) (stdSimplex.{u1, u2} ğ•œ Î¹ _inst_1 _inst_2)
but is expected to have type
  forall (ğ•œ : Type.{u2}) (Î¹ : Type.{u1}) [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : Fintype.{u1} Î¹], Convex.{u2, max u2 u1} ğ•œ (Î¹ -> ğ•œ) _inst_1 (Pi.addCommMonoid.{u1, u2} Î¹ (fun (á¾° : Î¹) => ğ•œ) (fun (i : Î¹) => OrderedAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u2} ğ•œ _inst_1))) (Pi.instSMul.{u1, u2, u2} Î¹ ğ•œ (fun (a._@.Mathlib.Analysis.Convex.Basic._hyg.7298 : Î¹) => ğ•œ) (fun (i : Î¹) => SMulZeroClass.toSMul.{u2, u2} ğ•œ ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (SMulWithZero.toSMulZeroClass.{u2, u2} ğ•œ ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (MulZeroClass.toSMulWithZero.{u2} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))))) (stdSimplex.{u2, u1} ğ•œ Î¹ _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align convex_std_simplex convex_stdSimplexâ‚“'. -/
theorem convex_stdSimplex : Convex ğ•œ (stdSimplex ğ•œ Î¹) :=
  by
  refine' fun f hf g hg a b ha hb hab => âŸ¨fun x => _, _âŸ©
  Â· apply_rules [add_nonneg, mul_nonneg, hf.1, hg.1]
  Â· erw [Finset.sum_add_distrib, â† Finset.smul_sum, â† Finset.smul_sum, hf.2, hg.2, smul_eq_mul,
      smul_eq_mul, mul_one, mul_one]
    exact hab
#align convex_std_simplex convex_stdSimplex

variable {Î¹}

/- warning: ite_eq_mem_std_simplex -> ite_eq_mem_stdSimplex is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {Î¹ : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : Fintype.{u2} Î¹] (i : Î¹), Membership.Mem.{max u2 u1, max u2 u1} (Î¹ -> ğ•œ) (Set.{max u2 u1} (Î¹ -> ğ•œ)) (Set.hasMem.{max u2 u1} (Î¹ -> ğ•œ)) (fun (j : Î¹) => ite.{succ u1} ğ•œ (Eq.{succ u2} Î¹ i j) (Classical.propDecidable (Eq.{succ u2} Î¹ i j)) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) (stdSimplex.{u1, u2} ğ•œ Î¹ _inst_1 _inst_2)
but is expected to have type
  forall (ğ•œ : Type.{u2}) {Î¹ : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : Fintype.{u1} Î¹] (i : Î¹), Membership.mem.{max u2 u1, max u2 u1} (Î¹ -> ğ•œ) (Set.{max u2 u1} (Î¹ -> ğ•œ)) (Set.instMembershipSet.{max u2 u1} (Î¹ -> ğ•œ)) (fun (j : Î¹) => ite.{succ u2} ğ•œ (Eq.{succ u1} Î¹ i j) (Classical.propDecidable (Eq.{succ u1} Î¹ i j)) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) (stdSimplex.{u2, u1} ğ•œ Î¹ _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ite_eq_mem_std_simplex ite_eq_mem_stdSimplexâ‚“'. -/
theorem ite_eq_mem_stdSimplex (i : Î¹) : (fun j => ite (i = j) (1 : ğ•œ) 0) âˆˆ stdSimplex ğ•œ Î¹ :=
  âŸ¨fun j => by simp only <;> split_ifs <;> norm_num, by
    rw [Finset.sum_ite_eq, if_pos (Finset.mem_univ _)]âŸ©
#align ite_eq_mem_std_simplex ite_eq_mem_stdSimplex

end Simplex

