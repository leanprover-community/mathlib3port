/-
Copyright (c) 2019 Alexander Bentkamp. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alexander Bentkamp, Yury Kudryashov, YaÃ«l Dillies

! This file was ported from Lean 3 source module analysis.convex.segment
! leanprover-community/mathlib commit cb3ceec8485239a61ed51d944cb9a95b68c6bafc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Invertible
import Mathbin.Algebra.Order.Smul
import Mathbin.LinearAlgebra.AffineSpace.Midpoint
import Mathbin.LinearAlgebra.Ray
import Mathbin.Tactic.Positivity

/-!
# Segments in vector spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In a ğ•œ-vector space, we define the following objects and properties.
* `segment ğ•œ x y`: Closed segment joining `x` and `y`.
* `open_segment ğ•œ x y`: Open segment joining `x` and `y`.

## Notations

We provide the following notation:
* `[x -[ğ•œ] y] = segment ğ•œ x y` in locale `convex`

## TODO

Generalize all this file to affine spaces.

Should we rename `segment` and `open_segment` to `convex.Icc` and `convex.Ioo`? Should we also
define `clopen_segment`/`convex.Ico`/`convex.Ioc`?
-/


variable {ğ•œ E F G Î¹ : Type _} {Ï€ : Î¹ â†’ Type _}

open Function Set

open Pointwise

section OrderedSemiring

variable [OrderedSemiring ğ•œ] [AddCommMonoid E]

section SMul

variable (ğ•œ) [SMul ğ•œ E] {s : Set E} {x y : E}

#print segment /-
/-- Segments in a vector space. -/
def segment (x y : E) : Set E :=
  { z : E | âˆƒ (a b : ğ•œ)(ha : 0 â‰¤ a)(hb : 0 â‰¤ b)(hab : a + b = 1), a â€¢ x + b â€¢ y = z }
#align segment segment
-/

#print openSegment /-
/-- Open segment in a vector space. Note that `open_segment ğ•œ x x = {x}` instead of being `âˆ…` when
the base semiring has some element between `0` and `1`. -/
def openSegment (x y : E) : Set E :=
  { z : E | âˆƒ (a b : ğ•œ)(ha : 0 < a)(hb : 0 < b)(hab : a + b = 1), a â€¢ x + b â€¢ y = z }
#align open_segment openSegment
-/

-- mathport name: segment
scoped[Convex] notation "[" x " -[" ğ•œ "] " y "]" => segment ğ•œ x y

/- warning: segment_eq_imageâ‚‚ -> segment_eq_imageâ‚‚ is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) (Set.image.{u1, u2} (Prod.{u1, u1} ğ•œ ğ•œ) E (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E _inst_3 (Prod.fst.{u1, u1} ğ•œ ğ•œ p) x) (SMul.smul.{u1, u2} ğ•œ E _inst_3 (Prod.snd.{u1, u1} ğ•œ ğ•œ p) y)) (setOf.{u1} (Prod.{u1, u1} ğ•œ ğ•œ) (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p)) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) (Set.image.{u1, u2} (Prod.{u1, u1} ğ•œ ğ•œ) E (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) (Prod.fst.{u1, u1} ğ•œ ğ•œ p) x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) (Prod.snd.{u1, u1} ğ•œ ğ•œ p) y)) (setOf.{u1} (Prod.{u1, u1} ğ•œ ğ•œ) (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p)) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align segment_eq_imageâ‚‚ segment_eq_imageâ‚‚â‚“'. -/
theorem segment_eq_imageâ‚‚ (x y : E) :
    [x -[ğ•œ] y] =
      (fun p : ğ•œ Ã— ğ•œ => p.1 â€¢ x + p.2 â€¢ y) '' { p | 0 â‰¤ p.1 âˆ§ 0 â‰¤ p.2 âˆ§ p.1 + p.2 = 1 } :=
  by simp only [segment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']
#align segment_eq_imageâ‚‚ segment_eq_imageâ‚‚

/- warning: open_segment_eq_imageâ‚‚ -> openSegment_eq_imageâ‚‚ is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) (Set.image.{u1, u2} (Prod.{u1, u1} ğ•œ ğ•œ) E (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E _inst_3 (Prod.fst.{u1, u1} ğ•œ ğ•œ p) x) (SMul.smul.{u1, u2} ğ•œ E _inst_3 (Prod.snd.{u1, u1} ğ•œ ğ•œ p) y)) (setOf.{u1} (Prod.{u1, u1} ğ•œ ğ•œ) (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p)) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) (Set.image.{u1, u2} (Prod.{u1, u1} ğ•œ ğ•œ) E (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) (Prod.fst.{u1, u1} ğ•œ ğ•œ p) x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) (Prod.snd.{u1, u1} ğ•œ ğ•œ p) y)) (setOf.{u1} (Prod.{u1, u1} ğ•œ ğ•œ) (fun (p : Prod.{u1, u1} ğ•œ ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p)) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) (Prod.fst.{u1, u1} ğ•œ ğ•œ p) (Prod.snd.{u1, u1} ğ•œ ğ•œ p)) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align open_segment_eq_imageâ‚‚ openSegment_eq_imageâ‚‚â‚“'. -/
theorem openSegment_eq_imageâ‚‚ (x y : E) :
    openSegment ğ•œ x y =
      (fun p : ğ•œ Ã— ğ•œ => p.1 â€¢ x + p.2 â€¢ y) '' { p | 0 < p.1 âˆ§ 0 < p.2 âˆ§ p.1 + p.2 = 1 } :=
  by simp only [openSegment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']
#align open_segment_eq_imageâ‚‚ openSegment_eq_imageâ‚‚

#print segment_symm /-
theorem segment_symm (x y : E) : [x -[ğ•œ] y] = [y -[ğ•œ] x] :=
  Set.ext fun z =>
    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,
      fun âŸ¨a, b, ha, hb, hab, HâŸ© =>
      âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©
#align segment_symm segment_symm
-/

#print openSegment_symm /-
theorem openSegment_symm (x y : E) : openSegment ğ•œ x y = openSegment ğ•œ y x :=
  Set.ext fun z =>
    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,
      fun âŸ¨a, b, ha, hb, hab, HâŸ© =>
      âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©
#align open_segment_symm openSegment_symm
-/

#print openSegment_subset_segment /-
theorem openSegment_subset_segment (x y : E) : openSegment ğ•œ x y âŠ† [x -[ğ•œ] y] :=
  fun z âŸ¨a, b, ha, hb, hab, hzâŸ© => âŸ¨a, b, ha.le, hb.le, hab, hzâŸ©
#align open_segment_subset_segment openSegment_subset_segment
-/

/- warning: segment_subset_iff -> segment_subset_iff is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E} {y : E}, Iff (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) s) (forall (a : ğ•œ) (b : ğ•œ), (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E _inst_3 a x) (SMul.smul.{u1, u2} ğ•œ E _inst_3 b y)) s))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E} {y : E}, Iff (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) s) (forall (a : ğ•œ) (b : ğ•œ), (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) a x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) b y)) s))
Case conversion may be inaccurate. Consider using '#align segment_subset_iff segment_subset_iffâ‚“'. -/
theorem segment_subset_iff :
    [x -[ğ•œ] y] âŠ† s â†” âˆ€ a b : ğ•œ, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=
  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H z âŸ¨a, b, ha, hb, hab, hzâŸ© =>
    hz â–¸ H a b ha hb habâŸ©
#align segment_subset_iff segment_subset_iff

/- warning: open_segment_subset_iff -> openSegment_subset_iff is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E} {y : E}, Iff (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) s) (forall (a : ğ•œ) (b : ğ•œ), (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (SMul.smul.{u1, u2} ğ•œ E _inst_3 a x) (SMul.smul.{u1, u2} ğ•œ E _inst_3 b y)) s))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : SMul.{u1, u2} ğ•œ E] {s : Set.{u2} E} {x : E} {y : E}, Iff (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 x y) s) (forall (a : ğ•œ) (b : ğ•œ), (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) a) -> (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedSemiring.toPartialOrder.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) a x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E _inst_3) b y)) s))
Case conversion may be inaccurate. Consider using '#align open_segment_subset_iff openSegment_subset_iffâ‚“'. -/
theorem openSegment_subset_iff :
    openSegment ğ•œ x y âŠ† s â†” âˆ€ a b : ğ•œ, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=
  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H z âŸ¨a, b, ha, hb, hab, hzâŸ© =>
    hz â–¸ H a b ha hb habâŸ©
#align open_segment_subset_iff openSegment_subset_iff

end SMul

open Convex

section MulActionWithZero

variable (ğ•œ) [MulActionWithZero ğ•œ E]

/- warning: left_mem_segment -> left_mem_segment is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : MulActionWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))] (x : E) (y : E), Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) _inst_3))) x y)
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : MulActionWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))] (x : E) (y : E), Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) _inst_3))) x y)
Case conversion may be inaccurate. Consider using '#align left_mem_segment left_mem_segmentâ‚“'. -/
theorem left_mem_segment (x y : E) : x âˆˆ [x -[ğ•œ] y] :=
  âŸ¨1, 0, zero_le_one, le_refl 0, add_zero 1, by rw [zero_smul, one_smul, add_zero]âŸ©
#align left_mem_segment left_mem_segment

/- warning: right_mem_segment -> right_mem_segment is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : MulActionWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)))] (x : E) (y : E), Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) _inst_3))) x y)
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : MulActionWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))] (x : E) (y : E), Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) y (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2)) _inst_3))) x y)
Case conversion may be inaccurate. Consider using '#align right_mem_segment right_mem_segmentâ‚“'. -/
theorem right_mem_segment (x y : E) : y âˆˆ [x -[ğ•œ] y] :=
  segment_symm ğ•œ y x â–¸ left_mem_segment ğ•œ y x
#align right_mem_segment right_mem_segment

end MulActionWithZero

section Module

variable (ğ•œ) [Module ğ•œ E] {s : Set E} {x y z : E}

#print segment_same /-
@[simp]
theorem segment_same (x : E) : [x -[ğ•œ] x] = {x} :=
  Set.ext fun z =>
    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => by
      simpa only [(add_smul _ _ _).symm, mem_singleton_iff, hab, one_smul, eq_comm] using hz,
      fun h => mem_singleton_iff.1 h â–¸ left_mem_segment ğ•œ z zâŸ©
#align segment_same segment_same
-/

#print insert_endpoints_openSegment /-
theorem insert_endpoints_openSegment (x y : E) :
    insert x (insert y (openSegment ğ•œ x y)) = [x -[ğ•œ] y] :=
  by
  simp only [subset_antisymm_iff, insert_subset, left_mem_segment, right_mem_segment,
    openSegment_subset_segment, true_and_iff]
  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©
  refine' hb.eq_or_gt.imp _ fun hb' => ha.eq_or_gt.imp _ fun ha' => _
  Â· rintro rfl
    rw [â† add_zero a, hab, one_smul, zero_smul, add_zero]
  Â· rintro rfl
    rw [â† zero_add b, hab, one_smul, zero_smul, zero_add]
  Â· exact âŸ¨a, b, ha', hb', hab, rflâŸ©
#align insert_endpoints_open_segment insert_endpoints_openSegment
-/

variable {ğ•œ}

#print mem_openSegment_of_ne_left_right /-
theorem mem_openSegment_of_ne_left_right (hx : x â‰  z) (hy : y â‰  z) (hz : z âˆˆ [x -[ğ•œ] y]) :
    z âˆˆ openSegment ğ•œ x y := by
  rw [â† insert_endpoints_openSegment] at hz
  exact (hz.resolve_left hx.symm).resolve_left hy.symm
#align mem_open_segment_of_ne_left_right mem_openSegment_of_ne_left_right
-/

#print openSegment_subset_iff_segment_subset /-
theorem openSegment_subset_iff_segment_subset (hx : x âˆˆ s) (hy : y âˆˆ s) :
    openSegment ğ•œ x y âŠ† s â†” [x -[ğ•œ] y] âŠ† s := by
  simp only [â† insert_endpoints_openSegment, insert_subset, *, true_and_iff]
#align open_segment_subset_iff_segment_subset openSegment_subset_iff_segment_subset
-/

end Module

end OrderedSemiring

open Convex

section OrderedRing

variable (ğ•œ) [OrderedRing ğ•œ] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [Module ğ•œ E]
  [Module ğ•œ F]

section DenselyOrdered

variable [Nontrivial ğ•œ] [DenselyOrdered ğ•œ]

#print openSegment_same /-
@[simp]
theorem openSegment_same (x : E) : openSegment ğ•œ x x = {x} :=
  Set.ext fun z =>
    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => by
      simpa only [â† add_smul, mem_singleton_iff, hab, one_smul, eq_comm] using hz, fun h : z = x =>
      by
      obtain âŸ¨a, haâ‚€, haâ‚âŸ© := DenselyOrdered.dense (0 : ğ•œ) 1 zero_lt_one
      refine' âŸ¨a, 1 - a, haâ‚€, sub_pos_of_lt haâ‚, add_sub_cancel'_right _ _, _âŸ©
      rw [â† add_smul, add_sub_cancel'_right, one_smul, h]âŸ©
#align open_segment_same openSegment_same
-/

end DenselyOrdered

/- warning: segment_eq_image -> segment_eq_image is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HSub.hSub.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHSub.{u1} ğ•œ (SubNegMonoid.toHasSub.{u1} ğ•œ (AddGroup.toSubNegMonoid.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))) Î¸) x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) Î¸ y)) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5))))) (HSub.hSub.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHSub.{u1} ğ•œ (Ring.toSub.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) Î¸) x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5))))) Î¸ y)) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_1)) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align segment_eq_image segment_eq_imageâ‚“'. -/
theorem segment_eq_image (x y : E) :
    [x -[ğ•œ] y] = (fun Î¸ : ğ•œ => (1 - Î¸) â€¢ x + Î¸ â€¢ y) '' Icc (0 : ğ•œ) 1 :=
  Set.ext fun z =>
    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© =>
      âŸ¨b, âŸ¨hb, hab â–¸ le_add_of_nonneg_left haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel]âŸ©,
      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_nonneg.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©
#align segment_eq_image segment_eq_image

/- warning: open_segment_eq_image -> openSegment_eq_image is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HSub.hSub.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHSub.{u1} ğ•œ (SubNegMonoid.toHasSub.{u1} ğ•œ (AddGroup.toSubNegMonoid.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))) Î¸) x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) Î¸ y)) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5))))) (HSub.hSub.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHSub.{u1} ğ•œ (Ring.toSub.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) Î¸) x) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5))))) Î¸ y)) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_1)) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align open_segment_eq_image openSegment_eq_imageâ‚“'. -/
theorem openSegment_eq_image (x y : E) :
    openSegment ğ•œ x y = (fun Î¸ : ğ•œ => (1 - Î¸) â€¢ x + Î¸ â€¢ y) '' Ioo (0 : ğ•œ) 1 :=
  Set.ext fun z =>
    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© =>
      âŸ¨b, âŸ¨hb, hab â–¸ lt_add_of_pos_left _ haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel]âŸ©,
      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_pos.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©
#align open_segment_eq_image openSegment_eq_image

/- warning: segment_eq_image' -> segment_eq_image' is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) Î¸ (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) y x))) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5))))) Î¸ (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) y x))) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_1)) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align segment_eq_image' segment_eq_image'â‚“'. -/
theorem segment_eq_image' (x y : E) :
    [x -[ğ•œ] y] = (fun Î¸ : ğ•œ => x + Î¸ â€¢ (y - x)) '' Icc (0 : ğ•œ) 1 :=
  by
  convert segment_eq_image ğ•œ x y
  ext Î¸
  simp only [smul_sub, sub_smul, one_smul]
  abel
#align segment_eq_image' segment_eq_image'

/- warning: open_segment_eq_image' -> openSegment_eq_image' is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) Î¸ (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) y x))) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (fun (Î¸ : ğ•œ) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5))))) Î¸ (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) y x))) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_1)) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align open_segment_eq_image' openSegment_eq_image'â‚“'. -/
theorem openSegment_eq_image' (x y : E) :
    openSegment ğ•œ x y = (fun Î¸ : ğ•œ => x + Î¸ â€¢ (y - x)) '' Ioo (0 : ğ•œ) 1 :=
  by
  convert openSegment_eq_image ğ•œ x y
  ext Î¸
  simp only [smul_sub, sub_smul, one_smul]
  abel
#align open_segment_eq_image' openSegment_eq_image'

/- warning: segment_eq_image_line_map -> segment_eq_image_lineMap is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) => ğ•œ -> E) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) x y)) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (Ring.toAddCommGroup.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (Ring.toAddGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) ğ•œ (fun (_x : ğ•œ) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ğ•œ) => E) _x) (AffineMap.funLike.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (Ring.toAddCommGroup.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (Ring.toAddGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) x y)) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_1)) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align segment_eq_image_line_map segment_eq_image_lineMapâ‚“'. -/
theorem segment_eq_image_lineMap (x y : E) : [x -[ğ•œ] y] = AffineMap.lineMap x y '' Icc (0 : ğ•œ) 1 :=
  by
  convert segment_eq_image ğ•œ x y
  ext
  exact AffineMap.lineMap_apply_module _ _ _
#align segment_eq_image_line_map segment_eq_image_lineMap

/- warning: open_segment_eq_image_line_map -> openSegment_eq_image_lineMap is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) => ğ•œ -> E) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) x y)) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_1))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))))))))))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E), Eq.{succ u2} (Set.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) x y) (Set.image.{u1, u2} ğ•œ E (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (Ring.toAddCommGroup.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (Ring.toAddGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) ğ•œ (fun (_x : ğ•œ) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ğ•œ) => E) _x) (AffineMap.funLike.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) (Ring.toAddCommGroup.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (Ring.toAddGroupWithOne.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} ğ•œ E E (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) x y)) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_1)) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align open_segment_eq_image_line_map openSegment_eq_image_lineMapâ‚“'. -/
theorem openSegment_eq_image_lineMap (x y : E) :
    openSegment ğ•œ x y = AffineMap.lineMap x y '' Ioo (0 : ğ•œ) 1 :=
  by
  convert openSegment_eq_image ğ•œ x y
  ext
  exact AffineMap.lineMap_apply_module _ _ _
#align open_segment_eq_image_line_map openSegment_eq_image_lineMap

/- warning: image_segment -> image_segment is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_6 : Module.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] (f : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (a : E) (b : E), Eq.{succ u3} (Set.{u3} F) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) a b)) (segment.{u1, u3} ğ•œ F (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_6)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f b))
but is expected to have type
  forall (ğ•œ : Type.{u3}) {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedRing.{u3} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_6 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] (f : AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) (a : E) (b : E), Eq.{succ u1} (Set.{u1} F) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) (segment.{u3, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) a b)) (segment.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3) (SMulZeroClass.toSMul.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3))))) (Module.toMulActionWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3) _inst_6)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f b))
Case conversion may be inaccurate. Consider using '#align image_segment image_segmentâ‚“'. -/
@[simp]
theorem image_segment (f : E â†’áµƒ[ğ•œ] F) (a b : E) : f '' [a -[ğ•œ] b] = [f a -[ğ•œ] f b] :=
  Set.ext fun x => by
    simp_rw [segment_eq_image_lineMap, mem_image, exists_exists_and_eq_and, AffineMap.apply_lineMap]
#align image_segment image_segment

/- warning: image_open_segment -> image_openSegment is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_6 : Module.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] (f : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (a : E) (b : E), Eq.{succ u3} (Set.{u3} F) (Set.image.{u2, u3} E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) a b)) (openSegment.{u1, u3} ğ•œ F (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_6)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} ğ•œ E E F F (OrderedRing.toRing.{u1} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f b))
but is expected to have type
  forall (ğ•œ : Type.{u3}) {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : OrderedRing.{u3} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_6 : Module.{u3, u1} ğ•œ F (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] (f : AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) (a : E) (b : E), Eq.{succ u1} (Set.{u1} F) (Set.image.{u2, u1} E F (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f) (openSegment.{u3, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u3, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} ğ•œ E (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} ğ•œ E (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} ğ•œ E (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) a b)) (openSegment.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3) (SMulZeroClass.toSMul.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (MonoidWithZero.toZero.{u3} ğ•œ (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (Semiring.toMonoidWithZero.{u3} ğ•œ (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1))) (NegZeroClass.toZero.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3))))) (Module.toMulActionWithZero.{u3, u1} ğ•œ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) (OrderedSemiring.toSemiring.{u3} ğ•œ (OrderedRing.toOrderedSemiring.{u3} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) a) _inst_3) _inst_6)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineMap.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) E (fun (_x : E) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : E) => F) _x) (AffineMap.funLike.{u3, u2, u2, u1, u1} ğ•œ E E F F (OrderedRing.toRing.{u3} ğ•œ _inst_1) _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_6 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))) f b))
Case conversion may be inaccurate. Consider using '#align image_open_segment image_openSegmentâ‚“'. -/
@[simp]
theorem image_openSegment (f : E â†’áµƒ[ğ•œ] F) (a b : E) :
    f '' openSegment ğ•œ a b = openSegment ğ•œ (f a) (f b) :=
  Set.ext fun x => by
    simp_rw [openSegment_eq_image_lineMap, mem_image, exists_exists_and_eq_and,
      AffineMap.apply_lineMap]
#align image_open_segment image_openSegment

/- warning: vadd_segment -> vadd_segment is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} {G : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : AddCommGroup.{u3} G] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_7 : AddTorsor.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4)] [_inst_8 : VAddCommClass.{u3, u2, u2} G E E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) (Add.toVAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))] (a : G) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (VAdd.vadd.{u3, u2} G (Set.{u2} E) (Set.vaddSet.{u3, u2} G E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7))) a (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (VAdd.vadd.{u3, u2} G E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) a b) (VAdd.vadd.{u3, u2} G E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) a c))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} {G : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : AddCommGroup.{u3} G] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_7 : AddTorsor.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4)] [_inst_8 : VAddCommClass.{u3, u2, u2} G E E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) (AddAction.toVAdd.{u2, u2} E E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AddTorsor.toAddAction.{u2, u2} E E (AddCommGroup.toAddGroup.{u2} E _inst_2) (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))] (a : G) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (HVAdd.hVAdd.{u3, u2, u2} G (Set.{u2} E) (Set.{u2} E) (instHVAdd.{u3, u2} G (Set.{u2} E) (Set.vaddSet.{u3, u2} G E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)))) a (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HVAdd.hVAdd.{u3, u2, u2} G E E (instHVAdd.{u3, u2} G E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7))) a b) (HVAdd.hVAdd.{u3, u2, u2} G E E (instHVAdd.{u3, u2} G E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7))) a c))
Case conversion may be inaccurate. Consider using '#align vadd_segment vadd_segmentâ‚“'. -/
@[simp]
theorem vadd_segment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :
    a +áµ¥ [b -[ğ•œ] c] = [a +áµ¥ b -[ğ•œ] a +áµ¥ c] :=
  image_segment ğ•œ âŸ¨_, LinearMap.id, fun _ _ => vadd_comm _ _ _âŸ© b c
#align vadd_segment vadd_segment

/- warning: vadd_open_segment -> vadd_openSegment is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} {G : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : AddCommGroup.{u3} G] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_7 : AddTorsor.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4)] [_inst_8 : VAddCommClass.{u3, u2, u2} G E E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) (Add.toVAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))] (a : G) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (VAdd.vadd.{u3, u2} G (Set.{u2} E) (Set.vaddSet.{u3, u2} G E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7))) a (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (VAdd.vadd.{u3, u2} G E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) a b) (VAdd.vadd.{u3, u2} G E (AddAction.toHasVadd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) a c))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} {G : Type.{u3}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_4 : AddCommGroup.{u3} G] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_7 : AddTorsor.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4)] [_inst_8 : VAddCommClass.{u3, u2, u2} G E E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)) (AddAction.toVAdd.{u2, u2} E E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AddTorsor.toAddAction.{u2, u2} E E (AddCommGroup.toAddGroup.{u2} E _inst_2) (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))] (a : G) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (HVAdd.hVAdd.{u3, u2, u2} G (Set.{u2} E) (Set.{u2} E) (instHVAdd.{u3, u2} G (Set.{u2} E) (Set.vaddSet.{u3, u2} G E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7)))) a (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HVAdd.hVAdd.{u3, u2, u2} G E E (instHVAdd.{u3, u2} G E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7))) a b) (HVAdd.hVAdd.{u3, u2, u2} G E E (instHVAdd.{u3, u2} G E (AddAction.toVAdd.{u3, u2} G E (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_4))) (AddTorsor.toAddAction.{u3, u2} G E (AddCommGroup.toAddGroup.{u3} G _inst_4) _inst_7))) a c))
Case conversion may be inaccurate. Consider using '#align vadd_open_segment vadd_openSegmentâ‚“'. -/
@[simp]
theorem vadd_openSegment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :
    a +áµ¥ openSegment ğ•œ b c = openSegment ğ•œ (a +áµ¥ b) (a +áµ¥ c) :=
  image_openSegment ğ•œ âŸ¨_, LinearMap.id, fun _ _ => vadd_comm _ _ _âŸ© b c
#align vadd_open_segment vadd_openSegment

/- warning: mem_segment_translate -> mem_segment_translate is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) {x : E} {b : E} {c : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) {x : E} {b : E} {c : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c))
Case conversion may be inaccurate. Consider using '#align mem_segment_translate mem_segment_translateâ‚“'. -/
@[simp]
theorem mem_segment_translate (a : E) {x b c} : a + x âˆˆ [a + b -[ğ•œ] a + c] â†” x âˆˆ [b -[ğ•œ] c] := by
  simp_rw [â† vadd_eq_add, â† vadd_segment, vadd_mem_vadd_set_iff]
#align mem_segment_translate mem_segment_translate

/- warning: mem_open_segment_translate -> mem_openSegment_translate is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) {x : E} {b : E} {c : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) {x : E} {b : E} {c : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c))
Case conversion may be inaccurate. Consider using '#align mem_open_segment_translate mem_openSegment_translateâ‚“'. -/
@[simp]
theorem mem_openSegment_translate (a : E) {x b c : E} :
    a + x âˆˆ openSegment ğ•œ (a + b) (a + c) â†” x âˆˆ openSegment ğ•œ b c := by
  simp_rw [â† vadd_eq_add, â† vadd_openSegment, vadd_mem_vadd_set_iff]
#align mem_open_segment_translate mem_openSegment_translate

/- warning: segment_translate_preimage -> segment_translate_preimage is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)
Case conversion may be inaccurate. Consider using '#align segment_translate_preimage segment_translate_preimageâ‚“'. -/
theorem segment_translate_preimage (a b c : E) :
    (fun x => a + x) â»Â¹' [a + b -[ğ•œ] a + c] = [b -[ğ•œ] c] :=
  Set.ext fun x => mem_segment_translate ğ•œ a
#align segment_translate_preimage segment_translate_preimage

/- warning: open_segment_translate_preimage -> openSegment_translate_preimage is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.preimage.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)
Case conversion may be inaccurate. Consider using '#align open_segment_translate_preimage openSegment_translate_preimageâ‚“'. -/
theorem openSegment_translate_preimage (a b c : E) :
    (fun x => a + x) â»Â¹' openSegment ğ•œ (a + b) (a + c) = openSegment ğ•œ b c :=
  Set.ext fun x => mem_openSegment_translate ğ•œ a
#align open_segment_translate_preimage openSegment_translate_preimage

/- warning: segment_translate_image -> segment_translate_image is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (segment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))
Case conversion may be inaccurate. Consider using '#align segment_translate_image segment_translate_imageâ‚“'. -/
theorem segment_translate_image (a b c : E) : (fun x => a + x) '' [b -[ğ•œ] c] = [a + b -[ğ•œ] a + c] :=
  segment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a
#align segment_translate_image segment_translate_image

/- warning: open_segment_translate_image -> openSegment_translate_image is a dubious translation:
lean 3 declaration is
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))
but is expected to have type
  forall (ğ•œ : Type.{u1}) {E : Type.{u2}} [_inst_1 : OrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (a : E) (b : E) (c : E), Eq.{succ u2} (Set.{u2} E) (Set.image.{u2, u2} E E (fun (x : E) => HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a x) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) b c)) (openSegment.{u1, u2} ğ•œ E (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_5)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a b) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) a c))
Case conversion may be inaccurate. Consider using '#align open_segment_translate_image openSegment_translate_imageâ‚“'. -/
theorem openSegment_translate_image (a b c : E) :
    (fun x => a + x) '' openSegment ğ•œ b c = openSegment ğ•œ (a + b) (a + c) :=
  openSegment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a
#align open_segment_translate_image openSegment_translate_image

end OrderedRing

/- warning: same_ray_of_mem_segment -> sameRay_of_mem_segment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : StrictOrderedCommRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (StrictOrderedCommRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {z : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (StrictOrderedCommRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (StrictOrderedCommRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (StrictOrderedCommRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (StrictOrderedCommRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) y z)) -> (SameRay.{u1, u2} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} ğ•œ _inst_1) E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) z x))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : StrictOrderedCommRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {y : E} {z : E}, (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (segment.{u2, u1} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (CommMonoidWithZero.toZero.{u2} ğ•œ (CommSemiring.toCommMonoidWithZero.{u2} ğ•œ (StrictOrderedCommSemiring.toCommSemiring.{u2} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u2} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) y z)) -> (SameRay.{u2, u1} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u2} ğ•œ _inst_1) E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3 (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))) x y) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))) z x))
Case conversion may be inaccurate. Consider using '#align same_ray_of_mem_segment sameRay_of_mem_segmentâ‚“'. -/
theorem sameRay_of_mem_segment [StrictOrderedCommRing ğ•œ] [AddCommGroup E] [Module ğ•œ E] {x y z : E}
    (h : x âˆˆ [y -[ğ•œ] z]) : SameRay ğ•œ (x - y) (z - x) :=
  by
  rw [segment_eq_image'] at h
  rcases h with âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, rflâŸ©
  simpa only [add_sub_cancel', â† sub_sub, sub_smul, one_smul] using
    (SameRay.sameRay_nonneg_smul_left (z - y) hÎ¸â‚€).nonneg_smul_right (sub_nonneg.2 hÎ¸â‚)
#align same_ray_of_mem_segment sameRay_of_mem_segment

section LinearOrderedRing

variable [LinearOrderedRing ğ•œ] [AddCommGroup E] [Module ğ•œ E] {x y : E}

/- warning: midpoint_mem_segment -> midpoint_mem_segment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : Invertible.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 2 (OfNat.mk.{u1} ğ•œ 2 (bit0.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))))))] (x : E) (y : E), Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (midpoint.{u1, u2, u2} ğ•œ E E (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)) _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) x y) (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : Invertible.{u2} ğ•œ (NonUnitalNonAssocRing.toMul.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1))))) (NonAssocRing.toOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1)))) (OfNat.ofNat.{u2} ğ•œ 2 (instOfNat.{u2} ğ•œ 2 (NonAssocRing.toNatCast.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (x : E) (y : E), Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) (midpoint.{u2, u1, u1} ğ•œ E E (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1)) _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) x y) (segment.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) x y)
Case conversion may be inaccurate. Consider using '#align midpoint_mem_segment midpoint_mem_segmentâ‚“'. -/
theorem midpoint_mem_segment [Invertible (2 : ğ•œ)] (x y : E) : midpoint ğ•œ x y âˆˆ [x -[ğ•œ] y] :=
  by
  rw [segment_eq_image_lineMap]
  exact âŸ¨â…Ÿ 2, âŸ¨inv_of_nonneg.mpr zero_le_two, invOf_le_one one_le_twoâŸ©, rflâŸ©
#align midpoint_mem_segment midpoint_mem_segment

/- warning: mem_segment_sub_add -> mem_segment_sub_add is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : Invertible.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 2 (OfNat.mk.{u1} ğ•œ 2 (bit0.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))))))] (x : E) (y : E), Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x y))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : Invertible.{u2} ğ•œ (NonUnitalNonAssocRing.toMul.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1))))) (NonAssocRing.toOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1)))) (OfNat.ofNat.{u2} ğ•œ 2 (instOfNat.{u2} ğ•œ 2 (NonAssocRing.toNatCast.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (x : E) (y : E), Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (segment.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))) x y) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x y))
Case conversion may be inaccurate. Consider using '#align mem_segment_sub_add mem_segment_sub_addâ‚“'. -/
theorem mem_segment_sub_add [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ [x - y -[ğ•œ] x + y] :=
  by
  convert@midpoint_mem_segment ğ•œ _ _ _ _ _ _ _
  rw [midpoint_sub_add]
#align mem_segment_sub_add mem_segment_sub_add

/- warning: mem_segment_add_sub -> mem_segment_add_sub is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : Invertible.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 2 (OfNat.mk.{u1} ğ•œ 2 (bit0.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))))))] (x : E) (y : E), Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x y) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : Invertible.{u2} ğ•œ (NonUnitalNonAssocRing.toMul.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1))))) (NonAssocRing.toOne.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1)))) (OfNat.ofNat.{u2} ğ•œ 2 (instOfNat.{u2} ğ•œ 2 (NonAssocRing.toNatCast.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (x : E) (y : E), Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (segment.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x y) (HSub.hSub.{u1, u1, u1} E E E (instHSub.{u1} E (SubNegMonoid.toSub.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))) x y))
Case conversion may be inaccurate. Consider using '#align mem_segment_add_sub mem_segment_add_subâ‚“'. -/
theorem mem_segment_add_sub [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ [x + y -[ğ•œ] x - y] :=
  by
  convert@midpoint_mem_segment ğ•œ _ _ _ _ _ _ _
  rw [midpoint_add_sub]
#align mem_segment_add_sub mem_segment_add_sub

/- warning: left_mem_open_segment_iff -> left_mem_openSegment_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))], Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (openSegment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y)) (Eq.{succ u2} E x y)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {y : E} [_inst_4 : DenselyOrdered.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1))))] [_inst_5 : NoZeroSMulDivisors.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))], Iff (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x (openSegment.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) x y)) (Eq.{succ u1} E x y)
Case conversion may be inaccurate. Consider using '#align left_mem_open_segment_iff left_mem_openSegment_iffâ‚“'. -/
@[simp]
theorem left_mem_openSegment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] :
    x âˆˆ openSegment ğ•œ x y â†” x = y := by
  constructor
  Â· rintro âŸ¨a, b, ha, hb, hab, hxâŸ©
    refine' smul_right_injective _ hb.ne' ((add_right_inj (a â€¢ x)).1 _)
    rw [hx, â† add_smul, hab, one_smul]
  Â· rintro rfl
    rw [openSegment_same]
    exact mem_singleton _
#align left_mem_open_segment_iff left_mem_openSegment_iff

/- warning: right_mem_open_segment_iff -> right_mem_openSegment_iff is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} [_inst_4 : DenselyOrdered.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))], Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y (openSegment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y)) (Eq.{succ u2} E x y)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {x : E} {y : E} [_inst_4 : DenselyOrdered.{u2} ğ•œ (Preorder.toLT.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_1))))] [_inst_5 : NoZeroSMulDivisors.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))], Iff (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) y (openSegment.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) x y)) (Eq.{succ u1} E x y)
Case conversion may be inaccurate. Consider using '#align right_mem_open_segment_iff right_mem_openSegment_iffâ‚“'. -/
@[simp]
theorem right_mem_openSegment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] :
    y âˆˆ openSegment ğ•œ x y â†” x = y := by rw [openSegment_symm, left_mem_openSegment_iff, eq_comm]
#align right_mem_open_segment_iff right_mem_openSegment_iff

end LinearOrderedRing

section LinearOrderedSemifield

variable [LinearOrderedSemifield ğ•œ] [AddCommGroup E] [Module ğ•œ E] {x y z : E}

/- warning: mem_segment_iff_div -> mem_segment_iff_div is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {z : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) y z)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedCancelAddCommMonoid.toPartialOrder.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))))) a) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedCancelAddCommMonoid.toPartialOrder.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))))) b) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedCancelAddCommMonoid.toPartialOrder.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))))) (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (GroupWithZero.toDivInvMonoid.{u1} ğ•œ (DivisionSemiring.toGroupWithZero.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) a (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) y) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (GroupWithZero.toDivInvMonoid.{u1} ğ•œ (DivisionSemiring.toGroupWithZero.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) b (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) z)) x))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {z : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (segment.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) y z)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedSemiring.toPartialOrder.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) a) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedSemiring.toPartialOrder.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) b) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedSemiring.toPartialOrder.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (LinearOrderedSemifield.toDiv.{u1} ğ•œ _inst_1)) a (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) y) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (LinearOrderedSemifield.toDiv.{u1} ğ•œ _inst_1)) b (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) z)) x))))))
Case conversion may be inaccurate. Consider using '#align mem_segment_iff_div mem_segment_iff_divâ‚“'. -/
theorem mem_segment_iff_div :
    x âˆˆ [y -[ğ•œ] z] â†”
      âˆƒ a b : ğ•œ, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ 0 < a + b âˆ§ (a / (a + b)) â€¢ y + (b / (a + b)) â€¢ z = x :=
  by
  constructor
  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©
    use a, b, ha, hb
    simp [*]
  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©
    refine' âŸ¨a / (a + b), b / (a + b), div_nonneg ha hab.le, div_nonneg hb hab.le, _, rflâŸ©
    rw [â† add_div, div_self hab.ne']
#align mem_segment_iff_div mem_segment_iff_div

/- warning: mem_open_segment_iff_div -> mem_openSegment_iff_div is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {z : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (openSegment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) y z)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedCancelAddCommMonoid.toPartialOrder.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))))) a) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedCancelAddCommMonoid.toPartialOrder.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))))) b) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (GroupWithZero.toDivInvMonoid.{u1} ğ•œ (DivisionSemiring.toGroupWithZero.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) a (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) y) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (DivInvMonoid.toHasDiv.{u1} ğ•œ (GroupWithZero.toDivInvMonoid.{u1} ğ•œ (DivisionSemiring.toGroupWithZero.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) b (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) z)) x)))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {z : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (openSegment.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) y z)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedSemiring.toPartialOrder.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) a) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedSemiring.toPartialOrder.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))) b) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (LinearOrderedSemifield.toDiv.{u1} ğ•œ _inst_1)) a (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) y) (HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (HDiv.hDiv.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHDiv.{u1} ğ•œ (LinearOrderedSemifield.toDiv.{u1} ğ•œ _inst_1)) b (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ _inst_1)))))))) a b)) z)) x)))))
Case conversion may be inaccurate. Consider using '#align mem_open_segment_iff_div mem_openSegment_iff_divâ‚“'. -/
theorem mem_openSegment_iff_div :
    x âˆˆ openSegment ğ•œ y z â†” âˆƒ a b : ğ•œ, 0 < a âˆ§ 0 < b âˆ§ (a / (a + b)) â€¢ y + (b / (a + b)) â€¢ z = x :=
  by
  constructor
  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©
    use a, b, ha, hb
    rw [hab, div_one, div_one]
  Â· rintro âŸ¨a, b, ha, hb, rflâŸ©
    have hab : 0 < a + b := by positivity
    refine' âŸ¨a / (a + b), b / (a + b), by positivity, by positivity, _, rflâŸ©
    rw [â† add_div, div_self hab.ne']
#align mem_open_segment_iff_div mem_openSegment_iff_div

end LinearOrderedSemifield

section LinearOrderedField

variable [LinearOrderedField ğ•œ] [AddCommGroup E] [Module ğ•œ E] {x y z : E}

/- warning: mem_segment_iff_same_ray -> mem_segment_iff_sameRay is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {z : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (segment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) y z)) (SameRay.{u1, u2} ğ•œ (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommRing.toStrictOrderedCommRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) z x))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {x : E} {y : E} {z : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (segment.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) y z)) (SameRay.{u1, u2} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) x y) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) z x))
Case conversion may be inaccurate. Consider using '#align mem_segment_iff_same_ray mem_segment_iff_sameRayâ‚“'. -/
theorem mem_segment_iff_sameRay : x âˆˆ [y -[ğ•œ] z] â†” SameRay ğ•œ (x - y) (z - x) :=
  by
  refine' âŸ¨sameRay_of_mem_segment, fun h => _âŸ©
  rcases h.exists_eq_smul_add with âŸ¨a, b, ha, hb, hab, hxy, hzxâŸ©
  rw [add_comm, sub_add_sub_cancel] at hxy hzx
  rw [â† mem_segment_translate _ (-x), neg_add_self]
  refine' âŸ¨b, a, hb, ha, add_comm a b â–¸ hab, _âŸ©
  rw [â† sub_eq_neg_add, â† neg_sub, hxy, â† sub_eq_neg_add, hzx, smul_neg, smul_comm, neg_add_self]
#align mem_segment_iff_same_ray mem_segment_iff_sameRay

open AffineMap

/- warning: open_segment_subset_union -> openSegment_subset_union is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E) {z : E}, (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) z (Set.range.{u2, succ u1} E ğ•œ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) => ğ•œ -> E) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} ğ•œ E E (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) x y)))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (openSegment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y) (Insert.insert.{u2, u2} E (Set.{u2} E) (Set.hasInsert.{u2} E) z (Union.union.{u2} (Set.{u2} E) (Set.hasUnion.{u2} E) (openSegment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x z) (openSegment.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) z y))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (x : E) (y : E) {z : E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) z (Set.range.{u2, succ u1} E ğ•œ (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AffineMap.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))) (Ring.toAddCommGroup.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (Ring.toAddGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) ğ•œ (fun (_x : ğ•œ) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ğ•œ) => E) _x) (AffineMap.funLike.{u1, u1, u1, u2, u2} ğ•œ ğ•œ ğ•œ E E (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))) (Ring.toAddCommGroup.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))) (addGroupIsAddTorsor.{u1} ğ•œ (AddGroupWithOne.toAddGroup.{u1} ğ•œ (Ring.toAddGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} ğ•œ E E (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) x y)))) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y) (Insert.insert.{u2, u2} E (Set.{u2} E) (Set.instInsertSet.{u2} E) z (Union.union.{u2} (Set.{u2} E) (Set.instUnionSet.{u2} E) (openSegment.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x z) (openSegment.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) z y))))
Case conversion may be inaccurate. Consider using '#align open_segment_subset_union openSegment_subset_unionâ‚“'. -/
/-- If `z = line_map x y c` is a point on the line passing through `x` and `y`, then the open
segment `open_segment ğ•œ x y` is included in the union of the open segments `open_segment ğ•œ x z`,
`open_segment ğ•œ z y`, and the point `z`. Informally, `(x, y) âŠ† {z} âˆª (x, z) âˆª (z, y)`. -/
theorem openSegment_subset_union (x y : E) {z : E} (hz : z âˆˆ range (lineMap x y : ğ•œ â†’ E)) :
    openSegment ğ•œ x y âŠ† insert z (openSegment ğ•œ x z âˆª openSegment ğ•œ z y) :=
  by
  rcases hz with âŸ¨c, rflâŸ©
  simp only [openSegment_eq_image_lineMap, â† maps_to']
  rintro a âŸ¨hâ‚€, hâ‚âŸ©
  rcases lt_trichotomy a c with (hac | rfl | hca)
  Â· right
    left
    have hc : 0 < c := hâ‚€.trans hac
    refine' âŸ¨a / c, âŸ¨div_pos hâ‚€ hc, (div_lt_one hc).2 hacâŸ©, _âŸ©
    simp only [â† homothety_eq_line_map, â† homothety_mul_apply, div_mul_cancel _ hc.ne']
  Â· left
    rfl
  Â· right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans hâ‚)
    simp only [â† line_map_apply_one_sub y]
    refine'
      âŸ¨(a - c) / (1 - c), âŸ¨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right hâ‚ _âŸ©,
        _âŸ©
    simp only [â† homothety_eq_line_map, â† homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel _ hc.ne', sub_sub_sub_cancel_right]
#align open_segment_subset_union openSegment_subset_union

end LinearOrderedField

/-!
#### Segments in an ordered space

Relates `segment`, `open_segment` and `set.Icc`, `set.Ico`, `set.Ioc`, `set.Ioo`
-/


section OrderedSemiring

variable [OrderedSemiring ğ•œ]

section OrderedAddCommMonoid

variable [OrderedAddCommMonoid E] [Module ğ•œ E] [OrderedSMul ğ•œ E] {x y : E}

/- warning: segment_subset_Icc -> segment_subset_Icc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : OrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3))] {x : E} {y : E}, (LE.le.{u2} E (Preorder.toLE.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2))) x y) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y) (Set.Icc.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2)) x y))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : OrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3))] {x : E} {y : E}, (LE.le.{u2} E (Preorder.toLE.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2))) x y) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y) (Set.Icc.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E _inst_2)) x y))
Case conversion may be inaccurate. Consider using '#align segment_subset_Icc segment_subset_Iccâ‚“'. -/
theorem segment_subset_Icc (h : x â‰¤ y) : [x -[ğ•œ] y] âŠ† Icc x y :=
  by
  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©
  constructor
  calc
    x = a â€¢ x + b â€¢ x := (Convex.combo_self hab _).symm
    _ â‰¤ a â€¢ x + b â€¢ y := add_le_add_left (smul_le_smul_of_nonneg h hb) _
    
  calc
    a â€¢ x + b â€¢ y â‰¤ a â€¢ y + b â€¢ y := add_le_add_right (smul_le_smul_of_nonneg h ha) _
    _ = y := Convex.combo_self hab _
    
#align segment_subset_Icc segment_subset_Icc

end OrderedAddCommMonoid

section OrderedCancelAddCommMonoid

variable [OrderedCancelAddCommMonoid E] [Module ğ•œ E] [OrderedSMul ğ•œ E] {x y : E}

/- warning: open_segment_subset_Ioo -> openSegment_subset_Ioo is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : OrderedCancelAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3))] {x : E} {y : E}, (LT.lt.{u2} E (Preorder.toLT.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedCancelAddCommMonoid.toPartialOrder.{u2} E _inst_2))) x y) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y) (Set.Ioo.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedCancelAddCommMonoid.toPartialOrder.{u2} E _inst_2)) x y))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : OrderedCancelAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3))] {x : E} {y : E}, (LT.lt.{u2} E (Preorder.toLT.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedCancelAddCommMonoid.toPartialOrder.{u2} E _inst_2))) x y) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (openSegment.{u1, u2} ğ•œ E _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddRightCancelMonoid.toZero.{u2} E (AddCancelMonoid.toAddRightCancelMonoid.{u2} E (AddCancelCommMonoid.toAddCancelMonoid.{u2} E (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddRightCancelMonoid.toZero.{u2} E (AddCancelMonoid.toAddRightCancelMonoid.{u2} E (AddCancelCommMonoid.toAddCancelMonoid.{u2} E (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddRightCancelMonoid.toZero.{u2} E (AddCancelMonoid.toAddRightCancelMonoid.{u2} E (AddCancelCommMonoid.toAddCancelMonoid.{u2} E (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y) (Set.Ioo.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedCancelAddCommMonoid.toPartialOrder.{u2} E _inst_2)) x y))
Case conversion may be inaccurate. Consider using '#align open_segment_subset_Ioo openSegment_subset_Iooâ‚“'. -/
theorem openSegment_subset_Ioo (h : x < y) : openSegment ğ•œ x y âŠ† Ioo x y :=
  by
  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©
  constructor
  calc
    x = a â€¢ x + b â€¢ x := (Convex.combo_self hab _).symm
    _ < a â€¢ x + b â€¢ y := add_lt_add_left (smul_lt_smul_of_pos h hb) _
    
  calc
    a â€¢ x + b â€¢ y < a â€¢ y + b â€¢ y := add_lt_add_right (smul_lt_smul_of_pos h ha) _
    _ = y := Convex.combo_self hab _
    
#align open_segment_subset_Ioo openSegment_subset_Ioo

end OrderedCancelAddCommMonoid

section LinearOrderedAddCommMonoid

variable [LinearOrderedAddCommMonoid E] [Module ğ•œ E] [OrderedSMul ğ•œ E] {ğ•œ} {a b : ğ•œ}

/- warning: segment_subset_uIcc -> segment_subset_uIcc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3))] (x : E) (y : E), HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3)))) x y) (Set.uIcc.{u2} E (LinearOrder.toLattice.{u2} E (LinearOrderedAddCommMonoid.toLinearOrder.{u2} E _inst_2)) x y)
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3))] (x : E) (y : E), HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (segment.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) x y) (Set.uIcc.{u2} E (DistribLattice.toLattice.{u2} E (instDistribLattice.{u2} E (LinearOrderedAddCommMonoid.toLinearOrder.{u2} E _inst_2))) x y)
Case conversion may be inaccurate. Consider using '#align segment_subset_uIcc segment_subset_uIccâ‚“'. -/
theorem segment_subset_uIcc (x y : E) : [x -[ğ•œ] y] âŠ† uIcc x y :=
  by
  cases le_total x y
  Â· rw [uIcc_of_le h]
    exact segment_subset_Icc h
  Â· rw [uIcc_of_ge h, segment_symm]
    exact segment_subset_Icc h
#align segment_subset_uIcc segment_subset_uIcc

/- warning: convex.min_le_combo -> Convex.min_le_combo is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3))] {a : ğ•œ} {b : ğ•œ} (x : E) (y : E), (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (LE.le.{u2} E (Preorder.toLE.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)))) (LinearOrder.min.{u2} E (LinearOrderedAddCommMonoid.toLinearOrder.{u2} E _inst_2) x y) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3)))) a x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3)))) b y)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : OrderedSMul.{u2, u1} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))] {a : ğ•œ} {b : ğ•œ} (x : E) (y : E), (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) b) -> (Eq.{succ u2} ğ•œ (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) -> (LE.le.{u1} E (Preorder.toLE.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2)))) (Min.min.{u1} E (LinearOrder.toMin.{u1} E (LinearOrderedAddCommMonoid.toLinearOrder.{u1} E _inst_2)) x y) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) a x) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) b y)))
Case conversion may be inaccurate. Consider using '#align convex.min_le_combo Convex.min_le_comboâ‚“'. -/
theorem Convex.min_le_combo (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
    min x y â‰¤ a â€¢ x + b â€¢ y :=
  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).1
#align convex.min_le_combo Convex.min_le_combo

/- warning: convex.combo_le_max -> Convex.combo_le_max is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))] [_inst_4 : OrderedSMul.{u1, u2} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3))] {a : ğ•œ} {b : ğ•œ} (x : E) (y : E), (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) a) -> (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommMonoid.toPartialOrder.{u1} ğ•œ (OrderedSemiring.toOrderedAddCommMonoid.{u1} ğ•œ _inst_1)))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))))) b) -> (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ğ•œ (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))))))) -> (LE.le.{u2} E (Preorder.toLE.{u2} E (PartialOrder.toPreorder.{u2} E (OrderedAddCommMonoid.toPartialOrder.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3)))) a x) (SMul.smul.{u1, u2} ğ•œ E (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (OrderedAddCommMonoid.toAddCommMonoid.{u2} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} E _inst_2)) _inst_3)))) b y)) (LinearOrder.max.{u2} E (LinearOrderedAddCommMonoid.toLinearOrder.{u2} E _inst_2) x y))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} ğ•œ] [_inst_2 : LinearOrderedAddCommMonoid.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : OrderedSMul.{u2, u1} ğ•œ E _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (OrderedAddCommMonoid.toAddCommMonoid.{u1} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))] {a : ğ•œ} {b : ğ•œ} (x : E) (y : E), (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) a) -> (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedSemiring.toPartialOrder.{u2} ğ•œ _inst_1))) (OfNat.ofNat.{u2} ğ•œ 0 (Zero.toOfNat0.{u2} ğ•œ (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) b) -> (Eq.{succ u2} ğ•œ (HAdd.hAdd.{u2, u2, u2} ğ•œ ğ•œ ğ•œ (instHAdd.{u2} ğ•œ (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ğ•œ (Semiring.toNonAssocSemiring.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u2} ğ•œ 1 (One.toOfNat1.{u2} ğ•œ (Semiring.toOne.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))))) -> (LE.le.{u1} E (Preorder.toLE.{u1} E (PartialOrder.toPreorder.{u1} E (OrderedAddCommMonoid.toPartialOrder.{u1} E (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} E _inst_2)))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))))) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) a x) (HSMul.hSMul.{u2, u1, u1} ğ•œ E E (instHSMul.{u2, u1} ğ•œ E (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1)) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ _inst_1) (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) b y)) (Max.max.{u1} E (LinearOrder.toMax.{u1} E (LinearOrderedAddCommMonoid.toLinearOrder.{u1} E _inst_2)) x y))
Case conversion may be inaccurate. Consider using '#align convex.combo_le_max Convex.combo_le_maxâ‚“'. -/
theorem Convex.combo_le_max (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
    a â€¢ x + b â€¢ y â‰¤ max x y :=
  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).2
#align convex.combo_le_max Convex.combo_le_max

end LinearOrderedAddCommMonoid

end OrderedSemiring

section LinearOrderedField

variable [LinearOrderedField ğ•œ] {x y z : ğ•œ}

/- warning: Icc_subset_segment -> Icc_subset_segment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, HasSubset.Subset.{u1} (Set.{u1} ğ•œ) (Set.hasSubset.{u1} ğ•œ) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) (segment.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x y)
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, HasSubset.Subset.{u1} (Set.{u1} ğ•œ) (Set.instHasSubsetSet.{u1} ğ•œ) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y) (segment.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x y)
Case conversion may be inaccurate. Consider using '#align Icc_subset_segment Icc_subset_segmentâ‚“'. -/
theorem Icc_subset_segment : Icc x y âŠ† [x -[ğ•œ] y] :=
  by
  rintro z âŸ¨hxz, hyzâŸ©
  obtain rfl | h := (hxz.trans hyz).eq_or_lt
  Â· rw [segment_same]
    exact hyz.antisymm hxz
  rw [â† sub_nonneg] at hxz hyz
  rw [â† sub_pos] at h
  refine' âŸ¨(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, _, _âŸ©
  Â· rw [â† add_div, sub_add_sub_cancel, div_self h.ne']
  Â·
    rw [smul_eq_mul, smul_eq_mul, â† mul_div_right_comm, â† mul_div_right_comm, â† add_div,
      div_eq_iff h.ne', add_comm, sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]
#align Icc_subset_segment Icc_subset_segment

/- warning: segment_eq_Icc -> segment_eq_Icc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) x y) -> (Eq.{succ u1} (Set.{u1} ğ•œ) (segment.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x y) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) -> (Eq.{succ u1} (Set.{u1} ğ•œ) (segment.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x y) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y))
Case conversion may be inaccurate. Consider using '#align segment_eq_Icc segment_eq_Iccâ‚“'. -/
@[simp]
theorem segment_eq_Icc (h : x â‰¤ y) : [x -[ğ•œ] y] = Icc x y :=
  (segment_subset_Icc h).antisymm Icc_subset_segment
#align segment_eq_Icc segment_eq_Icc

/- warning: Ioo_subset_open_segment -> Ioo_subset_openSegment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, HasSubset.Subset.{u1} (Set.{u1} ğ•œ) (Set.hasSubset.{u1} ğ•œ) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) (openSegment.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x y)
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, HasSubset.Subset.{u1} (Set.{u1} ğ•œ) (Set.instHasSubsetSet.{u1} ğ•œ) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y) (openSegment.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x y)
Case conversion may be inaccurate. Consider using '#align Ioo_subset_open_segment Ioo_subset_openSegmentâ‚“'. -/
theorem Ioo_subset_openSegment : Ioo x y âŠ† openSegment ğ•œ x y := fun z hz =>
  mem_openSegment_of_ne_left_right hz.1.Ne hz.2.ne' <| Icc_subset_segment <| Ioo_subset_Icc_self hz
#align Ioo_subset_open_segment Ioo_subset_openSegment

/- warning: open_segment_eq_Ioo -> openSegment_eq_Ioo is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) x y) -> (Eq.{succ u1} (Set.{u1} ğ•œ) (openSegment.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x y) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) -> (Eq.{succ u1} (Set.{u1} ğ•œ) (openSegment.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x y) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y))
Case conversion may be inaccurate. Consider using '#align open_segment_eq_Ioo openSegment_eq_Iooâ‚“'. -/
@[simp]
theorem openSegment_eq_Ioo (h : x < y) : openSegment ğ•œ x y = Ioo x y :=
  (openSegment_subset_Ioo h).antisymm Ioo_subset_openSegment
#align open_segment_eq_Ioo openSegment_eq_Ioo

/- warning: segment_eq_Icc' -> segment_eq_Icc' is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] (x : ğ•œ) (y : ğ•œ), Eq.{succ u1} (Set.{u1} ğ•œ) (segment.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x y) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (LinearOrder.min.{u1} ğ•œ (LinearOrderedRing.toLinearOrder.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y) (LinearOrder.max.{u1} ğ•œ (LinearOrderedRing.toLinearOrder.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] (x : ğ•œ) (y : ğ•œ), Eq.{succ u1} (Set.{u1} ğ•œ) (segment.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x y) (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (Min.min.{u1} ğ•œ (LinearOrderedRing.toMin.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y) (Max.max.{u1} ğ•œ (LinearOrderedRing.toMax.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y))
Case conversion may be inaccurate. Consider using '#align segment_eq_Icc' segment_eq_Icc'â‚“'. -/
theorem segment_eq_Icc' (x y : ğ•œ) : [x -[ğ•œ] y] = Icc (min x y) (max x y) :=
  by
  cases le_total x y
  Â· rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]
  Â· rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]
#align segment_eq_Icc' segment_eq_Icc'

/- warning: open_segment_eq_Ioo' -> openSegment_eq_Ioo' is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, (Ne.{succ u1} ğ•œ x y) -> (Eq.{succ u1} (Set.{u1} ğ•œ) (openSegment.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x y) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (LinearOrder.min.{u1} ğ•œ (LinearOrderedRing.toLinearOrder.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y) (LinearOrder.max.{u1} ğ•œ (LinearOrderedRing.toLinearOrder.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ}, (Ne.{succ u1} ğ•œ x y) -> (Eq.{succ u1} (Set.{u1} ğ•œ) (openSegment.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x y) (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (Min.min.{u1} ğ•œ (LinearOrderedRing.toMin.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y) (Max.max.{u1} ğ•œ (LinearOrderedRing.toMax.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))) x y)))
Case conversion may be inaccurate. Consider using '#align open_segment_eq_Ioo' openSegment_eq_Ioo'â‚“'. -/
theorem openSegment_eq_Ioo' (hxy : x â‰  y) : openSegment ğ•œ x y = Ioo (min x y) (max x y) :=
  by
  cases hxy.lt_or_lt
  Â· rw [openSegment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]
  Â· rw [openSegment_symm, openSegment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]
#align open_segment_eq_Ioo' openSegment_eq_Ioo'

/- warning: segment_eq_uIcc -> segment_eq_uIcc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] (x : ğ•œ) (y : ğ•œ), Eq.{succ u1} (Set.{u1} ğ•œ) (segment.{u1, u1} ğ•œ ğ•œ (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Mul.toSMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) x y) (Set.uIcc.{u1} ğ•œ (LinearOrder.toLattice.{u1} ğ•œ (LinearOrderedRing.toLinearOrder.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))) x y)
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] (x : ğ•œ) (y : ğ•œ), Eq.{succ u1} (Set.{u1} ğ•œ) (segment.{u1, u1} ğ•œ ğ•œ (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) (Algebra.toSMul.{u1, u1} ğ•œ ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))) (DivisionSemiring.toSemiring.{u1} ğ•œ (Semifield.toDivisionSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))) (Algebra.id.{u1} ğ•œ (Semifield.toCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) x y) (Set.uIcc.{u1} ğ•œ (DistribLattice.toLattice.{u1} ğ•œ (instDistribLattice.{u1} ğ•œ (LinearOrderedRing.toLinearOrder.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y)
Case conversion may be inaccurate. Consider using '#align segment_eq_uIcc segment_eq_uIccâ‚“'. -/
theorem segment_eq_uIcc (x y : ğ•œ) : [x -[ğ•œ] y] = uIcc x y :=
  segment_eq_Icc' _ _
#align segment_eq_uIcc segment_eq_uIcc

/- warning: convex.mem_Icc -> Convex.mem_Icc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) x y) -> (Iff (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) z (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) a) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) b y)) z)))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) -> (Iff (Membership.mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.instMembershipSet.{u1} ğ•œ) z (Set.Icc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) a) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) b y)) z)))))))
Case conversion may be inaccurate. Consider using '#align convex.mem_Icc Convex.mem_Iccâ‚“'. -/
/-- A point is in an `Icc` iff it can be expressed as a convex combination of the endpoints. -/
theorem Convex.mem_Icc (h : x â‰¤ y) :
    z âˆˆ Icc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=
  by
  rw [â† segment_eq_Icc h]
  simp_rw [â† exists_prop]
  rfl
#align convex.mem_Icc Convex.mem_Icc

/- warning: convex.mem_Ioo -> Convex.mem_Ioo is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) x y) -> (Iff (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) z (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) a) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) b y)) z)))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) -> (Iff (Membership.mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.instMembershipSet.{u1} ğ•œ) z (Set.Ioo.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) a) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) b y)) z)))))))
Case conversion may be inaccurate. Consider using '#align convex.mem_Ioo Convex.mem_Iooâ‚“'. -/
/-- A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.
-/
theorem Convex.mem_Ioo (h : x < y) :
    z âˆˆ Ioo x y â†” âˆƒ a b, 0 < a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=
  by
  rw [â† openSegment_eq_Ioo h]
  simp_rw [â† exists_prop]
  rfl
#align convex.mem_Ioo Convex.mem_Ioo

/- warning: convex.mem_Ioc -> Convex.mem_Ioc is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) x y) -> (Iff (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) z (Set.Ioc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) a) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) b y)) z)))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) -> (Iff (Membership.mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.instMembershipSet.{u1} ğ•œ) z (Set.Ioc.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) a) (And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) b y)) z)))))))
Case conversion may be inaccurate. Consider using '#align convex.mem_Ioc Convex.mem_Iocâ‚“'. -/
/-- A point is in an `Ioc` iff it can be expressed as a semistrict convex combination of the
endpoints. -/
theorem Convex.mem_Ioc (h : x < y) :
    z âˆˆ Ioc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=
  by
  refine' âŸ¨fun hz => _, _âŸ©
  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (Convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)
    obtain rfl | hb' := hb.eq_or_lt
    Â· rw [add_zero] at hab
      rw [hab, one_mul, MulZeroClass.zero_mul, add_zero] at hz
      exact (hz.1.Ne rfl).elim
    Â· exact âŸ¨a, b, ha, hb', hab, rflâŸ©
  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©
    obtain rfl | ha' := ha.eq_or_lt
    Â· rw [zero_add] at hab
      rwa [hab, one_mul, MulZeroClass.zero_mul, zero_add, right_mem_Ioc]
    Â· exact Ioo_subset_Ioc_self ((Convex.mem_Ioo h).2 âŸ¨a, b, ha', hb, hab, rflâŸ©)
#align convex.mem_Ioc Convex.mem_Ioc

/- warning: convex.mem_Ico -> Convex.mem_Ico is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) x y) -> (Iff (Membership.Mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.hasMem.{u1} ğ•œ) z (Set.Ico.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) a) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))))) (OfNat.ofNat.{u1} ğ•œ 0 (OfNat.mk.{u1} ğ•œ 0 (Zero.zero.{u1} ğ•œ (MulZeroClass.toHasZero.{u1} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (OfNat.mk.{u1} ğ•œ 1 (One.one.{u1} ğ•œ (AddMonoidWithOne.toOne.{u1} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ğ•œ (Ring.toAddCommGroupWithOne.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (Distrib.toHasMul.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))) b y)) z)))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] {x : ğ•œ} {y : ğ•œ} {z : ğ•œ}, (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) x y) -> (Iff (Membership.mem.{u1, u1} ğ•œ (Set.{u1} ğ•œ) (Set.instMembershipSet.{u1} ğ•œ) z (Set.Ico.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1))))) x y)) (Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Exists.{succ u1} ğ•œ (fun (b : ğ•œ) => And (LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) a) (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) b) (And (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) a b) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (NonAssocRing.toOne.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1)))))))) (Eq.{succ u1} ğ•œ (HAdd.hAdd.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHAdd.{u1} ğ•œ (Distrib.toAdd.{u1} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u1} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))))) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) a x) (HMul.hMul.{u1, u1, u1} ğ•œ ğ•œ ğ•œ (instHMul.{u1} ğ•œ (NonUnitalNonAssocRing.toMul.{u1} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (DivisionRing.toRing.{u1} ğ•œ (Field.toDivisionRing.{u1} ğ•œ (LinearOrderedField.toField.{u1} ğ•œ _inst_1))))))) b y)) z)))))))
Case conversion may be inaccurate. Consider using '#align convex.mem_Ico Convex.mem_Icoâ‚“'. -/
/-- A point is in an `Ico` iff it can be expressed as a semistrict convex combination of the
endpoints. -/
theorem Convex.mem_Ico (h : x < y) :
    z âˆˆ Ico x y â†” âˆƒ a b, 0 < a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=
  by
  refine' âŸ¨fun hz => _, _âŸ©
  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (Convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)
    obtain rfl | ha' := ha.eq_or_lt
    Â· rw [zero_add] at hab
      rw [hab, one_mul, MulZeroClass.zero_mul, zero_add] at hz
      exact (hz.2.Ne rfl).elim
    Â· exact âŸ¨a, b, ha', hb, hab, rflâŸ©
  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©
    obtain rfl | hb' := hb.eq_or_lt
    Â· rw [add_zero] at hab
      rwa [hab, one_mul, MulZeroClass.zero_mul, add_zero, left_mem_Ico]
    Â· exact Ioo_subset_Ico_self ((Convex.mem_Ioo h).2 âŸ¨a, b, ha, hb', hab, rflâŸ©)
#align convex.mem_Ico Convex.mem_Ico

end LinearOrderedField

namespace Prod

variable [OrderedSemiring ğ•œ] [AddCommMonoid E] [AddCommMonoid F] [Module ğ•œ E] [Module ğ•œ F]

/- warning: prod.segment_subset -> Prod.segment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : Prod.{u2, u3} E F) (y : Prod.{u2, u3} E F), HasSubset.Subset.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} E F)) (Set.hasSubset.{max u2 u3} (Prod.{u2, u3} E F)) (segment.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) x y) (Set.prod.{u2, u3} E F (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Prod.fst.{u2, u3} E F x) (Prod.fst.{u2, u3} E F y)) (segment.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (Prod.snd.{u2, u3} E F x) (Prod.snd.{u2, u3} E F y)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : Prod.{u3, u2} E F) (y : Prod.{u3, u2} E F), HasSubset.Subset.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} E F)) (Set.instHasSubsetSet.{max u3 u2} (Prod.{u3, u2} E F)) (segment.{u1, max u3 u2} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) x y) (Set.prod.{u3, u2} E F (segment.{u1, u3} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Prod.fst.{u3, u2} E F x) (Prod.fst.{u3, u2} E F y)) (segment.{u1, u2} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (Prod.snd.{u3, u2} E F x) (Prod.snd.{u3, u2} E F y)))
Case conversion may be inaccurate. Consider using '#align prod.segment_subset Prod.segment_subsetâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem segment_subset (x y : E Ã— F) : segment ğ•œ x y âŠ† segment ğ•œ x.1 y.1 Ã—Ë¢ segment ğ•œ x.2 y.2 :=
  by
  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ©
  exact âŸ¨âŸ¨a, b, ha, hb, hab, congr_arg Prod.fst hzâŸ©, a, b, ha, hb, hab, congr_arg Prod.snd hzâŸ©
#align prod.segment_subset Prod.segment_subset

/- warning: prod.open_segment_subset -> Prod.openSegment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : Prod.{u2, u3} E F) (y : Prod.{u2, u3} E F), HasSubset.Subset.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} E F)) (Set.hasSubset.{max u2 u3} (Prod.{u2, u3} E F)) (openSegment.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) x y) (Set.prod.{u2, u3} E F (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Prod.fst.{u2, u3} E F x) (Prod.fst.{u2, u3} E F y)) (openSegment.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (Prod.snd.{u2, u3} E F x) (Prod.snd.{u2, u3} E F y)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : Prod.{u3, u2} E F) (y : Prod.{u3, u2} E F), HasSubset.Subset.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} E F)) (Set.instHasSubsetSet.{max u3 u2} (Prod.{u3, u2} E F)) (openSegment.{u1, max u3 u2} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) x y) (Set.prod.{u3, u2} E F (openSegment.{u1, u3} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (Prod.fst.{u3, u2} E F x) (Prod.fst.{u3, u2} E F y)) (openSegment.{u1, u2} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) (Prod.snd.{u3, u2} E F x) (Prod.snd.{u3, u2} E F y)))
Case conversion may be inaccurate. Consider using '#align prod.open_segment_subset Prod.openSegment_subsetâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem openSegment_subset (x y : E Ã— F) :
    openSegment ğ•œ x y âŠ† openSegment ğ•œ x.1 y.1 Ã—Ë¢ openSegment ğ•œ x.2 y.2 :=
  by
  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ©
  exact âŸ¨âŸ¨a, b, ha, hb, hab, congr_arg Prod.fst hzâŸ©, a, b, ha, hb, hab, congr_arg Prod.snd hzâŸ©
#align prod.open_segment_subset Prod.openSegment_subset

/- warning: prod.image_mk_segment_left -> Prod.image_mk_segment_left is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (xâ‚ : E) (xâ‚‚ : E) (y : F), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (Prod.{u2, u3} E F)) (Set.image.{u2, max u2 u3} E (Prod.{u2, u3} E F) (fun (x : E) => Prod.mk.{u2, u3} E F x y) (segment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) xâ‚ xâ‚‚)) (segment.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u2, u3} E F xâ‚ y) (Prod.mk.{u2, u3} E F xâ‚‚ y))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (xâ‚ : E) (xâ‚‚ : E) (y : F), Eq.{max (succ u3) (succ u2)} (Set.{max u2 u3} (Prod.{u3, u2} E F)) (Set.image.{u3, max u2 u3} E (Prod.{u3, u2} E F) (fun (x : E) => Prod.mk.{u3, u2} E F x y) (segment.{u1, u3} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) xâ‚ xâ‚‚)) (segment.{u1, max u2 u3} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u3, u2} E F xâ‚ y) (Prod.mk.{u3, u2} E F xâ‚‚ y))
Case conversion may be inaccurate. Consider using '#align prod.image_mk_segment_left Prod.image_mk_segment_leftâ‚“'. -/
theorem image_mk_segment_left (xâ‚ xâ‚‚ : E) (y : F) :
    (fun x => (x, y)) '' [xâ‚ -[ğ•œ] xâ‚‚] = [(xâ‚, y) -[ğ•œ] (xâ‚‚, y)] :=
  by
  ext âŸ¨x', y'âŸ©
  simp_rw [Set.mem_image, segment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, â†
    exists_and_right, @exists_comm E, exists_eq_left']
  refine' existsâ‚…_congr fun a b ha hb hab => _
  rw [Convex.combo_self hab]
#align prod.image_mk_segment_left Prod.image_mk_segment_left

/- warning: prod.image_mk_segment_right -> Prod.image_mk_segment_right is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : E) (yâ‚ : F) (yâ‚‚ : F), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (Prod.{u2, u3} E F)) (Set.image.{u3, max u2 u3} F (Prod.{u2, u3} E F) (fun (y : F) => Prod.mk.{u2, u3} E F x y) (segment.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) yâ‚ yâ‚‚)) (segment.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u2, u3} E F x yâ‚) (Prod.mk.{u2, u3} E F x yâ‚‚))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : E) (yâ‚ : F) (yâ‚‚ : F), Eq.{max (succ u3) (succ u2)} (Set.{max u2 u3} (Prod.{u3, u2} E F)) (Set.image.{u2, max u2 u3} F (Prod.{u3, u2} E F) (fun (y : F) => Prod.mk.{u3, u2} E F x y) (segment.{u1, u2} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) yâ‚ yâ‚‚)) (segment.{u1, max u2 u3} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u3, u2} E F x yâ‚) (Prod.mk.{u3, u2} E F x yâ‚‚))
Case conversion may be inaccurate. Consider using '#align prod.image_mk_segment_right Prod.image_mk_segment_rightâ‚“'. -/
theorem image_mk_segment_right (x : E) (yâ‚ yâ‚‚ : F) :
    (fun y => (x, y)) '' [yâ‚ -[ğ•œ] yâ‚‚] = [(x, yâ‚) -[ğ•œ] (x, yâ‚‚)] :=
  by
  ext âŸ¨x', y'âŸ©
  simp_rw [Set.mem_image, segment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, â†
    exists_and_right, @exists_comm F, exists_eq_left']
  refine' existsâ‚…_congr fun a b ha hb hab => _
  rw [Convex.combo_self hab]
#align prod.image_mk_segment_right Prod.image_mk_segment_right

/- warning: prod.image_mk_open_segment_left -> Prod.image_mk_openSegment_left is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (xâ‚ : E) (xâ‚‚ : E) (y : F), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (Prod.{u2, u3} E F)) (Set.image.{u2, max u2 u3} E (Prod.{u2, u3} E F) (fun (x : E) => Prod.mk.{u2, u3} E F x y) (openSegment.{u1, u2} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) xâ‚ xâ‚‚)) (openSegment.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u2, u3} E F xâ‚ y) (Prod.mk.{u2, u3} E F xâ‚‚ y))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (xâ‚ : E) (xâ‚‚ : E) (y : F), Eq.{max (succ u3) (succ u2)} (Set.{max u2 u3} (Prod.{u3, u2} E F)) (Set.image.{u3, max u2 u3} E (Prod.{u3, u2} E F) (fun (x : E) => Prod.mk.{u3, u2} E F x y) (openSegment.{u1, u3} ğ•œ E _inst_1 _inst_2 (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) xâ‚ xâ‚‚)) (openSegment.{u1, max u2 u3} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u3, u2} E F xâ‚ y) (Prod.mk.{u3, u2} E F xâ‚‚ y))
Case conversion may be inaccurate. Consider using '#align prod.image_mk_open_segment_left Prod.image_mk_openSegment_leftâ‚“'. -/
theorem image_mk_openSegment_left (xâ‚ xâ‚‚ : E) (y : F) :
    (fun x => (x, y)) '' openSegment ğ•œ xâ‚ xâ‚‚ = openSegment ğ•œ (xâ‚, y) (xâ‚‚, y) :=
  by
  ext âŸ¨x', y'âŸ©
  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff,
    â† exists_and_right, @exists_comm E, exists_eq_left']
  refine' existsâ‚…_congr fun a b ha hb hab => _
  rw [Convex.combo_self hab]
#align prod.image_mk_open_segment_left Prod.image_mk_openSegment_left

/- warning: prod.image_mk_open_segment_right -> Prod.image_mk_openSegment_right is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u2} E] [_inst_3 : AddCommMonoid.{u3} F] [_inst_4 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : E) (yâ‚ : F) (yâ‚‚ : F), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (Prod.{u2, u3} E F)) (Set.image.{u3, max u2 u3} F (Prod.{u2, u3} E F) (fun (y : F) => Prod.mk.{u2, u3} E F x y) (openSegment.{u1, u3} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) yâ‚ yâ‚‚)) (openSegment.{u1, max u2 u3} ğ•œ (Prod.{u2, u3} E F) _inst_1 (Prod.addCommMonoid.{u2, u3} E F _inst_2 _inst_3) (Prod.smul.{u1, u2, u3} ğ•œ E F (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ F (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F _inst_3))) (Module.toMulActionWithZero.{u1, u3} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u2, u3} E F x yâ‚) (Prod.mk.{u2, u3} E F x yâ‚‚))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u3}} {F : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : AddCommMonoid.{u2} F] [_inst_4 : Module.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2] [_inst_5 : Module.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3] (x : E) (yâ‚ : F) (yâ‚‚ : F), Eq.{max (succ u3) (succ u2)} (Set.{max u2 u3} (Prod.{u3, u2} E F)) (Set.image.{u2, max u2 u3} F (Prod.{u3, u2} E F) (fun (y : F) => Prod.mk.{u3, u2} E F x y) (openSegment.{u1, u2} ğ•œ F _inst_1 _inst_3 (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5)))) yâ‚ yâ‚‚)) (openSegment.{u1, max u2 u3} ğ•œ (Prod.{u3, u2} E F) _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} E F _inst_2 _inst_3) (Prod.smul.{u1, u3, u2} ğ•œ E F (SMulZeroClass.toSMul.{u1, u3} ğ•œ E (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u3} ğ•œ E (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)) (Module.toMulActionWithZero.{u1, u3} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_2 _inst_4)))) (SMulZeroClass.toSMul.{u1, u2} ğ•œ F (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ F (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ F (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} F (AddCommMonoid.toAddMonoid.{u2} F _inst_3)) (Module.toMulActionWithZero.{u1, u2} ğ•œ F (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) _inst_3 _inst_5))))) (Prod.mk.{u3, u2} E F x yâ‚) (Prod.mk.{u3, u2} E F x yâ‚‚))
Case conversion may be inaccurate. Consider using '#align prod.image_mk_open_segment_right Prod.image_mk_openSegment_rightâ‚“'. -/
@[simp]
theorem image_mk_openSegment_right (x : E) (yâ‚ yâ‚‚ : F) :
    (fun y => (x, y)) '' openSegment ğ•œ yâ‚ yâ‚‚ = openSegment ğ•œ (x, yâ‚) (x, yâ‚‚) :=
  by
  ext âŸ¨x', y'âŸ©
  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff,
    â† exists_and_right, @exists_comm F, exists_eq_left']
  refine' existsâ‚…_congr fun a b ha hb hab => _
  rw [Convex.combo_self hab]
#align prod.image_mk_open_segment_right Prod.image_mk_openSegment_right

end Prod

namespace Pi

variable [OrderedSemiring ğ•œ] [âˆ€ i, AddCommMonoid (Ï€ i)] [âˆ€ i, Module ğ•œ (Ï€ i)] {s : Set Î¹}

/- warning: pi.segment_subset -> Pi.segment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u2}} {Ï€ : Î¹ -> Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u3} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] {s : Set.{u2} Î¹} (x : forall (i : Î¹), Ï€ i) (y : forall (i : Î¹), Ï€ i), HasSubset.Subset.{max u2 u3} (Set.{max u2 u3} (forall (i : Î¹), Ï€ i)) (Set.hasSubset.{max u2 u3} (forall (i : Î¹), Ï€ i)) (segment.{u1, max u2 u3} ğ•œ (forall (i : Î¹), Ï€ i) _inst_1 (Pi.addCommMonoid.{u2, u3} Î¹ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u2, u3, u1} Î¹ ğ•œ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) x y) (Set.pi.{u2, u3} Î¹ (fun (i : Î¹) => Ï€ i) s (fun (i : Î¹) => segment.{u1, u3} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) (x i) (y i)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u3}} {Ï€ : Î¹ -> Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u2} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] {s : Set.{u3} Î¹} (x : forall (i : Î¹), Ï€ i) (y : forall (i : Î¹), Ï€ i), HasSubset.Subset.{max u3 u2} (Set.{max u3 u2} (forall (i : Î¹), Ï€ i)) (Set.instHasSubsetSet.{max u3 u2} (forall (i : Î¹), Ï€ i)) (segment.{u1, max u3 u2} ğ•œ (forall (i : Î¹), Ï€ i) _inst_1 (Pi.addCommMonoid.{u3, u2} Î¹ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u3, u2, u1} Î¹ ğ•œ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) x y) (Set.pi.{u3, u2} Î¹ (fun (i : Î¹) => Ï€ i) s (fun (i : Î¹) => segment.{u1, u2} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) (x i) (y i)))
Case conversion may be inaccurate. Consider using '#align pi.segment_subset Pi.segment_subsetâ‚“'. -/
theorem segment_subset (x y : âˆ€ i, Ï€ i) : segment ğ•œ x y âŠ† s.pi fun i => segment ğ•œ (x i) (y i) :=
  by
  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ© i -
  exact âŸ¨a, b, ha, hb, hab, congr_fun hz iâŸ©
#align pi.segment_subset Pi.segment_subset

/- warning: pi.open_segment_subset -> Pi.openSegment_subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u2}} {Ï€ : Î¹ -> Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u3} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] {s : Set.{u2} Î¹} (x : forall (i : Î¹), Ï€ i) (y : forall (i : Î¹), Ï€ i), HasSubset.Subset.{max u2 u3} (Set.{max u2 u3} (forall (i : Î¹), Ï€ i)) (Set.hasSubset.{max u2 u3} (forall (i : Î¹), Ï€ i)) (openSegment.{u1, max u2 u3} ğ•œ (forall (i : Î¹), Ï€ i) _inst_1 (Pi.addCommMonoid.{u2, u3} Î¹ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u2, u3, u1} Î¹ ğ•œ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) x y) (Set.pi.{u2, u3} Î¹ (fun (i : Î¹) => Ï€ i) s (fun (i : Î¹) => openSegment.{u1, u3} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) (x i) (y i)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u3}} {Ï€ : Î¹ -> Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u2} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] {s : Set.{u3} Î¹} (x : forall (i : Î¹), Ï€ i) (y : forall (i : Î¹), Ï€ i), HasSubset.Subset.{max u3 u2} (Set.{max u3 u2} (forall (i : Î¹), Ï€ i)) (Set.instHasSubsetSet.{max u3 u2} (forall (i : Î¹), Ï€ i)) (openSegment.{u1, max u3 u2} ğ•œ (forall (i : Î¹), Ï€ i) _inst_1 (Pi.addCommMonoid.{u3, u2} Î¹ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u3, u2, u1} Î¹ ğ•œ (fun (i : Î¹) => Ï€ i) (fun (i : Î¹) => SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) x y) (Set.pi.{u3, u2} Î¹ (fun (i : Î¹) => Ï€ i) s (fun (i : Î¹) => openSegment.{u1, u2} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) (x i) (y i)))
Case conversion may be inaccurate. Consider using '#align pi.open_segment_subset Pi.openSegment_subsetâ‚“'. -/
theorem openSegment_subset (x y : âˆ€ i, Ï€ i) :
    openSegment ğ•œ x y âŠ† s.pi fun i => openSegment ğ•œ (x i) (y i) :=
  by
  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ© i -
  exact âŸ¨a, b, ha, hb, hab, congr_fun hz iâŸ©
#align pi.open_segment_subset Pi.openSegment_subset

variable [DecidableEq Î¹]

/- warning: pi.image_update_segment -> Pi.image_update_segment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u2}} {Ï€ : Î¹ -> Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u3} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} Î¹] (i : Î¹) (xâ‚ : Ï€ i) (xâ‚‚ : Ï€ i) (y : forall (i : Î¹), Ï€ i), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (forall (a : Î¹), Ï€ a)) (Set.image.{u3, max u2 u3} (Ï€ i) (forall (a : Î¹), Ï€ a) (Function.update.{succ u2, succ u3} Î¹ (fun (i : Î¹) => Ï€ i) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i) (segment.{u1, u3} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) xâ‚ xâ‚‚)) (segment.{u1, max u2 u3} ğ•œ (forall (a : Î¹), Ï€ a) _inst_1 (Pi.addCommMonoid.{u2, u3} Î¹ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u2, u3, u1} Î¹ ğ•œ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) (Function.update.{succ u2, succ u3} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚) (Function.update.{succ u2, succ u3} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚‚))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u3}} {Ï€ : Î¹ -> Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u2} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} Î¹] (i : Î¹) (xâ‚ : Ï€ i) (xâ‚‚ : Ï€ i) (y : forall (i : Î¹), Ï€ i), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (forall (a : Î¹), Ï€ a)) (Set.image.{u2, max u3 u2} (Ï€ i) (forall (a : Î¹), Ï€ a) (Function.update.{succ u3, succ u2} Î¹ (fun (i : Î¹) => Ï€ i) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i) (segment.{u1, u2} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) xâ‚ xâ‚‚)) (segment.{u1, max u3 u2} ğ•œ (forall (a : Î¹), Ï€ a) _inst_1 (Pi.addCommMonoid.{u3, u2} Î¹ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u3, u2, u1} Î¹ ğ•œ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) (Function.update.{succ u3, succ u2} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚) (Function.update.{succ u3, succ u2} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚‚))
Case conversion may be inaccurate. Consider using '#align pi.image_update_segment Pi.image_update_segmentâ‚“'. -/
theorem image_update_segment (i : Î¹) (xâ‚ xâ‚‚ : Ï€ i) (y : âˆ€ i, Ï€ i) :
    update y i '' [xâ‚ -[ğ•œ] xâ‚‚] = [update y i xâ‚ -[ğ•œ] update y i xâ‚‚] :=
  by
  ext z
  simp_rw [Set.mem_image, segment, Set.mem_setOf, â† update_smul, â† update_add, update_eq_iff, â†
    exists_and_right, @exists_comm (Ï€ i), exists_eq_left']
  refine' existsâ‚…_congr fun a b ha hb hab => _
  rw [Convex.combo_self hab]
#align pi.image_update_segment Pi.image_update_segment

/- warning: pi.image_update_open_segment -> Pi.image_update_openSegment is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u2}} {Ï€ : Î¹ -> Type.{u3}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u3} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} Î¹] (i : Î¹) (xâ‚ : Ï€ i) (xâ‚‚ : Ï€ i) (y : forall (i : Î¹), Ï€ i), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (forall (a : Î¹), Ï€ a)) (Set.image.{u3, max u2 u3} (Ï€ i) (forall (a : Î¹), Ï€ a) (Function.update.{succ u2, succ u3} Î¹ (fun (i : Î¹) => Ï€ i) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i) (openSegment.{u1, u3} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) xâ‚ xâ‚‚)) (openSegment.{u1, max u2 u3} ğ•œ (forall (a : Î¹), Ï€ a) _inst_1 (Pi.addCommMonoid.{u2, u3} Î¹ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u2, u3, u1} Î¹ ğ•œ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => SMulZeroClass.toHasSmul.{u1, u3} ğ•œ (Ï€ i) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} ğ•œ (Ï€ i) (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))))) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddZeroClass.toHasZero.{u3} (Ï€ i) (AddMonoid.toAddZeroClass.{u3} (Ï€ i) (AddCommMonoid.toAddMonoid.{u3} (Ï€ i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) (Function.update.{succ u2, succ u3} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚) (Function.update.{succ u2, succ u3} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚‚))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {Î¹ : Type.{u3}} {Ï€ : Î¹ -> Type.{u2}} [_inst_1 : OrderedSemiring.{u1} ğ•œ] [_inst_2 : forall (i : Î¹), AddCommMonoid.{u2} (Ï€ i)] [_inst_3 : forall (i : Î¹), Module.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} Î¹] (i : Î¹) (xâ‚ : Ï€ i) (xâ‚‚ : Ï€ i) (y : forall (i : Î¹), Ï€ i), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (forall (a : Î¹), Ï€ a)) (Set.image.{u2, max u3 u2} (Ï€ i) (forall (a : Î¹), Ï€ a) (Function.update.{succ u3, succ u2} Î¹ (fun (i : Î¹) => Ï€ i) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i) (openSegment.{u1, u2} ğ•œ (Ï€ i) _inst_1 (_inst_2 i) (SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i))))) xâ‚ xâ‚‚)) (openSegment.{u1, max u3 u2} ğ•œ (forall (a : Î¹), Ï€ a) _inst_1 (Pi.addCommMonoid.{u3, u2} Î¹ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => _inst_2 i)) (Pi.instSMul.{u3, u2, u1} Î¹ ğ•œ (fun (a : Î¹) => Ï€ a) (fun (i : Î¹) => SMulZeroClass.toSMul.{u1, u2} ğ•œ (Ï€ i) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ (Ï€ i) (MonoidWithZero.toZero.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1))) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ (Ï€ i) (Semiring.toMonoidWithZero.{u1} ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1)) (AddMonoid.toZero.{u2} (Ï€ i) (AddCommMonoid.toAddMonoid.{u2} (Ï€ i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u2} ğ•œ (Ï€ i) (OrderedSemiring.toSemiring.{u1} ğ•œ _inst_1) (_inst_2 i) (_inst_3 i)))))) (Function.update.{succ u3, succ u2} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚) (Function.update.{succ u3, succ u2} Î¹ (fun (a : Î¹) => Ï€ a) (fun (a : Î¹) (b : Î¹) => _inst_4 a b) y i xâ‚‚))
Case conversion may be inaccurate. Consider using '#align pi.image_update_open_segment Pi.image_update_openSegmentâ‚“'. -/
theorem image_update_openSegment (i : Î¹) (xâ‚ xâ‚‚ : Ï€ i) (y : âˆ€ i, Ï€ i) :
    update y i '' openSegment ğ•œ xâ‚ xâ‚‚ = openSegment ğ•œ (update y i xâ‚) (update y i xâ‚‚) :=
  by
  ext z
  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, â† update_smul, â† update_add, update_eq_iff, â†
    exists_and_right, @exists_comm (Ï€ i), exists_eq_left']
  refine' existsâ‚…_congr fun a b ha hb hab => _
  rw [Convex.combo_self hab]
#align pi.image_update_open_segment Pi.image_update_openSegment

end Pi

