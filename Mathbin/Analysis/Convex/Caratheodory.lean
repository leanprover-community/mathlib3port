/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Scott Morrison

! This file was ported from Lean 3 source module analysis.convex.caratheodory
! leanprover-community/mathlib commit 9d2f0748e6c50d7a2657c564b1ff2c695b39148d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Combination
import Mathbin.LinearAlgebra.AffineSpace.Independent
import Mathbin.Tactic.FieldSimp

/-!
# CarathÃ©odory's convexity theorem

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Convex hull can be regarded as a refinement of affine span. Both are closure operators but whereas
convex hull takes values in the lattice of convex subsets, affine span takes values in the much
coarser sublattice of affine subspaces.

The cost of this refinement is that one no longer has bases. However CarathÃ©odory's convexity
theorem offers some compensation. Given a set `s` together with a point `x` in its convex hull,
CarathÃ©odory says that one may find an affine-independent family of elements `s` whose convex hull
contains `x`. Thus the difference from the case of affine span is that the affine-independent family
depends on `x`.

In particular, in finite dimensions CarathÃ©odory's theorem implies that the convex hull of a set `s`
in `ğ•œáµˆ` is the union of the convex hulls of the `(d + 1)`-tuples in `s`.

## Main results

* `convex_hull_eq_union`: CarathÃ©odory's convexity theorem

## Implementation details

This theorem was formalized as part of the Sphere Eversion project.

## Tags
convex hull, caratheodory

-/


open Set Finset

open BigOperators

universe u

variable {ğ•œ : Type _} {E : Type u} [LinearOrderedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]

namespace Caratheodory

/- warning: caratheodory.mem_convex_hull_erase -> Caratheodory.mem_convexHull_erase is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_4 : DecidableEq.{succ u1} E] {t : Finset.{u1} E}, (Not (AffineIndependent.{u2, u1, u1, u1} ğ•œ E E (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x t)))))))) -> (forall {x : E}, (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t))) -> (Exists.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) (fun (y : coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) (Finset.erase.{u1} E (fun (a : E) (b : E) => _inst_4 a b) t ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} E) Type.{u1} (Set.hasCoeToSort.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)))))) y)))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : DecidableEq.{succ u2} E] {t : Finset.{u2} E}, (Not (AffineIndependent.{u1, u2, u2, u2} ğ•œ E E (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)))) -> (forall {x : E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E t))) -> (Exists.{succ u2} (Set.Elem.{u2} E (Finset.toSet.{u2} E t)) (fun (y : Set.Elem.{u2} E (Finset.toSet.{u2} E t)) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E (Finset.erase.{u2} E (fun (a : E) (b : E) => _inst_4 a b) t (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (Finset.toSet.{u2} E t)) y)))))))
Case conversion may be inaccurate. Consider using '#align caratheodory.mem_convex_hull_erase Caratheodory.mem_convexHull_eraseâ‚“'. -/
/-- If `x` is in the convex hull of some finset `t` whose elements are not affine-independent,
then it is in the convex hull of a strict subset of `t`. -/
theorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : Â¬AffineIndependent ğ•œ (coe : t â†’ E))
    {x : E} (m : x âˆˆ convexHull ğ•œ (â†‘t : Set E)) :
    âˆƒ y : (â†‘t : Set E), x âˆˆ convexHull ğ•œ (â†‘(t.eraseâ‚“ y) : Set E) :=
  by
  simp only [Finset.convexHull_eq, mem_set_of_eq] at mâŠ¢
  obtain âŸ¨f, fpos, fsum, rflâŸ© := m
  obtain âŸ¨g, gcombo, gsum, gposâŸ© := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLt _ _) t
  obtain âŸ¨iâ‚€, mem, wâŸ© : âˆƒ iâ‚€ âˆˆ s, âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i :=
    by
    apply s.exists_min_image fun z => f z / g z
    obtain âŸ¨x, hx, hgxâŸ© : âˆƒ x âˆˆ t, 0 < g x := gpos
    exact âŸ¨x, mem_filter.mpr âŸ¨hx, hgxâŸ©âŸ©
  have hg : 0 < g iâ‚€ := by
    rw [mem_filter] at mem
    exact mem.2
  have hiâ‚€ : iâ‚€ âˆˆ t := filter_subset _ _ mem
  let k : E â†’ ğ•œ := fun z => f z - f iâ‚€ / g iâ‚€ * g z
  have hk : k iâ‚€ = 0 := by field_simp [k, ne_of_gt hg]
  have ksum : (âˆ‘ e in t.erase iâ‚€, k e) = 1 := by
    calc
      (âˆ‘ e in t.erase iâ‚€, k e) = âˆ‘ e in t, k e := by
        conv_rhs => rw [â† insert_erase hiâ‚€, sum_insert (not_mem_erase iâ‚€ t), hk, zero_add]
      _ = âˆ‘ e in t, f e - f iâ‚€ / g iâ‚€ * g e := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, â† mul_sum, gsum, MulZeroClass.mul_zero, sub_zero]
      
  refine' âŸ¨âŸ¨iâ‚€, hiâ‚€âŸ©, k, _, by convert ksum, _âŸ©
  Â· simp only [and_imp, sub_nonneg, mem_erase, Ne.def, Subtype.coe_mk]
    intro e heiâ‚€ het
    by_cases hes : e âˆˆ s
    Â· have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [â† le_div_iff hge]
      exact w _ hes
    Â· calc
        _ â‰¤ 0 := mul_nonpos_of_nonneg_of_nonpos _ _
        -- prove two goals below
            _ â‰¤
            f e :=
          fpos e het
        
      Â· apply div_nonneg (fpos iâ‚€ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
      Â· simpa only [mem_filter, het, true_and_iff, not_lt] using hes
  Â· simp only [Subtype.coe_mk, center_mass_eq_of_sum_1 _ id ksum, id]
    calc
      (âˆ‘ e in t.erase iâ‚€, k e â€¢ e) = âˆ‘ e in t, k e â€¢ e := sum_erase _ (by rw [hk, zero_smul])
      _ = âˆ‘ e in t, (f e - f iâ‚€ / g iâ‚€ * g e) â€¢ e := rfl
      _ = t.center_mass f id := _
      
    simp only [sub_smul, mul_smul, sum_sub_distrib, â† smul_sum, gcombo, smul_zero, sub_zero,
      center_mass, fsum, inv_one, one_smul, id.def]
#align caratheodory.mem_convex_hull_erase Caratheodory.mem_convexHull_erase

variable {s : Set E} {x : E} (hx : x âˆˆ convexHull ğ•œ s)

include hx

#print Caratheodory.minCardFinsetOfMemConvexHull /-
/-- Given a point `x` in the convex hull of a set `s`, this is a finite subset of `s` of minimum
cardinality, whose convex hull contains `x`. -/
noncomputable def minCardFinsetOfMemConvexHull : Finset E :=
  Function.argminOn Finset.card Nat.lt_wfRel { t | â†‘t âŠ† s âˆ§ x âˆˆ convexHull ğ•œ (t : Set E) }
    (by
      simpa only [convexHull_eq_union_convexHull_finite_subsets s, exists_prop, mem_Union] using hx)
#align caratheodory.min_card_finset_of_mem_convex_hull Caratheodory.minCardFinsetOfMemConvexHull
-/

/- warning: caratheodory.min_card_finset_of_mem_convex_hull_subseteq -> Caratheodory.minCardFinsetOfMemConvexHull_subseteq is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) s
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) s
Case conversion may be inaccurate. Consider using '#align caratheodory.min_card_finset_of_mem_convex_hull_subseteq Caratheodory.minCardFinsetOfMemConvexHull_subseteqâ‚“'. -/
theorem minCardFinsetOfMemConvexHull_subseteq : â†‘(minCardFinsetOfMemConvexHull hx) âŠ† s :=
  (Function.argminOn_mem _ _ { t : Finset E | â†‘t âŠ† s âˆ§ x âˆˆ convexHull ğ•œ (t : Set E) } _).1
#align caratheodory.min_card_finset_of_mem_convex_hull_subseteq Caratheodory.minCardFinsetOfMemConvexHull_subseteq

/- warning: caratheodory.mem_min_card_finset_of_mem_convex_hull -> Caratheodory.mem_minCardFinsetOfMemConvexHull is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)))
Case conversion may be inaccurate. Consider using '#align caratheodory.mem_min_card_finset_of_mem_convex_hull Caratheodory.mem_minCardFinsetOfMemConvexHullâ‚“'. -/
theorem mem_minCardFinsetOfMemConvexHull :
    x âˆˆ convexHull ğ•œ (minCardFinsetOfMemConvexHull hx : Set E) :=
  (Function.argminOn_mem _ _ { t : Finset E | â†‘t âŠ† s âˆ§ x âˆˆ convexHull ğ•œ (t : Set E) } _).2
#align caratheodory.mem_min_card_finset_of_mem_convex_hull Caratheodory.mem_minCardFinsetOfMemConvexHull

/- warning: caratheodory.min_card_finset_of_mem_convex_hull_nonempty -> Caratheodory.minCardFinsetOfMemConvexHull_nonempty is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), Finset.Nonempty.{u1} E (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), Finset.Nonempty.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)
Case conversion may be inaccurate. Consider using '#align caratheodory.min_card_finset_of_mem_convex_hull_nonempty Caratheodory.minCardFinsetOfMemConvexHull_nonemptyâ‚“'. -/
theorem minCardFinsetOfMemConvexHull_nonempty : (minCardFinsetOfMemConvexHull hx).Nonempty :=
  by
  rw [â† Finset.coe_nonempty, â† @convexHull_nonempty_iff ğ•œ]
  exact âŸ¨x, mem_min_card_finset_of_mem_convex_hull hxâŸ©
#align caratheodory.min_card_finset_of_mem_convex_hull_nonempty Caratheodory.minCardFinsetOfMemConvexHull_nonempty

/- warning: caratheodory.min_card_finset_of_mem_convex_hull_card_le_card -> Caratheodory.minCardFinsetOfMemConvexHull_card_le_card is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)) {t : Finset.{u1} E}, (HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t) s) -> (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t))) -> (LE.le.{0} Nat Nat.hasLe (Finset.card.{u1} E (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) (Finset.card.{u1} E t))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)) {t : Finset.{u2} E}, (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E t) s) -> (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E t))) -> (LE.le.{0} Nat instLENat (Finset.card.{u2} E (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) (Finset.card.{u2} E t))
Case conversion may be inaccurate. Consider using '#align caratheodory.min_card_finset_of_mem_convex_hull_card_le_card Caratheodory.minCardFinsetOfMemConvexHull_card_le_cardâ‚“'. -/
theorem minCardFinsetOfMemConvexHull_card_le_card {t : Finset E} (htâ‚ : â†‘t âŠ† s)
    (htâ‚‚ : x âˆˆ convexHull ğ•œ (t : Set E)) : (minCardFinsetOfMemConvexHull hx).card â‰¤ t.card :=
  Function.argminOn_le _ _ _ âŸ¨htâ‚, htâ‚‚âŸ©
#align caratheodory.min_card_finset_of_mem_convex_hull_card_le_card Caratheodory.minCardFinsetOfMemConvexHull_card_le_card

/- warning: caratheodory.affine_independent_min_card_finset_of_mem_convex_hull -> Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E} (hx : Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)), AffineIndependent.{u2, u1, u1, u1} ğ•œ E E (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) E (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)) E (coeSubtype.{succ u1} E (fun (x_1 : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x_1 (Caratheodory.minCardFinsetOfMemConvexHull.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E} (hx : Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)), AffineIndependent.{u1, u2, u2, u2} ğ•œ E E (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x_1 : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x_1 (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx))) (Subtype.val.{succ u2} E (fun (x_1 : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x_1 (Caratheodory.minCardFinsetOfMemConvexHull.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 s x hx)))
Case conversion may be inaccurate. Consider using '#align caratheodory.affine_independent_min_card_finset_of_mem_convex_hull Caratheodory.affineIndependent_minCardFinsetOfMemConvexHullâ‚“'. -/
theorem affineIndependent_minCardFinsetOfMemConvexHull :
    AffineIndependent ğ•œ (coe : minCardFinsetOfMemConvexHull hx â†’ E) :=
  by
  let k := (min_card_finset_of_mem_convex_hull hx).card - 1
  have hk : (min_card_finset_of_mem_convex_hull hx).card = k + 1 :=
    (Nat.succ_pred_eq_of_pos
        (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm
  classical
    by_contra
    obtain âŸ¨p, hpâŸ© := mem_convex_hull_erase h (mem_min_card_finset_of_mem_convex_hull hx)
    have contra :=
      min_card_finset_of_mem_convex_hull_card_le_card hx
        (Set.Subset.trans (Finset.erase_subset (â†‘p) (min_card_finset_of_mem_convex_hull hx))
          (min_card_finset_of_mem_convex_hull_subseteq hx))
        hp
    rw [â† not_lt] at contra
    apply contra
    erw [card_erase_of_mem p.2, hk]
    exact lt_add_one _
#align caratheodory.affine_independent_min_card_finset_of_mem_convex_hull Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull

end Caratheodory

variable {s : Set E}

/- warning: convex_hull_eq_union -> convexHull_eq_union is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E}, Eq.{succ u1} (Set.{u1} E) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s) (Set.iUnion.{u1, succ u1} E (Finset.{u1} E) (fun (t : Finset.{u1} E) => Set.iUnion.{u1, 0} E (HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t) s) (fun (hss : HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t) s) => Set.iUnion.{u1, 0} E (AffineIndependent.{u2, u1, u1, u1} ğ•œ E E (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x t))))))) (fun (hai : AffineIndependent.{u2, u1, u1, u1} ğ•œ E E (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (CoeTCâ‚“.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} E) Type.{u1} (Finset.hasCoeToSort.{u1} E) t) E (coeSubtype.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Finset.{u1} E) (Finset.hasMem.{u1} E) x t))))))) => coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} E) (Set.{u1} E) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (CoeTCâ‚“.coe.{succ u1, succ u1} (Finset.{u1} E) (Set.{u1} E) (Finset.Set.hasCoeT.{u1} E))) t)))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E}, Eq.{succ u2} (Set.{u2} E) (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s) (Set.iUnion.{u2, succ u2} E (Finset.{u2} E) (fun (t : Finset.{u2} E) => Set.iUnion.{u2, 0} E (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E t) s) (fun (hss : HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Finset.toSet.{u2} E t) s) => Set.iUnion.{u2, 0} E (AffineIndependent.{u1, u2, u2, u2} ğ•œ E E (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t))) (fun (hai : AffineIndependent.{u1, u2, u2, u2} ğ•œ E E (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t)) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Finset.{u2} E) (Finset.instMembershipFinset.{u2} E) x t))) => OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Finset.toSet.{u2} E t)))))
Case conversion may be inaccurate. Consider using '#align convex_hull_eq_union convexHull_eq_unionâ‚“'. -/
/-- **CarathÃ©odory's convexity theorem** -/
theorem convexHull_eq_union :
    convexHull ğ•œ s =
      â‹ƒ (t : Finset E) (hss : â†‘t âŠ† s) (hai : AffineIndependent ğ•œ (coe : t â†’ E)), convexHull ğ•œ â†‘t :=
  by
  apply Set.Subset.antisymm
  Â· intro x hx
    simp only [exists_prop, Set.mem_iUnion]
    exact
      âŸ¨Caratheodory.minCardFinsetOfMemConvexHull hx,
        Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,
        Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,
        Caratheodory.mem_minCardFinsetOfMemConvexHull hxâŸ©
  Â· iterate 3 convert Set.iUnion_subset _; intro
    exact convexHull_mono â€¹_â€º
#align convex_hull_eq_union convexHull_eq_union

/- warning: eq_pos_convex_span_of_mem_convex_hull -> eq_pos_convex_span_of_mem_convexHull is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : LinearOrderedField.{u2} ğ•œ] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {s : Set.{u1} E} {x : E}, (Membership.Mem.{u1, u1} E (Set.{u1} E) (Set.hasMem.{u1} E) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (fun (_x : ClosureOperator.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) => (Set.{u1} E) -> (Set.{u1} E)) (ClosureOperator.hasCoeToFun.{u1} (Set.{u1} E) (PartialOrder.toPreorder.{u1} (Set.{u1} E) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} E) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} E) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} E) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} E) (Set.completeBooleanAlgebra.{u1} E)))))))) (convexHull.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) s)) -> (Exists.{succ (succ u1)} Type.{u1} (fun (Î¹ : Type.{u1}) => Exists.{succ u1} (Fintype.{u1} Î¹) (fun (_x : Fintype.{u1} Î¹) => Exists.{succ u1} (Î¹ -> E) (fun (z : Î¹ -> E) => Exists.{max (succ u1) (succ u2)} (Î¹ -> ğ•œ) (fun (w : Î¹ -> ğ•œ) => Exists.{0} (HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) (Set.range.{u1, succ u1} E Î¹ z) s) (fun (hss : HasSubset.Subset.{u1} (Set.{u1} E) (Set.hasSubset.{u1} E) (Set.range.{u1, succ u1} E Î¹ z) s) => Exists.{0} (AffineIndependent.{u2, u1, u1, u1} ğ•œ E E (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) Î¹ z) (fun (hai : AffineIndependent.{u2, u1, u1, u1} ğ•œ E E (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) Î¹ z) => Exists.{0} (forall (i : Î¹), LT.lt.{u2} ğ•œ (Preorder.toHasLt.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))))) (OfNat.ofNat.{u2} ğ•œ 0 (OfNat.mk.{u2} ğ•œ 0 (Zero.zero.{u2} ğ•œ (MulZeroClass.toHasZero.{u2} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))))))))) (w i)) (fun (hw : forall (i : Î¹), LT.lt.{u2} ğ•œ (Preorder.toHasLt.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))))) (OfNat.ofNat.{u2} ğ•œ 0 (OfNat.mk.{u2} ğ•œ 0 (Zero.zero.{u2} ğ•œ (MulZeroClass.toHasZero.{u2} ğ•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))))))))) (w i)) => And (Eq.{succ u2} ğ•œ (Finset.sum.{u2, u1} ğ•œ Î¹ (AddCommGroup.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u2} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (Finset.univ.{u1} Î¹ _x) (fun (i : Î¹) => w i)) (OfNat.ofNat.{u2} ğ•œ 1 (OfNat.mk.{u2} ğ•œ 1 (One.one.{u2} ğ•œ (AddMonoidWithOne.toOne.{u2} ğ•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ğ•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ğ•œ (Ring.toAddCommGroupWithOne.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))))))))) (Eq.{succ u1} E (Finset.sum.{u1, u1} E Î¹ (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Finset.univ.{u1} Î¹ _x) (fun (i : Î¹) => SMul.smul.{u2, u1} ğ•œ E (SMulZeroClass.toHasSmul.{u2, u1} ğ•œ E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u1} ğ•œ E (MulZeroClass.toHasZero.{u2} ğ•œ (MulZeroOneClass.toMulZeroClass.{u2} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (Ring.toSemiring.{u2} ğ•œ (StrictOrderedRing.toRing.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u2} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u2} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)))) (w i) (z i))) x)))))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} ğ•œ] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {s : Set.{u2} E} {x : E}, (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (OrderHom.toFun.{u2, u2} (Set.{u2} E) (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (ClosureOperator.toOrderHom.{u2} (Set.{u2} E) (PartialOrder.toPreorder.{u2} (Set.{u2} E) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} E) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} E) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} E) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} E) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} E) (Set.instCompleteBooleanAlgebraSet.{u2} E))))))) (convexHull.{u1, u2} ğ•œ E (OrderedCommSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s)) -> (Exists.{succ (succ u2)} Type.{u2} (fun (Î¹ : Type.{u2}) => Exists.{succ u2} (Fintype.{u2} Î¹) (fun (_x : Fintype.{u2} Î¹) => Exists.{succ u2} (Î¹ -> E) (fun (z : Î¹ -> E) => Exists.{max (succ u2) (succ u1)} (Î¹ -> ğ•œ) (fun (w : Î¹ -> ğ•œ) => Exists.{0} (HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Set.range.{u2, succ u2} E Î¹ z) s) (fun (hss : HasSubset.Subset.{u2} (Set.{u2} E) (Set.instHasSubsetSet.{u2} E) (Set.range.{u2, succ u2} E Î¹ z) s) => Exists.{0} (AffineIndependent.{u1, u2, u2, u2} ğ•œ E E (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) Î¹ z) (fun (hai : AffineIndependent.{u1, u2, u2, u2} ğ•œ E E (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) Î¹ z) => Exists.{0} (forall (i : Î¹), LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) (w i)) (fun (hw : forall (i : Î¹), LT.lt.{u1} ğ•œ (Preorder.toLT.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (StrictOrderedRing.toPartialOrder.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ (LinearOrderedCommRing.toLinearOrderedRing.{u1} ğ•œ (LinearOrderedField.toLinearOrderedCommRing.{u1} ğ•œ _inst_1)))))) (OfNat.ofNat.{u1} ğ•œ 0 (Zero.toOfNat0.{u1} ğ•œ (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))) (w i)) => And (Eq.{succ u1} ğ•œ (Finset.sum.{u1, u2} ğ•œ Î¹ (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))))) (Finset.univ.{u2} Î¹ _x) (fun (i : Î¹) => w i)) (OfNat.ofNat.{u1} ğ•œ 1 (One.toOfNat1.{u1} ğ•œ (Semiring.toOne.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))))))) (Eq.{succ u2} E (Finset.sum.{u2, u2} E Î¹ (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Finset.univ.{u2} Î¹ _x) (fun (i : Î¹) => HSMul.hSMul.{u1, u2, u2} ğ•œ E E (instHSMul.{u1, u2} ğ•œ E (SMulZeroClass.toSMul.{u1, u2} ğ•œ E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} ğ•œ E (CommMonoidWithZero.toZero.{u1} ğ•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ğ•œ (Semifield.toCommGroupWithZero.{u1} ğ•œ (LinearOrderedSemifield.toSemifield.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1)))))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (StrictOrderedSemiring.toSemiring.{u1} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} ğ•œ (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} ğ•œ (LinearOrderedField.toLinearOrderedSemifield.{u1} ğ•œ _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (w i) (z i))) x)))))))))
Case conversion may be inaccurate. Consider using '#align eq_pos_convex_span_of_mem_convex_hull eq_pos_convex_span_of_mem_convexHullâ‚“'. -/
/-- A more explicit version of `convex_hull_eq_union`. -/
theorem eq_pos_convex_span_of_mem_convexHull {x : E} (hx : x âˆˆ convexHull ğ•œ s) :
    âˆƒ (Î¹ : Sort (u + 1))(_ : Fintype Î¹),
      âˆƒ (z : Î¹ â†’ E)(w : Î¹ â†’ ğ•œ)(hss : Set.range z âŠ† s)(hai : AffineIndependent ğ•œ z)(hw :
        âˆ€ i, 0 < w i), (âˆ‘ i, w i) = 1 âˆ§ (âˆ‘ i, w i â€¢ z i) = x :=
  by
  rw [convexHull_eq_union] at hx
  simp only [exists_prop, Set.mem_iUnion] at hx
  obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := hx
  simp only [t.convex_hull_eq, exists_prop, Set.mem_setOf_eq] at htâ‚ƒ
  obtain âŸ¨w, hwâ‚, hwâ‚‚, hwâ‚ƒâŸ© := htâ‚ƒ
  let t' := t.filter fun i => w i â‰  0
  refine' âŸ¨t', t'.fintype_coe_sort, (coe : t' â†’ E), w âˆ˜ (coe : t' â†’ E), _, _, _, _, _âŸ©
  Â· rw [Subtype.range_coe_subtype]
    exact subset.trans (Finset.filter_subset _ t) htâ‚
  Â· exact htâ‚‚.comp_embedding âŸ¨_, inclusion_injective (Finset.filter_subset (fun i => w i â‰  0) t)âŸ©
  Â·
    exact fun i =>
      (hwâ‚ _ (finset.mem_filter.mp i.2).1).lt_of_ne (finset.mem_filter.mp i.property).2.symm
  Â· erw [Finset.sum_attach, Finset.sum_filter_ne_zero, hwâ‚‚]
  Â· change (âˆ‘ i : t' in t'.attach, (fun e => w e â€¢ e) â†‘i) = x
    erw [Finset.sum_attach, Finset.sum_filter_of_ne]
    Â· rw [t.center_mass_eq_of_sum_1 id hwâ‚‚] at hwâ‚ƒ
      exact hwâ‚ƒ
    Â· intro e he hwe contra
      apply hwe
      rw [contra, zero_smul]
#align eq_pos_convex_span_of_mem_convex_hull eq_pos_convex_span_of_mem_convexHull

