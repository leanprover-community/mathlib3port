/-
Copyright (c) 2021 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: YaÃ«l Dillies, Bhavik Mehta

! This file was ported from Lean 3 source module analysis.convex.exposed
! leanprover-community/mathlib commit ce38d86c0b2d427ce208c3cee3159cb421d2b3c4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Convex.Extreme
import Mathbin.Analysis.Convex.Function
import Mathbin.Topology.Algebra.Module.Basic
import Mathbin.Topology.Order.Basic

/-!
# Exposed sets

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines exposed sets and exposed points for sets in a real vector space.

An exposed subset of `A` is a subset of `A` that is the set of all maximal points of a functional
(a continuous linear map `E â†’ ğ•œ`) over `A`. By convention, `âˆ…` is an exposed subset of all sets.
This allows for better functoriality of the definition (the intersection of two exposed subsets is
exposed, faces of a polytope form a bounded lattice).
This is an analytic notion of "being on the side of". It is stronger than being extreme (see
`is_exposed.is_extreme`), but weaker (for exposed points) than being a vertex.

An exposed set of `A` is sometimes called a "face of `A`", but we decided to reserve this
terminology to the more specific notion of a face of a polytope (sometimes hopefully soon out
on mathlib!).

## Main declarations

* `is_exposed ğ•œ A B`: States that `B` is an exposed set of `A` (in the literature, `A` is often
  implicit).
* `is_exposed.is_extreme`: An exposed set is also extreme.

## References

See chapter 8 of [Barry Simon, *Convexity*][simon2011]

## TODO

Define intrinsic frontier/interior and prove the lemmas related to exposed sets and points.

Generalise to Locally Convex Topological Vector Spacesâ„¢

More not-yet-PRed stuff is available on the branch `sperner_again`.
-/


open Classical Affine BigOperators

open Set

section PreorderSemiring

variable (ğ•œ : Type _) {E : Type _} [TopologicalSpace ğ•œ] [Semiring ğ•œ] [Preorder ğ•œ] [AddCommMonoid E]
  [TopologicalSpace E] [Module ğ•œ E] {A B : Set E}

#print IsExposed /-
/-- A set `B` is exposed with respect to `A` iff it maximizes some functional over `A` (and contains
all points maximizing it). Written `is_exposed ğ•œ A B`. -/
def IsExposed (A B : Set E) : Prop :=
  B.Nonempty â†’ âˆƒ l : E â†’L[ğ•œ] ğ•œ, B = { x âˆˆ A | âˆ€ y âˆˆ A, l y â‰¤ l x }
#align is_exposed IsExposed
-/

end PreorderSemiring

section OrderedRing

variable {ğ•œ : Type _} {E : Type _} [TopologicalSpace ğ•œ] [OrderedRing ğ•œ] [AddCommMonoid E]
  [TopologicalSpace E] [Module ğ•œ E] {l : E â†’L[ğ•œ] ğ•œ} {A B C : Set E} {X : Finset E} {x : E}

#print ContinuousLinearMap.toExposed /-
/-- A useful way to build exposed sets from intersecting `A` with halfspaces (modelled by an
inequality with a functional). -/
def ContinuousLinearMap.toExposed (l : E â†’L[ğ•œ] ğ•œ) (A : Set E) : Set E :=
  { x âˆˆ A | âˆ€ y âˆˆ A, l y â‰¤ l x }
#align continuous_linear_map.to_exposed ContinuousLinearMap.toExposed
-/

/- warning: continuous_linear_map.to_exposed.is_exposed -> ContinuousLinearMap.toExposed.isExposed is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {l : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))} {A : Set.{u2} E}, IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A (ContinuousLinearMap.toExposed.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 l A)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {l : ContinuousLinearMap.{u2, u2, u1, u2} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))} {A : Set.{u1} E}, IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A (ContinuousLinearMap.toExposed.{u2, u1} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 l A)
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.to_exposed.is_exposed ContinuousLinearMap.toExposed.isExposedâ‚“'. -/
theorem ContinuousLinearMap.toExposed.isExposed : IsExposed ğ•œ A (l.toExposed A) := fun h => âŸ¨l, rflâŸ©
#align continuous_linear_map.to_exposed.is_exposed ContinuousLinearMap.toExposed.isExposed

/- warning: is_exposed_empty -> isExposed_empty is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E}, IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A (EmptyCollection.emptyCollection.{u2} (Set.{u2} E) (Set.hasEmptyc.{u2} E))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {A : Set.{u1} E}, IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A (EmptyCollection.emptyCollection.{u1} (Set.{u1} E) (Set.instEmptyCollectionSet.{u1} E))
Case conversion may be inaccurate. Consider using '#align is_exposed_empty isExposed_emptyâ‚“'. -/
theorem isExposed_empty : IsExposed ğ•œ A âˆ… := fun âŸ¨x, hxâŸ© =>
  by
  exfalso
  exact hx
#align is_exposed_empty isExposed_empty

namespace IsExposed

/- warning: is_exposed.subset -> IsExposed.subset is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) B A)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) B A)
Case conversion may be inaccurate. Consider using '#align is_exposed.subset IsExposed.subsetâ‚“'. -/
protected theorem subset (hAB : IsExposed ğ•œ A B) : B âŠ† A :=
  by
  rintro x hx
  obtain âŸ¨_, rflâŸ© := hAB âŸ¨x, hxâŸ©
  exact hx.1
#align is_exposed.subset IsExposed.subset

#print IsExposed.refl /-
@[refl]
protected theorem refl (A : Set E) : IsExposed ğ•œ A A := fun âŸ¨w, hwâŸ© =>
  âŸ¨0, Subset.antisymm (fun x hx => âŸ¨hx, fun y hy => le_refl 0âŸ©) fun x hx => hx.1âŸ©
#align is_exposed.refl IsExposed.refl
-/

/- warning: is_exposed.antisymm -> IsExposed.antisymm is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 B A) -> (Eq.{succ u2} (Set.{u2} E) A B)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 B A) -> (Eq.{succ u1} (Set.{u1} E) A B)
Case conversion may be inaccurate. Consider using '#align is_exposed.antisymm IsExposed.antisymmâ‚“'. -/
protected theorem antisymm (hB : IsExposed ğ•œ A B) (hA : IsExposed ğ•œ B A) : A = B :=
  hA.Subset.antisymm hB.Subset
#align is_exposed.antisymm IsExposed.antisymm

/- warning: is_exposed.mono -> IsExposed.mono is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E} {C : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A C) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) B A) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) C B) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 B C)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {A : Set.{u1} E} {B : Set.{u1} E} {C : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A C) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) B A) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) C B) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 B C)
Case conversion may be inaccurate. Consider using '#align is_exposed.mono IsExposed.monoâ‚“'. -/
/- `is_exposed` is *not* transitive: Consider a (topologically) open cube with vertices
`Aâ‚€â‚€â‚€, ..., Aâ‚â‚â‚` and add to it the triangle `Aâ‚€â‚€â‚€Aâ‚€â‚€â‚Aâ‚€â‚â‚€`. Then `Aâ‚€â‚€â‚Aâ‚€â‚â‚€` is an exposed subset
of `Aâ‚€â‚€â‚€Aâ‚€â‚€â‚Aâ‚€â‚â‚€` which is an exposed subset of the cube, but `Aâ‚€â‚€â‚Aâ‚€â‚â‚€` is not itself an exposed
subset of the cube. -/
protected theorem mono (hC : IsExposed ğ•œ A C) (hBA : B âŠ† A) (hCB : C âŠ† B) : IsExposed ğ•œ B C :=
  by
  rintro âŸ¨w, hwâŸ©
  obtain âŸ¨l, rflâŸ© := hC âŸ¨w, hwâŸ©
  exact
    âŸ¨l,
      subset.antisymm (fun x hx => âŸ¨hCB hx, fun y hy => hx.2 y (hBA hy)âŸ©) fun x hx =>
        âŸ¨hBA hx.1, fun y hy => (hw.2 y hy).trans (hx.2 w (hCB hw))âŸ©âŸ©
#align is_exposed.mono IsExposed.mono

/- warning: is_exposed.eq_inter_halfspace' -> IsExposed.eq_inter_halfspace' is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (Set.Nonempty.{u2} E B) -> (Exists.{max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (l : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Eq.{succ u2} (Set.{u2} E) B (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2)))) a (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (_x : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => E -> ğ•œ) (ContinuousLinearMap.toFun.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) l x)) A))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B) -> (Set.Nonempty.{u2} E B) -> (Exists.{max (succ u1) (succ u2)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) (fun (l : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) => Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Eq.{succ u2} (Set.{u2} E) B (setOf.{u2} E (fun (x : E) => And (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x A) (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedRing.toPartialOrder.{u1} ğ•œ _inst_2))) a (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E (fun (a : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) a) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E ğ•œ _inst_4 _inst_1 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u1 u2, u1, u1, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))))) l x)))))))
Case conversion may be inaccurate. Consider using '#align is_exposed.eq_inter_halfspace' IsExposed.eq_inter_halfspace'â‚“'. -/
/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed
halfspace. The converse is *not* true. It would require that the corresponding open halfspace
doesn't intersect `A`. -/
theorem eq_inter_halfspace' {A B : Set E} (hAB : IsExposed ğ•œ A B) (hB : B.Nonempty) :
    âˆƒ l : E â†’L[ğ•œ] ğ•œ, âˆƒ a, B = { x âˆˆ A | a â‰¤ l x } :=
  by
  obtain âŸ¨l, rflâŸ© := hAB hB
  obtain âŸ¨w, hwâŸ© := hB
  exact
    âŸ¨l, l w,
      subset.antisymm (fun x hx => âŸ¨hx.1, hx.2 w hw.1âŸ©) fun x hx =>
        âŸ¨hx.1, fun y hy => (hw.2 y hy).trans hx.2âŸ©âŸ©
#align is_exposed.eq_inter_halfspace' IsExposed.eq_inter_halfspace'

/- warning: is_exposed.eq_inter_halfspace -> IsExposed.eq_inter_halfspace is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] [_inst_6 : Nontrivial.{u1} ğ•œ] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (Exists.{max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (l : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => Exists.{succ u1} ğ•œ (fun (a : ğ•œ) => Eq.{succ u2} (Set.{u2} E) B (Sep.sep.{u2, u2} E (Set.{u2} E) (Set.hasSep.{u2} E) (fun (x : E) => LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2)))) a (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (_x : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => E -> ğ•œ) (ContinuousLinearMap.toFun.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) l x)) A))))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] [_inst_6 : Nontrivial.{u2} ğ•œ] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B) -> (Exists.{max (succ u2) (succ u1)} (ContinuousLinearMap.{u2, u2, u1, u2} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))) (fun (l : ContinuousLinearMap.{u2, u2, u1, u2} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))) => Exists.{succ u2} ğ•œ (fun (a : ğ•œ) => Eq.{succ u1} (Set.{u1} E) B (setOf.{u1} E (fun (x : E) => And (Membership.mem.{u1, u1} E (Set.{u1} E) (Set.instMembershipSet.{u1} E) x A) (LE.le.{u2} ğ•œ (Preorder.toLE.{u2} ğ•œ (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2))) a (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (ContinuousLinearMap.{u2, u2, u1, u2} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))) E (fun (a : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) a) (ContinuousMapClass.toFunLike.{max u2 u1, u1, u2} (ContinuousLinearMap.{u2, u2, u1, u2} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))) E ğ•œ _inst_4 _inst_1 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u2 u1, u2, u2, u1, u2} (ContinuousLinearMap.{u2, u2, u1, u2} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))) ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)) (ContinuousLinearMap.continuousSemilinearMapClass.{u2, u2, u1, u2} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (RingHom.id.{u2} ğ•œ (NonAssocRing.toNonAssocSemiring.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u2} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u2} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))))) l x)))))))
Case conversion may be inaccurate. Consider using '#align is_exposed.eq_inter_halfspace IsExposed.eq_inter_halfspaceâ‚“'. -/
/-- For nontrivial `ğ•œ`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with
some closed halfspace. The converse is *not* true. It would require that the corresponding open
halfspace doesn't intersect `A`. -/
theorem eq_inter_halfspace [Nontrivial ğ•œ] {A B : Set E} (hAB : IsExposed ğ•œ A B) :
    âˆƒ l : E â†’L[ğ•œ] ğ•œ, âˆƒ a, B = { x âˆˆ A | a â‰¤ l x } :=
  by
  obtain rfl | hB := B.eq_empty_or_nonempty
  Â· refine' âŸ¨0, 1, _âŸ©
    rw [eq_comm, eq_empty_iff_forall_not_mem]
    rintro x âŸ¨-, hâŸ©
    rw [ContinuousLinearMap.zero_apply] at h
    have : Â¬(1 : ğ•œ) â‰¤ 0 := not_le_of_lt zero_lt_one
    contradiction
  exact hAB.eq_inter_halfspace' hB
#align is_exposed.eq_inter_halfspace IsExposed.eq_inter_halfspace

/- warning: is_exposed.inter -> IsExposed.inter is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] [_inst_6 : ContinuousAdd.{u1} ğ•œ _inst_1 (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))] {A : Set.{u2} E} {B : Set.{u2} E} {C : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A C) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) B C))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] [_inst_6 : ContinuousAdd.{u2} ğ•œ _inst_1 (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))))))] {A : Set.{u1} E} {B : Set.{u1} E} {C : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A C) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A (Inter.inter.{u1} (Set.{u1} E) (Set.instInterSet.{u1} E) B C))
Case conversion may be inaccurate. Consider using '#align is_exposed.inter IsExposed.interâ‚“'. -/
protected theorem inter [ContinuousAdd ğ•œ] {A B C : Set E} (hB : IsExposed ğ•œ A B)
    (hC : IsExposed ğ•œ A C) : IsExposed ğ•œ A (B âˆ© C) :=
  by
  rintro âŸ¨w, hwB, hwCâŸ©
  obtain âŸ¨lâ‚, rflâŸ© := hB âŸ¨w, hwBâŸ©
  obtain âŸ¨lâ‚‚, rflâŸ© := hC âŸ¨w, hwCâŸ©
  refine' âŸ¨lâ‚ + lâ‚‚, subset.antisymm _ _âŸ©
  Â· rintro x âŸ¨âŸ¨hxA, hxBâŸ©, âŸ¨-, hxCâŸ©âŸ©
    exact âŸ¨hxA, fun z hz => add_le_add (hxB z hz) (hxC z hz)âŸ©
  rintro x âŸ¨hxA, hxâŸ©
  refine' âŸ¨âŸ¨hxA, fun y hy => _âŸ©, hxA, fun y hy => _âŸ©
  Â·
    exact
      (add_le_add_iff_right (lâ‚‚ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))
  Â·
    exact
      (add_le_add_iff_left (lâ‚ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))
#align is_exposed.inter IsExposed.inter

/- warning: is_exposed.sInter -> IsExposed.interâ‚› is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} [_inst_6 : ContinuousAdd.{u1} ğ•œ _inst_1 (Distrib.toHasAdd.{u1} ğ•œ (Ring.toDistrib.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))] {F : Finset.{u2} (Set.{u2} E)}, (Finset.Nonempty.{u2} (Set.{u2} E) F) -> (forall (B : Set.{u2} E), (Membership.Mem.{u2, u2} (Set.{u2} E) (Finset.{u2} (Set.{u2} E)) (Finset.hasMem.{u2} (Set.{u2} E)) B F) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B)) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A (Set.interâ‚›.{u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} (Set.{u2} E)) (Set.{u2} (Set.{u2} E)) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} (Set.{u2} E)) (Set.{u2} (Set.{u2} E)) (CoeTCâ‚“.coe.{succ u2, succ u2} (Finset.{u2} (Set.{u2} E)) (Set.{u2} (Set.{u2} E)) (Finset.Set.hasCoeT.{u2} (Set.{u2} E)))) F)))
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {A : Set.{u1} E} [_inst_6 : ContinuousAdd.{u2} ğ•œ _inst_1 (Distrib.toAdd.{u2} ğ•œ (NonUnitalNonAssocSemiring.toDistrib.{u2} ğ•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ğ•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ğ•œ (Ring.toNonAssocRing.{u2} ğ•œ (OrderedRing.toRing.{u2} ğ•œ _inst_2))))))] {F : Finset.{u1} (Set.{u1} E)}, (Finset.Nonempty.{u1} (Set.{u1} E) F) -> (forall (B : Set.{u1} E), (Membership.mem.{u1, u1} (Set.{u1} E) (Finset.{u1} (Set.{u1} E)) (Finset.instMembershipFinset.{u1} (Set.{u1} E)) B F) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B)) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A (Set.interâ‚›.{u1} E (Finset.toSet.{u1} (Set.{u1} E) F)))
Case conversion may be inaccurate. Consider using '#align is_exposed.sInter IsExposed.interâ‚›â‚“'. -/
theorem interâ‚› [ContinuousAdd ğ•œ] {F : Finset (Set E)} (hF : F.Nonempty)
    (hAF : âˆ€ B âˆˆ F, IsExposed ğ•œ A B) : IsExposed ğ•œ A (â‹‚â‚€ F) :=
  by
  revert hF F
  refine' Finset.induction _ _
  Â· rintro h
    exfalso
    exact not_nonempty_empty h
  rintro C F _ hF _ hCF
  rw [Finset.coe_insert, sInter_insert]
  obtain rfl | hFnemp := F.eq_empty_or_nonempty
  Â· rw [Finset.coe_empty, sInter_empty, inter_univ]
    exact hCF C (Finset.mem_singleton_self C)
  exact
    (hCF C (Finset.mem_insert_self C F)).inter
      (hF hFnemp fun B hB => hCF B (Finset.mem_insert_of_mem hB))
#align is_exposed.sInter IsExposed.interâ‚›

/- warning: is_exposed.inter_left -> IsExposed.inter_left is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E} {C : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A C) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) C B) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) A B) C)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {A : Set.{u1} E} {B : Set.{u1} E} {C : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A C) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) C B) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 (Inter.inter.{u1} (Set.{u1} E) (Set.instInterSet.{u1} E) A B) C)
Case conversion may be inaccurate. Consider using '#align is_exposed.inter_left IsExposed.inter_leftâ‚“'. -/
theorem inter_left (hC : IsExposed ğ•œ A C) (hCB : C âŠ† B) : IsExposed ğ•œ (A âˆ© B) C :=
  by
  rintro âŸ¨w, hwâŸ©
  obtain âŸ¨l, rflâŸ© := hC âŸ¨w, hwâŸ©
  exact
    âŸ¨l,
      subset.antisymm (fun x hx => âŸ¨âŸ¨hx.1, hCB hxâŸ©, fun y hy => hx.2 y hy.1âŸ©)
        fun x âŸ¨âŸ¨hxC, _âŸ©, hxâŸ© => âŸ¨hxC, fun y hy => (hw.2 y hy).trans (hx w âŸ¨hC.subset hw, hCB hwâŸ©)âŸ©âŸ©
#align is_exposed.inter_left IsExposed.inter_left

/- warning: is_exposed.inter_right -> IsExposed.inter_right is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E} {C : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 B C) -> (HasSubset.Subset.{u2} (Set.{u2} E) (Set.hasSubset.{u2} E) C A) -> (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 (Inter.inter.{u2} (Set.{u2} E) (Set.hasInter.{u2} E) A B) C)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] {A : Set.{u1} E} {B : Set.{u1} E} {C : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 B C) -> (HasSubset.Subset.{u1} (Set.{u1} E) (Set.instHasSubsetSet.{u1} E) C A) -> (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 (Inter.inter.{u1} (Set.{u1} E) (Set.instInterSet.{u1} E) A B) C)
Case conversion may be inaccurate. Consider using '#align is_exposed.inter_right IsExposed.inter_rightâ‚“'. -/
theorem inter_right (hC : IsExposed ğ•œ B C) (hCA : C âŠ† A) : IsExposed ğ•œ (A âˆ© B) C :=
  by
  rw [inter_comm]
  exact hC.inter_left hCA
#align is_exposed.inter_right IsExposed.inter_right

/- warning: is_exposed.is_closed -> IsExposed.isClosed is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] [_inst_6 : OrderClosedTopology.{u1} ğ•œ _inst_1 (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2)))] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (IsClosed.{u2} E _inst_4 A) -> (IsClosed.{u2} E _inst_4 B)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] [_inst_6 : OrderClosedTopology.{u2} ğ•œ _inst_1 (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2))] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B) -> (IsClosed.{u1} E _inst_4 A) -> (IsClosed.{u1} E _inst_4 B)
Case conversion may be inaccurate. Consider using '#align is_exposed.is_closed IsExposed.isClosedâ‚“'. -/
protected theorem isClosed [OrderClosedTopology ğ•œ] {A B : Set E} (hAB : IsExposed ğ•œ A B)
    (hA : IsClosed A) : IsClosed B :=
  by
  obtain rfl | hB := B.eq_empty_or_nonempty
  Â· simp
  obtain âŸ¨l, a, rflâŸ© := hAB.eq_inter_halfspace' hB
  exact hA.is_closed_le continuousOn_const l.continuous.continuous_on
#align is_exposed.is_closed IsExposed.isClosed

/- warning: is_exposed.is_compact -> IsExposed.isCompact is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] [_inst_6 : OrderClosedTopology.{u1} ğ•œ _inst_1 (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2)))] [_inst_7 : T2Space.{u2} E _inst_4] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (IsCompact.{u2} E _inst_4 A) -> (IsCompact.{u2} E _inst_4 B)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : OrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) _inst_3] [_inst_6 : OrderClosedTopology.{u2} ğ•œ _inst_1 (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2))] [_inst_7 : T2Space.{u1} E _inst_4] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (OrderedSemiring.toSemiring.{u2} ğ•œ (OrderedRing.toOrderedSemiring.{u2} ğ•œ _inst_2)) (PartialOrder.toPreorder.{u2} ğ•œ (OrderedRing.toPartialOrder.{u2} ğ•œ _inst_2)) _inst_3 _inst_4 _inst_5 A B) -> (IsCompact.{u1} E _inst_4 A) -> (IsCompact.{u1} E _inst_4 B)
Case conversion may be inaccurate. Consider using '#align is_exposed.is_compact IsExposed.isCompactâ‚“'. -/
protected theorem isCompact [OrderClosedTopology ğ•œ] [T2Space E] {A B : Set E}
    (hAB : IsExposed ğ•œ A B) (hA : IsCompact A) : IsCompact B :=
  isCompact_of_isClosed_subset hA (hAB.IsClosed hA.IsClosed) hAB.Subset
#align is_exposed.is_compact IsExposed.isCompact

end IsExposed

variable (ğ•œ)

#print Set.exposedPoints /-
/-- A point is exposed with respect to `A` iff there exists an hyperplane whose intersection with
`A` is exactly that point. -/
def Set.exposedPoints (A : Set E) : Set E :=
  { x âˆˆ A | âˆƒ l : E â†’L[ğ•œ] ğ•œ, âˆ€ y âˆˆ A, l y â‰¤ l x âˆ§ (l x â‰¤ l y â†’ y = x) }
#align set.exposed_points Set.exposedPoints
-/

variable {ğ•œ}

/- warning: exposed_point_def -> exposed_point_def is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {x : E}, Iff (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x (Set.exposedPoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 A)) (And (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) x A) (Exists.{max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (l : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => forall (y : E), (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) y A) -> (And (LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2)))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (_x : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => E -> ğ•œ) (ContinuousLinearMap.toFun.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) l y) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (_x : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => E -> ğ•œ) (ContinuousLinearMap.toFun.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) l x)) ((LE.le.{u1} ğ•œ (Preorder.toLE.{u1} ğ•œ (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2)))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (_x : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => E -> ğ•œ) (ContinuousLinearMap.toFun.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) l x) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) (fun (_x : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) => E -> ğ•œ) (ContinuousLinearMap.toFun.{u1, u1, u2, u1} ğ•œ ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (Semiring.toNonAssocSemiring.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toAddCommGroup.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (Semiring.toModule.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) l y)) -> (Eq.{succ u2} E y x))))))
but is expected to have type
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : OrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) _inst_3] {A : Set.{u2} E} {x : E}, Iff (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (Set.exposedPoints.{u1, u2} ğ•œ E _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 A)) (And (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x A) (Exists.{max (succ u1) (succ u2)} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) (fun (l : ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) => forall (y : E), (Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) y A) -> (And (LE.le.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) y) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) y) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) y) (OrderedRing.toPartialOrder.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) y) _inst_2))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E (fun (_x : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E ğ•œ _inst_4 _inst_1 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u1 u2, u1, u1, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))))) l y) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E (fun (_x : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E ğ•œ _inst_4 _inst_1 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u1 u2, u1, u1, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))))) l x)) ((LE.le.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) x) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) x) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) x) (OrderedRing.toPartialOrder.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) x) _inst_2))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E (fun (_x : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E ğ•œ _inst_4 _inst_1 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u1 u2, u1, u1, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))))) l x) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E (fun (_x : E) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : E) => ğ•œ) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) E ğ•œ _inst_4 _inst_1 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u1 u2, u1, u1, u2, u1} (ContinuousLinearMap.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))) ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u2, u1} ğ•œ ğ•œ (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (OrderedSemiring.toSemiring.{u1} ğ•œ (OrderedRing.toOrderedSemiring.{u1} ğ•œ _inst_2)) (RingHom.id.{u1} ğ•œ (NonAssocRing.toNonAssocSemiring.{u1} ğ•œ (Ring.toNonAssocRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2)))) E _inst_4 _inst_3 ğ•œ _inst_1 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} ğ•œ (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} ğ•œ (OrderedRing.toOrderedAddCommGroup.{u1} ğ•œ _inst_2))) _inst_5 (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} ğ•œ (OrderedRing.toRing.{u1} ğ•œ _inst_2))))) l y)) -> (Eq.{succ u2} E y x))))))
Case conversion may be inaccurate. Consider using '#align exposed_point_def exposed_point_defâ‚“'. -/
theorem exposed_point_def :
    x âˆˆ A.exposedPoints ğ•œ â†” x âˆˆ A âˆ§ âˆƒ l : E â†’L[ğ•œ] ğ•œ, âˆ€ y âˆˆ A, l y â‰¤ l x âˆ§ (l x â‰¤ l y â†’ y = x) :=
  Iff.rfl
#align exposed_point_def exposed_point_def

#print exposedPoints_subset /-
theorem exposedPoints_subset : A.exposedPoints ğ•œ âŠ† A := fun x hx => hx.1
#align exposed_points_subset exposedPoints_subset
-/

#print exposedPoints_empty /-
@[simp]
theorem exposedPoints_empty : (âˆ… : Set E).exposedPoints ğ•œ = âˆ… :=
  subset_empty_iff.1 exposedPoints_subset
#align exposed_points_empty exposedPoints_empty
-/

#print mem_exposedPoints_iff_exposed_singleton /-
/-- Exposed points exactly correspond to exposed singletons. -/
theorem mem_exposedPoints_iff_exposed_singleton : x âˆˆ A.exposedPoints ğ•œ â†” IsExposed ğ•œ A {x} :=
  by
  use fun âŸ¨hxA, l, hlâŸ© h =>
    âŸ¨l,
      Eq.symm <|
        eq_singleton_iff_unique_mem.2
          âŸ¨âŸ¨hxA, fun y hy => (hl y hy).1âŸ©, fun z hz => (hl z hz.1).2 (hz.2 x hxA)âŸ©âŸ©
  rintro h
  obtain âŸ¨l, hlâŸ© := h âŸ¨x, mem_singleton _âŸ©
  rw [eq_comm, eq_singleton_iff_unique_mem] at hl
  exact
    âŸ¨hl.1.1, l, fun y hy =>
      âŸ¨hl.1.2 y hy, fun hxy => hl.2 y âŸ¨hy, fun z hz => (hl.1.2 z hz).trans hxyâŸ©âŸ©âŸ©
#align mem_exposed_points_iff_exposed_singleton mem_exposedPoints_iff_exposed_singleton
-/

end OrderedRing

section LinearOrderedRing

variable {ğ•œ : Type _} {E : Type _} [TopologicalSpace ğ•œ] [LinearOrderedRing ğ•œ] [AddCommMonoid E]
  [TopologicalSpace E] [Module ğ•œ E] {A B C : Set E}

namespace IsExposed

/- warning: is_exposed.convex -> IsExposed.convex is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : LinearOrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2)))) _inst_3 _inst_4 _inst_5 A B) -> (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3 _inst_5)))) A) -> (Convex.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3 _inst_5)))) B)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : LinearOrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (Convex.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2)))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3 _inst_5)))) A) -> (Convex.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2)))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3 _inst_5)))) B)
Case conversion may be inaccurate. Consider using '#align is_exposed.convex IsExposed.convexâ‚“'. -/
protected theorem convex (hAB : IsExposed ğ•œ A B) (hA : Convex ğ•œ A) : Convex ğ•œ B :=
  by
  obtain rfl | hB := B.eq_empty_or_nonempty
  Â· exact convex_empty
  obtain âŸ¨l, rflâŸ© := hAB hB
  exact fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ a b ha hb hab =>
    âŸ¨hA hxâ‚.1 hxâ‚‚.1 ha hb hab, fun y hy =>
      ((l.to_linear_map.concave_on convex_univ).convex_ge _ âŸ¨mem_univ _, hxâ‚.2 y hyâŸ©
          âŸ¨mem_univ _, hxâ‚‚.2 y hyâŸ© ha hb hab).2âŸ©
#align is_exposed.convex IsExposed.convex

/- warning: is_exposed.is_extreme -> IsExposed.isExtreme is a dubious translation:
lean 3 declaration is
  forall {ğ•œ : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} ğ•œ] [_inst_2 : LinearOrderedRing.{u1} ğ•œ] [_inst_3 : AddCommMonoid.{u2} E] [_inst_4 : TopologicalSpace.{u2} E] [_inst_5 : Module.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3] {A : Set.{u2} E} {B : Set.{u2} E}, (IsExposed.{u1, u2} ğ•œ E _inst_1 (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) (PartialOrder.toPreorder.{u1} ğ•œ (OrderedAddCommGroup.toPartialOrder.{u1} ğ•œ (StrictOrderedRing.toOrderedAddCommGroup.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2)))) _inst_3 _inst_4 _inst_5 A B) -> (IsExtreme.{u1, u2} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u1} ğ•œ (StrictOrderedRing.toStrictOrderedSemiring.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3 (SMulZeroClass.toHasSmul.{u1, u2} ğ•œ E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (SMulWithZero.toSmulZeroClass.{u1, u2} ğ•œ E (MulZeroClass.toHasZero.{u1} ğ•œ (MulZeroOneClass.toMulZeroClass.{u1} ğ•œ (MonoidWithZero.toMulZeroOneClass.{u1} ğ•œ (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (MulActionWithZero.toSMulWithZero.{u1, u2} ğ•œ E (Semiring.toMonoidWithZero.{u1} ğ•œ (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E _inst_3))) (Module.toMulActionWithZero.{u1, u2} ğ•œ E (Ring.toSemiring.{u1} ğ•œ (StrictOrderedRing.toRing.{u1} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u1} ğ•œ _inst_2))) _inst_3 _inst_5)))) A B)
but is expected to have type
  forall {ğ•œ : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} ğ•œ] [_inst_2 : LinearOrderedRing.{u2} ğ•œ] [_inst_3 : AddCommMonoid.{u1} E] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : Module.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3] {A : Set.{u1} E} {B : Set.{u1} E}, (IsExposed.{u2, u1} ğ•œ E _inst_1 (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) (PartialOrder.toPreorder.{u2} ğ•œ (StrictOrderedRing.toPartialOrder.{u2} ğ•œ (LinearOrderedRing.toStrictOrderedRing.{u2} ğ•œ _inst_2))) _inst_3 _inst_4 _inst_5 A B) -> (IsExtreme.{u2, u1} ğ•œ E (StrictOrderedSemiring.toOrderedSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3 (SMulZeroClass.toSMul.{u2, u1} ğ•œ E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} ğ•œ E (MonoidWithZero.toZero.{u2} ğ•œ (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} ğ•œ E (Semiring.toMonoidWithZero.{u2} ğ•œ (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2)))) (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_3)) (Module.toMulActionWithZero.{u2, u1} ğ•œ E (StrictOrderedSemiring.toSemiring.{u2} ğ•œ (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} ğ•œ (LinearOrderedRing.toLinearOrderedSemiring.{u2} ğ•œ _inst_2))) _inst_3 _inst_5)))) A B)
Case conversion may be inaccurate. Consider using '#align is_exposed.is_extreme IsExposed.isExtremeâ‚“'. -/
protected theorem isExtreme (hAB : IsExposed ğ•œ A B) : IsExtreme ğ•œ A B :=
  by
  refine' âŸ¨hAB.subset, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxB hx => _âŸ©
  obtain âŸ¨l, rflâŸ© := hAB âŸ¨x, hxBâŸ©
  have hl : ConvexOn ğ•œ univ l := l.to_linear_map.convex_on convex_univ
  have hlxâ‚ := hxB.2 xâ‚ hxâ‚A
  have hlxâ‚‚ := hxB.2 xâ‚‚ hxâ‚‚A
  refine' âŸ¨âŸ¨hxâ‚A, fun y hy => _âŸ©, âŸ¨hxâ‚‚A, fun y hy => _âŸ©âŸ©
  Â· have := @ConvexOn.le_left_of_right_le ğ•œ E ğ•œ _ _ _
    rw [hlxâ‚.antisymm (hl.le_left_of_right_le (mem_univ _) (mem_univ _) hx hlxâ‚‚)]
    exact hxB.2 y hy
  Â· rw [hlxâ‚‚.antisymm (hl.le_right_of_left_le (mem_univ _) (mem_univ _) hx hlxâ‚)]
    exact hxB.2 y hy
#align is_exposed.is_extreme IsExposed.isExtreme

end IsExposed

#print exposedPoints_subset_extremePoints /-
theorem exposedPoints_subset_extremePoints : A.exposedPoints ğ•œ âŠ† A.extremePoints ğ•œ := fun x hx =>
  mem_extremePoints_iff_extreme_singleton.2 (mem_exposedPoints_iff_exposed_singleton.1 hx).IsExtreme
#align exposed_points_subset_extreme_points exposedPoints_subset_extremePoints
-/

end LinearOrderedRing

