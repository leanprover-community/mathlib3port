/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module algebra.category.Group.limits
! leanprover-community/mathlib commit 70fd9563a21e7b963887c9360bd29b2393e6225a
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Category.Mon.Limits
import Mathbin.Algebra.Category.Group.Preadditive
import Mathbin.CategoryTheory.Over
import Mathbin.GroupTheory.Subgroup.Basic
import Mathbin.CategoryTheory.ConcreteCategory.Elementwise

/-!
# The category of (commutative) (additive) groups has all limits

Further, these limits are preserved by the forgetful functor --- that is,
the underlying types are just the limits in the category of types.

-/


open CategoryTheory

open CategoryTheory.Limits

universe v u

noncomputable section

variable {J : Type v} [SmallCategory J]

namespace GroupCat

/- warning: Group.group_obj -> GroupCat.groupObj is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} GroupCat.largeCategory.{max u1 u2}) (j : J), Group.{max u1 u2} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.comp.{u1, max u1 u2, max u1 u2, u1, succ (max u1 u2), succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} GroupCat.largeCategory.{max u1 u2} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.forget.{succ (max u1 u2), max u1 u2, max u1 u2} GroupCat.{max u1 u2} GroupCat.largeCategory.{max u1 u2} GroupCat.concreteCategory.{max u1 u2})) j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 GroupCatMax.{u1, u2} instGroupCatLargeCategory.{max u2 u1}) (j : J), Group.{max u2 u1} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.comp.{u1, max u2 u1, max u2 u1, u1, max (succ u2) (succ u1), max (succ u2) (succ u1)} J _inst_1 GroupCatMax.{u1, u2} instGroupCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} GroupCat.{max u2 u1} instGroupCatLargeCategory.{max u2 u1} GroupCat.concreteCategory.{max u2 u1}))) j)
Case conversion may be inaccurate. Consider using '#align Group.group_obj GroupCat.groupObjâ‚“'. -/
@[to_additive]
instance groupObj (F : J â¥¤ GroupCat.{max v u}) (j) : Group ((F â‹™ forget GroupCat).obj j) :=
  by
  change Group (F.obj j)
  infer_instance
#align Group.group_obj GroupCat.groupObj
#align AddGroup.add_group_obj AddGroupCat.addGroupObj

/- warning: Group.sections_subgroup -> GroupCat.sectionsSubgroup is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} GroupCat.largeCategory.{max u1 u2}), Subgroup.{max u1 u2} (forall (j : J), coeSort.{succ (succ (max u1 u2)), succ (succ (max u1 u2))} GroupCat.{max u1 u2} Type.{max u1 u2} GroupCat.hasCoeToSort.{max u1 u2} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} GroupCat.largeCategory.{max u1 u2} F j)) (Pi.group.{u1, max u1 u2} J (fun (j : J) => coeSort.{succ (succ (max u1 u2)), succ (succ (max u1 u2))} GroupCat.{max u1 u2} Type.{max u1 u2} GroupCat.hasCoeToSort.{max u1 u2} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} GroupCat.largeCategory.{max u1 u2} F j)) (fun (i : J) => GroupCat.group.{max u1 u2} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} GroupCat.largeCategory.{max u1 u2} F i)))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} instGroupCatLargeCategory.{max u1 u2}), Subgroup.{max u1 u2} (forall (j : J), CategoryTheory.Bundled.Î±.{max u1 u2, max u1 u2} Group.{max u1 u2} (Prefunctor.obj.{succ u1, succ (max u1 u2), u1, succ (max u1 u2)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) GroupCat.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, succ (max u1 u2)} GroupCat.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} GroupCat.{max u1 u2} instGroupCatLargeCategory.{max u1 u2})) (CategoryTheory.Functor.toPrefunctor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} instGroupCatLargeCategory.{max u1 u2} F) j)) (Pi.group.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Bundled.Î±.{max u1 u2, max u1 u2} Group.{max u1 u2} (Prefunctor.obj.{succ u1, succ (max u1 u2), u1, succ (max u1 u2)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) GroupCat.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, succ (max u1 u2)} GroupCat.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} GroupCat.{max u1 u2} instGroupCatLargeCategory.{max u1 u2})) (CategoryTheory.Functor.toPrefunctor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} instGroupCatLargeCategory.{max u1 u2} F) j)) (fun (i : J) => GroupCat.instGroupÎ±.{max u1 u2} (Prefunctor.obj.{succ u1, succ (max u1 u2), u1, succ (max u1 u2)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) GroupCat.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, succ (max u1 u2)} GroupCat.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} GroupCat.{max u1 u2} instGroupCatLargeCategory.{max u1 u2})) (CategoryTheory.Functor.toPrefunctor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 GroupCat.{max u1 u2} instGroupCatLargeCategory.{max u1 u2} F) i)))
Case conversion may be inaccurate. Consider using '#align Group.sections_subgroup GroupCat.sectionsSubgroupâ‚“'. -/
/-- The flat sections of a functor into `Group` form a subgroup of all sections.
-/
@[to_additive
      "The flat sections of a functor into `AddGroup` form an additive subgroup of all sections."]
def sectionsSubgroup (F : J â¥¤ GroupCat) : Subgroup (âˆ€ j, F.obj j) :=
  {
    MonCat.sectionsSubmonoid
      (F â‹™ forgetâ‚‚ GroupCat
          MonCat) with
    carrier := (F â‹™ forget GroupCat).sections
    inv_mem' := fun a ah j j' f =>
      by
      simp only [forget_map_eq_coe, functor.comp_map, Pi.inv_apply, MonoidHom.map_inv, inv_inj]
      dsimp [functor.sections] at ah
      rw [ah f] }
#align Group.sections_subgroup GroupCat.sectionsSubgroup
#align AddGroup.sections_add_subgroup AddGroupCat.sectionsAddSubgroup

#print GroupCat.limitGroup /-
@[to_additive]
instance limitGroup (F : J â¥¤ GroupCat.{max v u}) :
    Group (Types.limitCone (F â‹™ forget GroupCat)).pt :=
  by
  change Group (sections_subgroup F)
  infer_instance
#align Group.limit_group GroupCat.limitGroup
#align AddGroup.limit_add_group AddGroupCat.limitAddGroup
-/

#print GroupCat.Forgetâ‚‚.createsLimit /-
/-- We show that the forgetful functor `Group â¥¤ Mon` creates limits.

All we need to do is notice that the limit point has a `group` instance available, and then reuse
the existing limit. -/
@[to_additive
      "We show that the forgetful functor `AddGroup â¥¤ AddMon` creates limits.\n\nAll we need to do is notice that the limit point has an `add_group` instance available, and then\nreuse the existing limit."]
instance Forgetâ‚‚.createsLimit (F : J â¥¤ GroupCat.{max v u}) :
    CreatesLimit F (forgetâ‚‚ GroupCat.{max v u} MonCat.{max v u}) :=
  createsLimitOfReflectsIso fun c' t =>
    { liftedCone :=
        { pt := GroupCat.of (Types.limitCone (F â‹™ forget GroupCat)).pt
          Ï€ :=
            { app := MonCat.limitÏ€MonoidHom (F â‹™ forgetâ‚‚ GroupCat MonCat.{max v u})
              naturality' :=
                (MonCat.HasLimits.limitCone
                      (F â‹™ forgetâ‚‚ GroupCat MonCat.{max v u})).Ï€.naturality } }
      validLift := by apply is_limit.unique_up_to_iso (MonCat.HasLimits.limitConeIsLimit _) t
      makesLimit :=
        IsLimit.ofFaithful (forgetâ‚‚ GroupCat MonCat.{max v u}) (MonCat.HasLimits.limitConeIsLimit _)
          (fun s => _) fun s => rfl }
#align Group.forgetâ‚‚.creates_limit GroupCat.Forgetâ‚‚.createsLimit
#align AddGroup.forgetâ‚‚.creates_limit AddGroupCat.Forgetâ‚‚.createsLimit
-/

#print GroupCat.limitCone /-
/-- A choice of limit cone for a functor into `Group`.
(Generally, you'll just want to use `limit F`.)
-/
@[to_additive
      "A choice of limit cone for a functor into `Group`.\n(Generally, you'll just want to use `limit F`.)"]
def limitCone (F : J â¥¤ GroupCat.{max v u}) : Cone F :=
  liftLimit (limit.isLimit (F â‹™ forgetâ‚‚ GroupCat MonCat.{max v u}))
#align Group.limit_cone GroupCat.limitCone
#align AddGroup.limit_cone AddGroupCat.limitCone
-/

#print GroupCat.limitConeIsLimit /-
/-- The chosen cone is a limit cone.
(Generally, you'll just want to use `limit.cone F`.)
-/
@[to_additive
      "The chosen cone is a limit cone.\n(Generally, you'll just want to use `limit.cone F`.)"]
def limitConeIsLimit (F : J â¥¤ GroupCat.{max v u}) : IsLimit (limitCone F) :=
  liftedLimitIsLimit _
#align Group.limit_cone_is_limit GroupCat.limitConeIsLimit
#align AddGroup.limit_cone_is_limit AddGroupCat.limitConeIsLimit
-/

#print GroupCat.hasLimitsOfSize /-
/-- The category of groups has all limits. -/
@[to_additive "The category of additive groups has all limits."]
instance hasLimitsOfSize : HasLimitsOfSize.{v, v} GroupCat.{max v u}
    where HasLimitsOfShape J ð’¥ :=
    { HasLimit := fun F => has_limit_of_created F (forgetâ‚‚ GroupCat MonCat.{max v u}) }
#align Group.has_limits_of_size GroupCat.hasLimitsOfSize
#align AddGroup.has_limits_of_size AddGroupCat.hasLimitsOfSize
-/

#print GroupCat.hasLimits /-
@[to_additive]
instance hasLimits : HasLimits GroupCat.{u} :=
  GroupCat.hasLimitsOfSize.{u, u}
#align Group.has_limits GroupCat.hasLimits
#align AddGroup.has_limits AddGroupCat.hasLimits
-/

#print GroupCat.forgetâ‚‚MonPreservesLimitsOfSize /-
/-- The forgetful functor from groups to monoids preserves all limits.

This means the underlying monoid of a limit can be computed as a limit in the category of monoids.
-/
@[to_additive AddGroupCat.forgetâ‚‚AddMonPreservesLimits
      "The forgetful functor from additive groups\nto additive monoids preserves all limits.\n\nThis means the underlying additive monoid of a limit can be computed as a limit in the category of\nadditive monoids."]
instance forgetâ‚‚MonPreservesLimitsOfSize :
    PreservesLimitsOfSize.{v, v} (forgetâ‚‚ GroupCat MonCat.{max v u})
    where PreservesLimitsOfShape J ð’¥ := { PreservesLimit := fun F => by infer_instance }
#align Group.forgetâ‚‚_Mon_preserves_limits_of_size GroupCat.forgetâ‚‚MonPreservesLimitsOfSize
#align AddGroup.forgetâ‚‚_AddMon_preserves_limits AddGroupCat.forgetâ‚‚AddMonPreservesLimits
-/

#print GroupCat.forgetâ‚‚MonPreservesLimits /-
@[to_additive]
instance forgetâ‚‚MonPreservesLimits : PreservesLimits (forgetâ‚‚ GroupCat MonCat.{u}) :=
  GroupCat.forgetâ‚‚MonPreservesLimitsOfSize.{u, u}
#align Group.forgetâ‚‚_Mon_preserves_limits GroupCat.forgetâ‚‚MonPreservesLimits
#align AddGroup.forgetâ‚‚_Mon_preserves_limits AddGroupCat.forgetâ‚‚MonPreservesLimits
-/

#print GroupCat.forgetPreservesLimitsOfSize /-
/-- The forgetful functor from groups to types preserves all limits.

This means the underlying type of a limit can be computed as a limit in the category of types. -/
@[to_additive
      "The forgetful functor from additive groups to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types."]
instance forgetPreservesLimitsOfSize : PreservesLimitsOfSize.{v, v} (forget GroupCat.{max v u})
    where PreservesLimitsOfShape J ð’¥ :=
    {
      PreservesLimit := fun F =>
        limits.comp_preserves_limit (forgetâ‚‚ GroupCat MonCat) (forget MonCat) }
#align Group.forget_preserves_limits_of_size GroupCat.forgetPreservesLimitsOfSize
#align AddGroup.forget_preserves_limits_of_size AddGroupCat.forgetPreservesLimitsOfSize
-/

#print GroupCat.forgetPreservesLimits /-
@[to_additive]
instance forgetPreservesLimits : PreservesLimits (forget GroupCat.{u}) :=
  GroupCat.forgetPreservesLimitsOfSize.{u, u}
#align Group.forget_preserves_limits GroupCat.forgetPreservesLimits
#align AddGroup.forget_preserves_limits AddGroupCat.forgetPreservesLimits
-/

end GroupCat

namespace CommGroupCat

/- warning: CommGroup.comm_group_obj -> CommGroupCat.commGroupObj is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 CommGroupCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2}) (j : J), CommGroup.{max u1 u2} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.comp.{u1, max u1 u2, max u1 u2, u1, succ (max u1 u2), succ (max u1 u2)} J _inst_1 CommGroupCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.forget.{succ (max u1 u2), max u1 u2, max u1 u2} CommGroupCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2} CommGroupCat.concreteCategory.{max u1 u2})) j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 CommGroupCatMax.{u1, u2} instCommGroupCatLargeCategory.{max u2 u1}) (j : J), CommGroup.{max u2 u1} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.comp.{u1, max u2 u1, max u2 u1, u1, max (succ u2) (succ u1), max (succ u2) (succ u1)} J _inst_1 CommGroupCatMax.{u1, u2} instCommGroupCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F (CategoryTheory.forget.{max (succ u2) (succ u1), max u2 u1, max u2 u1} CommGroupCatMax.{u1, u2} instCommGroupCatLargeCategory.{max u2 u1} CommGroupCat.concreteCategory.{max u2 u1}))) j)
Case conversion may be inaccurate. Consider using '#align CommGroup.comm_group_obj CommGroupCat.commGroupObjâ‚“'. -/
@[to_additive]
instance commGroupObj (F : J â¥¤ CommGroupCat.{max v u}) (j) :
    CommGroup ((F â‹™ forget CommGroupCat).obj j) :=
  by
  change CommGroup (F.obj j)
  infer_instance
#align CommGroup.comm_group_obj CommGroupCat.commGroupObj
#align AddCommGroup.add_comm_group_obj AddCommGroupCat.addCommGroupObj

#print CommGroupCat.limitCommGroup /-
@[to_additive]
instance limitCommGroup (F : J â¥¤ CommGroupCat.{max v u}) :
    CommGroup (Types.limitCone (F â‹™ forget CommGroupCat.{max v u})).pt :=
  @Subgroup.toCommGroup (âˆ€ j, F.obj j) _
    (GroupCat.sectionsSubgroup (F â‹™ forgetâ‚‚ CommGroupCat GroupCat.{max v u}))
#align CommGroup.limit_comm_group CommGroupCat.limitCommGroup
#align AddCommGroup.limit_add_comm_group AddCommGroupCat.limitAddCommGroup
-/

#print CommGroupCat.Forgetâ‚‚.createsLimit /-
/-- We show that the forgetful functor `CommGroup â¥¤ Group` creates limits.

All we need to do is notice that the limit point has a `comm_group` instance available,
and then reuse the existing limit.
-/
@[to_additive
      "We show that the forgetful functor `AddCommGroup â¥¤ AddGroup` creates limits.\n\nAll we need to do is notice that the limit point has an `add_comm_group` instance available, and\nthen reuse the existing limit."]
instance Forgetâ‚‚.createsLimit (F : J â¥¤ CommGroupCat.{max v u}) :
    CreatesLimit F (forgetâ‚‚ CommGroupCat GroupCat.{max v u}) :=
  createsLimitOfReflectsIso fun c' t =>
    { liftedCone :=
        { pt := CommGroupCat.of (Types.limitCone (F â‹™ forget CommGroupCat)).pt
          Ï€ :=
            { app :=
                MonCat.limitÏ€MonoidHom
                  (F â‹™ forgetâ‚‚ CommGroupCat GroupCat.{max v u} â‹™ forgetâ‚‚ GroupCat MonCat.{max v u})
              naturality' := (MonCat.HasLimits.limitCone _).Ï€.naturality } }
      validLift := by apply is_limit.unique_up_to_iso (GroupCat.limitConeIsLimit _) t
      makesLimit :=
        IsLimit.ofFaithful (forgetâ‚‚ _ GroupCat.{max v u} â‹™ forgetâ‚‚ _ MonCat.{max v u})
          (by apply MonCat.HasLimits.limitConeIsLimit _) (fun s => _) fun s => rfl }
#align CommGroup.forgetâ‚‚.creates_limit CommGroupCat.Forgetâ‚‚.createsLimit
#align AddCommGroup.forgetâ‚‚.creates_limit AddCommGroupCat.Forgetâ‚‚.createsLimit
-/

#print CommGroupCat.limitCone /-
/-- A choice of limit cone for a functor into `CommGroup`.
(Generally, you'll just want to use `limit F`.)
-/
@[to_additive
      "A choice of limit cone for a functor into `CommGroup`.\n(Generally, you'll just want to use `limit F`.)"]
def limitCone (F : J â¥¤ CommGroupCat.{max v u}) : Cone F :=
  liftLimit (limit.isLimit (F â‹™ forgetâ‚‚ CommGroupCat GroupCat.{max v u}))
#align CommGroup.limit_cone CommGroupCat.limitCone
#align AddCommGroup.limit_cone AddCommGroupCat.limitCone
-/

#print CommGroupCat.limitConeIsLimit /-
/-- The chosen cone is a limit cone.
(Generally, you'll just want to use `limit.cone F`.)
-/
@[to_additive
      "The chosen cone is a limit cone.\n(Generally, you'll just wantto use `limit.cone F`.)"]
def limitConeIsLimit (F : J â¥¤ CommGroupCat.{max v u}) : IsLimit (limitCone F) :=
  liftedLimitIsLimit _
#align CommGroup.limit_cone_is_limit CommGroupCat.limitConeIsLimit
#align AddCommGroup.limit_cone_is_limit AddCommGroupCat.limitConeIsLimit
-/

#print CommGroupCat.hasLimitsOfSize /-
/-- The category of commutative groups has all limits. -/
@[to_additive "The category of additive commutative groups has all limits."]
instance hasLimitsOfSize : HasLimitsOfSize.{v, v} CommGroupCat.{max v u}
    where HasLimitsOfShape J ð’¥ :=
    { HasLimit := fun F => has_limit_of_created F (forgetâ‚‚ CommGroupCat GroupCat.{max v u}) }
#align CommGroup.has_limits_of_size CommGroupCat.hasLimitsOfSize
#align AddCommGroup.has_limits_of_size AddCommGroupCat.hasLimitsOfSize
-/

#print CommGroupCat.hasLimits /-
@[to_additive]
instance hasLimits : HasLimits CommGroupCat.{u} :=
  CommGroupCat.hasLimitsOfSize.{u, u}
#align CommGroup.has_limits CommGroupCat.hasLimits
#align AddCommGroup.has_limits AddCommGroupCat.hasLimits
-/

#print CommGroupCat.forgetâ‚‚GroupPreservesLimitsOfSize /-
/-- The forgetful functor from commutative groups to groups preserves all limits.
(That is, the underlying group could have been computed instead as limits in the category
of groups.)
-/
@[to_additive AddCommGroupCat.forgetâ‚‚AddGroupPreservesLimitsOfSize
      "The forgetful functor from additive commutative groups to groups preserves all limits.\n(That is, the underlying group could have been computed instead as limits in the category\nof additive groups.)"]
instance forgetâ‚‚GroupPreservesLimitsOfSize :
    PreservesLimitsOfSize.{v, v} (forgetâ‚‚ CommGroupCat GroupCat.{max v u})
    where PreservesLimitsOfShape J ð’¥ := { PreservesLimit := fun F => by infer_instance }
#align CommGroup.forgetâ‚‚_Group_preserves_limits_of_size CommGroupCat.forgetâ‚‚GroupPreservesLimitsOfSize
#align AddCommGroup.forgetâ‚‚_AddGroup_preserves_limits AddCommGroupCat.forgetâ‚‚AddGroupPreservesLimitsOfSize
-/

#print CommGroupCat.forgetâ‚‚GroupPreservesLimits /-
@[to_additive]
instance forgetâ‚‚GroupPreservesLimits : PreservesLimits (forgetâ‚‚ CommGroupCat GroupCat.{u}) :=
  CommGroupCat.forgetâ‚‚GroupPreservesLimitsOfSize.{u, u}
#align CommGroup.forgetâ‚‚_Group_preserves_limits CommGroupCat.forgetâ‚‚GroupPreservesLimits
#align AddCommGroup.forgetâ‚‚_Group_preserves_limits AddCommGroupCat.forgetâ‚‚AddGroupPreservesLimits
-/

/- warning: CommGroup.forgetâ‚‚_CommMon_preserves_limits_aux -> CommGroupCat.forgetâ‚‚CommMonPreservesLimitsAux is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 CommGroupCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2}), CategoryTheory.Limits.IsLimit.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 CommMonCat.{max u1 u2} CommMonCat.largeCategory.{max u1 u2} (CategoryTheory.Functor.comp.{u1, max u1 u2, max u1 u2, u1, succ (max u1 u2), succ (max u1 u2)} J _inst_1 CommGroupCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2} CommMonCat.{max u1 u2} CommMonCat.largeCategory.{max u1 u2} F (CategoryTheory.forgetâ‚‚.{succ (max u1 u2), succ (max u1 u2), max u1 u2, max u1 u2, max u1 u2} CommGroupCat.{max u1 u2} CommMonCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2} CommGroupCat.concreteCategory.{max u1 u2} CommMonCat.largeCategory.{max u1 u2} CommMonCat.concreteCategory.{max u1 u2} CommGroupCat.hasForgetToCommMonCat.{max u1 u2})) (CategoryTheory.Functor.mapCone.{u1, max u1 u2, max u1 u2, u1, succ (max u1 u2), succ (max u1 u2)} J _inst_1 CommGroupCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2} CommMonCat.{max u1 u2} CommMonCat.largeCategory.{max u1 u2} F (CategoryTheory.forgetâ‚‚.{succ (max u1 u2), succ (max u1 u2), max u1 u2, max u1 u2, max u1 u2} CommGroupCat.{max u1 u2} CommMonCat.{max u1 u2} CommGroupCat.largeCategory.{max u1 u2} CommGroupCat.concreteCategory.{max u1 u2} CommMonCat.largeCategory.{max u1 u2} CommMonCat.concreteCategory.{max u1 u2} CommGroupCat.hasForgetToCommMonCat.{max u1 u2}) (CommGroupCat.limitCone.{u1, u2} J _inst_1 F))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 CommGroupCatMax.{u1, u2} instCommGroupCatLargeCategory.{max u2 u1}), CategoryTheory.Limits.IsLimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 CommMonCat.{max u2 u1} instCommMonCatLargeCategory.{max u2 u1} (CategoryTheory.Functor.comp.{u1, max u2 u1, max u2 u1, u1, max (succ u2) (succ u1), max (succ u2) (succ u1)} J _inst_1 CommGroupCatMax.{u1, u2} instCommGroupCatLargeCategory.{max u2 u1} CommMonCat.{max u2 u1} instCommMonCatLargeCategory.{max u2 u1} F (CategoryTheory.forgetâ‚‚.{max (succ u2) (succ u1), succ (max u2 u1), max u2 u1, max u2 u1, max u2 u1} CommGroupCatMax.{u1, u2} CommMonCat.{max u2 u1} instCommGroupCatLargeCategory.{max u2 u1} CommGroupCat.concreteCategory.{max u2 u1} instCommMonCatLargeCategory.{max u2 u1} CommMonCat.concreteCategory.{max u2 u1} CommGroupCat.hasForgetToCommMonCat.{max u2 u1})) (CategoryTheory.Functor.mapCone.{u1, max u2 u1, max u2 u1, u1, max (succ u2) (succ u1), max (succ u2) (succ u1)} J _inst_1 CommGroupCatMax.{u1, u2} instCommGroupCatLargeCategory.{max u2 u1} CommMonCat.{max u2 u1} instCommMonCatLargeCategory.{max u2 u1} (CategoryTheory.forgetâ‚‚.{max (succ u2) (succ u1), succ (max u2 u1), max u2 u1, max u2 u1, max u2 u1} CommGroupCatMax.{u1, u2} CommMonCat.{max u2 u1} instCommGroupCatLargeCategory.{max u2 u1} CommGroupCat.concreteCategory.{max u2 u1} instCommMonCatLargeCategory.{max u2 u1} CommMonCat.concreteCategory.{max u2 u1} CommGroupCat.hasForgetToCommMonCat.{max u2 u1}) F (CommGroupCat.limitCone.{u1, u2} J _inst_1 F))
Case conversion may be inaccurate. Consider using '#align CommGroup.forgetâ‚‚_CommMon_preserves_limits_aux CommGroupCat.forgetâ‚‚CommMonPreservesLimitsAuxâ‚“'. -/
/-- An auxiliary declaration to speed up typechecking.
-/
@[to_additive AddCommGroupCat.forgetâ‚‚AddCommMonPreservesLimitsAux
      "An auxiliary declaration to speed up typechecking."]
def forgetâ‚‚CommMonPreservesLimitsAux (F : J â¥¤ CommGroupCat.{max v u}) :
    IsLimit ((forgetâ‚‚ CommGroupCat CommMonCat).mapCone (limitCone F)) :=
  CommMonCat.limitConeIsLimit (F â‹™ forgetâ‚‚ CommGroupCat CommMonCat)
#align CommGroup.forgetâ‚‚_CommMon_preserves_limits_aux CommGroupCat.forgetâ‚‚CommMonPreservesLimitsAux
#align AddCommGroup.forgetâ‚‚_AddCommMon_preserves_limits_aux AddCommGroupCat.forgetâ‚‚AddCommMonPreservesLimitsAux

#print CommGroupCat.forgetâ‚‚CommMonPreservesLimitsOfSize /-
/-- The forgetful functor from commutative groups to commutative monoids preserves all limits.
(That is, the underlying commutative monoids could have been computed instead as limits
in the category of commutative monoids.)
-/
@[to_additive AddCommGroupCat.forgetâ‚‚AddCommMonPreservesLimits
      "The forgetful functor from additive commutative groups to additive commutative monoids preserves\nall limits. (That is, the underlying additive commutative monoids could have been computed instead\nas limits in the category of additive commutative monoids.)"]
instance forgetâ‚‚CommMonPreservesLimitsOfSize :
    PreservesLimitsOfSize.{v, v} (forgetâ‚‚ CommGroupCat CommMonCat.{max v u})
    where PreservesLimitsOfShape J ð’¥ :=
    {
      PreservesLimit := fun F =>
        preserves_limit_of_preserves_limit_cone (limit_cone_is_limit F)
          (forgetâ‚‚_CommMon_preserves_limits_aux F) }
#align CommGroup.forgetâ‚‚_CommMon_preserves_limits_of_size CommGroupCat.forgetâ‚‚CommMonPreservesLimitsOfSize
#align AddCommGroup.forgetâ‚‚_AddCommMon_preserves_limits AddCommGroupCat.forgetâ‚‚AddCommMonPreservesLimits
-/

#print CommGroupCat.forgetPreservesLimitsOfSize /-
/-- The forgetful functor from commutative groups to types preserves all limits. (That is, the
underlying types could have been computed instead as limits in the category of types.)
-/
@[to_additive AddCommGroupCat.forgetPreservesLimits
      "The forgetful functor from additive commutative groups to types preserves all limits. (That is,\nthe underlying types could have been computed instead as limits in the category of types.)"]
instance forgetPreservesLimitsOfSize : PreservesLimitsOfSize.{v, v} (forget CommGroupCat.{max v u})
    where PreservesLimitsOfShape J ð’¥ :=
    {
      PreservesLimit := fun F =>
        limits.comp_preserves_limit (forgetâ‚‚ CommGroupCat GroupCat) (forget GroupCat) }
#align CommGroup.forget_preserves_limits_of_size CommGroupCat.forgetPreservesLimitsOfSize
#align AddCommGroup.forget_preserves_limits AddCommGroupCat.forgetPreservesLimits
-/

-- Verify we can form limits indexed over smaller categories.
example (f : â„• â†’ AddCommGroupCat) : HasProduct f := by infer_instance

end CommGroupCat

namespace AddCommGroupCat

/- warning: AddCommGroup.kernel_iso_ker -> AddCommGroupCat.kernelIsoKer is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1})) G H), CategoryTheory.Iso.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f)) (AddCommGroupCat.of.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddSubgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)) (AddSubgroup.toAddCommGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)))
but is expected to have type
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1})) G H), CategoryTheory.Iso.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f)) (AddCommGroupCat.of.{u1} (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) x (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.toAddCommGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)))
Case conversion may be inaccurate. Consider using '#align AddCommGroup.kernel_iso_ker AddCommGroupCat.kernelIsoKerâ‚“'. -/
/-- The categorical kernel of a morphism in `AddCommGroup`
agrees with the usual group-theoretical kernel.
-/
def kernelIsoKer {G H : AddCommGroupCat.{u}} (f : G âŸ¶ H) : kernel f â‰… AddCommGroupCat.of f.ker
    where
  Hom :=
    { toFun := fun g =>
        âŸ¨kernel.Î¹ f g,
          by
          -- TODO where is this `has_coe_t_aux.coe` coming from? can we prevent it appearing?
          change (kernel.Î¹ f) g âˆˆ f.ker
          simp [AddMonoidHom.mem_ker]âŸ©
      map_zero' := by
        ext
        simp
      map_add' := fun g g' => by
        ext
        simp }
  inv := kernel.lift f (AddSubgroup.subtype f.ker) (by tidy)
  hom_inv_id' := by
    apply equalizer.hom_ext _
    ext
    simp
  inv_hom_id' := by
    apply AddCommGroupCat.ext
    simp only [AddMonoidHom.coe_mk, coe_id, coe_comp]
    rintro âŸ¨x, memâŸ©
    simp
#align AddCommGroup.kernel_iso_ker AddCommGroupCat.kernelIsoKer

/- warning: AddCommGroup.kernel_iso_ker_hom_comp_subtype -> AddCommGroupCat.kernelIsoKer_hom_comp_subtype is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1})) G H), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1})) (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f)) G) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1}) (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f)) (AddCommGroupCat.of.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddSubgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)) (AddSubgroup.toAddCommGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) G (CategoryTheory.Iso.hom.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f)) (AddCommGroupCat.of.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddSubgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)) (AddSubgroup.toAddCommGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddCommGroupCat.kernelIsoKer.{u1} G H f)) (AddSubgroup.subtype.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (CategoryTheory.Limits.kernel.Î¹.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f))
but is expected to have type
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1})) G H), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1})) (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f)) G) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f)) (AddCommGroupCat.of.{u1} (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) x (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.toAddCommGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) G (CategoryTheory.Iso.hom.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f)) (AddCommGroupCat.of.{u1} (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) x (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.toAddCommGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddCommGroupCat.kernelIsoKer.{u1} G H f)) (AddSubgroup.subtype.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (CategoryTheory.Limits.kernel.Î¹.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f))
Case conversion may be inaccurate. Consider using '#align AddCommGroup.kernel_iso_ker_hom_comp_subtype AddCommGroupCat.kernelIsoKer_hom_comp_subtypeâ‚“'. -/
@[simp]
theorem kernelIsoKer_hom_comp_subtype {G H : AddCommGroupCat} (f : G âŸ¶ H) :
    (kernelIsoKer f).Hom â‰« AddSubgroup.subtype f.ker = kernel.Î¹ f := by ext <;> rfl
#align AddCommGroup.kernel_iso_ker_hom_comp_subtype AddCommGroupCat.kernelIsoKer_hom_comp_subtype

/- warning: AddCommGroup.kernel_iso_ker_inv_comp_Î¹ -> AddCommGroupCat.kernelIsoKer_inv_comp_Î¹ is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1})) G H), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1})) (AddCommGroupCat.of.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddSubgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)) (AddSubgroup.toAddCommGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) G) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1}) (AddCommGroupCat.of.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddSubgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)) (AddSubgroup.toAddCommGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f)) G (CategoryTheory.Iso.inv.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f)) (AddCommGroupCat.of.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddSubgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)) (AddSubgroup.toAddCommGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddCommGroupCat.kernelIsoKer.{u1} G H f)) (CategoryTheory.Limits.kernel.Î¹.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKer._proof_1.{u1} G H f))) (AddSubgroup.subtype.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))
but is expected to have type
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1})) G H), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1})) (AddCommGroupCat.of.{u1} (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) x (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.toAddCommGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) G) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1}) (AddCommGroupCat.of.{u1} (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) x (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.toAddCommGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f)) G (CategoryTheory.Iso.inv.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f)) (AddCommGroupCat.of.{u1} (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) x (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.toAddCommGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddCommGroupCat.kernelIsoKer.{u1} G H f)) (CategoryTheory.Limits.kernel.Î¹.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f))) (AddSubgroup.subtype.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))
Case conversion may be inaccurate. Consider using '#align AddCommGroup.kernel_iso_ker_inv_comp_Î¹ AddCommGroupCat.kernelIsoKer_inv_comp_Î¹â‚“'. -/
@[simp]
theorem kernelIsoKer_inv_comp_Î¹ {G H : AddCommGroupCat} (f : G âŸ¶ H) :
    (kernelIsoKer f).inv â‰« kernel.Î¹ f = AddSubgroup.subtype f.ker :=
  by
  ext
  simp [kernel_iso_ker]
#align AddCommGroup.kernel_iso_ker_inv_comp_Î¹ AddCommGroupCat.kernelIsoKer_inv_comp_Î¹

/- warning: AddCommGroup.kernel_iso_ker_over -> AddCommGroupCat.kernelIsoKerOver is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1})) G H), CategoryTheory.Iso.{u1, succ u1} (CategoryTheory.Over.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} G) (CategoryTheory.Over.category.{succ u1, u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} G) (CategoryTheory.Over.mk.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} G (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKerOver._proof_1.{u1} G H f)) (CategoryTheory.Limits.kernel.Î¹.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} AddCommGroupCat.CategoryTheory.preadditive.{u1}) G H f (AddCommGroupCat.kernelIsoKerOver._proof_2.{u1} G H f))) (CategoryTheory.Over.mk.{u1, succ u1} AddCommGroupCat.{u1} AddCommGroupCat.largeCategory.{u1} G (AddCommGroupCat.of.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddSubgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)) (AddSubgroup.toAddCommGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.subtype.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (AddMonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (AddCommGroup.toAddGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddCommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddCommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)))
but is expected to have type
  forall {G : AddCommGroupCat.{u1}} {H : AddCommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddCommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1})) G H), CategoryTheory.Iso.{u1, succ u1} (CategoryTheory.Over.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} G) (CategoryTheory.instCategoryOver.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} G) (CategoryTheory.Over.mk.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} G (CategoryTheory.Limits.kernel.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f)) (CategoryTheory.Limits.kernel.Î¹.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) G H f (CategoryTheory.Limits.HasKernels.has_limit.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} AddCommGroupCat.instPreadditiveAddCommGroupCatInstAddCommGroupCatLargeCategory.{u1}) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory AddCommGroupCat.hasLimitsOfSize.{0, u1})) G H f))) (CategoryTheory.Over.mk.{u1, succ u1} AddCommGroupCat.{u1} instAddCommGroupCatLargeCategory.{u1} G (AddCommGroupCat.of.{u1} (Subtype.{succ u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (fun (x : CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) => Membership.mem.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G))) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)))) x (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.toAddCommGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f))) (AddSubgroup.subtype.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (AddMonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} G) (AddCommGroupCat.addCommGroupInstance.{u1} G)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddMonoid.toAddZeroClass.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) ((fun {Î± : Type.{u1}} (h : AddGroup.{u1} Î±) => SubNegMonoid.toAddMonoid.{u1} Î± (AddGroup.toSubNegMonoid.{u1} Î± h)) (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (AddCommGroup.toAddGroup.{u1} (CategoryTheory.Bundled.Î±.{u1, u1} AddCommGroup.{u1} H) (CategoryTheory.Bundled.str.{u1, u1} AddCommGroup.{u1} H)))) f)))
Case conversion may be inaccurate. Consider using '#align AddCommGroup.kernel_iso_ker_over AddCommGroupCat.kernelIsoKerOverâ‚“'. -/
/-- The categorical kernel inclusion for `f : G âŸ¶ H`, as an object over `G`,
agrees with the `subtype` map.
-/
@[simps]
def kernelIsoKerOver {G H : AddCommGroupCat.{u}} (f : G âŸ¶ H) :
    Over.mk (kernel.Î¹ f) â‰… @Over.mk _ _ G (AddCommGroupCat.of f.ker) (AddSubgroup.subtype f.ker) :=
  Over.isoMk (kernelIsoKer f) (by simp)
#align AddCommGroup.kernel_iso_ker_over AddCommGroupCat.kernelIsoKerOver

end AddCommGroupCat

