/-
Copyright (c) 2022 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa
-/
import Mathbin.Algebra.MonoidAlgebra.Basic

/-!
#  Lemmas about the support of a finitely supported function
-/


universe u₁ u₂ u₃

namespace MonoidAlgebra

open Finset Finsupp

variable {k : Type u₁} {G : Type u₂} {R : Type u₃} [Semiringₓ k]

theorem support_mul [Mul G] [DecidableEq G] (a b : MonoidAlgebra k G) :
    (a * b).Support ⊆ a.Support.bUnion fun a₁ => b.Support.bUnion fun a₂ => {a₁ * a₂} :=
  Subset.trans support_sum <|
    bUnion_mono fun a₁ _ => Subset.trans support_sum <| bUnion_mono fun a₂ _ => support_single_subset

theorem support_mul_single [RightCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, y * r = 0 ↔ y = 0)
    (x : G) : (f * single x r).Support = f.Support.map (mulRightEmbedding x) := by
  ext y
  simp only [mem_support_iff, mem_map, exists_prop, mul_right_embedding_apply]
  by_cases' H : ∃ a, a * x = y
  · rcases H with ⟨a, rfl⟩
    rw [mul_single_apply_aux f fun _ => mul_left_injₓ x]
    simp [hr]
    
  · push_neg  at H
    classical
    simp [mul_apply, H]
    

theorem support_single_mul [LeftCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, r * y = 0 ↔ y = 0)
    (x : G) : (single x r * f : MonoidAlgebra k G).Support = f.Support.map (mulLeftEmbedding x) := by
  ext y
  simp only [mem_support_iff, mem_map, exists_prop, mul_left_embedding_apply]
  by_cases' H : ∃ a, x * a = y
  · rcases H with ⟨a, rfl⟩
    rw [single_mul_apply_aux f fun _ => mul_right_injₓ x]
    simp [hr]
    
  · push_neg  at H
    classical
    simp [mul_apply, H]
    

section Span

variable [MulOneClassₓ G]

/-- An element of `monoid_algebra R M` is in the subalgebra generated by its support. -/
theorem mem_span_support (f : MonoidAlgebra k G) : f ∈ Submodule.span k (of k G '' (f.Support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

end MonoidAlgebra

namespace AddMonoidAlgebra

open Finset Finsupp MulOpposite

variable {k : Type u₁} {G : Type u₂} {R : Type u₃} [Semiringₓ k]

theorem support_mul [DecidableEq G] [Add G] (a b : AddMonoidAlgebra k G) :
    (a * b).Support ⊆ a.Support.bUnion fun a₁ => b.Support.bUnion fun a₂ => {a₁ + a₂} :=
  @MonoidAlgebra.support_mul k (Multiplicative G) _ _ _ _ _

theorem support_mul_single [AddRightCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, y * r = 0 ↔ y = 0)
    (x : G) : (f * single x r : AddMonoidAlgebra k G).Support = f.Support.map (addRightEmbedding x) :=
  @MonoidAlgebra.support_mul_single k (Multiplicative G) _ _ _ _ hr _

theorem support_single_mul [AddLeftCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, r * y = 0 ↔ y = 0)
    (x : G) : (single x r * f : AddMonoidAlgebra k G).Support = f.Support.map (addLeftEmbedding x) :=
  @MonoidAlgebra.support_single_mul k (Multiplicative G) _ _ _ _ hr _

section Span

/-- An element of `add_monoid_algebra R M` is in the submodule generated by its support. -/
theorem mem_span_support [AddZeroClassₓ G] (f : AddMonoidAlgebra k G) :
    f ∈ Submodule.span k (of k G '' (f.Support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

/-- An element of `add_monoid_algebra R M` is in the subalgebra generated by its support, using
unbundled inclusion. -/
theorem mem_span_support' (f : AddMonoidAlgebra k G) : f ∈ Submodule.span k (of' k G '' (f.Support : Set G)) := by
  rw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

end AddMonoidAlgebra

