import Mathbin.Control.Functor.Multivariate 
import Mathbin.Data.Pfunctor.Multivariate.Basic 
import Mathbin.Data.Pfunctor.Multivariate.M 
import Mathbin.Data.Qpf.Multivariate.Basic

/-!
# The final co-algebra of a multivariate qpf is again a qpf.

For a `(n+1)`-ary QPF `F (α₀,..,αₙ)`, we take the least fixed point of `F` with
regards to its last argument `αₙ`. The result is a `n`-ary functor: `fix F (α₀,..,αₙ₋₁)`.
Making `fix F` into a functor allows us to take the fixed point, compose with other functors
and take a fixed point again.

## Main definitions

 * `cofix.mk`     - constructor
 * `cofix.dest    - destructor
 * `cofix.corec`  - corecursor: useful for formulating infinite, productive computations
 * `cofix.bisim`  - bisimulation: proof technique to show the equality of possibly infinite values
                    of `cofix F α`

## Implementation notes

For `F` a QPF`, we define `cofix F α` in terms of the M-type of the polynomial functor `P` of `F`.
We define the relation `Mcongr` and take its quotient as the definition of `cofix F α`.

`Mcongr` is taken as the weakest bisimulation on M-type.  See
[avigad-carneiro-hudon2019] for more details.

## Reference

 * [Jeremy Avigad, Mario M. Carneiro and Simon Hudon, *Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]
-/


universe u

open_locale Mvfunctor

namespace Mvqpf

open Typevec Mvpfunctor

open mvfunctor(Liftp Liftr)

variable {n : ℕ} {F : Typevec.{u} (n+1) → Type u} [Mvfunctor F] [q : Mvqpf F]

include q

/-- `corecF` is used as a basis for defining the corecursor of `cofix F α`. `corecF`
uses corecursion to construct the M-type generated by `q.P` and uses function on `F`
as a corecursive step -/
def corecF {α : Typevec n} {β : Type _} (g : β → F (α.append1 β)) : β → q.P.M α :=
  M.corec _ fun x => reprₓ (g x)

theorem corecF_eq {α : Typevec n} {β : Type _} (g : β → F (α.append1 β)) (x : β) :
  M.dest q.P (corecF g x) = append_fun id (corecF g) <$$> reprₓ (g x) :=
  by 
    rw [corecF, M.dest_corec]

/-- Characterization of desirable equivalence relations on M-types -/
def is_precongr {α : Typevec n} (r : q.P.M α → q.P.M α → Prop) : Prop :=
  ∀ ⦃x y⦄, r x y → abs (append_fun id (Quot.mk r) <$$> M.dest q.P x) = abs (append_fun id (Quot.mk r) <$$> M.dest q.P y)

/-- Equivalence relation on M-types representing a value of type `cofix F` -/
def Mcongr {α : Typevec n} (x y : q.P.M α) : Prop :=
  ∃ r, is_precongr r ∧ r x y

/-- Greatest fixed point of functor F. The result is a functor with one fewer parameters
than the input. For `F a b c` a ternary functor, fix F is a binary functor such that

```lean
cofix F a b = F a b (cofix F a b)
```
-/
def cofix (F : Typevec (n+1) → Type u) [Mvfunctor F] [q : Mvqpf F] (α : Typevec n) :=
  Quot (@Mcongr _ F _ q α)

instance {α : Typevec n} [Inhabited q.P.A] [∀ i : Fin2 n, Inhabited (α i)] : Inhabited (cofix F α) :=
  ⟨Quot.mk _ (default _)⟩

/-- maps every element of the W type to a canonical representative -/
def Mrepr {α : Typevec n} : q.P.M α → q.P.M α :=
  corecF (abs ∘ M.dest q.P)

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- the map function for the functor `cofix F` -/
def cofix.map {α β : typevec n} (g : «expr ⟹ »(α, β)) : cofix F α → cofix F β :=
quot.lift (λ
 x : q.P.M α, quot.mk Mcongr «expr <$$> »(g, x)) (begin
   rintros [ident aa₁, ident aa₂, "⟨", ident r, ",", ident pr, ",", ident ra₁a₂, "⟩"],
   apply [expr quot.sound],
   let [ident r'] [] [":=", expr λ
    b₁
    b₂, «expr∃ , »((a₁
      a₂ : q.P.M α), «expr ∧ »(r a₁ a₂, «expr ∧ »(«expr = »(b₁, «expr <$$> »(g, a₁)), «expr = »(b₂, «expr <$$> »(g, a₂)))))],
   use [expr r'],
   split,
   { show [expr is_precongr r'],
     rintros [ident b₁, ident b₂, "⟨", ident a₁, ",", ident a₂, ",", ident ra₁a₂, ",", ident b₁eq, ",", ident b₂eq, "⟩"],
     let [ident u] [":", expr quot r → quot r'] [":=", expr quot.lift (λ
       x : q.P.M α, quot.mk r' «expr <$$> »(g, x)) (by { intros [ident a₁, ident a₂, ident ra₁a₂],
         apply [expr quot.sound],
         exact [expr ⟨a₁, a₂, ra₁a₂, rfl, rfl⟩] })],
     have [ident hu] [":", expr «expr = »(«expr ∘ »(quot.mk r', λ
        x : q.P.M α, «expr <$$> »(g, x)), «expr ∘ »(u, quot.mk r))] [],
     { ext [] [ident x] [],
       refl },
     rw ["[", expr b₁eq, ",", expr b₂eq, ",", expr M.dest_map, ",", expr M.dest_map, ",", "<-", expr q.P.comp_map, ",", "<-", expr q.P.comp_map, "]"] [],
     rw ["[", "<-", expr append_fun_comp, ",", expr id_comp, ",", expr hu, ",", expr hu, ",", "<-", expr comp_id g, ",", expr append_fun_comp, "]"] [],
     rw ["[", expr q.P.comp_map, ",", expr q.P.comp_map, ",", expr abs_map, ",", expr pr ra₁a₂, ",", "<-", expr abs_map, "]"] [] },
   show [expr r' «expr <$$> »(g, aa₁) «expr <$$> »(g, aa₂)],
   from [expr ⟨aa₁, aa₂, ra₁a₂, rfl, rfl⟩]
 end)

instance cofix.mvfunctor : Mvfunctor (cofix F) :=
  { map := @cofix.map _ _ _ _ }

/-- Corecursor for `cofix F` -/
def cofix.corec {α : Typevec n} {β : Type u} (g : β → F (α.append1 β)) : β → cofix F α :=
  fun x => Quot.mk _ (corecF g x)

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Destructor for `cofix F` -/ def cofix.dest {α : typevec n} : cofix F α → F (α.append1 (cofix F α)) :=
quot.lift (λ
 x, «expr <$$> »(append_fun id (quot.mk Mcongr), abs (M.dest q.P x))) (begin
   rintros [ident x, ident y, "⟨", ident r, ",", ident pr, ",", ident rxy, "⟩"],
   dsimp [] [] [] [],
   have [] [":", expr ∀ x y, r x y → Mcongr x y] [],
   { intros [ident x, ident y, ident h],
     exact [expr ⟨r, pr, h⟩] },
   rw ["[", "<-", expr quot.factor_mk_eq _ _ this, "]"] [],
   dsimp [] [] [] [],
   conv [] [] { to_lhs,
     rw ["[", expr append_fun_comp_id, ",", expr comp_map, ",", "<-", expr abs_map, ",", expr pr rxy, ",", expr abs_map, ",", "<-", expr comp_map, ",", "<-", expr append_fun_comp_id, "]"] }
 end)

/-- Abstraction function for `cofix F α` -/
def cofix.abs {α} : q.P.M α → cofix F α :=
  Quot.mk _

/-- Representation function for `cofix F α` -/
def cofix.repr {α} : cofix F α → q.P.M α :=
  M.corec _$ reprₓ ∘ cofix.dest

/-- Corecursor for `cofix F` -/
def cofix.corec'₁ {α : Typevec n} {β : Type u} (g : ∀ {X}, (β → X) → F (α.append1 X)) (x : β) : cofix F α :=
  cofix.corec (fun x => g id) x

/-- More flexible corecursor for `cofix F`. Allows the return of a fully formed
value instead of making a recursive call -/
def cofix.corec' {α : Typevec n} {β : Type u} (g : β → F (α.append1 (Sum (cofix F α) β))) (x : β) : cofix F α :=
  let f : (α ::: cofix F α) ⟹ (α ::: Sum (cofix F α) β) := id ::: Sum.inl 
  cofix.corec (Sum.elim (Mvfunctor.map f ∘ cofix.dest) g) (Sum.inr x : Sum (cofix F α) β)

/-- Corecursor for `cofix F`. The shape allows recursive calls to
look like recursive calls. -/
def cofix.corec₁ {α : Typevec n} {β : Type u} (g : ∀ {X}, (cofix F α → X) → (β → X) → β → F (α ::: X)) (x : β) :
  cofix F α :=
  cofix.corec' (fun x => g Sum.inl Sum.inr x) x

theorem cofix.dest_corec {α : Typevec n} {β : Type u} (g : β → F (α.append1 β)) (x : β) :
  cofix.dest (cofix.corec g x) = append_fun id (cofix.corec g) <$$> g x :=
  by 
    conv  => toLHS rw [cofix.dest, cofix.corec]
    dsimp 
    rw [corecF_eq, abs_map, abs_repr, ←comp_map, ←append_fun_comp]
    rfl

/-- constructor for `cofix F` -/
def cofix.mk {α : Typevec n} : F (α.append1$ cofix F α) → cofix F α :=
  cofix.corec fun x => (append_fun id fun i : cofix F α => cofix.dest.{u} i) <$$> x

/-!
## Bisimulation principles for `cofix F`

The following theorems are bisimulation principles. The general idea
is to use a bisimulation relation to prove the equality between
specific values of type `cofix F α`.

A bisimulation relation `R` for values `x y : cofix F α`:

 * holds for `x y`: `R x y`
 * for any values `x y` that satisfy `R`, their root has the same shape
   and their children can be paired in such a way that they satisfy `R`.

-/


-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
private
theorem cofix.bisim_aux
{α : typevec n}
(r : cofix F α → cofix F α → exprProp())
(h' : ∀ x, r x x)
(h : ∀
 x
 y, r x y → «expr = »(«expr <$$> »(append_fun id (quot.mk r), cofix.dest x), «expr <$$> »(append_fun id (quot.mk r), cofix.dest y))) : ∀
x y, r x y → «expr = »(x, y) :=
begin
  intro [ident x],
  apply [expr quot.induction_on x],
  clear [ident x],
  intros [ident x, ident y],
  apply [expr quot.induction_on y],
  clear [ident y],
  intros [ident y, ident rxy],
  apply [expr quot.sound],
  let [ident r'] [] [":=", expr λ x y, r (quot.mk _ x) (quot.mk _ y)],
  have [] [":", expr is_precongr r'] [],
  { intros [ident a, ident b, ident r'ab],
    have [ident h₀] [":", expr «expr = »(«expr <$$> »(append_fun id «expr ∘ »(quot.mk r, quot.mk Mcongr), abs (M.dest q.P a)), «expr <$$> »(append_fun id «expr ∘ »(quot.mk r, quot.mk Mcongr), abs (M.dest q.P b)))] [":=", expr by rw ["[", expr append_fun_comp_id, ",", expr comp_map, ",", expr comp_map, "]"] []; exact [expr h _ _ r'ab]],
    have [ident h₁] [":", expr ∀ u v : q.P.M α, Mcongr u v → «expr = »(quot.mk r' u, quot.mk r' v)] [],
    { intros [ident u, ident v, ident cuv],
      apply [expr quot.sound],
      dsimp [] ["[", expr r', "]"] [] [],
      rw [expr quot.sound cuv] [],
      apply [expr h'] },
    let [ident f] [":", expr quot r → quot r'] [":=", expr quot.lift (quot.lift (quot.mk r') h₁) (begin
        intro [ident c],
        apply [expr quot.induction_on c],
        clear [ident c],
        intros [ident c, ident d],
        apply [expr quot.induction_on d],
        clear [ident d],
        intros [ident d, ident rcd],
        apply [expr quot.sound],
        apply [expr rcd]
      end)],
    have [] [":", expr «expr = »(«expr ∘ »(f, «expr ∘ »(quot.mk r, quot.mk Mcongr)), quot.mk r')] [":=", expr rfl],
    rw ["[", "<-", expr this, ",", expr append_fun_comp_id, ",", expr q.P.comp_map, ",", expr q.P.comp_map, ",", expr abs_map, ",", expr abs_map, ",", expr abs_map, ",", expr abs_map, ",", expr h₀, "]"] [] },
  refine [expr ⟨r', this, rxy⟩]
end

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Bisimulation principle using `map` and `quot.mk` to match and relate children of two trees. -/
theorem cofix.bisim_rel
{α : typevec n}
(r : cofix F α → cofix F α → exprProp())
(h : ∀
 x
 y, r x y → «expr = »(«expr <$$> »(append_fun id (quot.mk r), cofix.dest x), «expr <$$> »(append_fun id (quot.mk r), cofix.dest y))) : ∀
x y, r x y → «expr = »(x, y) :=
let r' (x y) := «expr ∨ »(«expr = »(x, y), r x y) in
begin
  intros [ident x, ident y, ident rxy],
  apply [expr cofix.bisim_aux r'],
  { intro [ident x],
    left,
    reflexivity },
  { intros [ident x, ident y, ident r'xy],
    cases [expr r'xy] [],
    { rw [expr r'xy] [] },
    have [] [":", expr ∀ x y, r x y → r' x y] [":=", expr λ x y h, or.inr h],
    rw ["<-", expr quot.factor_mk_eq _ _ this] [],
    dsimp [] [] [] [],
    rw ["[", expr append_fun_comp_id, ",", expr append_fun_comp_id, "]"] [],
    rw ["[", expr @comp_map _ _ _ q _ _ _ (append_fun id (quot.mk r)), ",", expr @comp_map _ _ _ q _ _ _ (append_fun id (quot.mk r)), "]"] [],
    rw [expr h _ _ r'xy] [] },
  right,
  exact [expr rxy]
end

/-- Bisimulation principle using `liftr` to match and relate children of two trees. -/
theorem cofix.bisim {α : Typevec n} (r : cofix F α → cofix F α → Prop)
  (h : ∀ x y, r x y → liftr (rel_last α r) (cofix.dest x) (cofix.dest y)) : ∀ x y, r x y → x = y :=
  by 
    apply cofix.bisim_rel 
    intro x y rxy 
    rcases(liftr_iff (rel_last α r) _ _).mp (h x y rxy) with ⟨a, f₀, f₁, dxeq, dyeq, h'⟩
    rw [dxeq, dyeq, ←abs_map, ←abs_map, Mvpfunctor.map_eq, Mvpfunctor.map_eq]
    rw [←split_drop_fun_last_fun f₀, ←split_drop_fun_last_fun f₁]
    rw [append_fun_comp_split_fun, append_fun_comp_split_fun]
    rw [id_comp, id_comp]
    congr 2 with i j 
    cases' i with _ i <;> dsimp
    ·
      apply Quot.sound 
      apply h' _ j
    ·
      change f₀ _ j = f₁ _ j 
      apply h' _ j

open Mvfunctor

/-- Bisimulation principle using `liftr'` to match and relate children of two trees. -/
theorem cofix.bisim₂ {α : Typevec n} (r : cofix F α → cofix F α → Prop)
  (h : ∀ x y, r x y → liftr' (rel_last' α r) (cofix.dest x) (cofix.dest y)) : ∀ x y, r x y → x = y :=
  cofix.bisim _$
    by 
      intros  <;> rw [←liftr_last_rel_iff] <;> apply h <;> assumption

/-- Bisimulation principle the values `⟨a,f⟩` of the polynomial functor representing
`cofix F α` as well as an invariant `Q : β → Prop` and a state `β` generating the
left-hand side and right-hand side of the equality through functions `u v : β → cofix F α` -/
theorem cofix.bisim' {α : Typevec n} {β : Type _} (Q : β → Prop) (u v : β → cofix F α)
  (h :
    ∀ x,
      Q x →
        ∃ a f' f₀ f₁,
          cofix.dest (u x) = abs ⟨a, q.P.append_contents f' f₀⟩ ∧
            cofix.dest (v x) = abs ⟨a, q.P.append_contents f' f₁⟩ ∧ ∀ i, ∃ x', Q x' ∧ f₀ i = u x' ∧ f₁ i = v x') :
  ∀ x, Q x → u x = v x :=
  fun x Qx =>
    let R := fun w z : cofix F α => ∃ x', Q x' ∧ w = u x' ∧ z = v x' 
    cofix.bisim R
      (fun x y ⟨x', Qx', xeq, yeq⟩ =>
        by 
          rcases h x' Qx' with ⟨a, f', f₀, f₁, ux'eq, vx'eq, h'⟩
          rw [liftr_iff]
          refine' ⟨a, q.P.append_contents f' f₀, q.P.append_contents f' f₁, xeq.symm ▸ ux'eq, yeq.symm ▸ vx'eq, _⟩
          intro i 
          cases i
          ·
            apply h'
          ·
            intro j 
            apply Eq.refl)
      _ _ ⟨x, Qx, rfl, rfl⟩

theorem cofix.mk_dest {α : Typevec n} (x : cofix F α) : cofix.mk (cofix.dest x) = x :=
  by 
    apply cofix.bisim_rel (fun x y : cofix F α => x = cofix.mk (cofix.dest y)) _ _ _ rfl 
    dsimp 
    intro x y h 
    rw [h]
    conv  => toLHS congr skip rw [cofix.mk]rw [cofix.dest_corec]
    rw [←comp_map, ←append_fun_comp, id_comp]
    rw [←comp_map, ←append_fun_comp, id_comp, ←cofix.mk]
    congr 2 with u 
    apply Quot.sound 
    rfl

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem cofix.dest_mk {α : typevec n} (x : F «expr $ »(α.append1, cofix F α)) : «expr = »(cofix.dest (cofix.mk x), x) :=
begin
  have [] [":", expr «expr = »(«expr ∘ »(cofix.mk, cofix.dest), @_root_.id (cofix F α))] [":=", expr funext cofix.mk_dest],
  rw ["[", expr cofix.mk, ",", expr cofix.dest_corec, ",", "<-", expr comp_map, ",", "<-", expr cofix.mk, ",", "<-", expr append_fun_comp, ",", expr this, ",", expr id_comp, ",", expr append_fun_id_id, ",", expr mvfunctor.id_map, "]"] []
end

theorem cofix.ext {α : Typevec n} (x y : cofix F α) (h : x.dest = y.dest) : x = y :=
  by 
    rw [←cofix.mk_dest x, h, cofix.mk_dest]

theorem cofix.ext_mk {α : Typevec n} (x y : F (α ::: cofix F α)) (h : cofix.mk x = cofix.mk y) : x = y :=
  by 
    rw [←cofix.dest_mk x, h, cofix.dest_mk]

/-!
`liftr_map`, `liftr_map_last` and `liftr_map_last'` are useful for reasoning about
the induction step in bisimulation proofs.
-/


section LiftrMap

omit q

theorem liftr_map {α β : Typevec n} {F' : Typevec n → Type u} [Mvfunctor F'] [IsLawfulMvfunctor F']
  (R : β ⊗ β ⟹ repeat n Prop) (x : F' α) (f g : α ⟹ β) (h : α ⟹ subtype_ R)
  (hh : subtype_val _ ⊚ h = (f ⊗' g) ⊚ prod.diag) : liftr' R (f <$$> x) (g <$$> x) :=
  by 
    rw [liftr_def]
    exists h <$$> x 
    rw [Mvfunctor.map_map, comp_assoc, hh, ←comp_assoc, fst_prod_mk, comp_assoc, fst_diag]
    rw [Mvfunctor.map_map, comp_assoc, hh, ←comp_assoc, snd_prod_mk, comp_assoc, snd_diag]
    dsimp [liftr']
    split  <;> rfl

open Function

theorem liftr_map_last [IsLawfulMvfunctor F] {α : Typevec n} {ι ι'} (R : ι' → ι' → Prop) (x : F (α ::: ι))
  (f g : ι → ι') (hh : ∀ x : ι, R (f x) (g x)) : liftr' (rel_last' _ R) ((id ::: f) <$$> x) ((id ::: g) <$$> x) :=
  let h : ι → { x : ι' × ι' // uncurry R x } := fun x => ⟨(f x, g x), hh x⟩
  let b : (α ::: ι) ⟹ _ := @diag_sub n α ::: h 
  let c :
    (subtype_ α.repeat_eq ::: { x // uncurry R x }) ⟹
      ((fun i : Fin2 n => { x // of_repeat (α.rel_last' R i.fs x) }) ::: Subtype (uncurry R)) :=
    of_subtype _ ::: id 
  have hh : subtype_val _ ⊚ to_subtype _ ⊚ from_append1_drop_last ⊚ c ⊚ b = ((id ::: f) ⊗' (id ::: g)) ⊚ prod.diag :=
    by 
      dsimp [c, b]
      apply eq_of_drop_last_eq
      ·
        dsimp 
        simp only [prod_map_id, drop_fun_prod, drop_fun_append_fun, drop_fun_diag, id_comp, drop_fun_to_subtype]
        erw [to_subtype_of_subtype_assoc, id_comp]
        clear * - 
        ext i x : 2
        induction i 
        rfl 
        apply i_ih 
      simp only [h, last_fun_from_append1_drop_last, last_fun_to_subtype, last_fun_append_fun, last_fun_subtype_val,
        comp.left_id, last_fun_comp, last_fun_prod]
      dsimp 
      ext1 
      rfl 
  liftr_map _ _ _ _ (to_subtype _ ⊚ from_append1_drop_last ⊚ c ⊚ b) hh

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem liftr_map_last'
[is_lawful_mvfunctor F]
{α : typevec n}
{ι}
(R : ι → ι → exprProp())
(x : F [«expr ::: »/«expr ::: »](α, ι))
(f : ι → ι)
(hh : ∀ x : ι, R (f x) x) : liftr' (rel_last' _ R) «expr <$$> »([«expr ::: »/«expr ::: »](id, f), x) x :=
begin
  have [] [] [":=", expr liftr_map_last R x f id hh],
  rwa ["[", expr append_fun_id_id, ",", expr mvfunctor.id_map, "]"] ["at", ident this]
end

end LiftrMap

theorem cofix.abs_repr {α} (x : cofix F α) : Quot.mk _ (cofix.repr x) = x :=
  by 
    let R := fun x y : cofix F α => cofix.abs (cofix.repr y) = x 
    refine' cofix.bisim₂ R _ _ _ rfl 
    clear x 
    rintro x y h 
    dsimp [R]  at h 
    subst h 
    dsimp [cofix.dest, cofix.abs]
    induction y using Quot.ind 
    simp only [cofix.repr, M.dest_corec, abs_map, abs_repr]
    conv  => congr skip rw [cofix.dest]
    dsimp 
    rw [Mvfunctor.map_map, Mvfunctor.map_map, ←append_fun_comp_id, ←append_fun_comp_id]
    let f : (α ::: (P F).M α) ⟹ subtype_ (α.rel_last' R) :=
      split_fun diag_sub fun x => ⟨(cofix.abs (cofix.abs x).repr, cofix.abs x), _⟩
    refine' liftr_map _ _ _ _ f _
    ·
      simp only [←append_prod_append_fun, prod_map_id]
      apply eq_of_drop_last_eq
      ·
        dsimp 
        simp only [drop_fun_diag]
        erw [subtype_val_diag_sub]
      ext1 
      simp only [cofix.abs, Prod.mk.inj_iffₓ, prod_mapₓ, Function.comp_app, last_fun_append_fun, last_fun_subtype_val,
        last_fun_comp, last_fun_split_fun]
      dsimp [drop_fun_rel_last, last_fun, prod.diag]
      split  <;> rfl 
    dsimp [rel_last', split_fun, Function.uncurry, R]
    rfl

section Tactic

setup_tactic_parser

open Tactic

omit q

/-- tactic for proof by bisimulation -/
unsafe def mv_bisim (e : parse texpr) (ids : parse with_ident_list) : tactic Unit :=
  do 
    let e ← to_expr e 
    let expr.pi n bi d b ←
      retrieve$
          do 
            generalize e 
            target 
    let quote.1 (@Eq (%%ₓt) (%%ₓl) (%%ₓr)) ← pure b 
    let x ← mk_local_def `n d 
    let v₀ ← mk_local_def `a t 
    let v₁ ← mk_local_def `b t 
    let x₀ ← mk_app `` Eq [v₀, l.instantiate_var x]
    let x₁ ← mk_app `` Eq [v₁, r.instantiate_var x]
    let xx ← mk_app `` And [x₀, x₁]
    let ex ← lambdas [x] xx 
    let ex ← mk_app `` Exists [ex] >>= lambdas [v₀, v₁]
    let R ← pose `R none ex 
    refine (pquote.1 (cofix.bisim₂ (%%ₓR) _ _ _ ⟨_, rfl, rfl⟩))
    let f (a b : Name) : Name := if a = `_ then b else a 
    let ids := (ids ++ List.repeat `_ 5).zipWith f [`a, `b, `x, `Ha, `Hb]
    let (ids₀, w :: ids₁) ← pure$ List.splitAt 2 ids 
    intro_lst ids₀ 
    let h ← intro1 
    let [(_, [w, h], _)] ← cases_core h [w]
    cases h ids₁ 
    pure ()

run_cmd 
  add_interactive [`` mv_bisim]

end Tactic

theorem corec_roll {α : Typevec n} {X Y} {x₀ : X} (f : X → Y) (g : Y → F (α ::: X)) :
  cofix.corec (g ∘ f) x₀ = cofix.corec (Mvfunctor.map (id ::: f) ∘ g) (f x₀) :=
  by 
    mvBisim x₀ 
    rw [Ha, Hb, cofix.dest_corec, cofix.dest_corec]
    rw [Mvfunctor.map_map, ←append_fun_comp_id]
    refine' liftr_map_last _ _ _ _ _ 
    intro a 
    refine' ⟨a, rfl, rfl⟩

theorem cofix.dest_corec' {α : Typevec n} {β : Type u} (g : β → F (α.append1 (Sum (cofix F α) β))) (x : β) :
  cofix.dest (cofix.corec' g x) = append_fun id (Sum.elim id (cofix.corec' g)) <$$> g x :=
  by 
    rw [cofix.corec', cofix.dest_corec]
    dsimp 
    congr with (i | i) <;> rw [corec_roll] <;> dsimp [cofix.corec']
    ·
      mvBisim i 
      rw [Ha, Hb, cofix.dest_corec]
      dsimp [· ∘ ·]
      repeat' 
        rw [Mvfunctor.map_map, ←append_fun_comp_id]
      apply liftr_map_last' 
      dsimp [· ∘ ·, R]
      intros 
      exact ⟨_, rfl, rfl⟩
    ·
      congr with y 
      erw [append_fun_id_id]
      simp [Mvfunctor.id_map]

theorem cofix.dest_corec₁ {α : Typevec n} {β : Type u} (g : ∀ {X}, (cofix F α → X) → (β → X) → β → F (α.append1 X))
  (x : β) (h : ∀ X Y f : cofix F α → X f' : β → X k : X → Y, g (k ∘ f) (k ∘ f') x = (id ::: k) <$$> g f f' x) :
  cofix.dest (cofix.corec₁ (@g) x) = g id (cofix.corec₁ @g) x :=
  by 
    rw [cofix.corec₁, cofix.dest_corec', ←h] <;> rfl

instance mvqpf_cofix : Mvqpf (cofix F) :=
  { p := q.P.Mp, abs := fun α => Quot.mk Mcongr, repr := fun α => cofix.repr, abs_repr := fun α => cofix.abs_repr,
    abs_map := fun α β g x => rfl }

end Mvqpf

