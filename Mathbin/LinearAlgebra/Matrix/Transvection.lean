/-
Copyright (c) 2021 SÃ©bastien GouÃ«zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel

! This file was ported from Lean 3 source module linear_algebra.matrix.transvection
! leanprover-community/mathlib commit f2b757fc5c341d88741b9c4630b1e8ba973c5726
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Matrix.Basis
import Mathbin.Data.Matrix.Dmatrix
import Mathbin.LinearAlgebra.Matrix.Determinant
import Mathbin.LinearAlgebra.Matrix.Reindex
import Mathbin.Tactic.FieldSimp

/-!
# Transvections

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Transvections are matrices of the form `1 + std_basis_matrix i j c`, where `std_basis_matrix i j c`
is the basic matrix with a `c` at position `(i, j)`. Multiplying by such a transvection on the left
(resp. on the right) amounts to adding `c` times the `j`-th row to to the `i`-th row
(resp `c` times the `i`-th column to the `j`-th column). Therefore, they are useful to present
algorithms operating on rows and columns.

Transvections are a special case of *elementary matrices* (according to most references, these also
contain the matrices exchanging rows, and the matrices multiplying a row by a constant).

We show that, over a field, any matrix can be written as `L â¬ D â¬ L'`, where `L` and `L'` are
products of transvections and `D` is diagonal. In other words, one can reduce a matrix to diagonal
form by operations on its rows and columns, a variant of Gauss' pivot algorithm.

## Main definitions and results

* `transvection i j c` is the matrix equal to `1 + std_basis_matrix i j c`.
* `transvection_struct n R` is a structure containing the data of `i, j, c` and a proof that
  `i â‰  j`. These are often easier to manipulate than straight matrices, especially in inductive
  arguments.

* `exists_list_transvec_mul_diagonal_mul_list_transvec` states that any matrix `M` over a field can
  be written in the form `t_1 â¬ ... â¬ t_k â¬ D â¬ t'_1 â¬ ... â¬ t'_l`, where `D` is diagonal and
  the `t_i`, `t'_j` are transvections.

* `diagonal_transvection_induction` shows that a property which is true for diagonal matrices and
  transvections, and invariant under product, is true for all matrices.
* `diagonal_transvection_induction_of_det_ne_zero` is the same statement over invertible matrices.

## Implementation details

The proof of the reduction results is done inductively on the size of the matrices, reducing an
`(r + 1) Ã— (r + 1)` matrix to a matrix whose last row and column are zeroes, except possibly for
the last diagonal entry. This step is done as follows.

If all the coefficients on the last row and column are zero, there is nothing to do. Otherwise,
one can put a nonzero coefficient in the last diagonal entry by a row or column operation, and then
subtract this last diagonal entry from the other entries in the last row and column to make them
vanish.

This step is done in the type `fin r âŠ• unit`, where `fin r` is useful to choose arbitrarily some
order in which we cancel the coefficients, and the sum structure is useful to use the formalism of
block matrices.

To proceed with the induction, we reindex our matrices to reduce to the above situation.
-/


universe uâ‚ uâ‚‚

namespace Matrix

open Matrix

variable (n p : Type _) (R : Type uâ‚‚) {ð•œ : Type _} [Field ð•œ]

variable [DecidableEq n] [DecidableEq p]

variable [CommRing R]

section Transvection

variable {R n} (i j : n)

#print Matrix.transvection /-
/-- The transvection matrix `transvection i j c` is equal to the identity plus `c` at position
`(i, j)`. Multiplying by it on the left (as in `transvection i j c â¬ M`) corresponds to adding
`c` times the `j`-th line of `M` to its `i`-th line. Multiplying by it on the right corresponds
to adding `c` times the `i`-th column to the `j`-th column. -/
def transvection (c : R) : Matrix n n R :=
  1 + Matrix.stdBasisMatrix i j c
#align matrix.transvection Matrix.transvection
-/

/- warning: matrix.transvection_zero -> Matrix.transvection_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4)))))) (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_zero Matrix.transvection_zeroâ‚“'. -/
@[simp]
theorem transvection_zero : transvection i j (0 : R) = 1 := by simp [transvection]
#align matrix.transvection_zero Matrix.transvection_zero

section

/- warning: matrix.update_row_eq_transvection -> Matrix.updateRow_eq_transvection is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) [_inst_5 : Finite.{succ u2} n] (c : R), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_2 a b) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4))))))))) i (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u2, u1} n (fun (á¾° : n) => R) (fun (i : n) => Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) i) (SMul.smul.{u1, max u2 u1} R (n -> R) (Function.hasSMul.{u2, u1, u1} n R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))))) c (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) j)))) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c)
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) [_inst_5 : Finite.{succ u1} n] (c : R), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_2 a b) (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))) i (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u1, u2} n (fun (á¾° : n) => R) (fun (i : n) => Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))))) (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) i) (HSMul.hSMul.{u2, max u2 u1, max u2 u1} R (n -> R) (n -> R) (instHSMul.{u2, max u2 u1} R (n -> R) (Pi.instSMul.{u1, u2, u2} n R (fun (a._@.Mathlib.Data.Matrix.Basic._hyg.12 : n) => R) (fun (i : n) => Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_4) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))))) c (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) j)))) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c)
Case conversion may be inaccurate. Consider using '#align matrix.update_row_eq_transvection Matrix.updateRow_eq_transvectionâ‚“'. -/
/-- A transvection matrix is obtained from the identity by adding `c` times the `j`-th row to
the `i`-th row. -/
theorem updateRow_eq_transvection [Finite n] (c : R) :
    updateRow (1 : Matrix n n R) i ((1 : Matrix n n R) i + c â€¢ (1 : Matrix n n R) j) =
      transvection i j c :=
  by
  cases nonempty_fintype n
  ext (a b)
  by_cases ha : i = a; by_cases hb : j = b
  Â·
    simp only [update_row_self, transvection, ha, hb, Pi.add_apply, std_basis_matrix.apply_same,
      one_apply_eq, Pi.smul_apply, mul_one, Algebra.id.smul_eq_mul]
  Â·
    simp only [update_row_self, transvection, ha, hb, std_basis_matrix.apply_of_ne, Pi.add_apply,
      Ne.def, not_false_iff, Pi.smul_apply, and_false_iff, one_apply_ne, Algebra.id.smul_eq_mul,
      MulZeroClass.mul_zero]
  Â·
    simp only [update_row_ne, transvection, ha, Ne.symm ha, std_basis_matrix.apply_of_ne, add_zero,
      Algebra.id.smul_eq_mul, Ne.def, not_false_iff, DMatrix.add_apply, Pi.smul_apply,
      MulZeroClass.mul_zero, false_and_iff]
#align matrix.update_row_eq_transvection Matrix.updateRow_eq_transvection

variable [Fintype n]

/- warning: matrix.transvection_mul_transvection_same -> Matrix.transvection_mul_transvection_same is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) [_inst_5 : Fintype.{u2} n], (Ne.{succ u2} n i j) -> (forall (c : R) (d : R), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j d)) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4)))) c d)))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) [_inst_5 : Fintype.{u1} n], (Ne.{succ u1} n i j) -> (forall (c : R) (d : R), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j d)) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))) c d)))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_mul_transvection_same Matrix.transvection_mul_transvection_sameâ‚“'. -/
theorem transvection_mul_transvection_same (h : i â‰  j) (c d : R) :
    transvection i j c â¬ transvection i j d = transvection i j (c + d) := by
  simp [transvection, Matrix.add_mul, Matrix.mul_add, h, h.symm, add_smul, add_assoc,
    std_basis_matrix_add]
#align matrix.transvection_mul_transvection_same Matrix.transvection_mul_transvection_same

/- warning: matrix.transvection_mul_apply_same -> Matrix.transvection_mul_apply_same is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) [_inst_5 : Fintype.{u2} n] (b : n) (c : R) (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) M i b) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4)))) (M i b) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4)))) c (M j b)))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) [_inst_5 : Fintype.{u1} n] (b : n) (c : R) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) M i b) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))) (M i b) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) c (M j b)))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_mul_apply_same Matrix.transvection_mul_apply_sameâ‚“'. -/
@[simp]
theorem transvection_mul_apply_same (b : n) (c : R) (M : Matrix n n R) :
    (transvection i j c â¬ M) i b = M i b + c * M j b := by simp [transvection, Matrix.add_mul]
#align matrix.transvection_mul_apply_same Matrix.transvection_mul_apply_same

/- warning: matrix.mul_transvection_apply_same -> Matrix.mul_transvection_apply_same is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) [_inst_5 : Fintype.{u2} n] (a : n) (c : R) (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) M (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) a j) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4)))) (M a j) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4)))) c (M a i)))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) [_inst_5 : Fintype.{u1} n] (a : n) (c : R) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) M (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) a j) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))) (M a j) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) c (M a i)))
Case conversion may be inaccurate. Consider using '#align matrix.mul_transvection_apply_same Matrix.mul_transvection_apply_sameâ‚“'. -/
@[simp]
theorem mul_transvection_apply_same (a : n) (c : R) (M : Matrix n n R) :
    (M â¬ transvection i j c) a j = M a j + c * M a i := by
  simp [transvection, Matrix.mul_add, mul_comm]
#align matrix.mul_transvection_apply_same Matrix.mul_transvection_apply_same

/- warning: matrix.transvection_mul_apply_of_ne -> Matrix.transvection_mul_apply_of_ne is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) [_inst_5 : Fintype.{u2} n] (a : n) (b : n), (Ne.{succ u2} n a i) -> (forall (c : R) (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) M a b) (M a b))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) [_inst_5 : Fintype.{u1} n] (a : n) (b : n), (Ne.{succ u1} n a i) -> (forall (c : R) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) M a b) (M a b))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_mul_apply_of_ne Matrix.transvection_mul_apply_of_neâ‚“'. -/
@[simp]
theorem transvection_mul_apply_of_ne (a b : n) (ha : a â‰  i) (c : R) (M : Matrix n n R) :
    (transvection i j c â¬ M) a b = M a b := by simp [transvection, Matrix.add_mul, ha]
#align matrix.transvection_mul_apply_of_ne Matrix.transvection_mul_apply_of_ne

/- warning: matrix.mul_transvection_apply_of_ne -> Matrix.mul_transvection_apply_of_ne is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) [_inst_5 : Fintype.{u2} n] (a : n) (b : n), (Ne.{succ u2} n b j) -> (forall (c : R) (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) M (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) a b) (M a b))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) [_inst_5 : Fintype.{u1} n] (a : n) (b : n), (Ne.{succ u1} n b j) -> (forall (c : R) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) M (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c) a b) (M a b))
Case conversion may be inaccurate. Consider using '#align matrix.mul_transvection_apply_of_ne Matrix.mul_transvection_apply_of_neâ‚“'. -/
@[simp]
theorem mul_transvection_apply_of_ne (a b : n) (hb : b â‰  j) (c : R) (M : Matrix n n R) :
    (M â¬ transvection i j c) a b = M a b := by simp [transvection, Matrix.mul_add, hb]
#align matrix.mul_transvection_apply_of_ne Matrix.mul_transvection_apply_of_ne

/- warning: matrix.det_transvection_of_ne -> Matrix.det_transvection_of_ne is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) [_inst_5 : Fintype.{u2} n], (Ne.{succ u2} n i j) -> (forall (c : R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 R _inst_4 (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) [_inst_5 : Fintype.{u1} n], (Ne.{succ u1} n i j) -> (forall (c : R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 R _inst_4 (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c)) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_transvection_of_ne Matrix.det_transvection_of_neâ‚“'. -/
@[simp]
theorem det_transvection_of_ne (h : i â‰  j) (c : R) : det (transvection i j c) = 1 := by
  rw [â† update_row_eq_transvection i j, det_update_row_add_smul_self _ h, det_one]
#align matrix.det_transvection_of_ne Matrix.det_transvection_of_ne

end

variable (R n)

/- warning: matrix.transvection_struct -> Matrix.TransvectionStruct is a dubious translation:
lean 3 declaration is
  forall (n : Type.{u2}) (R : Type.{u1}) [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R], Sort.{max (succ u2) (succ u1)}
but is expected to have type
  Type.{u2} -> Type.{u1} -> Sort.{max (succ u2) (succ u1)}
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct Matrix.TransvectionStructâ‚“'. -/
/-- A structure containing all the information from which one can build a nontrivial transvection.
This structure is easier to manipulate than transvections as one has a direct access to all the
relevant fields. -/
@[nolint has_nonempty_instance]
structure TransvectionStruct where
  (i j : n)
  hij : i â‰  j
  c : R
#align matrix.transvection_struct Matrix.TransvectionStruct

instance [Nontrivial n] : Nonempty (TransvectionStruct n R) :=
  by
  choose x y hxy using exists_pair_ne n
  exact âŸ¨âŸ¨x, y, hxy, 0âŸ©âŸ©

namespace TransvectionStruct

variable {R n}

#print Matrix.TransvectionStruct.toMatrix /-
/-- Associating to a `transvection_struct` the corresponding transvection matrix. -/
def toMatrix (t : TransvectionStruct n R) : Matrix n n R :=
  transvection t.i t.j t.c
#align matrix.transvection_struct.to_matrix Matrix.TransvectionStruct.toMatrix
-/

/- warning: matrix.transvection_struct.to_matrix_mk -> Matrix.TransvectionStruct.toMatrix_mk is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] (i : n) (j : n) (hij : Ne.{succ u2} n i j) (c : R), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 (Matrix.TransvectionStruct.mk.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j hij c)) (Matrix.transvection.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c)
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] (i : n) (j : n) (hij : Ne.{succ u1} n i j) (c : R), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 (Matrix.TransvectionStruct.mk.{u2, u1} n R i j hij c)) (Matrix.transvection.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 i j c)
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.to_matrix_mk Matrix.TransvectionStruct.toMatrix_mkâ‚“'. -/
@[simp]
theorem toMatrix_mk (i j : n) (hij : i â‰  j) (c : R) :
    TransvectionStruct.toMatrix âŸ¨i, j, hij, câŸ© = transvection i j c :=
  rfl
#align matrix.transvection_struct.to_matrix_mk Matrix.TransvectionStruct.toMatrix_mk

/- warning: matrix.transvection_struct.det -> Matrix.TransvectionStruct.det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] (t : Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 R _inst_4 (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t)) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4))))))))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] [_inst_5 : Fintype.{u1} n] (t : Matrix.TransvectionStruct.{u2, u1} n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 R _inst_4 (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t)) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.det Matrix.TransvectionStruct.detâ‚“'. -/
@[simp]
protected theorem det [Fintype n] (t : TransvectionStruct n R) : det t.toMatrix = 1 :=
  det_transvection_of_ne _ _ t.hij _
#align matrix.transvection_struct.det Matrix.TransvectionStruct.det

/- warning: matrix.transvection_struct.det_to_matrix_prod -> Matrix.TransvectionStruct.det_toMatrix_prod is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {ð•œ : Type.{u2}} [_inst_1 : Field.{u2} ð•œ] [_inst_2 : DecidableEq.{succ u1} n] [_inst_5 : Fintype.{u1} n] (L : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))), Eq.{succ u2} ð•œ (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.hasMul.{u2, u1} n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.hasOne.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u2} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ð•œ (Ring.toAddCommGroupWithOne.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L))) (OfNat.ofNat.{u2} ð•œ 1 (OfNat.mk.{u2} ð•œ 1 (One.one.{u2} ð•œ (AddMonoidWithOne.toOne.{u2} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ð•œ (Ring.toAddCommGroupWithOne.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))))))
but is expected to have type
  forall {n : Type.{u2}} {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] [_inst_2 : DecidableEq.{succ u2} n] [_inst_5 : Fintype.{u2} n] (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)), Eq.{succ u1} ð•œ (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.instMulMatrix.{u1, u2} n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ) (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L))) (OfNat.ofNat.{u1} ð•œ 1 (One.toOfNat1.{u1} ð•œ (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.det_to_matrix_prod Matrix.TransvectionStruct.det_toMatrix_prodâ‚“'. -/
@[simp]
theorem det_toMatrix_prod [Fintype n] (L : List (TransvectionStruct n ð•œ)) :
    det (L.map toMatrix).Prod = 1 := by
  induction' L with t L IH
  Â· simp
  Â· simp [IH]
#align matrix.transvection_struct.det_to_matrix_prod Matrix.TransvectionStruct.det_toMatrix_prod

/- warning: matrix.transvection_struct.inv -> Matrix.TransvectionStruct.inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R], (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) -> (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)
but is expected to have type
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : CommRing.{u1} R], (Matrix.TransvectionStruct.{u1, u2} n R) -> (Matrix.TransvectionStruct.{u1, u2} n R)
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.inv Matrix.TransvectionStruct.invâ‚“'. -/
/-- The inverse of a `transvection_struct`, designed so that `t.inv.to_matrix` is the inverse of
`t.to_matrix`. -/
@[simps]
protected def inv (t : TransvectionStruct n R) : TransvectionStruct n R
    where
  i := t.i
  j := t.j
  hij := t.hij
  c := -t.c
#align matrix.transvection_struct.inv Matrix.TransvectionStruct.inv

section

variable [Fintype n]

/- warning: matrix.transvection_struct.inv_mul -> Matrix.TransvectionStruct.inv_mul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] (t : Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 (Matrix.TransvectionStruct.inv.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t)) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t)) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] [_inst_5 : Fintype.{u1} n] (t : Matrix.TransvectionStruct.{u2, u1} n R), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 (Matrix.TransvectionStruct.inv.{u2, u1} n R _inst_4 t)) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t)) (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.inv_mul Matrix.TransvectionStruct.inv_mulâ‚“'. -/
theorem inv_mul (t : TransvectionStruct n R) : t.inv.toMatrix â¬ t.toMatrix = 1 :=
  by
  rcases t with âŸ¨âŸ©
  simp [to_matrix, transvection_mul_transvection_same, t_hij]
#align matrix.transvection_struct.inv_mul Matrix.TransvectionStruct.inv_mul

/- warning: matrix.transvection_struct.mul_inv -> Matrix.TransvectionStruct.mul_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] (t : Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 (Matrix.TransvectionStruct.inv.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t))) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] [_inst_5 : Fintype.{u1} n] (t : Matrix.TransvectionStruct.{u2, u1} n R), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 (Matrix.TransvectionStruct.inv.{u2, u1} n R _inst_4 t))) (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.mul_inv Matrix.TransvectionStruct.mul_invâ‚“'. -/
theorem mul_inv (t : TransvectionStruct n R) : t.toMatrix â¬ t.inv.toMatrix = 1 :=
  by
  rcases t with âŸ¨âŸ©
  simp [to_matrix, transvection_mul_transvection_same, t_hij]
#align matrix.transvection_struct.mul_inv Matrix.TransvectionStruct.mul_inv

/- warning: matrix.transvection_struct.reverse_inv_prod_mul_prod -> Matrix.TransvectionStruct.reverse_inv_prod_mul_prod is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasMul.{u1, u2} n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Function.comp.{succ (max u2 u1), max (succ u2) (succ u1), succ (max u2 u1)} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.inv.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)) (List.reverse.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L))) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasMul.{u1, u2} n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L))) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] [_inst_5 : Fintype.{u1} n] (L : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n R)), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (List.prod.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.instMulMatrix.{u2, u1} n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.{u1, u1, u2} n n R) (Function.comp.{succ (max u1 u2), max (succ u1) (succ u2), succ (max u1 u2)} (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.{u1, u1, u2} n n R) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.inv.{u2, u1} n R _inst_4)) (List.reverse.{max u2 u1} (Matrix.TransvectionStruct.{u2, u1} n R) L))) (List.prod.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.instMulMatrix.{u2, u1} n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.{u1, u1, u2} n n R) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L))) (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.reverse_inv_prod_mul_prod Matrix.TransvectionStruct.reverse_inv_prod_mul_prodâ‚“'. -/
theorem reverse_inv_prod_mul_prod (L : List (TransvectionStruct n R)) :
    (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).Prod â¬ (L.map toMatrix).Prod = 1 :=
  by
  induction' L with t L IH
  Â· simp
  Â· suffices
      (L.reverse.map (to_matrix âˆ˜ transvection_struct.inv)).Prod â¬ (t.inv.to_matrix â¬ t.to_matrix) â¬
          (L.map to_matrix).Prod =
        1
      by simpa [Matrix.mul_assoc]
    simpa [inv_mul] using IH
#align matrix.transvection_struct.reverse_inv_prod_mul_prod Matrix.TransvectionStruct.reverse_inv_prod_mul_prod

/- warning: matrix.transvection_struct.prod_mul_reverse_inv_prod -> Matrix.TransvectionStruct.prod_mul_reverse_inv_prod is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)), Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasMul.{u1, u2} n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L)) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasMul.{u1, u2} n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Function.comp.{succ (max u2 u1), max (succ u2) (succ u1), succ (max u2 u1)} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.inv.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)) (List.reverse.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L)))) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))
but is expected to have type
  forall {n : Type.{u1}} {R : Type.{u2}} [_inst_2 : DecidableEq.{succ u1} n] [_inst_4 : CommRing.{u2} R] [_inst_5 : Fintype.{u1} n] (L : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n R)), Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (List.prod.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.instMulMatrix.{u2, u1} n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.{u1, u1, u2} n n R) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L)) (List.prod.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.instMulMatrix.{u2, u1} n R _inst_5 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))))) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.{u1, u1, u2} n n R) (Function.comp.{succ (max u1 u2), max (succ u1) (succ u2), succ (max u1 u2)} (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.TransvectionStruct.{u2, u1} n R) (Matrix.{u1, u1, u2} n n R) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.inv.{u2, u1} n R _inst_4)) (List.reverse.{max u2 u1} (Matrix.TransvectionStruct.{u2, u1} n R) L)))) (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.prod_mul_reverse_inv_prod Matrix.TransvectionStruct.prod_mul_reverse_inv_prodâ‚“'. -/
theorem prod_mul_reverse_inv_prod (L : List (TransvectionStruct n R)) :
    (L.map toMatrix).Prod â¬ (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).Prod = 1 :=
  by
  induction' L with t L IH
  Â· simp
  Â· suffices
      t.to_matrix â¬
            ((L.map to_matrix).Prod â¬ (L.reverse.map (to_matrix âˆ˜ transvection_struct.inv)).Prod) â¬
          t.inv.to_matrix =
        1
      by simpa [Matrix.mul_assoc]
    simp_rw [IH, Matrix.mul_one, t.mul_inv]
#align matrix.transvection_struct.prod_mul_reverse_inv_prod Matrix.TransvectionStruct.prod_mul_reverse_inv_prod

end

variable (p)

open Sum

/- warning: matrix.transvection_struct.sum_inl -> Matrix.TransvectionStruct.sumInl is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} (p : Type.{u3}) {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_4 : CommRing.{u1} R], (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) -> (Matrix.TransvectionStruct.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4)
but is expected to have type
  forall {n : Type.{u2}} (p : Type.{u3}) {R : Type.{u1}}, (Matrix.TransvectionStruct.{u1, u2} n R) -> (Matrix.TransvectionStruct.{u1, max u3 u2} (Sum.{u2, u3} n p) R)
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.sum_inl Matrix.TransvectionStruct.sumInlâ‚“'. -/
/-- Given a `transvection_struct` on `n`, define the corresponding `transvection_struct` on `n âŠ• p`
using the identity on `p`. -/
def sumInl (t : TransvectionStruct n R) : TransvectionStruct (Sum n p) R
    where
  i := inl t.i
  j := inl t.j
  hij := by simp [t.hij]
  c := t.c
#align matrix.transvection_struct.sum_inl Matrix.TransvectionStruct.sumInl

/- warning: matrix.transvection_struct.to_matrix_sum_inl -> Matrix.TransvectionStruct.toMatrix_sumInl is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} (p : Type.{u3}) {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_4 : CommRing.{u1} R] (t : Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4), Eq.{succ (max (max u2 u3) u1)} (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Matrix.TransvectionStruct.toMatrix.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => (fun (a : p) (b : p) => _inst_3 a b) a b) a b) _inst_4 (Matrix.TransvectionStruct.sumInl.{u1, u2, u3} n p R (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) _inst_4 t)) (Matrix.fromBlocks.{u2, u3, u2, u3, u1} n p n p R (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t) (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) (Matrix.hasZero.{u1, u2, u3} n p R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) (Matrix.hasZero.{u1, u3, u2} p n R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) (OfNat.ofNat.{max u3 u1} (Matrix.{u3, u3, u1} p p R) 1 (OfNat.mk.{max u3 u1} (Matrix.{u3, u3, u1} p p R) 1 (One.one.{max u3 u1} (Matrix.{u3, u3, u1} p p R) (Matrix.hasOne.{u1, u3} p R (fun (a : p) (b : p) => _inst_3 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4))))))))))
but is expected to have type
  forall {n : Type.{u2}} (p : Type.{u1}) {R : Type.{u3}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u1} p] [_inst_4 : CommRing.{u3} R] (t : Matrix.TransvectionStruct.{u3, u2} n R), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (Matrix.{max u2 u1, max u2 u1, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Matrix.TransvectionStruct.toMatrix.{u3, max u2 u1} (Sum.{u2, u1} n p) R (fun (a : Sum.{u2, u1} n p) (b : Sum.{u2, u1} n p) => Sum.instDecidableEqSum.{u2, u1} n p (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4 (Matrix.TransvectionStruct.sumInl.{u3, u2, u1} n p R t)) (Matrix.fromBlocks.{u2, u1, u2, u1, u3} n p n p R (Matrix.TransvectionStruct.toMatrix.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) (Matrix.zero.{u3, u2, u1} n p R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) (Matrix.zero.{u3, u1, u2} p n R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) (OfNat.ofNat.{max u3 u1} (Matrix.{u1, u1, u3} p p R) 1 (One.toOfNat1.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.one.{u3, u1} p R (fun (a : p) (b : p) => _inst_3 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (NonAssocRing.toOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))))))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.to_matrix_sum_inl Matrix.TransvectionStruct.toMatrix_sumInlâ‚“'. -/
theorem toMatrix_sumInl (t : TransvectionStruct n R) :
    (t.sumInl p).toMatrix = fromBlocks t.toMatrix 0 0 1 :=
  by
  cases t
  ext (a b)
  cases a <;> cases b
  Â· by_cases h : a = b <;> simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]
  Â· simp [transvection_struct.sum_inl, transvection]
  Â· simp [transvection_struct.sum_inl, transvection]
  Â· by_cases h : a = b <;> simp [transvection_struct.sum_inl, transvection, h]
#align matrix.transvection_struct.to_matrix_sum_inl Matrix.TransvectionStruct.toMatrix_sumInl

/- warning: matrix.transvection_struct.sum_inl_to_matrix_prod_mul -> Matrix.TransvectionStruct.sumInl_toMatrix_prod_mul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} (p : Type.{u3}) {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u3} p] (M : Matrix.{u2, u2, u1} n n R) (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)) (N : Matrix.{u3, u3, u1} p p R), Eq.{succ (max (max u2 u3) u1)} (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Matrix.mul.{u1, max u2 u3, max u2 u3, max u2 u3} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R (Sum.fintype.{u2, u3} n p _inst_5 _inst_6) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (List.prod.{max (max u2 u3) u1} (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Matrix.hasMul.{u1, max u2 u3} (Sum.{u2, u3} n p) R (Sum.fintype.{u2, u3} n p _inst_5 _inst_6) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => _inst_3 a b) a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max (max u2 u3) u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Function.comp.{succ (max u2 u1), max (succ (max u2 u3)) (succ u1), succ (max (max u2 u3) u1)} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4) (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Matrix.TransvectionStruct.toMatrix.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4) (Matrix.TransvectionStruct.sumInl.{u1, u2, u3} n p R (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) _inst_4)) L)) (Matrix.fromBlocks.{u2, u3, u2, u3, u1} n p n p R M (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) (Matrix.hasZero.{u1, u2, u3} n p R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) (Matrix.hasZero.{u1, u3, u2} p n R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) N)) (Matrix.fromBlocks.{u2, u3, u2, u3, u1} n p n p R (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasMul.{u1, u2} n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L)) M) (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) (Matrix.hasZero.{u1, u2, u3} n p R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) (Matrix.hasZero.{u1, u3, u2} p n R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) N)
but is expected to have type
  forall {n : Type.{u2}} (p : Type.{u1}) {R : Type.{u3}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u1} p] [_inst_4 : CommRing.{u3} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u1} p] (M : Matrix.{u2, u2, u3} n n R) (L : List.{max u2 u3} (Matrix.TransvectionStruct.{u3, u2} n R)) (N : Matrix.{u1, u1, u3} p p R), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (Matrix.{max u2 u1, max u1 u2, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Matrix.mul.{u3, max u2 u1, max u2 u1, max u1 u2} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R (instFintypeSum.{u2, u1} n p _inst_5 _inst_6) (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4))))) (List.prod.{max (max u3 u2) u1} (Matrix.{max u1 u2, max u1 u2, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Matrix.instMulMatrix.{u3, max u2 u1} (Sum.{u2, u1} n p) R (instFintypeSum.{u2, u1} n p _inst_5 _inst_6) (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))))) (Matrix.one.{u3, max u2 u1} (Sum.{u2, u1} n p) R (fun (a : Sum.{u2, u1} n p) (b : Sum.{u2, u1} n p) => Sum.instDecidableEqSum.{u2, u1} n p (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (NonAssocRing.toOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (List.map.{max u2 u3, max (max u1 u2) u3} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.{max u1 u2, max u1 u2, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Function.comp.{succ (max u2 u3), max (succ (max u1 u2)) (succ u3), succ (max (max u1 u2) u3)} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.TransvectionStruct.{u3, max u1 u2} (Sum.{u2, u1} n p) R) (Matrix.{max u1 u2, max u1 u2, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Matrix.TransvectionStruct.toMatrix.{u3, max u1 u2} (Sum.{u2, u1} n p) R (fun (a : Sum.{u2, u1} n p) (b : Sum.{u2, u1} n p) => Sum.instDecidableEqSum.{u2, u1} n p (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4) (Matrix.TransvectionStruct.sumInl.{u3, u2, u1} n p R)) L)) (Matrix.fromBlocks.{u2, u1, u2, u1, u3} n p n p R M (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) (Matrix.zero.{u3, u2, u1} n p R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) (Matrix.zero.{u3, u1, u2} p n R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) N)) (Matrix.fromBlocks.{u2, u1, u2, u1, u3} n p n p R (Matrix.mul.{u3, u2, u2, u2} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4))))) (List.prod.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.instMulMatrix.{u3, u2} n R _inst_5 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))))) (Matrix.one.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (NonAssocRing.toOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (List.map.{max u2 u3, max u2 u3} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.{u2, u2, u3} n n R) (Matrix.TransvectionStruct.toMatrix.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L)) M) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) (Matrix.zero.{u3, u2, u1} n p R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) (Matrix.zero.{u3, u1, u2} p n R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) N)
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.sum_inl_to_matrix_prod_mul Matrix.TransvectionStruct.sumInl_toMatrix_prod_mulâ‚“'. -/
@[simp]
theorem sumInl_toMatrix_prod_mul [Fintype n] [Fintype p] (M : Matrix n n R)
    (L : List (TransvectionStruct n R)) (N : Matrix p p R) :
    (L.map (toMatrix âˆ˜ sumInl p)).Prod â¬ fromBlocks M 0 0 N =
      fromBlocks ((L.map toMatrix).Prod â¬ M) 0 0 N :=
  by
  induction' L with t L IH
  Â· simp
  Â· simp [Matrix.mul_assoc, IH, to_matrix_sum_inl, from_blocks_multiply]
#align matrix.transvection_struct.sum_inl_to_matrix_prod_mul Matrix.TransvectionStruct.sumInl_toMatrix_prod_mul

/- warning: matrix.transvection_struct.mul_sum_inl_to_matrix_prod -> Matrix.TransvectionStruct.mul_sumInl_toMatrix_prod is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} (p : Type.{u3}) {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u3} p] (M : Matrix.{u2, u2, u1} n n R) (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)) (N : Matrix.{u3, u3, u1} p p R), Eq.{succ (max (max u2 u3) u1)} (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Matrix.mul.{u1, max u2 u3, max u2 u3, max u2 u3} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R (Sum.fintype.{u2, u3} n p _inst_5 _inst_6) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Matrix.fromBlocks.{u2, u3, u2, u3, u1} n p n p R M (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) (Matrix.hasZero.{u1, u2, u3} n p R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) (Matrix.hasZero.{u1, u3, u2} p n R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) N) (List.prod.{max (max u2 u3) u1} (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Matrix.hasMul.{u1, max u2 u3} (Sum.{u2, u3} n p) R (Sum.fintype.{u2, u3} n p _inst_5 _inst_6) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => _inst_3 a b) a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max (max u2 u3) u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Function.comp.{succ (max u2 u1), max (succ (max u2 u3)) (succ u1), succ (max (max u2 u3) u1)} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4) (Matrix.{max u2 u3, max u2 u3, u1} (Sum.{u2, u3} n p) (Sum.{u2, u3} n p) R) (Matrix.TransvectionStruct.toMatrix.{u1, max u2 u3} (Sum.{u2, u3} n p) R (fun (a : Sum.{u2, u3} n p) (b : Sum.{u2, u3} n p) => Sum.decidableEq.{u2, u3} n (fun (a : n) (b : n) => _inst_2 a b) p (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4) (Matrix.TransvectionStruct.sumInl.{u1, u2, u3} n p R (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) _inst_4)) L))) (Matrix.fromBlocks.{u2, u3, u2, u3, u1} n p n p R (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4))))) M (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasMul.{u1, u2} n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L))) (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} n p R) (Matrix.hasZero.{u1, u2, u3} n p R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} p n R) (Matrix.hasZero.{u1, u3, u2} p n R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))))))) N)
but is expected to have type
  forall {n : Type.{u2}} (p : Type.{u1}) {R : Type.{u3}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u1} p] [_inst_4 : CommRing.{u3} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u1} p] (M : Matrix.{u2, u2, u3} n n R) (L : List.{max u2 u3} (Matrix.TransvectionStruct.{u3, u2} n R)) (N : Matrix.{u1, u1, u3} p p R), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (Matrix.{max u1 u2, max u2 u1, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Matrix.mul.{u3, max u1 u2, max u1 u2, max u2 u1} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R (instFintypeSum.{u2, u1} n p _inst_5 _inst_6) (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4))))) (Matrix.fromBlocks.{u2, u1, u2, u1, u3} n p n p R M (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) (Matrix.zero.{u3, u2, u1} n p R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) (Matrix.zero.{u3, u1, u2} p n R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) N) (List.prod.{max (max u3 u2) u1} (Matrix.{max u1 u2, max u1 u2, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Matrix.instMulMatrix.{u3, max u2 u1} (Sum.{u2, u1} n p) R (instFintypeSum.{u2, u1} n p _inst_5 _inst_6) (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))))) (Matrix.one.{u3, max u2 u1} (Sum.{u2, u1} n p) R (fun (a : Sum.{u2, u1} n p) (b : Sum.{u2, u1} n p) => Sum.instDecidableEqSum.{u2, u1} n p (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (NonAssocRing.toOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (List.map.{max u2 u3, max (max u1 u2) u3} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.{max u1 u2, max u1 u2, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Function.comp.{succ (max u2 u3), max (succ (max u1 u2)) (succ u3), succ (max (max u1 u2) u3)} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.TransvectionStruct.{u3, max u1 u2} (Sum.{u2, u1} n p) R) (Matrix.{max u1 u2, max u1 u2, u3} (Sum.{u2, u1} n p) (Sum.{u2, u1} n p) R) (Matrix.TransvectionStruct.toMatrix.{u3, max u1 u2} (Sum.{u2, u1} n p) R (fun (a : Sum.{u2, u1} n p) (b : Sum.{u2, u1} n p) => Sum.instDecidableEqSum.{u2, u1} n p (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) a b) _inst_4) (Matrix.TransvectionStruct.sumInl.{u3, u2, u1} n p R)) L))) (Matrix.fromBlocks.{u2, u1, u2, u1, u3} n p n p R (Matrix.mul.{u3, u2, u2, u2} n n n R _inst_5 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4))))) M (List.prod.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.instMulMatrix.{u3, u2} n R _inst_5 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))))) (Matrix.one.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (NonAssocRing.toOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (List.map.{max u2 u3, max u2 u3} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.{u2, u2, u3} n n R) (Matrix.TransvectionStruct.toMatrix.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L))) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} n p R) (Matrix.zero.{u3, u2, u1} n p R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} p n R) (Matrix.zero.{u3, u1, u2} p n R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))) N)
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.mul_sum_inl_to_matrix_prod Matrix.TransvectionStruct.mul_sumInl_toMatrix_prodâ‚“'. -/
@[simp]
theorem mul_sumInl_toMatrix_prod [Fintype n] [Fintype p] (M : Matrix n n R)
    (L : List (TransvectionStruct n R)) (N : Matrix p p R) :
    fromBlocks M 0 0 N â¬ (L.map (toMatrix âˆ˜ sumInl p)).Prod =
      fromBlocks (M â¬ (L.map toMatrix).Prod) 0 0 N :=
  by
  induction' L with t L IH generalizing M N
  Â· simp
  Â· simp [IH, to_matrix_sum_inl, from_blocks_multiply]
#align matrix.transvection_struct.mul_sum_inl_to_matrix_prod Matrix.TransvectionStruct.mul_sumInl_toMatrix_prod

variable {p}

/- warning: matrix.transvection_struct.reindex_equiv -> Matrix.TransvectionStruct.reindexEquiv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {p : Type.{u3}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_4 : CommRing.{u1} R], (Equiv.{succ u2, succ u3} n p) -> (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) -> (Matrix.TransvectionStruct.{u1, u3} p R (fun (a : p) (b : p) => _inst_3 a b) _inst_4)
but is expected to have type
  forall {n : Type.{u2}} {p : Type.{u3}} {R : Type.{u1}}, (Equiv.{succ u2, succ u3} n p) -> (Matrix.TransvectionStruct.{u1, u2} n R) -> (Matrix.TransvectionStruct.{u1, u3} p R)
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.reindex_equiv Matrix.TransvectionStruct.reindexEquivâ‚“'. -/
/-- Given a `transvection_struct` on `n` and an equivalence between `n` and `p`, define the
corresponding `transvection_struct` on `p`. -/
def reindexEquiv (e : n â‰ƒ p) (t : TransvectionStruct n R) : TransvectionStruct p R
    where
  i := e t.i
  j := e t.j
  hij := by simp [t.hij]
  c := t.c
#align matrix.transvection_struct.reindex_equiv Matrix.TransvectionStruct.reindexEquiv

variable [Fintype n] [Fintype p]

/- warning: matrix.transvection_struct.to_matrix_reindex_equiv -> Matrix.TransvectionStruct.toMatrix_reindexEquiv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {p : Type.{u3}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u3} p] (e : Equiv.{succ u2, succ u3} n p) (t : Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4), Eq.{succ (max u3 u1)} (Matrix.{u3, u3, u1} p p R) (Matrix.TransvectionStruct.toMatrix.{u1, u3} p R (fun (a : p) (b : p) => _inst_3 a b) _inst_4 (Matrix.TransvectionStruct.reindexEquiv.{u1, u2, u3} n p R (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) _inst_4 e t)) (coeFn.{max (succ (max u2 u1)) (succ (max u3 u1)), max (succ (max u2 u1)) (succ (max u3 u1))} (AlgEquiv.{u1, max u2 u1, max u3 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.{u3, u3, u1} p p R) (CommRing.toCommSemiring.{u1} R _inst_4) (Matrix.semiring.{u1, u2} n R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u1, u3} p R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.algebra.{u1, u2, u1} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4))) (Matrix.algebra.{u1, u3, u1} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)))) (fun (_x : AlgEquiv.{u1, max u2 u1, max u3 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.{u3, u3, u1} p p R) (CommRing.toCommSemiring.{u1} R _inst_4) (Matrix.semiring.{u1, u2} n R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u1, u3} p R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.algebra.{u1, u2, u1} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4))) (Matrix.algebra.{u1, u3, u1} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)))) => (Matrix.{u2, u2, u1} n n R) -> (Matrix.{u3, u3, u1} p p R)) (AlgEquiv.hasCoeToFun.{u1, max u2 u1, max u3 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.{u3, u3, u1} p p R) (CommRing.toCommSemiring.{u1} R _inst_4) (Matrix.semiring.{u1, u2} n R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u1, u3} p R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.algebra.{u1, u2, u1} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4))) (Matrix.algebra.{u1, u3, u1} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)))) (Matrix.reindexAlgEquiv.{u2, u3, u1} n p R (CommRing.toCommSemiring.{u1} R _inst_4) _inst_6 _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) e) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t))
but is expected to have type
  forall {n : Type.{u2}} {p : Type.{u1}} {R : Type.{u3}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u1} p] [_inst_4 : CommRing.{u3} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u1} p] (e : Equiv.{succ u2, succ u1} n p) (t : Matrix.TransvectionStruct.{u3, u2} n R), Eq.{max (succ u3) (succ u1)} (Matrix.{u1, u1, u3} p p R) (Matrix.TransvectionStruct.toMatrix.{u3, u1} p R (fun (a : p) (b : p) => _inst_3 a b) _inst_4 (Matrix.TransvectionStruct.reindexEquiv.{u3, u2, u1} n p R e t)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), max (succ u3) (succ u1)} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (Matrix.{u2, u2, u3} n n R) (fun (_x : Matrix.{u2, u2, u3} n n R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u2, u2, u3} n n R) => Matrix.{u1, u1, u3} p p R) _x) (SMulHomClass.toFunLike.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (SMulZeroClass.toSMul.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (AddMonoid.toZero.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (AddMonoid.toAddZeroClass.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))))) (Module.toDistribMulAction.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))))) (SMulZeroClass.toSMul.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (AddMonoid.toZero.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (AddMonoid.toAddZeroClass.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))))) (Module.toDistribMulAction.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))))) (Module.toDistribMulAction.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (Module.toDistribMulAction.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))) (Module.toDistribMulAction.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (Module.toDistribMulAction.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u3, max u3 u2, max u3 u1, max (max u3 u2) u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AlgEquivClass.toAlgHomClass.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (AlgEquiv.instAlgEquivClassAlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))))))) (Matrix.reindexAlgEquiv.{u2, u1, u3} n p R (CommRing.toCommSemiring.{u3} R _inst_4) _inst_6 _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) e) (Matrix.TransvectionStruct.toMatrix.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4 t))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.to_matrix_reindex_equiv Matrix.TransvectionStruct.toMatrix_reindexEquivâ‚“'. -/
theorem toMatrix_reindexEquiv (e : n â‰ƒ p) (t : TransvectionStruct n R) :
    (t.reindexEquiv e).toMatrix = reindexAlgEquiv R e t.toMatrix :=
  by
  cases t
  ext (a b)
  simp only [reindex_equiv, transvection, mul_boole, Algebra.id.smul_eq_mul, to_matrix_mk,
    submatrix_apply, reindex_apply, DMatrix.add_apply, Pi.smul_apply, reindex_alg_equiv_apply]
  by_cases ha : e t_i = a <;> by_cases hb : e t_j = b <;> by_cases hab : a = b <;>
    simp [ha, hb, hab, â† e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
#align matrix.transvection_struct.to_matrix_reindex_equiv Matrix.TransvectionStruct.toMatrix_reindexEquiv

/- warning: matrix.transvection_struct.to_matrix_reindex_equiv_prod -> Matrix.TransvectionStruct.toMatrix_reindexEquiv_prod is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} {p : Type.{u3}} {R : Type.{u1}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_4 : CommRing.{u1} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u3} p] (e : Equiv.{succ u2, succ u3} n p) (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4)), Eq.{succ (max u3 u1)} (Matrix.{u3, u3, u1} p p R) (List.prod.{max u3 u1} (Matrix.{u3, u3, u1} p p R) (Matrix.hasMul.{u1, u3} p R _inst_6 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u3} p R (fun (a : p) (b : p) => _inst_3 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u3 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u3, u3, u1} p p R) (Function.comp.{succ (max u2 u1), max (succ u3) (succ u1), succ (max u3 u1)} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.TransvectionStruct.{u1, u3} p R (fun (a : p) (b : p) => _inst_3 a b) _inst_4) (Matrix.{u3, u3, u1} p p R) (Matrix.TransvectionStruct.toMatrix.{u1, u3} p R (fun (a : p) (b : p) => _inst_3 a b) _inst_4) (Matrix.TransvectionStruct.reindexEquiv.{u1, u2, u3} n p R (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) _inst_4 e)) L)) (coeFn.{max (succ (max u2 u1)) (succ (max u3 u1)), max (succ (max u2 u1)) (succ (max u3 u1))} (AlgEquiv.{u1, max u2 u1, max u3 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.{u3, u3, u1} p p R) (CommRing.toCommSemiring.{u1} R _inst_4) (Matrix.semiring.{u1, u2} n R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u1, u3} p R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.algebra.{u1, u2, u1} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4))) (Matrix.algebra.{u1, u3, u1} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)))) (fun (_x : AlgEquiv.{u1, max u2 u1, max u3 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.{u3, u3, u1} p p R) (CommRing.toCommSemiring.{u1} R _inst_4) (Matrix.semiring.{u1, u2} n R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u1, u3} p R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.algebra.{u1, u2, u1} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4))) (Matrix.algebra.{u1, u3, u1} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)))) => (Matrix.{u2, u2, u1} n n R) -> (Matrix.{u3, u3, u1} p p R)) (AlgEquiv.hasCoeToFun.{u1, max u2 u1, max u3 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.{u3, u3, u1} p p R) (CommRing.toCommSemiring.{u1} R _inst_4) (Matrix.semiring.{u1, u2} n R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u1, u3} p R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.algebra.{u1, u2, u1} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4))) (Matrix.algebra.{u1, u3, u1} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u1} R _inst_4) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)))) (Matrix.reindexAlgEquiv.{u2, u3, u1} n p R (CommRing.toCommSemiring.{u1} R _inst_4) _inst_6 _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) e) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasMul.{u1, u2} n R _inst_5 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_4)))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) (Matrix.{u2, u2, u1} n n R) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L)))
but is expected to have type
  forall {n : Type.{u2}} {p : Type.{u1}} {R : Type.{u3}} [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : DecidableEq.{succ u1} p] [_inst_4 : CommRing.{u3} R] [_inst_5 : Fintype.{u2} n] [_inst_6 : Fintype.{u1} p] (e : Equiv.{succ u2, succ u1} n p) (L : List.{max u2 u3} (Matrix.TransvectionStruct.{u3, u2} n R)), Eq.{max (succ u3) (succ u1)} (Matrix.{u1, u1, u3} p p R) (List.prod.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.instMulMatrix.{u3, u1} p R _inst_6 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))))) (Matrix.one.{u3, u1} p R (fun (a : p) (b : p) => _inst_3 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (NonAssocRing.toOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (List.map.{max u2 u3, max u1 u3} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.{u1, u1, u3} p p R) (Function.comp.{succ (max u2 u3), max (succ u1) (succ u3), succ (max u1 u3)} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.TransvectionStruct.{u3, u1} p R) (Matrix.{u1, u1, u3} p p R) (Matrix.TransvectionStruct.toMatrix.{u3, u1} p R (fun (a : p) (b : p) => _inst_3 a b) _inst_4) (Matrix.TransvectionStruct.reindexEquiv.{u3, u2, u1} n p R e)) L)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), max (succ u3) (succ u1)} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (Matrix.{u2, u2, u3} n n R) (fun (_x : Matrix.{u2, u2, u3} n n R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u2, u2, u3} n n R) => Matrix.{u1, u1, u3} p p R) _x) (SMulHomClass.toFunLike.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (SMulZeroClass.toSMul.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (AddMonoid.toZero.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (AddMonoid.toAddZeroClass.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))))) (Module.toDistribMulAction.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))))) (SMulZeroClass.toSMul.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (AddMonoid.toZero.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (AddMonoid.toAddZeroClass.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))))) (Module.toDistribMulAction.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))))) (Module.toDistribMulAction.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (Module.toDistribMulAction.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))) (Module.toDistribMulAction.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u3, max u3 u2} R (Matrix.{u2, u2, u3} n n R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (Module.toDistribMulAction.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} p p R) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u3, max u3 u1} R (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u3, max u3 u2, max u3 u1, max (max u3 u2) u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) (AlgEquivClass.toAlgHomClass.{max (max u3 u2) u1, u3, max u3 u2, max u3 u1} (AlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)))) R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (AlgEquiv.instAlgEquivClassAlgEquiv.{u3, max u3 u2, max u3 u1} R (Matrix.{u2, u2, u3} n n R) (Matrix.{u1, u1, u3} p p R) (CommRing.toCommSemiring.{u3} R _inst_4) (Matrix.semiring.{u3, u2} n R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.semiring.{u3, u1} p R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u2, u3} n R R _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u3} p R R _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (CommRing.toCommSemiring.{u3} R _inst_4) (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))))))))) (Matrix.reindexAlgEquiv.{u2, u1, u3} n p R (CommRing.toCommSemiring.{u3} R _inst_4) _inst_6 _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (fun (a : p) (b : p) => _inst_3 a b) e) (List.prod.{max u3 u2} (Matrix.{u2, u2, u3} n n R) (Matrix.instMulMatrix.{u3, u2} n R _inst_5 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))))) (Matrix.one.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_4))) (NonAssocRing.toOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_4)))) (List.map.{max u2 u3, max u2 u3} (Matrix.TransvectionStruct.{u3, u2} n R) (Matrix.{u2, u2, u3} n n R) (Matrix.TransvectionStruct.toMatrix.{u3, u2} n R (fun (a : n) (b : n) => _inst_2 a b) _inst_4) L)))
Case conversion may be inaccurate. Consider using '#align matrix.transvection_struct.to_matrix_reindex_equiv_prod Matrix.TransvectionStruct.toMatrix_reindexEquiv_prodâ‚“'. -/
theorem toMatrix_reindexEquiv_prod (e : n â‰ƒ p) (L : List (TransvectionStruct n R)) :
    (L.map (toMatrix âˆ˜ reindexEquiv e)).Prod = reindexAlgEquiv R e (L.map toMatrix).Prod :=
  by
  induction' L with t L IH
  Â· simp
  Â· simp only [to_matrix_reindex_equiv, IH, Function.comp_apply, List.prod_cons, mul_eq_mul,
      reindex_alg_equiv_apply, List.map]
    exact (reindex_alg_equiv_mul _ _ _ _).symm
#align matrix.transvection_struct.to_matrix_reindex_equiv_prod Matrix.TransvectionStruct.toMatrix_reindexEquiv_prod

end TransvectionStruct

end Transvection

/-!
# Reducing matrices by left and right multiplication by transvections

In this section, we show that any matrix can be reduced to diagonal form by left and right
multiplication by transvections (or, equivalently, by elementary operations on lines and columns).
The main step is to kill the last row and column of a matrix in `fin r âŠ• unit` with nonzero last
coefficient, by subtracting this coefficient from the other ones. The list of these operations is
recorded in `list_transvec_col M` and `list_transvec_row M`. We have to analyze inductively how
these operations affect the coefficients in the last row and the last column to conclude that they
have the desired effect.

Once this is done, one concludes the reduction by induction on the size
of the matrices, through a suitable reindexing to identify any fintype with `fin r âŠ• unit`.
-/


namespace Pivot

variable {R} {r : â„•} (M : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ð•œ)

open Sum Unit Fin TransvectionStruct

#print Matrix.Pivot.listTransvecCol /-
/-- A list of transvections such that multiplying on the left with these transvections will replace
the last column with zeroes. -/
def listTransvecCol : List (Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ð•œ) :=
  List.ofFn fun i : Fin r =>
    transvection (inl i) (inr unit) <| -M (inl i) (inr unit) / M (inr unit) (inr unit)
#align matrix.pivot.list_transvec_col Matrix.Pivot.listTransvecCol
-/

#print Matrix.Pivot.listTransvecRow /-
/-- A list of transvections such that multiplying on the right with these transvections will replace
the last row with zeroes. -/
def listTransvecRow : List (Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ð•œ) :=
  List.ofFn fun i : Fin r =>
    transvection (inr unit) (inl i) <| -M (inr unit) (inl i) / M (inr unit) (inr unit)
#align matrix.pivot.list_transvec_row Matrix.Pivot.listTransvecRow
-/

/- warning: matrix.pivot.list_transvec_col_mul_last_row_drop -> Matrix.Pivot.listTransvecCol_mul_last_row_drop is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit) {k : Nat}, (LE.le.{0} Nat Nat.hasLe k r) -> (Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (List.drop.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) k (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M))) M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i) (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit) {k : Nat}, (LE.le.{0} Nat instLENat k r) -> (Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.drop.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) k (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M))) M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i) (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.list_transvec_col_mul_last_row_drop Matrix.Pivot.listTransvecCol_mul_last_row_dropâ‚“'. -/
/-- Multiplying by some of the matrices in `list_transvec_col M` does not change the last row. -/
theorem listTransvecCol_mul_last_row_drop (i : Sum (Fin r) Unit) {k : â„•} (hk : k â‰¤ r) :
    (((listTransvecCol M).drop k).Prod â¬ M) (inr unit) i = M (inr unit) i :=
  by
  apply Nat.decreasingInduction' _ hk
  Â·
    simp only [list_transvec_col, List.length_ofFn, Matrix.one_mul, List.drop_eq_nil_of_le,
      List.prod_nil]
  Â· intro n hn hk IH
    have hn' : n < (list_transvec_col M).length := by simpa [list_transvec_col] using hn
    rw [â† List.cons_nthLe_drop_succ hn']
    simpa [list_transvec_col, Matrix.mul_assoc]
#align matrix.pivot.list_transvec_col_mul_last_row_drop Matrix.Pivot.listTransvecCol_mul_last_row_drop

/- warning: matrix.pivot.list_transvec_col_mul_last_row -> Matrix.Pivot.listTransvecCol_mul_last_row is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i) (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i)
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i) (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) i)
Case conversion may be inaccurate. Consider using '#align matrix.pivot.list_transvec_col_mul_last_row Matrix.Pivot.listTransvecCol_mul_last_rowâ‚“'. -/
/-- Multiplying by all the matrices in `list_transvec_col M` does not change the last row. -/
theorem listTransvecCol_mul_last_row (i : Sum (Fin r) Unit) :
    ((listTransvecCol M).Prod â¬ M) (inr unit) i = M (inr unit) i := by
  simpa using list_transvec_col_mul_last_row_drop M i (zero_le _)
#align matrix.pivot.list_transvec_col_mul_last_row Matrix.Pivot.listTransvecCol_mul_last_row

/- warning: matrix.pivot.list_transvec_col_mul_last_col -> Matrix.Pivot.listTransvecCol_mul_last_col is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M (Sum.inl.{0, 0} (Fin r) Unit i) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))))))))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M (Sum.inl.{0, 0} (Fin r) Unit i) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.list_transvec_col_mul_last_col Matrix.Pivot.listTransvecCol_mul_last_colâ‚“'. -/
/-- Multiplying by all the matrices in `list_transvec_col M` kills all the coefficients in the
last column but the last one. -/
theorem listTransvecCol_mul_last_col (hM : M (inr unit) (inr unit) â‰  0) (i : Fin r) :
    ((listTransvecCol M).Prod â¬ M) (inl i) (inr unit) = 0 :=
  by
  suffices H :
    âˆ€ k : â„•,
      k â‰¤ r â†’
        (((list_transvec_col M).drop k).Prod â¬ M) (inl i) (inr star) =
          if k â‰¤ i then 0 else M (inl i) (inr star)
  Â· simpa only [if_true, List.drop.equations._eqn_1] using H 0 (zero_le _)
  intro k hk
  apply Nat.decreasingInduction' _ hk
  Â· simp only [list_transvec_col, List.length_ofFn, Matrix.one_mul, List.drop_eq_nil_of_le,
      List.prod_nil]
    rw [if_neg]
    simpa only [not_le] using i.2
  Â· intro n hn hk IH
    have hn' : n < (list_transvec_col M).length := by simpa [list_transvec_col] using hn
    let n' : Fin r := âŸ¨n, hnâŸ©
    rw [â† List.cons_nthLe_drop_succ hn']
    have A :
      (list_transvec_col M).nthLe n hn' =
        transvection (inl n') (inr star) (-M (inl n') (inr star) / M (inr star) (inr star)) :=
      by simp [list_transvec_col]
    simp only [Matrix.mul_assoc, A, Matrix.mul_eq_mul, List.prod_cons]
    by_cases h : n' = i
    Â· have hni : n = i := by
        cases i
        simp only [Fin.mk_eq_mk] at h
        simp [h]
      rw [h, transvection_mul_apply_same, IH, list_transvec_col_mul_last_row_drop _ _ hn, â† hni]
      field_simp [hM]
    Â· have hni : n â‰  i := by
        rintro rfl
        cases i
        simpa using h
      simp only [transvection_mul_apply_of_ne, Ne.def, not_false_iff, Ne.symm h]
      rw [IH]
      rcases le_or_lt (n + 1) i with (hi | hi)
      Â· simp only [hi, n.le_succ.trans hi, if_true]
      Â· rw [if_neg, if_neg]
        Â· simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi
        Â· simpa only [not_le] using hi
#align matrix.pivot.list_transvec_col_mul_last_col Matrix.Pivot.listTransvecCol_mul_last_col

/- warning: matrix.pivot.mul_list_transvec_row_last_col_take -> Matrix.Pivot.mul_listTransvecRow_last_col_take is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit) {k : Nat}, (LE.le.{0} Nat Nat.hasLe k r) -> (Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) M (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (List.take.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) k (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M))) i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (M i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit) {k : Nat}, (LE.le.{0} Nat instLENat k r) -> (Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) M (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.take.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) k (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M))) i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (M i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.mul_list_transvec_row_last_col_take Matrix.Pivot.mul_listTransvecRow_last_col_takeâ‚“'. -/
/-- Multiplying by some of the matrices in `list_transvec_row M` does not change the last column. -/
theorem mul_listTransvecRow_last_col_take (i : Sum (Fin r) Unit) {k : â„•} (hk : k â‰¤ r) :
    (M â¬ ((listTransvecRow M).take k).Prod) i (inr unit) = M i (inr unit) :=
  by
  induction' k with k IH
  Â· simp only [Matrix.mul_one, List.take_zero, List.prod_nil]
  Â· have hkr : k < r := hk
    let k' : Fin r := âŸ¨k, hkrâŸ©
    have :
      (list_transvec_row M).get? k =
        â†‘(transvection (inr Unit.unit) (inl k')
            (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) :=
      by
      simp only [list_transvec_row, List.ofFnNthVal, hkr, dif_pos, List.get?_ofFn]
      rfl
    simp only [List.take_succ, â† Matrix.mul_assoc, this, List.prod_append, Matrix.mul_one,
      Matrix.mul_eq_mul, List.prod_cons, List.prod_nil, Option.to_list_some]
    rw [mul_transvection_apply_of_ne, IH hkr.le]
    simp only [Ne.def, not_false_iff]
#align matrix.pivot.mul_list_transvec_row_last_col_take Matrix.Pivot.mul_listTransvecRow_last_col_take

/- warning: matrix.pivot.mul_list_transvec_row_last_col -> Matrix.Pivot.mul_listTransvecRow_last_col is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) M (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (M i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (i : Sum.{0, 0} (Fin r) Unit), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) M (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (M i (Sum.inr.{0, 0} (Fin r) Unit Unit.unit))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.mul_list_transvec_row_last_col Matrix.Pivot.mul_listTransvecRow_last_colâ‚“'. -/
/-- Multiplying by all the matrices in `list_transvec_row M` does not change the last column. -/
theorem mul_listTransvecRow_last_col (i : Sum (Fin r) Unit) :
    (M â¬ (listTransvecRow M).Prod) i (inr unit) = M i (inr unit) :=
  by
  have A : (list_transvec_row M).length = r := by simp [list_transvec_row]
  rw [â† List.take_length (list_transvec_row M), A]
  simpa using mul_list_transvec_row_last_col_take M i le_rfl
#align matrix.pivot.mul_list_transvec_row_last_col Matrix.Pivot.mul_listTransvecRow_last_col

/- warning: matrix.pivot.mul_list_transvec_row_last_row -> Matrix.Pivot.mul_listTransvecRow_last_row is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) M (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inl.{0, 0} (Fin r) Unit i)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))))))))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) M (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inl.{0, 0} (Fin r) Unit i)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.mul_list_transvec_row_last_row Matrix.Pivot.mul_listTransvecRow_last_rowâ‚“'. -/
/-- Multiplying by all the matrices in `list_transvec_row M` kills all the coefficients in the
last row but the last one. -/
theorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) â‰  0) (i : Fin r) :
    (M â¬ (listTransvecRow M).Prod) (inr unit) (inl i) = 0 :=
  by
  suffices H :
    âˆ€ k : â„•,
      k â‰¤ r â†’
        (M â¬ ((list_transvec_row M).take k).Prod) (inr star) (inl i) =
          if k â‰¤ i then M (inr star) (inl i) else 0
  Â· have A : (list_transvec_row M).length = r := by simp [list_transvec_row]
    rw [â† List.take_length (list_transvec_row M), A]
    have : Â¬r â‰¤ i := by simp
    simpa only [this, ite_eq_right_iff] using H r le_rfl
  intro k hk
  induction' k with n IH
  Â· simp only [if_true, Matrix.mul_one, List.take_zero, zero_le', List.prod_nil]
  Â· have hnr : n < r := hk
    let n' : Fin r := âŸ¨n, hnrâŸ©
    have A :
      (list_transvec_row M).get? n =
        â†‘(transvection (inr Unit.unit) (inl n')
            (-M (inr Unit.unit) (inl n') / M (inr Unit.unit) (inr Unit.unit))) :=
      by
      simp only [list_transvec_row, List.ofFnNthVal, hnr, dif_pos, List.get?_ofFn]
      rfl
    simp only [List.take_succ, A, â† Matrix.mul_assoc, List.prod_append, Matrix.mul_one,
      Matrix.mul_eq_mul, List.prod_cons, List.prod_nil, Option.to_list_some]
    by_cases h : n' = i
    Â· have hni : n = i := by
        cases i
        simp only [Fin.mk_eq_mk] at h
        simp only [h, coe_mk]
      have : Â¬n.succ â‰¤ i := by simp only [â† hni, n.lt_succ_self, not_le]
      simp only [h, mul_transvection_apply_same, List.take, if_false,
        mul_list_transvec_row_last_col_take _ _ hnr.le, hni.le, this, if_true, IH hnr.le]
      field_simp [hM]
    Â· have hni : n â‰  i := by
        rintro rfl
        cases i
        simpa using h
      simp only [IH hnr.le, Ne.def, mul_transvection_apply_of_ne, not_false_iff, Ne.symm h]
      rcases le_or_lt (n + 1) i with (hi | hi)
      Â· simp [hi, n.le_succ.trans hi, if_true]
      Â· rw [if_neg, if_neg]
        Â· simpa only [not_le] using hi
        Â· simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi
#align matrix.pivot.mul_list_transvec_row_last_row Matrix.Pivot.mul_listTransvecRow_last_row

/- warning: matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_col -> Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_col is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inl.{0, 0} (Fin r) Unit i)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))))))))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inl.{0, 0} (Fin r) Unit i)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_col Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_colâ‚“'. -/
/-- Multiplying by all the matrices either in `list_transvec_col M` and `list_transvec_row M` kills
all the coefficients in the last row but the last one. -/
theorem listTransvecCol_mul_mul_listTransvecRow_last_col (hM : M (inr unit) (inr unit) â‰  0)
    (i : Fin r) :
    ((listTransvecCol M).Prod â¬ M â¬ (listTransvecRow M).Prod) (inr unit) (inl i) = 0 :=
  by
  have : list_transvec_row M = list_transvec_row ((list_transvec_col M).Prod â¬ M) := by
    simp [list_transvec_row, list_transvec_col_mul_last_row]
  rw [this]
  apply mul_list_transvec_row_last_row
  simpa [list_transvec_col_mul_last_row] using hM
#align matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_col Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_col

/- warning: matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_row -> Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_row is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) (Sum.inl.{0, 0} (Fin r) Unit i) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))))))))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (forall (i : Fin r), Eq.{succ u1} ð•œ (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M)) (Sum.inl.{0, 0} (Fin r) Unit i) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_row Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_rowâ‚“'. -/
/-- Multiplying by all the matrices either in `list_transvec_col M` and `list_transvec_row M` kills
all the coefficients in the last column but the last one. -/
theorem listTransvecCol_mul_mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) â‰  0)
    (i : Fin r) :
    ((listTransvecCol M).Prod â¬ M â¬ (listTransvecRow M).Prod) (inl i) (inr unit) = 0 :=
  by
  have : list_transvec_col M = list_transvec_col (M â¬ (list_transvec_row M).Prod) := by
    simp [list_transvec_col, mul_list_transvec_row_last_col]
  rw [this, Matrix.mul_assoc]
  apply list_transvec_col_mul_last_col
  simpa [mul_list_transvec_row_last_col] using hM
#align matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_row Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_row

/- warning: matrix.pivot.is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row -> Matrix.Pivot.isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))))))) -> (Matrix.IsTwoBlockDiagonal.{0, 0, 0, 0, u1} (Fin r) Unit (Fin r) Unit ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M))))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (Matrix.IsTwoBlockDiagonal.{0, 0, 0, 0, u1} (Fin r) Unit (Fin r) Unit ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecCol.{u1} ð•œ _inst_1 r M)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (Matrix.Pivot.listTransvecRow.{u1} ð•œ _inst_1 r M))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row Matrix.Pivot.isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRowâ‚“'. -/
/-- Multiplying by all the matrices either in `list_transvec_col M` and `list_transvec_row M` turns
the matrix in block-diagonal form. -/
theorem isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow
    (hM : M (inr unit) (inr unit) â‰  0) :
    IsTwoBlockDiagonal ((listTransvecCol M).Prod â¬ M â¬ (listTransvecRow M).Prod) :=
  by
  constructor
  Â· ext (i j)
    have : j = star := by simp only [eq_iff_true_of_subsingleton]
    simp [to_blocksâ‚â‚‚, this, list_transvec_col_mul_mul_list_transvec_row_last_row M hM]
  Â· ext (i j)
    have : i = star := by simp only [eq_iff_true_of_subsingleton]
    simp [to_blocksâ‚‚â‚, this, list_transvec_col_mul_mul_list_transvec_row_last_col M hM]
#align matrix.pivot.is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row Matrix.Pivot.isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow

/- warning: matrix.pivot.exists_is_two_block_diagonal_of_ne_zero -> Matrix.Pivot.exists_isTwoBlockDiagonal_of_ne_zero is a dubious translation:
lean 3 declaration is
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (OfNat.mk.{u1} ð•œ 0 (Zero.zero.{u1} ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))))))) -> (Exists.{succ u1} (List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)))) (fun (L : List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)))) => Exists.{succ u1} (List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)))) (fun (L' : List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)))) => Matrix.IsTwoBlockDiagonal.{0, 0, 0, 0, u1} (Fin r) Unit (Fin r) Unit ð•œ (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (List.map.{u1, u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.hasMul.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (Sum.fintype.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (Distrib.toHasMul.{u1} ð•œ (Ring.toDistrib.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.hasOne.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (MulZeroClass.toHasZero.{u1} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u1} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u1} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u1} ð•œ (Ring.toAddCommGroupWithOne.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (List.map.{u1, u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.decidableEq.{0, 0} (Fin r) (fun (a : Fin r) (b : Fin r) => Fin.decidableEq r a b) Unit (fun (a : Unit) (b : Unit) => PUnit.decidableEq.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L'))))))
but is expected to have type
  forall {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] {r : Nat} (M : Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ), (Ne.{succ u1} ð•œ (M (Sum.inr.{0, 0} (Fin r) Unit Unit.unit) (Sum.inr.{0, 0} (Fin r) Unit Unit.unit)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (Exists.{succ u1} (List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ)) (fun (L : List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ)) => Exists.{succ u1} (List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ)) (fun (L' : List.{u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ)) => Matrix.IsTwoBlockDiagonal.{0, 0, 0, 0, u1} (Fin r) Unit (Fin r) Unit ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, 0, 0, 0} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.map.{u1, u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L)) M) (List.prod.{u1} (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.instMulMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (instFintypeSum.{0, 0} (Fin r) Unit (Fin.fintype r) PUnit.fintype.{0}) (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.map.{u1, u1} (Matrix.TransvectionStruct.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.{0, 0, u1} (Sum.{0, 0} (Fin r) Unit) (Sum.{0, 0} (Fin r) Unit) ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, 0} (Sum.{0, 0} (Fin r) Unit) ð•œ (fun (a : Sum.{0, 0} (Fin r) Unit) (b : Sum.{0, 0} (Fin r) Unit) => Sum.instDecidableEqSum.{0, 0} (Fin r) Unit (fun (a : Fin r) (b : Fin r) => instDecidableEqFin r a b) (fun (a : Unit) (b : Unit) => instDecidableEqPUnit.{1} a b) a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L'))))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.exists_is_two_block_diagonal_of_ne_zero Matrix.Pivot.exists_isTwoBlockDiagonal_of_ne_zeroâ‚“'. -/
/-- There exist two lists of `transvection_struct` such that multiplying by them on the left and
on the right makes a matrix block-diagonal, when the last coefficient is nonzero. -/
theorem exists_isTwoBlockDiagonal_of_ne_zero (hM : M (inr unit) (inr unit) â‰  0) :
    âˆƒ L L' : List (TransvectionStruct (Sum (Fin r) Unit) ð•œ),
      IsTwoBlockDiagonal ((L.map toMatrix).Prod â¬ M â¬ (L'.map toMatrix).Prod) :=
  by
  let L : List (transvection_struct (Sum (Fin r) Unit) ð•œ) :=
    List.ofFn fun i : Fin r =>
      âŸ¨inl i, inr star, by simp, -M (inl i) (inr star) / M (inr star) (inr star)âŸ©
  let L' : List (transvection_struct (Sum (Fin r) Unit) ð•œ) :=
    List.ofFn fun i : Fin r =>
      âŸ¨inr star, inl i, by simp, -M (inr star) (inl i) / M (inr star) (inr star)âŸ©
  refine' âŸ¨L, L', _âŸ©
  have A : L.map to_matrix = list_transvec_col M := by simp [L, list_transvec_col, (Â· âˆ˜ Â·)]
  have B : L'.map to_matrix = list_transvec_row M := by simp [L, list_transvec_row, (Â· âˆ˜ Â·)]
  rw [A, B]
  exact is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row M hM
#align matrix.pivot.exists_is_two_block_diagonal_of_ne_zero Matrix.Pivot.exists_isTwoBlockDiagonal_of_ne_zero

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
#print Matrix.Pivot.exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec /-
/-- There exist two lists of `transvection_struct` such that multiplying by them on the left and
on the right makes a matrix block-diagonal. -/
theorem exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec
    (M : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ð•œ) :
    âˆƒ L L' : List (TransvectionStruct (Sum (Fin r) Unit) ð•œ),
      IsTwoBlockDiagonal ((L.map toMatrix).Prod â¬ M â¬ (L'.map toMatrix).Prod) :=
  by
  by_cases H : is_two_block_diagonal M
  Â· refine' âŸ¨List.nil, List.nil, by simpa using HâŸ©
  -- we have already proved this when the last coefficient is nonzero
  by_cases hM : M (inr star) (inr star) â‰  0
  Â· exact exists_is_two_block_diagonal_of_ne_zero M hM
  -- when the last coefficient is zero but there is a nonzero coefficient on the last row or the
  -- last column, we will first put this nonzero coefficient in last position, and then argue as
  -- above.
  push_neg  at hM
  simp [not_and_or, is_two_block_diagonal, to_blocksâ‚â‚‚, to_blocksâ‚‚â‚, â† Matrix.ext_iff] at H
  have : âˆƒ i : Fin r, M (inl i) (inr star) â‰  0 âˆ¨ M (inr star) (inl i) â‰  0 :=
    by
    cases H
    Â· contrapose! H
      rintro i âŸ¨âŸ©
      exact (H i).1
    Â· contrapose! H
      rintro âŸ¨âŸ© j
      exact (H j).2
  rcases this with âŸ¨i, h | hâŸ©
  Â· let M' := transvection (inr Unit.unit) (inl i) 1 â¬ M
    have hM' : M' (inr star) (inr star) â‰  0 := by simpa [M', hM]
    rcases exists_is_two_block_diagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©
    rw [Matrix.mul_assoc] at hLL'
    refine' âŸ¨L ++ [âŸ¨inr star, inl i, by simp, 1âŸ©], L', _âŸ©
    simp only [List.map_append, List.prod_append, Matrix.mul_one, to_matrix_mk, List.prod_cons,
      List.prod_nil, mul_eq_mul, List.map, Matrix.mul_assoc (L.map to_matrix).Prod]
    exact hLL'
  Â· let M' := M â¬ transvection (inl i) (inr star) 1
    have hM' : M' (inr star) (inr star) â‰  0 := by simpa [M', hM]
    rcases exists_is_two_block_diagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©
    refine' âŸ¨L, âŸ¨inl i, inr star, by simp, 1âŸ©::L', _âŸ©
    simp only [â† Matrix.mul_assoc, to_matrix_mk, List.prod_cons, mul_eq_mul, List.map]
    rw [Matrix.mul_assoc (L.map to_matrix).Prod]
    exact hLL'
#align matrix.pivot.exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec Matrix.Pivot.exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec
-/

#print Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction /-
/-- Inductive step for the reduction: if one knows that any size `r` matrix can be reduced to
diagonal form by elementary operations, then one deduces it for matrices over `fin r âŠ• unit`. -/
theorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction
    (IH :
      âˆ€ M : Matrix (Fin r) (Fin r) ð•œ,
        âˆƒ (Lâ‚€ Lâ‚€' : List (TransvectionStruct (Fin r) ð•œ))(Dâ‚€ : Fin r â†’ ð•œ),
          (Lâ‚€.map toMatrix).Prod â¬ M â¬ (Lâ‚€'.map toMatrix).Prod = diagonal Dâ‚€)
    (M : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ð•œ) :
    âˆƒ (L L' : List (TransvectionStruct (Sum (Fin r) Unit) ð•œ))(D : Sum (Fin r) Unit â†’ ð•œ),
      (L.map toMatrix).Prod â¬ M â¬ (L'.map toMatrix).Prod = diagonal D :=
  by
  rcases exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec M with âŸ¨Lâ‚, Lâ‚', hMâŸ©
  let M' := (Lâ‚.map to_matrix).Prod â¬ M â¬ (Lâ‚'.map to_matrix).Prod
  let M'' := to_blocksâ‚â‚ M'
  rcases IH M'' with âŸ¨Lâ‚€, Lâ‚€', Dâ‚€, hâ‚€âŸ©
  set c := M' (inr star) (inr star) with hc
  refine'
    âŸ¨Lâ‚€.map (sum_inl Unit) ++ Lâ‚, Lâ‚' ++ Lâ‚€'.map (sum_inl Unit),
      Sum.elim Dâ‚€ fun _ => M' (inr star) (inr star), _âŸ©
  suffices
    (Lâ‚€.map (to_matrix âˆ˜ sum_inl Unit)).Prod â¬ M' â¬ (Lâ‚€'.map (to_matrix âˆ˜ sum_inl Unit)).Prod =
      diagonal (Sum.elim Dâ‚€ fun _ => c)
    by simpa [M', Matrix.mul_assoc, c]
  have : M' = from_blocks M'' 0 0 (diagonal fun _ => c) :=
    by
    rw [â† from_blocks_to_blocks M']
    congr
    Â· exact hM.1
    Â· exact hM.2
    Â· ext (âŸ¨âŸ©âŸ¨âŸ©)
      rw [hc, to_blocksâ‚‚â‚‚, of_apply]
      rfl
  rw [this]
  simp [hâ‚€]
#align matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction
-/

variable {n p} [Fintype n] [Fintype p]

/- warning: matrix.pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal -> Matrix.Pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {p : Type.{u2}} {ð•œ : Type.{u3}} [_inst_1 : Field.{u3} ð•œ] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : DecidableEq.{succ u2} p] [_inst_5 : Fintype.{u1} n] [_inst_6 : Fintype.{u2} p] (M : Matrix.{u2, u2, u3} p p ð•œ) (e : Equiv.{succ u2, succ u1} p n), (Exists.{succ (max u1 u3)} (List.{max u1 u3} (Matrix.TransvectionStruct.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) (fun (L : List.{max u1 u3} (Matrix.TransvectionStruct.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) => Exists.{succ (max u1 u3)} (List.{max u1 u3} (Matrix.TransvectionStruct.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) (fun (L' : List.{max u1 u3} (Matrix.TransvectionStruct.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) => Exists.{max (succ u1) (succ u3)} (n -> ð•œ) (fun (D : n -> ð•œ) => Eq.{succ (max u1 u3)} (Matrix.{u1, u1, u3} n n ð•œ) (Matrix.mul.{u3, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))))) (Matrix.mul.{u3, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))))) (List.prod.{max u1 u3} (Matrix.{u1, u1, u3} n n ð•œ) (Matrix.hasMul.{u3, u1} n ð•œ _inst_5 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (Matrix.hasOne.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u3} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u3} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u3} ð•œ (Ring.toAddCommGroupWithOne.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (List.map.{max u1 u3, max u1 u3} (Matrix.TransvectionStruct.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) (Matrix.{u1, u1, u3} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) L)) (coeFn.{max (succ (max u2 u3)) (succ (max u1 u3)), max (succ (max u2 u3)) (succ (max u1 u3))} (AlgEquiv.{u3, max u2 u3, max u1 u3} ð•œ (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.{u1, u1, u3} n n ð•œ) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (Matrix.semiring.{u3, u2} p ð•œ (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u3, u1} n ð•œ (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.algebra.{u3, u2, u3} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) (Algebra.id.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)))) (Matrix.algebra.{u3, u1, u3} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) (Algebra.id.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))))) (fun (_x : AlgEquiv.{u3, max u2 u3, max u1 u3} ð•œ (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.{u1, u1, u3} n n ð•œ) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (Matrix.semiring.{u3, u2} p ð•œ (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u3, u1} n ð•œ (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.algebra.{u3, u2, u3} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) (Algebra.id.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)))) (Matrix.algebra.{u3, u1, u3} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) (Algebra.id.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))))) => (Matrix.{u2, u2, u3} p p ð•œ) -> (Matrix.{u1, u1, u3} n n ð•œ)) (AlgEquiv.hasCoeToFun.{u3, max u2 u3, max u1 u3} ð•œ (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.{u1, u1, u3} n n ð•œ) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (Matrix.semiring.{u3, u2} p ð•œ (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u3, u1} n ð•œ (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.algebra.{u3, u2, u3} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) (Algebra.id.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)))) (Matrix.algebra.{u3, u1, u3} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) (CommSemiring.toSemiring.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))) (Algebra.id.{u3} ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1))))) (Matrix.reindexAlgEquiv.{u2, u1, u3} p n ð•œ (Semifield.toCommSemiring.{u3} ð•œ (Field.toSemifield.{u3} ð•œ _inst_1)) _inst_5 _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (fun (a : n) (b : n) => _inst_2 a b) e) M)) (List.prod.{max u1 u3} (Matrix.{u1, u1, u3} n n ð•œ) (Matrix.hasMul.{u3, u1} n ð•œ _inst_5 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (Matrix.hasOne.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u3} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u3} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u3} ð•œ (Ring.toAddCommGroupWithOne.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (List.map.{max u1 u3, max u1 u3} (Matrix.TransvectionStruct.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) (Matrix.{u1, u1, u3} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) L'))) (Matrix.diagonal.{u3, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) D))))) -> (Exists.{succ (max u2 u3)} (List.{max u2 u3} (Matrix.TransvectionStruct.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) (fun (L : List.{max u2 u3} (Matrix.TransvectionStruct.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) => Exists.{succ (max u2 u3)} (List.{max u2 u3} (Matrix.TransvectionStruct.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) (fun (L' : List.{max u2 u3} (Matrix.TransvectionStruct.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1)))) => Exists.{max (succ u2) (succ u3)} (p -> ð•œ) (fun (D : p -> ð•œ) => Eq.{succ (max u2 u3)} (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.mul.{u3, u2, u2, u2} p p p ð•œ _inst_6 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))))) (Matrix.mul.{u3, u2, u2, u2} p p p ð•œ _inst_6 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))))) (List.prod.{max u2 u3} (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.hasMul.{u3, u2} p ð•œ _inst_6 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (Matrix.hasOne.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u3} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u3} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u3} ð•œ (Ring.toAddCommGroupWithOne.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (List.map.{max u2 u3, max u2 u3} (Matrix.TransvectionStruct.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.TransvectionStruct.toMatrix.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) L)) M) (List.prod.{max u2 u3} (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.hasMul.{u3, u2} p ð•œ _inst_6 (Distrib.toHasMul.{u3} ð•œ (Ring.toDistrib.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u3} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (Matrix.hasOne.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u3} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u3} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u3} ð•œ (Ring.toAddCommGroupWithOne.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) (List.map.{max u2 u3, max u2 u3} (Matrix.TransvectionStruct.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) (Matrix.{u2, u2, u3} p p ð•œ) (Matrix.TransvectionStruct.toMatrix.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u3} ð•œ (Field.toEuclideanDomain.{u3} ð•œ _inst_1))) L'))) (Matrix.diagonal.{u3, u2} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (MulZeroClass.toHasZero.{u3} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u3} ð•œ (Ring.toNonAssocRing.{u3} ð•œ (DivisionRing.toRing.{u3} ð•œ (Field.toDivisionRing.{u3} ð•œ _inst_1))))))) D)))))
but is expected to have type
  forall {n : Type.{u1}} {p : Type.{u3}} {ð•œ : Type.{u2}} [_inst_1 : Field.{u2} ð•œ] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : DecidableEq.{succ u3} p] [_inst_5 : Fintype.{u1} n] [_inst_6 : Fintype.{u3} p] (M : Matrix.{u3, u3, u2} p p ð•œ) (e : Equiv.{succ u3, succ u1} p n), (Exists.{max (succ u1) (succ u2)} (List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ)) (fun (L : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ)) => Exists.{max (succ u1) (succ u2)} (List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ)) (fun (L' : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ)) => Exists.{max (succ u1) (succ u2)} (n -> ð•œ) (fun (D : n -> ð•œ) => Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.instMulMatrix.{u2, u1} n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.one.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ð•œ (Semifield.toCommGroupWithZero.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (NonAssocRing.toOne.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L)) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (succ u3) (succ u2), max (succ u1) (succ u2)} (AlgEquiv.{u2, max u2 u3, max u2 u1} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) (Matrix.{u3, u3, u2} p p ð•œ) (fun (_x : Matrix.{u3, u3, u2} p p ð•œ) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u3, u3, u2} p p ð•œ) => Matrix.{u1, u1, u2} n n ð•œ) _x) (SMulHomClass.toFunLike.{max (max u1 u3) u2, u2, max u3 u2, max u1 u2} (AlgEquiv.{u2, max u2 u3, max u2 u1} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (SMulZeroClass.toSMul.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (AddMonoid.toZero.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))))) (DistribSMul.toSMulZeroClass.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (AddMonoid.toAddZeroClass.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))))) (DistribMulAction.toDistribSMul.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (MonoidWithZero.toMonoid.{u2} ð•œ (Semiring.toMonoidWithZero.{u2} ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))))) (Module.toDistribMulAction.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))))))) (SMulZeroClass.toSMul.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (AddMonoid.toZero.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (AddCommMonoid.toAddMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))))) (DistribSMul.toSMulZeroClass.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (AddMonoid.toAddZeroClass.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (AddCommMonoid.toAddMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))))) (DistribMulAction.toDistribSMul.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (MonoidWithZero.toMonoid.{u2} ð•œ (Semiring.toMonoidWithZero.{u2} ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))))) (Module.toDistribMulAction.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u1 u3) u2, u2, max u3 u2, max u1 u2} (AlgEquiv.{u2, max u2 u3, max u2 u1} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (MonoidWithZero.toMonoid.{u2} ð•œ (Semiring.toMonoidWithZero.{u2} ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))))) (Module.toDistribMulAction.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))))) (Module.toDistribMulAction.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u1 u3) u2, u2, max u3 u2, max u1 u2} (AlgEquiv.{u2, max u2 u3, max u2 u1} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (MonoidWithZero.toMonoid.{u2} ð•œ (Semiring.toMonoidWithZero.{u2} ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)))) (Module.toDistribMulAction.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Semiring.toNonAssocSemiring.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b))))) (Algebra.toModule.{u2, max u3 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))))) (Module.toDistribMulAction.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Semiring.toNonAssocSemiring.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b))))) (Algebra.toModule.{u2, max u1 u2} ð•œ (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, max u3 u2, max u1 u2, max (max u1 u3) u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (AlgEquiv.{u2, max u2 u3, max u2 u1} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) (AlgEquivClass.toAlgHomClass.{max (max u1 u3) u2, u2, max u3 u2, max u1 u2} (AlgEquiv.{u2, max u2 u3, max u2 u1} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))))) ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (AlgEquiv.instAlgEquivClassAlgEquiv.{u2, max u3 u2, max u1 u2} ð•œ (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (Matrix.semiring.{u2, u3} p ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_6 (fun (a : p) (b : p) => _inst_3 a b)) (Matrix.semiring.{u2, u1} n ð•œ (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) _inst_5 (fun (a : n) (b : n) => _inst_2 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u3, u2} p ð•œ ð•œ _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (Matrix.instAlgebraMatrixSemiring.{u2, u1, u2} n ð•œ ð•œ _inst_5 (fun (a : n) (b : n) => _inst_2 a b) (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) (CommSemiring.toSemiring.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1))) (Algebra.id.{u2} ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))))))))) (Matrix.reindexAlgEquiv.{u3, u1, u2} p n ð•œ (Semifield.toCommSemiring.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)) _inst_5 _inst_6 (fun (a : p) (b : p) => _inst_3 a b) (fun (a : n) (b : n) => _inst_2 a b) e) M)) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.instMulMatrix.{u2, u1} n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.one.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ð•œ (Semifield.toCommGroupWithZero.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (NonAssocRing.toOne.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ) (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L'))) (Matrix.diagonal.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ð•œ (Semifield.toCommGroupWithZero.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) D))))) -> (Exists.{max (succ u3) (succ u2)} (List.{max u3 u2} (Matrix.TransvectionStruct.{u2, u3} p ð•œ)) (fun (L : List.{max u3 u2} (Matrix.TransvectionStruct.{u2, u3} p ð•œ)) => Exists.{max (succ u3) (succ u2)} (List.{max u3 u2} (Matrix.TransvectionStruct.{u2, u3} p ð•œ)) (fun (L' : List.{max u3 u2} (Matrix.TransvectionStruct.{u2, u3} p ð•œ)) => Exists.{max (succ u3) (succ u2)} (p -> ð•œ) (fun (D : p -> ð•œ) => Eq.{max (succ u3) (succ u2)} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.mul.{u2, u3, u3, u3} p p p ð•œ _inst_6 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (Matrix.mul.{u2, u3, u3, u3} p p p ð•œ _inst_6 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (List.prod.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.instMulMatrix.{u2, u3} p ð•œ _inst_6 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.one.{u2, u3} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (CommMonoidWithZero.toZero.{u2} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ð•œ (Semifield.toCommGroupWithZero.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (NonAssocRing.toOne.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (List.map.{max u3 u2, max u3 u2} (Matrix.TransvectionStruct.{u2, u3} p ð•œ) (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u3} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L)) M) (List.prod.{max u3 u2} (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.instMulMatrix.{u2, u3} p ð•œ _inst_6 (NonUnitalNonAssocRing.toMul.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.one.{u2, u3} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (CommMonoidWithZero.toZero.{u2} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ð•œ (Semifield.toCommGroupWithZero.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) (NonAssocRing.toOne.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))) (List.map.{max u3 u2, max u3 u2} (Matrix.TransvectionStruct.{u2, u3} p ð•œ) (Matrix.{u3, u3, u2} p p ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u3} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L'))) (Matrix.diagonal.{u2, u3} p ð•œ (fun (a : p) (b : p) => _inst_3 a b) (CommMonoidWithZero.toZero.{u2} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u2} ð•œ (Semifield.toCommGroupWithZero.{u2} ð•œ (Field.toSemifield.{u2} ð•œ _inst_1)))) D)))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal Matrix.Pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonalâ‚“'. -/
/-- Reduction to diagonal form by elementary operations is invariant under reindexing. -/
theorem reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : Matrix p p ð•œ)
    (e : p â‰ƒ n)
    (H :
      âˆƒ (L L' : List (TransvectionStruct n ð•œ))(D : n â†’ ð•œ),
        (L.map toMatrix).Prod â¬ Matrix.reindexAlgEquiv ð•œ e M â¬ (L'.map toMatrix).Prod =
          diagonal D) :
    âˆƒ (L L' : List (TransvectionStruct p ð•œ))(D : p â†’ ð•œ),
      (L.map toMatrix).Prod â¬ M â¬ (L'.map toMatrix).Prod = diagonal D :=
  by
  rcases H with âŸ¨Lâ‚€, Lâ‚€', Dâ‚€, hâ‚€âŸ©
  refine' âŸ¨Lâ‚€.map (reindex_equiv e.symm), Lâ‚€'.map (reindex_equiv e.symm), Dâ‚€ âˆ˜ e, _âŸ©
  have : M = reindex_alg_equiv ð•œ e.symm (reindex_alg_equiv ð•œ e M) := by
    simp only [Equiv.symm_symm, submatrix_submatrix, reindex_apply, submatrix_id_id,
      Equiv.symm_comp_self, reindex_alg_equiv_apply]
  rw [this]
  simp only [to_matrix_reindex_equiv_prod, List.map_map, reindex_alg_equiv_apply]
  simp only [â† reindex_alg_equiv_apply, â† reindex_alg_equiv_mul, hâ‚€]
  simp only [Equiv.symm_symm, reindex_apply, submatrix_diagonal_equiv, reindex_alg_equiv_apply]
#align matrix.pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal Matrix.Pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal

#print Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux /-
/-- Any matrix can be reduced to diagonal form by elementary operations. Formulated here on `Type 0`
because we will make an induction using `fin r`.
See `exists_list_transvec_mul_mul_list_transvec_eq_diagonal` for the general version (which follows
from this one and reindexing). -/
theorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux (n : Type) [Fintype n]
    [DecidableEq n] (M : Matrix n n ð•œ) :
    âˆƒ (L L' : List (TransvectionStruct n ð•œ))(D : n â†’ ð•œ),
      (L.map toMatrix).Prod â¬ M â¬ (L'.map toMatrix).Prod = diagonal D :=
  by
  induction' hn : Fintype.card n with r IH generalizing n M
  Â· refine' âŸ¨List.nil, List.nil, fun _ => 1, _âŸ©
    ext (i j)
    rw [Fintype.card_eq_zero_iff] at hn
    exact hn.elim' i
  Â· have e : n â‰ƒ Sum (Fin r) Unit :=
      by
      refine' Fintype.equivOfCardEq _
      rw [hn]
      convert(@Fintype.card_sum (Fin r) Unit _ _).symm
      simp
    apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
    apply
      exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction fun N =>
        IH (Fin r) N (by simp)
#align matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux
-/

/- warning: matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal -> Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {ð•œ : Type.{u2}} [_inst_1 : Field.{u2} ð•œ] [_inst_2 : DecidableEq.{succ u1} n] [_inst_5 : Fintype.{u1} n] (M : Matrix.{u1, u1, u2} n n ð•œ), Exists.{succ (max u1 u2)} (List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) (fun (L : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) => Exists.{succ (max u1 u2)} (List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) (fun (L' : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) => Exists.{max (succ u1) (succ u2)} (n -> ð•œ) (fun (D : n -> ð•œ) => Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.hasMul.{u2, u1} n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.hasOne.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u2} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ð•œ (Ring.toAddCommGroupWithOne.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L)) M) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.hasMul.{u2, u1} n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.hasOne.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u2} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ð•œ (Ring.toAddCommGroupWithOne.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L'))) (Matrix.diagonal.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) D))))
but is expected to have type
  forall {n : Type.{u2}} {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] [_inst_2 : DecidableEq.{succ u2} n] [_inst_5 : Fintype.{u2} n] (M : Matrix.{u2, u2, u1} n n ð•œ), Exists.{max (succ u2) (succ u1)} (List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) (fun (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) => Exists.{max (succ u2) (succ u1)} (List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) (fun (L' : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) => Exists.{max (succ u2) (succ u1)} (n -> ð•œ) (fun (D : n -> ð•œ) => Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.mul.{u1, u2, u2, u2} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, u2, u2, u2} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.instMulMatrix.{u1, u2} n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ) (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L)) M) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.instMulMatrix.{u1, u2} n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ) (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L'))) (Matrix.diagonal.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) D))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonalâ‚“'. -/
/-- Any matrix can be reduced to diagonal form by elementary operations. -/
theorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : Matrix n n ð•œ) :
    âˆƒ (L L' : List (TransvectionStruct n ð•œ))(D : n â†’ ð•œ),
      (L.map toMatrix).Prod â¬ M â¬ (L'.map toMatrix).Prod = diagonal D :=
  by
  have e : n â‰ƒ Fin (Fintype.card n) := Fintype.equivOfCardEq (by simp)
  apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
  apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux
#align matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal

/- warning: matrix.pivot.exists_list_transvec_mul_diagonal_mul_list_transvec -> Matrix.Pivot.exists_list_transvec_mul_diagonal_mul_list_transvec is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {ð•œ : Type.{u2}} [_inst_1 : Field.{u2} ð•œ] [_inst_2 : DecidableEq.{succ u1} n] [_inst_5 : Fintype.{u1} n] (M : Matrix.{u1, u1, u2} n n ð•œ), Exists.{succ (max u1 u2)} (List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) (fun (L : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) => Exists.{succ (max u1 u2)} (List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) (fun (L' : List.{max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)))) => Exists.{max (succ u1) (succ u2)} (n -> ð•œ) (fun (D : n -> ð•œ) => Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n ð•œ) M (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.hasMul.{u2, u1} n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.hasOne.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u2} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ð•œ (Ring.toAddCommGroupWithOne.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L)) (Matrix.diagonal.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) D)) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.hasMul.{u2, u1} n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (Matrix.hasOne.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (AddMonoidWithOne.toOne.{u2} ð•œ (AddGroupWithOne.toAddMonoidWithOne.{u2} ð•œ (AddCommGroupWithOne.toAddGroupWithOne.{u2} ð•œ (Ring.toAddCommGroupWithOne.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) (List.map.{max u1 u2, max u1 u2} (Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) (Matrix.{u1, u1, u2} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))) L'))))))
but is expected to have type
  forall {n : Type.{u2}} {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] [_inst_2 : DecidableEq.{succ u2} n] [_inst_5 : Fintype.{u2} n] (M : Matrix.{u2, u2, u1} n n ð•œ), Exists.{max (succ u2) (succ u1)} (List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) (fun (L : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) => Exists.{max (succ u2) (succ u1)} (List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) (fun (L' : List.{max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ)) => Exists.{max (succ u2) (succ u1)} (n -> ð•œ) (fun (D : n -> ð•œ) => Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} n n ð•œ) M (Matrix.mul.{u1, u2, u2, u2} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (Matrix.mul.{u1, u2, u2, u2} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.instMulMatrix.{u1, u2} n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ) (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L)) (Matrix.diagonal.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) D)) (List.prod.{max u2 u1} (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.instMulMatrix.{u1, u2} n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))))) (Matrix.one.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) (NonAssocRing.toOne.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (List.map.{max u2 u1, max u2 u1} (Matrix.TransvectionStruct.{u1, u2} n ð•œ) (Matrix.{u2, u2, u1} n n ð•œ) (Matrix.TransvectionStruct.toMatrix.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1))) L'))))))
Case conversion may be inaccurate. Consider using '#align matrix.pivot.exists_list_transvec_mul_diagonal_mul_list_transvec Matrix.Pivot.exists_list_transvec_mul_diagonal_mul_list_transvecâ‚“'. -/
/-- Any matrix can be written as the product of transvections, a diagonal matrix, and
transvections.-/
theorem exists_list_transvec_mul_diagonal_mul_list_transvec (M : Matrix n n ð•œ) :
    âˆƒ (L L' : List (TransvectionStruct n ð•œ))(D : n â†’ ð•œ),
      M = (L.map toMatrix).Prod â¬ diagonal D â¬ (L'.map toMatrix).Prod :=
  by
  rcases exists_list_transvec_mul_mul_list_transvec_eq_diagonal M with âŸ¨L, L', D, hâŸ©
  refine' âŸ¨L.reverse.map transvection_struct.inv, L'.reverse.map transvection_struct.inv, D, _âŸ©
  suffices
    M =
      (L.reverse.map (to_matrix âˆ˜ transvection_struct.inv)).Prod â¬ (L.map to_matrix).Prod â¬ M â¬
        ((L'.map to_matrix).Prod â¬ (L'.reverse.map (to_matrix âˆ˜ transvection_struct.inv)).Prod)
    by simpa [â† h, Matrix.mul_assoc]
  rw [reverse_inv_prod_mul_prod, prod_mul_reverse_inv_prod, Matrix.one_mul, Matrix.mul_one]
#align matrix.pivot.exists_list_transvec_mul_diagonal_mul_list_transvec Matrix.Pivot.exists_list_transvec_mul_diagonal_mul_list_transvec

end Pivot

open Pivot TransvectionStruct

variable {n} [Fintype n]

/- warning: matrix.diagonal_transvection_induction -> Matrix.diagonal_transvection_induction is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {ð•œ : Type.{u2}} [_inst_1 : Field.{u2} ð•œ] [_inst_2 : DecidableEq.{succ u1} n] [_inst_5 : Fintype.{u1} n] (P : (Matrix.{u1, u1, u2} n n ð•œ) -> Prop) (M : Matrix.{u1, u1, u2} n n ð•œ), (forall (D : n -> ð•œ), (Eq.{succ u2} ð•œ (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) (Matrix.diagonal.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) D)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) M)) -> (P (Matrix.diagonal.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) D))) -> (forall (t : Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))), P (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) t)) -> (forall (A : Matrix.{u1, u1, u2} n n ð•œ) (B : Matrix.{u1, u1, u2} n n ð•œ), (P A) -> (P B) -> (P (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) A B))) -> (P M)
but is expected to have type
  forall {n : Type.{u2}} {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] [_inst_2 : DecidableEq.{succ u2} n] [_inst_5 : Fintype.{u2} n] (P : (Matrix.{u2, u2, u1} n n ð•œ) -> Prop) (M : Matrix.{u2, u2, u1} n n ð•œ), (forall (D : n -> ð•œ), (Eq.{succ u1} ð•œ (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) (Matrix.diagonal.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) D)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) M)) -> (P (Matrix.diagonal.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) D))) -> (forall (t : Matrix.TransvectionStruct.{u1, u2} n ð•œ), P (Matrix.TransvectionStruct.toMatrix.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) t)) -> (forall (A : Matrix.{u2, u2, u1} n n ð•œ) (B : Matrix.{u2, u2, u1} n n ð•œ), (P A) -> (P B) -> (P (Matrix.mul.{u1, u2, u2, u2} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) A B))) -> (P M)
Case conversion may be inaccurate. Consider using '#align matrix.diagonal_transvection_induction Matrix.diagonal_transvection_inductionâ‚“'. -/
/-- Induction principle for matrices based on transvections: if a property is true for all diagonal
matrices, all transvections, and is stable under product, then it is true for all matrices. This is
the useful way to say that matrices are generated by diagonal matrices and transvections.

We state a slightly more general version: to prove a property for a matrix `M`, it suffices to
assume that the diagonal matrices we consider have the same determinant as `M`. This is useful to
obtain similar principles for `SLâ‚™` or `GLâ‚™`. -/
theorem diagonal_transvection_induction (P : Matrix n n ð•œ â†’ Prop) (M : Matrix n n ð•œ)
    (hdiag : âˆ€ D : n â†’ ð•œ, det (diagonal D) = det M â†’ P (diagonal D))
    (htransvec : âˆ€ t : TransvectionStruct n ð•œ, P t.toMatrix) (hmul : âˆ€ A B, P A â†’ P B â†’ P (A â¬ B)) :
    P M :=
  by
  rcases exists_list_transvec_mul_diagonal_mul_list_transvec M with âŸ¨L, L', D, hâŸ©
  have PD : P (diagonal D) := hdiag D (by simp [h])
  suffices H :
    âˆ€ (Lâ‚ Lâ‚‚ : List (transvection_struct n ð•œ)) (E : Matrix n n ð•œ),
      P E â†’ P ((Lâ‚.map to_matrix).Prod â¬ E â¬ (Lâ‚‚.map to_matrix).Prod)
  Â· rw [h]
    apply H L L'
    exact PD
  intro Lâ‚ Lâ‚‚ E PE
  induction' Lâ‚ with t Lâ‚ IH
  Â· simp only [Matrix.one_mul, List.prod_nil, List.map]
    induction' Lâ‚‚ with t Lâ‚‚ IH generalizing E
    Â· simpa
    Â· simp only [â† Matrix.mul_assoc, List.prod_cons, mul_eq_mul, List.map]
      apply IH
      exact hmul _ _ PE (htransvec _)
  Â· simp only [Matrix.mul_assoc, List.prod_cons, mul_eq_mul, List.map] at IHâŠ¢
    exact hmul _ _ (htransvec _) IH
#align matrix.diagonal_transvection_induction Matrix.diagonal_transvection_induction

/- warning: matrix.diagonal_transvection_induction_of_det_ne_zero -> Matrix.diagonal_transvection_induction_of_det_ne_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {ð•œ : Type.{u2}} [_inst_1 : Field.{u2} ð•œ] [_inst_2 : DecidableEq.{succ u1} n] [_inst_5 : Fintype.{u1} n] (P : (Matrix.{u1, u1, u2} n n ð•œ) -> Prop) (M : Matrix.{u1, u1, u2} n n ð•œ), (Ne.{succ u2} ð•œ (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) M) (OfNat.ofNat.{u2} ð•œ 0 (OfNat.mk.{u2} ð•œ 0 (Zero.zero.{u2} ð•œ (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))))))) -> (forall (D : n -> ð•œ), (Ne.{succ u2} ð•œ (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) (Matrix.diagonal.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) D)) (OfNat.ofNat.{u2} ð•œ 0 (OfNat.mk.{u2} ð•œ 0 (Zero.zero.{u2} ð•œ (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))))))) -> (P (Matrix.diagonal.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))) D))) -> (forall (t : Matrix.TransvectionStruct.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1))), P (Matrix.TransvectionStruct.toMatrix.{u2, u1} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) t)) -> (forall (A : Matrix.{u1, u1, u2} n n ð•œ) (B : Matrix.{u1, u1, u2} n n ð•œ), (Ne.{succ u2} ð•œ (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) A) (OfNat.ofNat.{u2} ð•œ 0 (OfNat.mk.{u2} ð•œ 0 (Zero.zero.{u2} ð•œ (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))))))) -> (Ne.{succ u2} ð•œ (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u2} ð•œ (Field.toEuclideanDomain.{u2} ð•œ _inst_1)) B) (OfNat.ofNat.{u2} ð•œ 0 (OfNat.mk.{u2} ð•œ 0 (Zero.zero.{u2} ð•œ (MulZeroClass.toHasZero.{u2} ð•œ (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1))))))))))) -> (P A) -> (P B) -> (P (Matrix.mul.{u2, u1, u1, u1} n n n ð•œ _inst_5 (Distrib.toHasMul.{u2} ð•œ (Ring.toDistrib.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} ð•œ (NonUnitalNonAssocRing.toAddCommGroup.{u2} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u2} ð•œ (Ring.toNonAssocRing.{u2} ð•œ (DivisionRing.toRing.{u2} ð•œ (Field.toDivisionRing.{u2} ð•œ _inst_1)))))) A B))) -> (P M)
but is expected to have type
  forall {n : Type.{u2}} {ð•œ : Type.{u1}} [_inst_1 : Field.{u1} ð•œ] [_inst_2 : DecidableEq.{succ u2} n] [_inst_5 : Fintype.{u2} n] (P : (Matrix.{u2, u2, u1} n n ð•œ) -> Prop) (M : Matrix.{u2, u2, u1} n n ð•œ), (Ne.{succ u1} ð•œ (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) M) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (forall (D : n -> ð•œ), (Ne.{succ u1} ð•œ (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) (Matrix.diagonal.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) D)) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (P (Matrix.diagonal.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1)))) D))) -> (forall (t : Matrix.TransvectionStruct.{u1, u2} n ð•œ), P (Matrix.TransvectionStruct.toMatrix.{u1, u2} n ð•œ (fun (a : n) (b : n) => _inst_2 a b) (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) t)) -> (forall (A : Matrix.{u2, u2, u1} n n ð•œ) (B : Matrix.{u2, u2, u1} n n ð•œ), (Ne.{succ u1} ð•œ (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) A) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (Ne.{succ u1} ð•œ (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_5 ð•œ (EuclideanDomain.toCommRing.{u1} ð•œ (Field.toEuclideanDomain.{u1} ð•œ _inst_1)) B) (OfNat.ofNat.{u1} ð•œ 0 (Zero.toOfNat0.{u1} ð•œ (CommMonoidWithZero.toZero.{u1} ð•œ (CommGroupWithZero.toCommMonoidWithZero.{u1} ð•œ (Semifield.toCommGroupWithZero.{u1} ð•œ (Field.toSemifield.{u1} ð•œ _inst_1))))))) -> (P A) -> (P B) -> (P (Matrix.mul.{u1, u2, u2, u2} n n n ð•œ _inst_5 (NonUnitalNonAssocRing.toMul.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ð•œ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} ð•œ (NonAssocRing.toNonUnitalNonAssocRing.{u1} ð•œ (Ring.toNonAssocRing.{u1} ð•œ (DivisionRing.toRing.{u1} ð•œ (Field.toDivisionRing.{u1} ð•œ _inst_1)))))) A B))) -> (P M)
Case conversion may be inaccurate. Consider using '#align matrix.diagonal_transvection_induction_of_det_ne_zero Matrix.diagonal_transvection_induction_of_det_ne_zeroâ‚“'. -/
/-- Induction principle for invertible matrices based on transvections: if a property is true for
all invertible diagonal matrices, all transvections, and is stable under product of invertible
matrices, then it is true for all invertible matrices. This is the useful way to say that
invertible matrices are generated by invertible diagonal matrices and transvections. -/
theorem diagonal_transvection_induction_of_det_ne_zero (P : Matrix n n ð•œ â†’ Prop) (M : Matrix n n ð•œ)
    (hMdet : det M â‰  0) (hdiag : âˆ€ D : n â†’ ð•œ, det (diagonal D) â‰  0 â†’ P (diagonal D))
    (htransvec : âˆ€ t : TransvectionStruct n ð•œ, P t.toMatrix)
    (hmul : âˆ€ A B, det A â‰  0 â†’ det B â‰  0 â†’ P A â†’ P B â†’ P (A â¬ B)) : P M :=
  by
  let Q : Matrix n n ð•œ â†’ Prop := fun N => det N â‰  0 âˆ§ P N
  have : Q M := by
    apply diagonal_transvection_induction Q M
    Â· intro D hD
      have detD : det (diagonal D) â‰  0 := by
        rw [hD]
        exact hMdet
      exact âŸ¨detD, hdiag _ detDâŸ©
    Â· intro t
      exact âŸ¨by simp, htransvec tâŸ©
    Â· intro A B QA QB
      exact âŸ¨by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2âŸ©
  exact this.2
#align matrix.diagonal_transvection_induction_of_det_ne_zero Matrix.diagonal_transvection_induction_of_det_ne_zero

end Matrix

