/-
Copyright (c) 2021 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang, Eric Wieser

! This file was ported from Lean 3 source module ring_theory.graded_algebra.homogeneous_ideal
! leanprover-community/mathlib commit 4e861f25ba5ceef42ba0712d8ffeb32f38ad6441
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.Ideal.Basic
import Mathbin.RingTheory.Ideal.Operations
import Mathbin.LinearAlgebra.Finsupp
import Mathbin.RingTheory.GradedAlgebra.Basic

/-!
# Homogeneous ideals of a graded algebra

This file defines homogeneous ideals of `graded_ring ùíú` where `ùíú : Œπ ‚Üí submodule R A` and
operations on them.

## Main definitions

For any `I : ideal A`:
* `ideal.is_homogeneous ùíú I`: The property that an ideal is closed under `graded_ring.proj`.
* `homogeneous_ideal ùíú`: The structure extending ideals which satisfy `ideal.is_homogeneous`
* `ideal.homogeneous_core I ùíú`: The largest homogeneous ideal smaller than `I`.
* `ideal.homogeneous_hull I ùíú`: The smallest homogeneous ideal larger than `I`.

## Main statements

* `homogeneous_ideal.complete_lattice`: `ideal.is_homogeneous` is preserved by `‚ä•`, `‚ä§`, `‚äî`, `‚äì`,
  `‚®Ü`, `‚®Ö`, and so the subtype of homogeneous ideals inherits a complete lattice structure.
* `ideal.homogeneous_core.gi`: `ideal.homogeneous_core` forms a galois insertion with coercion.
* `ideal.homogeneous_hull.gi`: `ideal.homogeneous_hull` forms a galois insertion with coercion.

## Implementation notes

We introduce `ideal.homogeneous_core'` earlier than might be expected so that we can get access
to `ideal.is_homogeneous.iff_exists` as quickly as possible.

## Tags

graded algebra, homogeneous
-/


open SetLike DirectSum Set

open BigOperators Pointwise DirectSum

variable {Œπ œÉ R A : Type _}

section HomogeneousDef

variable [Semiring A]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] (ùíú : Œπ ‚Üí œÉ)

variable [DecidableEq Œπ] [AddMonoid Œπ] [GradedRing ùíú]

variable (I : Ideal A)

include A

#print Ideal.IsHomogeneous /-
/-- An `I : ideal A` is homogeneous if for every `r ‚àà I`, all homogeneous components
  of `r` are in `I`.-/
def Ideal.IsHomogeneous : Prop :=
  ‚àÄ (i : Œπ) ‚¶Ér : A‚¶Ñ, r ‚àà I ‚Üí (DirectSum.decompose ùíú r i : A) ‚àà I
#align ideal.is_homogeneous Ideal.IsHomogeneous
-/

#print HomogeneousIdeal /-
/-- For any `semiring A`, we collect the homogeneous ideals of `A` into a type. -/
structure HomogeneousIdeal extends Submodule A A where
  is_homogeneous' : Ideal.IsHomogeneous ùíú to_submodule
#align homogeneous_ideal HomogeneousIdeal
-/

variable {ùíú}

#print HomogeneousIdeal.toIdeal /-
/-- Converting a homogeneous ideal to an ideal-/
def HomogeneousIdeal.toIdeal (I : HomogeneousIdeal ùíú) : Ideal A :=
  I.toSubmodule
#align homogeneous_ideal.to_ideal HomogeneousIdeal.toIdeal
-/

/- warning: homogeneous_ideal.is_homogeneous -> HomogeneousIdeal.isHomogeneous is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6), Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6), Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.is_homogeneous HomogeneousIdeal.isHomogeneous‚Çì'. -/
theorem HomogeneousIdeal.isHomogeneous (I : HomogeneousIdeal ùíú) : I.toIdeal.Homogeneous ùíú :=
  I.is_homogeneous'
#align homogeneous_ideal.is_homogeneous HomogeneousIdeal.isHomogeneous

/- warning: homogeneous_ideal.to_ideal_injective -> HomogeneousIdeal.toIdeal_injective is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú], Function.Injective.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u1, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u2} Œπ] [_inst_5 : AddMonoid.{u2} Œπ] [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú], Function.Injective.{succ u3, succ u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_injective HomogeneousIdeal.toIdeal_injective‚Çì'. -/
theorem HomogeneousIdeal.toIdeal_injective :
    Function.Injective (HomogeneousIdeal.toIdeal : HomogeneousIdeal ùíú ‚Üí Ideal A) :=
  fun ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© (h : x = y) => by simp [h]
#align homogeneous_ideal.to_ideal_injective HomogeneousIdeal.toIdeal_injective

#print HomogeneousIdeal.setLike /-
instance HomogeneousIdeal.setLike : SetLike (HomogeneousIdeal ùíú) A
    where
  coe I := I.toIdeal
  coe_injective' I J h := HomogeneousIdeal.toIdeal_injective <| SetLike.coe_injective h
#align homogeneous_ideal.set_like HomogeneousIdeal.setLike
-/

/- warning: homogeneous_ideal.ext -> HomogeneousIdeal.ext is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6} {J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6}, (Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 J)) -> (Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) I J)
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6} {J : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6}, (Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 J)) -> (Eq.{succ u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) I J)
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.ext HomogeneousIdeal.ext‚Çì'. -/
@[ext]
theorem HomogeneousIdeal.ext {I J : HomogeneousIdeal ùíú} (h : I.toIdeal = J.toIdeal) : I = J :=
  HomogeneousIdeal.toIdeal_injective h
#align homogeneous_ideal.ext HomogeneousIdeal.ext

/- warning: homogeneous_ideal.mem_iff -> HomogeneousIdeal.mem_iff is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6} {x : A}, Iff (Membership.Mem.{u3, u3} A (Ideal.{u3} A _inst_1) (SetLike.hasMem.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))) x (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) (Membership.Mem.{u3, u3} A (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (SetLike.hasMem.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)) x I)
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6} {x : A}, Iff (Membership.mem.{u1, u1} A (Ideal.{u1} A _inst_1) (SetLike.instMembership.{u1, u1} (Ideal.{u1} A _inst_1) A (Submodule.setLike.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1))) x (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) (Membership.mem.{u1, u1} A (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (SetLike.instMembership.{u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) A (HomogeneousIdeal.setLike.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)) x I)
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.mem_iff HomogeneousIdeal.mem_iff‚Çì'. -/
@[simp]
theorem HomogeneousIdeal.mem_iff {I : HomogeneousIdeal ùíú} {x : A} : x ‚àà I.toIdeal ‚Üî x ‚àà I :=
  Iff.rfl
#align homogeneous_ideal.mem_iff HomogeneousIdeal.mem_iff

end HomogeneousDef

section HomogeneousCore

variable [Semiring A]

variable [SetLike œÉ A] (ùíú : Œπ ‚Üí œÉ)

variable (I : Ideal A)

include A

#print Ideal.homogeneousCore' /-
/-- For any `I : ideal A`, not necessarily homogeneous, `I.homogeneous_core' ùíú`
is the largest homogeneous ideal of `A` contained in `I`, as an ideal. -/
def Ideal.homogeneousCore' (I : Ideal A) : Ideal A :=
  Ideal.span (coe '' ((coe : Subtype (Homogeneous ùíú) ‚Üí A) ‚Åª¬π' I))
#align ideal.homogeneous_core' Ideal.homogeneousCore'
-/

/- warning: ideal.homogeneous_core'_mono -> Ideal.homogeneousCore'_mono is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] (ùíú : Œπ -> œÉ), Monotone.{u3, u3} (Ideal.{u3} A _inst_1) (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (Ideal.homogeneousCore'.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 ùíú)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u1, u3} œÉ A] (ùíú : Œπ -> œÉ), Monotone.{u3, u3} (Ideal.{u3} A _inst_1) (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (Ideal.homogeneousCore'.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 ùíú)
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_core'_mono Ideal.homogeneousCore'_mono‚Çì'. -/
theorem Ideal.homogeneousCore'_mono : Monotone (Ideal.homogeneousCore' ùíú) := fun I J I_le_J =>
  Ideal.span_mono <| Set.image_subset _ fun x => @I_le_J _
#align ideal.homogeneous_core'_mono Ideal.homogeneousCore'_mono

/- warning: ideal.homogeneous_core'_le -> Ideal.homogeneousCore'_le is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] (ùíú : Œπ -> œÉ) (I : Ideal.{u3} A _inst_1), LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toHasLe.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (Ideal.homogeneousCore'.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 ùíú I) I
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u1, u3} œÉ A] (ùíú : Œπ -> œÉ) (I : Ideal.{u3} A _inst_1), LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) (Ideal.homogeneousCore'.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 ùíú I) I
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_core'_le Ideal.homogeneousCore'_le‚Çì'. -/
theorem Ideal.homogeneousCore'_le : I.homogeneousCore' ùíú ‚â§ I :=
  Ideal.span_le.2 <| image_preimage_subset _ _
#align ideal.homogeneous_core'_le Ideal.homogeneousCore'_le

end HomogeneousCore

section IsHomogeneousIdealDefs

variable [Semiring A]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] (ùíú : Œπ ‚Üí œÉ)

variable [DecidableEq Œπ] [AddMonoid Œπ] [GradedRing ùíú]

variable (I : Ideal A)

include A

/- warning: ideal.is_homogeneous_iff_forall_subset -> Ideal.isHomogeneous_iff_forall_subset is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u3} A _inst_1), Iff (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (forall (i : Œπ), HasSubset.Subset.{u3} (Set.{u3} A) (Set.hasSubset.{u3} A) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I) (Set.preimage.{u3, u3} A A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6 i)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I)))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u1} A _inst_1), Iff (Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (forall (i : Œπ), HasSubset.Subset.{u1} (Set.{u1} A) (Set.instHasSubsetSet.{u1} A) (SetLike.coe.{u1, u1} (Ideal.{u1} A _inst_1) A (Submodule.setLike.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) I) (Set.preimage.{u1, u1} A A (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) A A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))))) (GradedRing.proj.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6 i)) (SetLike.coe.{u1, u1} (Ideal.{u1} A _inst_1) A (Submodule.setLike.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) I)))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous_iff_forall_subset Ideal.isHomogeneous_iff_forall_subset‚Çì'. -/
theorem Ideal.isHomogeneous_iff_forall_subset :
    I.Homogeneous ùíú ‚Üî ‚àÄ i, (I : Set A) ‚äÜ GradedRing.proj ùíú i ‚Åª¬π' I :=
  Iff.rfl
#align ideal.is_homogeneous_iff_forall_subset Ideal.isHomogeneous_iff_forall_subset

/- warning: ideal.is_homogeneous_iff_subset_Inter -> Ideal.isHomogeneous_iff_subset_iInter is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u3} A _inst_1), Iff (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (HasSubset.Subset.{u3} (Set.{u3} A) (Set.hasSubset.{u3} A) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I) (Set.iInter.{u3, succ u1} A Œπ (fun (i : Œπ) => Set.preimage.{u3, u3} A A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6 i)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I))))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u1} A _inst_1), Iff (Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (HasSubset.Subset.{u1} (Set.{u1} A) (Set.instHasSubsetSet.{u1} A) (SetLike.coe.{u1, u1} (Ideal.{u1} A _inst_1) A (Submodule.setLike.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) I) (Set.iInter.{u1, succ u3} A Œπ (fun (i : Œπ) => Set.preimage.{u1, u1} A A (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) A A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} A A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))))) (GradedRing.proj.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6 i)) (SetLike.coe.{u1, u1} (Ideal.{u1} A _inst_1) A (Submodule.setLike.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) I))))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous_iff_subset_Inter Ideal.isHomogeneous_iff_subset_iInter‚Çì'. -/
theorem Ideal.isHomogeneous_iff_subset_iInter :
    I.Homogeneous ùíú ‚Üî (I : Set A) ‚äÜ ‚ãÇ i, GradedRing.proj ùíú i ‚Åª¬π' ‚ÜëI :=
  subset_iInter_iff.symm
#align ideal.is_homogeneous_iff_subset_Inter Ideal.isHomogeneous_iff_subset_iInter

/- warning: ideal.mul_homogeneous_element_mem_of_mem -> Ideal.mul_homogeneous_element_mem_of_mem is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : Ideal.{u3} A _inst_1} (r : A) (x : A), (SetLike.Homogeneous.{u1, u3, u2} Œπ A œÉ _inst_2 ùíú x) -> (Membership.Mem.{u3, u3} A (Ideal.{u3} A _inst_1) (SetLike.hasMem.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))) x I) -> (forall (j : Œπ), Membership.Mem.{u3, u3} A (Ideal.{u3} A _inst_1) (SetLike.hasMem.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))) (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6 j) (HMul.hMul.{u3, u3, u3} A A A (instHMul.{u3} A (Distrib.toHasMul.{u3} A (NonUnitalNonAssocSemiring.toDistrib.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) r x)) I)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u1, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u2} Œπ] [_inst_5 : AddMonoid.{u2} Œπ] [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : Ideal.{u3} A _inst_1} (r : A) (x : A), (SetLike.Homogeneous.{u2, u3, u1} Œπ A œÉ _inst_2 ùíú x) -> (Membership.mem.{u3, u3} A (Ideal.{u3} A _inst_1) (SetLike.instMembership.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))) x I) -> (forall (j : Œπ), Membership.mem.{u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) (HMul.hMul.{u3, u3, u3} A A A (instHMul.{u3} A (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))) r x)) (Ideal.{u3} A _inst_1) (SetLike.instMembership.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))) (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6 j) (HMul.hMul.{u3, u3, u3} A A A (instHMul.{u3} A (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))) r x)) I)
Case conversion may be inaccurate. Consider using '#align ideal.mul_homogeneous_element_mem_of_mem Ideal.mul_homogeneous_element_mem_of_mem‚Çì'. -/
theorem Ideal.mul_homogeneous_element_mem_of_mem {I : Ideal A} (r x : A) (hx‚ÇÅ : Homogeneous ùíú x)
    (hx‚ÇÇ : x ‚àà I) (j : Œπ) : GradedRing.proj ùíú j (r * x) ‚àà I := by
  classical
    rw [‚Üê DirectSum.sum_support_decompose ùíú r, Finset.sum_mul, map_sum]
    apply Ideal.sum_mem
    intro k hk
    obtain ‚ü®i, hi‚ü© := hx‚ÇÅ
    have mem‚ÇÅ : (DirectSum.decompose ùíú r k : A) * x ‚àà ùíú (k + i) :=
      graded_monoid.mul_mem (SetLike.coe_mem _) hi
    erw [GradedRing.proj_apply, DirectSum.decompose_of_mem ùíú mem‚ÇÅ, coe_of_apply, [anonymous]]
    split_ifs
    ¬∑ exact I.mul_mem_left _ hx‚ÇÇ
    ¬∑ exact I.zero_mem
#align ideal.mul_homogeneous_element_mem_of_mem Ideal.mul_homogeneous_element_mem_of_mem

/- warning: ideal.is_homogeneous_span -> Ideal.homogeneous_span is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (s : Set.{u3} A), (forall (x : A), (Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x s) -> (SetLike.Homogeneous.{u1, u3, u2} Œπ A œÉ _inst_2 ùíú x)) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.span.{u3} A _inst_1 s))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u1, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u2} Œπ] [_inst_5 : AddMonoid.{u2} Œπ] [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (s : Set.{u3} A), (forall (x : A), (Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x s) -> (SetLike.Homogeneous.{u2, u3, u1} Œπ A œÉ _inst_2 ùíú x)) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.span.{u3} A _inst_1 s))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous_span Ideal.homogeneous_span‚Çì'. -/
theorem Ideal.homogeneous_span (s : Set A) (h : ‚àÄ x ‚àà s, Homogeneous ùíú x) :
    (Ideal.span s).Homogeneous ùíú := by
  rintro i r hr
  rw [Ideal.span, Finsupp.span_eq_range_total] at hr
  rw [LinearMap.mem_range] at hr
  obtain ‚ü®s, rfl‚ü© := hr
  rw [Finsupp.total_apply, Finsupp.sum, decompose_sum, Dfinsupp.finset_sum_apply,
    AddSubmonoidClass.coe_finset_sum]
  refine' Ideal.sum_mem _ _
  rintro z hz1
  rw [smul_eq_mul]
  refine' Ideal.mul_homogeneous_element_mem_of_mem ùíú (s z) z _ _ i
  ¬∑ rcases z with ‚ü®z, hz2‚ü©
    apply h _ hz2
  ¬∑ exact Ideal.subset_span z.2
#align ideal.is_homogeneous_span Ideal.homogeneous_span

#print Ideal.homogeneousCore /-
/-- For any `I : ideal A`, not necessarily homogeneous, `I.homogeneous_core' ùíú`
is the largest homogeneous ideal of `A` contained in `I`.-/
def Ideal.homogeneousCore : HomogeneousIdeal ùíú :=
  ‚ü®Ideal.homogeneousCore' ùíú I,
    Ideal.homogeneous_span _ _ fun x h =>
      by
      rw [Subtype.image_preimage_coe] at h
      exact h.2‚ü©
#align ideal.homogeneous_core Ideal.homogeneousCore
-/

/- warning: ideal.homogeneous_core_mono -> Ideal.homogeneousCore_mono is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú], Monotone.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (SetLike.partialOrder.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6))) (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u1, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u2} Œπ] [_inst_5 : AddMonoid.{u2} Œπ] [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú], Monotone.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (SetLike.instPartialOrder.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) A (HomogeneousIdeal.setLike.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6))) (Ideal.homogeneousCore.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_core_mono Ideal.homogeneousCore_mono‚Çì'. -/
theorem Ideal.homogeneousCore_mono : Monotone (Ideal.homogeneousCore ùíú) :=
  Ideal.homogeneousCore'_mono ùíú
#align ideal.homogeneous_core_mono Ideal.homogeneousCore_mono

/- warning: ideal.to_ideal_homogeneous_core_le -> Ideal.toIdeal_homogeneousCore_le is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u3} A _inst_1), LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toHasLe.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u1, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u2} Œπ] [_inst_5 : AddMonoid.{u2} Œπ] [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u3} A _inst_1), LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.homogeneousCore.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I
Case conversion may be inaccurate. Consider using '#align ideal.to_ideal_homogeneous_core_le Ideal.toIdeal_homogeneousCore_le‚Çì'. -/
theorem Ideal.toIdeal_homogeneousCore_le : (I.homogeneousCore ùíú).toIdeal ‚â§ I :=
  Ideal.homogeneousCore'_le ùíú I
#align ideal.to_ideal_homogeneous_core_le Ideal.toIdeal_homogeneousCore_le

variable {ùíú I}

/- warning: ideal.mem_homogeneous_core_of_is_homogeneous_of_mem -> Ideal.mem_homogeneousCore_of_homogeneous_of_mem is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : Ideal.{u3} A _inst_1} {x : A}, (SetLike.Homogeneous.{u1, u3, u2} Œπ A œÉ _inst_2 ùíú x) -> (Membership.Mem.{u3, u3} A (Ideal.{u3} A _inst_1) (SetLike.hasMem.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))) x I) -> (Membership.Mem.{u3, u3} A (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (SetLike.hasMem.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)) x (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u1}} {A : Type.{u2}} [_inst_1 : Semiring.{u2} A] [_inst_2 : SetLike.{u1, u2} œÉ A] [_inst_3 : AddSubmonoidClass.{u1, u2} œÉ A (AddMonoid.toAddZeroClass.{u2} A (AddMonoidWithOne.toAddMonoid.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u2, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : Ideal.{u2} A _inst_1} {x : A}, (SetLike.Homogeneous.{u3, u2, u1} Œπ A œÉ _inst_2 ùíú x) -> (Membership.mem.{u2, u2} A (Ideal.{u2} A _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} A _inst_1) A (Submodule.setLike.{u2, u2} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_1))) (Semiring.toModule.{u2} A _inst_1))) x I) -> (Membership.mem.{u2, u2} A (HomogeneousIdeal.{u3, u1, u2} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (SetLike.instMembership.{u2, u2} (HomogeneousIdeal.{u3, u1, u2} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) A (HomogeneousIdeal.setLike.{u3, u1, u2} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6)) x (Ideal.homogeneousCore.{u3, u1, u2} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I))
Case conversion may be inaccurate. Consider using '#align ideal.mem_homogeneous_core_of_is_homogeneous_of_mem Ideal.mem_homogeneousCore_of_homogeneous_of_mem‚Çì'. -/
theorem Ideal.mem_homogeneousCore_of_homogeneous_of_mem {x : A} (h : SetLike.Homogeneous ùíú x)
    (hmem : x ‚àà I) : x ‚àà I.homogeneousCore ùíú :=
  Ideal.subset_span ‚ü®‚ü®x, h‚ü©, hmem, rfl‚ü©
#align ideal.mem_homogeneous_core_of_is_homogeneous_of_mem Ideal.mem_homogeneousCore_of_homogeneous_of_mem

/- warning: ideal.is_homogeneous.to_ideal_homogeneous_core_eq_self -> Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : Ideal.{u3} A _inst_1}, (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) -> (Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I)
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] {I : Ideal.{u1} A _inst_1}, (Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) -> (Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.homogeneousCore.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I)
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.to_ideal_homogeneous_core_eq_self Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self‚Çì'. -/
theorem Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self (h : I.Homogeneous ùíú) :
    (I.homogeneousCore ùíú).toIdeal = I :=
  by
  apply le_antisymm (I.homogeneous_core'_le ùíú) _
  intro x hx
  classical
    rw [‚Üê DirectSum.sum_support_decompose ùíú x]
    exact Ideal.sum_mem _ fun j hj => Ideal.subset_span ‚ü®‚ü®_, is_homogeneous_coe _‚ü©, h _ hx, rfl‚ü©
#align ideal.is_homogeneous.to_ideal_homogeneous_core_eq_self Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self

/- warning: homogeneous_ideal.to_ideal_homogeneous_core_eq_self -> HomogeneousIdeal.toIdeal_homogeneousCore_eq_self is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6), Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] {ùíú : Œπ -> œÉ} [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6), Eq.{succ u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6) (Ideal.homogeneousCore.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_homogeneous_core_eq_self HomogeneousIdeal.toIdeal_homogeneousCore_eq_self‚Çì'. -/
@[simp]
theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self (I : HomogeneousIdeal ùíú) :
    I.toIdeal.homogeneousCore ùíú = I := by
  ext1 <;> convert Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self I.is_homogeneous
#align homogeneous_ideal.to_ideal_homogeneous_core_eq_self HomogeneousIdeal.toIdeal_homogeneousCore_eq_self

variable (ùíú I)

/- warning: ideal.is_homogeneous.iff_eq -> Ideal.IsHomogeneous.iff_eq is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u3} A _inst_1), Iff (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I)
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u1} A _inst_1), Iff (Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 (Ideal.homogeneousCore.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I)) I)
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.iff_eq Ideal.IsHomogeneous.iff_eq‚Çì'. -/
theorem Ideal.IsHomogeneous.iff_eq : I.Homogeneous ùíú ‚Üî (I.homogeneousCore ùíú).toIdeal = I :=
  ‚ü®fun hI => hI.toIdeal_homogeneousCore_eq_self, fun hI => hI ‚ñ∏ (Ideal.homogeneousCore ùíú I).2‚ü©
#align ideal.is_homogeneous.iff_eq Ideal.IsHomogeneous.iff_eq

/- warning: ideal.is_homogeneous.iff_exists -> Ideal.IsHomogeneous.iff_exists is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : SetLike.{u2, u3} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u1} Œπ] [_inst_5 : AddMonoid.{u1} Œπ] [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u3} A _inst_1), Iff (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (Exists.{succ u3} (Set.{u3} (coeSort.{succ u3, succ (succ u3)} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6)))) (fun (S : Set.{u3} (coeSort.{succ u3, succ (succ u3)} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6)))) => Eq.{succ u3} (Ideal.{u3} A _inst_1) I (Ideal.span.{u3} A _inst_1 (Set.image.{u3, u3} (coeSort.{succ u3, succ (succ u3)} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))) A ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))) A (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))) A (CoeTC‚Çì.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))) A (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))) A (coeSubtype.{succ u3} A (fun (x : A) => Membership.Mem.{u3, u3} A (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) (SetLike.hasMem.{u3, u3} (Submonoid.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))) A (Submonoid.setLike.{u3} A (Monoid.toMulOneClass.{u3} A (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1))))) x (SetLike.homogeneousSubmonoid.{u1, u3, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)) ùíú (GradedRing.to_gradedMonoid.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6)))))))) S))))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : SetLike.{u2, u1} œÉ A] [_inst_3 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_2] (ùíú : Œπ -> œÉ) [_inst_4 : DecidableEq.{succ u3} Œπ] [_inst_5 : AddMonoid.{u3} Œπ] [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú] (I : Ideal.{u1} A _inst_1), Iff (Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_2 _inst_3 ùíú (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_6 I) (Exists.{succ u1} (Set.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Submonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) A (Submonoid.instSetLikeSubmonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1))))) x (SetLike.homogeneousSubmonoid.{u3, u1, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)) ùíú (GradedRing.toGradedMonoid.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))))) (fun (S : Set.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Submonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) A (Submonoid.instSetLikeSubmonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1))))) x (SetLike.homogeneousSubmonoid.{u3, u1, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)) ùíú (GradedRing.toGradedMonoid.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))))) => Eq.{succ u1} (Ideal.{u1} A _inst_1) I (Ideal.span.{u1} A _inst_1 (Set.image.{u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Submonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) A (Submonoid.instSetLikeSubmonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1))))) x (SetLike.homogeneousSubmonoid.{u3, u1, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)) ùíú (GradedRing.toGradedMonoid.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6)))) A (Subtype.val.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x (SetLike.coe.{u1, u1} (Submonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) A (Submonoid.instSetLikeSubmonoid.{u1} A (Monoid.toMulOneClass.{u1} A (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)))) (SetLike.homogeneousSubmonoid.{u3, u1, u2} Œπ A œÉ _inst_2 _inst_5 (MonoidWithZero.toMonoid.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_1)) ùíú (GradedRing.toGradedMonoid.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_4 a b) _inst_5 _inst_1 _inst_2 _inst_3 ùíú _inst_6))))) S))))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.iff_exists Ideal.IsHomogeneous.iff_exists‚Çì'. -/
theorem Ideal.IsHomogeneous.iff_exists :
    I.Homogeneous ùíú ‚Üî ‚àÉ S : Set (homogeneousSubmonoid ùíú), I = Ideal.span (coe '' S) :=
  by
  rw [Ideal.IsHomogeneous.iff_eq, eq_comm]
  exact ((set.image_preimage.compose (Submodule.gi _ _).gc).exists_eq_l _).symm
#align ideal.is_homogeneous.iff_exists Ideal.IsHomogeneous.iff_exists

end IsHomogeneousIdealDefs

/-! ### Operations

In this section, we show that `ideal.is_homogeneous` is preserved by various notations, then use
these results to provide these notation typeclasses for `homogeneous_ideal`. -/


section Operations

section Semiring

variable [Semiring A] [DecidableEq Œπ] [AddMonoid Œπ]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] (ùíú : Œπ ‚Üí œÉ) [GradedRing ùíú]

include A

namespace Ideal.IsHomogeneous

/- warning: ideal.is_homogeneous.bot -> Ideal.IsHomogeneous.bot is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Bot.bot.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasBot.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Bot.bot.{u1} (Ideal.{u1} A _inst_1) (Submodule.instBotSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.bot Ideal.IsHomogeneous.bot‚Çì'. -/
theorem bot : Ideal.IsHomogeneous ùíú ‚ä• := fun i r hr =>
  by
  simp only [Ideal.mem_bot] at hr
  rw [hr, decompose_zero, zero_apply]
  apply Ideal.zero_mem
#align ideal.is_homogeneous.bot Ideal.IsHomogeneous.bot

/- warning: ideal.is_homogeneous.top -> Ideal.IsHomogeneous.top is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Top.top.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasTop.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Top.top.{u1} (Ideal.{u1} A _inst_1) (Submodule.instTopSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.top Ideal.IsHomogeneous.top‚Çì'. -/
theorem top : Ideal.IsHomogeneous ùíú ‚ä§ := fun i r hr => by simp only [Submodule.mem_top]
#align ideal.is_homogeneous.top Ideal.IsHomogeneous.top

variable {ùíú}

/- warning: ideal.is_homogeneous.inf -> Ideal.IsHomogeneous.inf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {I : Ideal.{u3} A _inst_1} {J : Ideal.{u3} A _inst_1}, (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Inf.inf.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I J))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {I : Ideal.{u3} A _inst_1} {J : Ideal.{u3} A _inst_1}, (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Inf.inf.{u3} (Ideal.{u3} A _inst_1) (Submodule.instInfSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I J))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.inf Ideal.IsHomogeneous.inf‚Çì'. -/
theorem inf {I J : Ideal A} (HI : I.Homogeneous ùíú) (HJ : J.Homogeneous ùíú) : (I ‚äì J).Homogeneous ùíú :=
  fun i r hr => ‚ü®HI _ hr.1, HJ _ hr.2‚ü©
#align ideal.is_homogeneous.inf Ideal.IsHomogeneous.inf

/- warning: ideal.is_homogeneous.sup -> Ideal.IsHomogeneous.sup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {I : Ideal.{u3} A _inst_1} {J : Ideal.{u3} A _inst_1}, (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Sup.sup.{u3} (Ideal.{u3} A _inst_1) (SemilatticeSup.toHasSup.{u3} (Ideal.{u3} A _inst_1) (Lattice.toSemilatticeSup.{u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) I J))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {I : Ideal.{u3} A _inst_1} {J : Ideal.{u3} A _inst_1}, (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Sup.sup.{u3} (Ideal.{u3} A _inst_1) (SemilatticeSup.toSup.{u3} (Ideal.{u3} A _inst_1) (Lattice.toSemilatticeSup.{u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.sup Ideal.IsHomogeneous.sup‚Çì'. -/
theorem sup {I J : Ideal A} (HI : I.Homogeneous ùíú) (HJ : J.Homogeneous ùíú) : (I ‚äî J).Homogeneous ùíú :=
  by
  rw [iff_exists] at HI HJ‚ä¢
  obtain ‚ü®‚ü®s‚ÇÅ, rfl‚ü©, ‚ü®s‚ÇÇ, rfl‚ü©‚ü© := HI, HJ
  refine' ‚ü®s‚ÇÅ ‚à™ s‚ÇÇ, _‚ü©
  rw [Set.image_union]
  exact (Submodule.span_union _ _).symm
#align ideal.is_homogeneous.sup Ideal.IsHomogeneous.sup

/- warning: ideal.is_homogeneous.supr -> Ideal.IsHomogeneous.iSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {f : Œ∫ -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫), Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i)) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u3, u4} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œ∫ (fun (i : Œ∫) => f i)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {f : Œ∫ -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫), Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i)) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u3, u4} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œ∫ (fun (i : Œ∫) => f i)))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.supr Ideal.IsHomogeneous.iSup‚Çì'. -/
protected theorem iSup {Œ∫ : Sort _} {f : Œ∫ ‚Üí Ideal A} (h : ‚àÄ i, (f i).Homogeneous ùíú) :
    (‚®Ü i, f i).Homogeneous ùíú := by
  simp_rw [iff_exists] at h‚ä¢
  choose s hs using h
  refine' ‚ü®‚ãÉ i, s i, _‚ü©
  simp_rw [Set.image_iUnion, Ideal.span_iUnion]
  congr
  exact funext hs
#align ideal.is_homogeneous.supr Ideal.IsHomogeneous.iSup

/- warning: ideal.is_homogeneous.infi -> Ideal.IsHomogeneous.iInf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {f : Œ∫ -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫), Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i)) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u3, u4} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) Œ∫ (fun (i : Œ∫) => f i)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {f : Œ∫ -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫), Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i)) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u3, u4} (Ideal.{u3} A _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) Œ∫ (fun (i : Œ∫) => f i)))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.infi Ideal.IsHomogeneous.iInf‚Çì'. -/
protected theorem iInf {Œ∫ : Sort _} {f : Œ∫ ‚Üí Ideal A} (h : ‚àÄ i, (f i).Homogeneous ùíú) :
    (‚®Ö i, f i).Homogeneous ùíú := by
  intro i x hx
  simp only [Ideal.mem_iInf] at hx‚ä¢
  exact fun j => h _ _ (hx j)
#align ideal.is_homogeneous.infi Ideal.IsHomogeneous.iInf

/- warning: ideal.is_homogeneous.supr‚ÇÇ -> Ideal.IsHomogeneous.iSup‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {Œ∫' : Œ∫ -> Sort.{u5}} {f : forall (i : Œ∫), (Œ∫' i) -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫) (j : Œ∫' i), Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i j)) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u3, u4} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œ∫ (fun (i : Œ∫) => iSup.{u3, u5} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (Œ∫' i) (fun (j : Œ∫' i) => f i j))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u5}} {Œ∫' : Œ∫ -> Sort.{u4}} {f : forall (i : Œ∫), (Œ∫' i) -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫) (j : Œ∫' i), Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i j)) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u3, u5} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œ∫ (fun (i : Œ∫) => iSup.{u3, u4} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (Œ∫' i) (fun (j : Œ∫' i) => f i j))))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.supr‚ÇÇ Ideal.IsHomogeneous.iSup‚ÇÇ‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
theorem iSup‚ÇÇ {Œ∫ : Sort _} {Œ∫' : Œ∫ ‚Üí Sort _} {f : ‚àÄ i, Œ∫' i ‚Üí Ideal A}
    (h : ‚àÄ i j, (f i j).Homogeneous ùíú) : (‚®Ü (i) (j), f i j).Homogeneous ùíú :=
  IsHomogeneous.iSup fun i => IsHomogeneous.iSup <| h i
#align ideal.is_homogeneous.supr‚ÇÇ Ideal.IsHomogeneous.iSup‚ÇÇ

/- warning: ideal.is_homogeneous.infi‚ÇÇ -> Ideal.IsHomogeneous.iInf‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {Œ∫' : Œ∫ -> Sort.{u5}} {f : forall (i : Œ∫), (Œ∫' i) -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫) (j : Œ∫' i), Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i j)) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u3, u4} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) Œ∫ (fun (i : Œ∫) => iInf.{u3, u5} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (Œ∫' i) (fun (j : Œ∫' i) => f i j))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u5}} {Œ∫' : Œ∫ -> Sort.{u4}} {f : forall (i : Œ∫), (Œ∫' i) -> (Ideal.{u3} A _inst_1)}, (forall (i : Œ∫) (j : Œ∫' i), Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (f i j)) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u3, u5} (Ideal.{u3} A _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) Œ∫ (fun (i : Œ∫) => iInf.{u3, u4} (Ideal.{u3} A _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (Œ∫' i) (fun (j : Œ∫' i) => f i j))))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.infi‚ÇÇ Ideal.IsHomogeneous.iInf‚ÇÇ‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
theorem iInf‚ÇÇ {Œ∫ : Sort _} {Œ∫' : Œ∫ ‚Üí Sort _} {f : ‚àÄ i, Œ∫' i ‚Üí Ideal A}
    (h : ‚àÄ i j, (f i j).Homogeneous ùíú) : (‚®Ö (i) (j), f i j).Homogeneous ùíú :=
  IsHomogeneous.iInf fun i => IsHomogeneous.iInf <| h i
#align ideal.is_homogeneous.infi‚ÇÇ Ideal.IsHomogeneous.iInf‚ÇÇ

/- warning: ideal.is_homogeneous.Sup -> Ideal.IsHomogeneous.sSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {‚Ñê : Set.{u3} (Ideal.{u3} A _inst_1)}, (forall (I : Ideal.{u3} A _inst_1), (Membership.Mem.{u3, u3} (Ideal.{u3} A _inst_1) (Set.{u3} (Ideal.{u3} A _inst_1)) (Set.hasMem.{u3} (Ideal.{u3} A _inst_1)) I ‚Ñê) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I)) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (SupSet.sSup.{u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) ‚Ñê))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {‚Ñê : Set.{u3} (Ideal.{u3} A _inst_1)}, (forall (I : Ideal.{u3} A _inst_1), (Membership.mem.{u3, u3} (Ideal.{u3} A _inst_1) (Set.{u3} (Ideal.{u3} A _inst_1)) (Set.instMembershipSet.{u3} (Ideal.{u3} A _inst_1)) I ‚Ñê) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I)) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (SupSet.sSup.{u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) ‚Ñê))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.Sup Ideal.IsHomogeneous.sSup‚Çì'. -/
theorem sSup {‚Ñê : Set (Ideal A)} (h : ‚àÄ I ‚àà ‚Ñê, Ideal.IsHomogeneous ùíú I) : (sSup ‚Ñê).Homogeneous ùíú :=
  by
  rw [sSup_eq_iSup]
  exact supr‚ÇÇ h
#align ideal.is_homogeneous.Sup Ideal.IsHomogeneous.sSup

/- warning: ideal.is_homogeneous.Inf -> Ideal.IsHomogeneous.sInf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {‚Ñê : Set.{u3} (Ideal.{u3} A _inst_1)}, (forall (I : Ideal.{u3} A _inst_1), (Membership.Mem.{u3, u3} (Ideal.{u3} A _inst_1) (Set.{u3} (Ideal.{u3} A _inst_1)) (Set.hasMem.{u3} (Ideal.{u3} A _inst_1)) I ‚Ñê) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I)) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (InfSet.sInf.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) ‚Ñê))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {‚Ñê : Set.{u3} (Ideal.{u3} A _inst_1)}, (forall (I : Ideal.{u3} A _inst_1), (Membership.mem.{u3, u3} (Ideal.{u3} A _inst_1) (Set.{u3} (Ideal.{u3} A _inst_1)) (Set.instMembershipSet.{u3} (Ideal.{u3} A _inst_1)) I ‚Ñê) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I)) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (InfSet.sInf.{u3} (Ideal.{u3} A _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) ‚Ñê))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.Inf Ideal.IsHomogeneous.sInf‚Çì'. -/
theorem sInf {‚Ñê : Set (Ideal A)} (h : ‚àÄ I ‚àà ‚Ñê, Ideal.IsHomogeneous ùíú I) : (sInf ‚Ñê).Homogeneous ùíú :=
  by
  rw [sInf_eq_iInf]
  exact infi‚ÇÇ h
#align ideal.is_homogeneous.Inf Ideal.IsHomogeneous.sInf

end Ideal.IsHomogeneous

variable {ùíú}

namespace HomogeneousIdeal

instance : PartialOrder (HomogeneousIdeal ùíú) :=
  SetLike.partialOrder

instance : Top (HomogeneousIdeal ùíú) :=
  ‚ü®‚ü®‚ä§, Ideal.IsHomogeneous.top ùíú‚ü©‚ü©

instance : Bot (HomogeneousIdeal ùíú) :=
  ‚ü®‚ü®‚ä•, Ideal.IsHomogeneous.bot ùíú‚ü©‚ü©

instance : Sup (HomogeneousIdeal ùíú) :=
  ‚ü®fun I J => ‚ü®_, I.Homogeneous.sup J.Homogeneous‚ü©‚ü©

instance : Inf (HomogeneousIdeal ùíú) :=
  ‚ü®fun I J => ‚ü®_, I.Homogeneous.inf J.Homogeneous‚ü©‚ü©

instance : SupSet (HomogeneousIdeal ùíú) :=
  ‚ü®fun S => ‚ü®‚®Ü s ‚àà S, toIdeal s, Ideal.IsHomogeneous.iSup‚ÇÇ fun s _ => s.Homogeneous‚ü©‚ü©

instance : InfSet (HomogeneousIdeal ùíú) :=
  ‚ü®fun S => ‚ü®‚®Ö s ‚àà S, toIdeal s, Ideal.IsHomogeneous.iInf‚ÇÇ fun s _ => s.Homogeneous‚ü©‚ü©

/- warning: homogeneous_ideal.coe_top -> HomogeneousIdeal.coe_top is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Set.{u3} A) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) (Top.top.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasTop.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Set.univ.{u3} A)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Set.{u3} A) (SetLike.coe.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Top.top.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instTopHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Set.univ.{u3} A)
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.coe_top HomogeneousIdeal.coe_top‚Çì'. -/
@[simp]
theorem coe_top : ((‚ä§ : HomogeneousIdeal ùíú) : Set A) = univ :=
  rfl
#align homogeneous_ideal.coe_top HomogeneousIdeal.coe_top

/- warning: homogeneous_ideal.coe_bot -> HomogeneousIdeal.coe_bot is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Set.{u3} A) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) (Bot.bot.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasBot.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (OfNat.ofNat.{u3} (Set.{u3} A) 0 (OfNat.mk.{u3} (Set.{u3} A) 0 (Zero.zero.{u3} (Set.{u3} A) (Set.zero.{u3} A (MulZeroClass.toHasZero.{u3} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Set.{u3} A) (SetLike.coe.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Bot.bot.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instBotHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (OfNat.ofNat.{u3} (Set.{u3} A) 0 (Zero.toOfNat0.{u3} (Set.{u3} A) (Set.zero.{u3} A (MonoidWithZero.toZero.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_1)))))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.coe_bot HomogeneousIdeal.coe_bot‚Çì'. -/
@[simp]
theorem coe_bot : ((‚ä• : HomogeneousIdeal ùíú) : Set A) = 0 :=
  rfl
#align homogeneous_ideal.coe_bot HomogeneousIdeal.coe_bot

/- warning: homogeneous_ideal.coe_sup -> HomogeneousIdeal.coe_sup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u3} (Set.{u3} A) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) (Sup.sup.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (HAdd.hAdd.{u3, u3, u3} (Set.{u3} A) (Set.{u3} A) (Set.{u3} A) (instHAdd.{u3} (Set.{u3} A) (Set.add.{u3} A (Distrib.toHasAdd.{u3} A (NonUnitalNonAssocSemiring.toDistrib.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) I) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) J))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u1} (Set.{u1} A) (SetLike.coe.{u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Sup.sup.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (HAdd.hAdd.{u1, u1, u1} (Set.{u1} A) (Set.{u1} A) (Set.{u1} A) (instHAdd.{u1} (Set.{u1} A) (Set.add.{u1} A (Distrib.toAdd.{u1} A (NonUnitalNonAssocSemiring.toDistrib.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1)))))) (SetLike.coe.{u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) I) (SetLike.coe.{u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) J))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.coe_sup HomogeneousIdeal.coe_sup‚Çì'. -/
@[simp]
theorem coe_sup (I J : HomogeneousIdeal ùíú) : ‚Üë(I ‚äî J) = (I + J : Set A) :=
  Submodule.coe_sup _ _
#align homogeneous_ideal.coe_sup HomogeneousIdeal.coe_sup

/- warning: homogeneous_ideal.coe_inf -> HomogeneousIdeal.coe_inf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u3} (Set.{u3} A) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) (Inf.inf.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasInf.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (Inter.inter.{u3} (Set.{u3} A) (Set.hasInter.{u3} A) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) I) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)))) J))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u1} (Set.{u1} A) (SetLike.coe.{u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Inf.inf.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instInfHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (Inter.inter.{u1} (Set.{u1} A) (Set.instInterSet.{u1} A) (SetLike.coe.{u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) I) (SetLike.coe.{u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) A (HomogeneousIdeal.setLike.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) J))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.coe_inf HomogeneousIdeal.coe_inf‚Çì'. -/
@[simp]
theorem coe_inf (I J : HomogeneousIdeal ùíú) : (‚Üë(I ‚äì J) : Set A) = I ‚à© J :=
  rfl
#align homogeneous_ideal.coe_inf HomogeneousIdeal.coe_inf

/- warning: homogeneous_ideal.to_ideal_top -> HomogeneousIdeal.toIdeal_top is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Top.top.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasTop.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Top.top.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasTop.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Top.top.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instTopHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Top.top.{u3} (Ideal.{u3} A _inst_1) (Submodule.instTopSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_top HomogeneousIdeal.toIdeal_top‚Çì'. -/
@[simp]
theorem toIdeal_top : (‚ä§ : HomogeneousIdeal ùíú).toIdeal = (‚ä§ : Ideal A) :=
  rfl
#align homogeneous_ideal.to_ideal_top HomogeneousIdeal.toIdeal_top

/- warning: homogeneous_ideal.to_ideal_bot -> HomogeneousIdeal.toIdeal_bot is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Bot.bot.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasBot.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Bot.bot.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasBot.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Bot.bot.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instBotHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Bot.bot.{u3} (Ideal.{u3} A _inst_1) (Submodule.instBotSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_bot HomogeneousIdeal.toIdeal_bot‚Çì'. -/
@[simp]
theorem toIdeal_bot : (‚ä• : HomogeneousIdeal ùíú).toIdeal = (‚ä• : Ideal A) :=
  rfl
#align homogeneous_ideal.to_ideal_bot HomogeneousIdeal.toIdeal_bot

/- warning: homogeneous_ideal.to_ideal_sup -> HomogeneousIdeal.toIdeal_sup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Sup.sup.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (Sup.sup.{u3} (Ideal.{u3} A _inst_1) (SemilatticeSup.toHasSup.{u3} (Ideal.{u3} A _inst_1) (Lattice.toSemilatticeSup.{u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Sup.sup.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (Sup.sup.{u1} (Ideal.{u1} A _inst_1) (SemilatticeSup.toSup.{u1} (Ideal.{u1} A _inst_1) (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} A _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} A _inst_1) (Submodule.completeLattice.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)))))) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_sup HomogeneousIdeal.toIdeal_sup‚Çì'. -/
@[simp]
theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=
  rfl
#align homogeneous_ideal.to_ideal_sup HomogeneousIdeal.toIdeal_sup

/- warning: homogeneous_ideal.to_ideal_inf -> HomogeneousIdeal.toIdeal_inf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Inf.inf.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasInf.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (Inf.inf.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Inf.inf.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instInfHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) I J)) (Inf.inf.{u1} (Ideal.{u1} A _inst_1) (Submodule.instInfSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_inf HomogeneousIdeal.toIdeal_inf‚Çì'. -/
@[simp]
theorem toIdeal_inf (I J : HomogeneousIdeal ùíú) : (I ‚äì J).toIdeal = I.toIdeal ‚äì J.toIdeal :=
  rfl
#align homogeneous_ideal.to_ideal_inf HomogeneousIdeal.toIdeal_inf

/- warning: homogeneous_ideal.to_ideal_Sup -> HomogeneousIdeal.toIdeal_sSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (‚Ñê : Set.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (SupSet.sSup.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) ‚Ñê)) (iSup.{u3, succ u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (s : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => iSup.{u3, 0} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (Membership.Mem.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.hasMem.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) (fun (H : Membership.Mem.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.hasMem.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) => HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 s)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (‚Ñê : Set.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (SupSet.sSup.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupSetHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) ‚Ñê)) (iSup.{u3, succ u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (s : HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => iSup.{u3, 0} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (Membership.mem.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.instMembershipSet.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) (fun (H : Membership.mem.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.instMembershipSet.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) => HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 s)))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_Sup HomogeneousIdeal.toIdeal_sSup‚Çì'. -/
@[simp]
theorem toIdeal_sSup (‚Ñê : Set (HomogeneousIdeal ùíú)) : (sSup ‚Ñê).toIdeal = ‚®Ü s ‚àà ‚Ñê, toIdeal s :=
  rfl
#align homogeneous_ideal.to_ideal_Sup HomogeneousIdeal.toIdeal_sSup

/- warning: homogeneous_ideal.to_ideal_Inf -> HomogeneousIdeal.toIdeal_sInf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (‚Ñê : Set.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (InfSet.sInf.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasInf.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) ‚Ñê)) (iInf.{u3, succ u3} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (s : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => iInf.{u3, 0} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (Membership.Mem.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.hasMem.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) (fun (H : Membership.Mem.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.hasMem.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) => HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 s)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (‚Ñê : Set.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (InfSet.sInf.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instInfSetHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) ‚Ñê)) (iInf.{u3, succ u3} (Ideal.{u3} A _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (s : HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => iInf.{u3, 0} (Ideal.{u3} A _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (Membership.mem.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.instMembershipSet.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) (fun (H : Membership.mem.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Set.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) (Set.instMembershipSet.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)) s ‚Ñê) => HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 s)))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_Inf HomogeneousIdeal.toIdeal_sInf‚Çì'. -/
@[simp]
theorem toIdeal_sInf (‚Ñê : Set (HomogeneousIdeal ùíú)) : (sInf ‚Ñê).toIdeal = ‚®Ö s ‚àà ‚Ñê, toIdeal s :=
  rfl
#align homogeneous_ideal.to_ideal_Inf HomogeneousIdeal.toIdeal_sInf

/- warning: homogeneous_ideal.to_ideal_supr -> HomogeneousIdeal.toIdeal_iSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} (s : Œ∫ -> (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u3, u4} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => s i))) (iSup.{u3, u4} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œ∫ (fun (i : Œ∫) => HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i)))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} (s : Œ∫ -> (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u1, u4} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupSetHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => s i))) (iSup.{u1, u4} (Ideal.{u1} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Ideal.{u1} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} A _inst_1) (Submodule.completeLattice.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)))) Œ∫ (fun (i : Œ∫) => HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i)))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_supr HomogeneousIdeal.toIdeal_iSup‚Çì'. -/
@[simp]
theorem toIdeal_iSup {Œ∫ : Sort _} (s : Œ∫ ‚Üí HomogeneousIdeal ùíú) :
    (‚®Ü i, s i).toIdeal = ‚®Ü i, (s i).toIdeal := by rw [iSup, to_ideal_Sup, iSup_range]
#align homogeneous_ideal.to_ideal_supr HomogeneousIdeal.toIdeal_iSup

/- warning: homogeneous_ideal.to_ideal_infi -> HomogeneousIdeal.toIdeal_iInf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} (s : Œ∫ -> (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u3, u4} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasInf.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => s i))) (iInf.{u3, u4} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) Œ∫ (fun (i : Œ∫) => HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i)))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} (s : Œ∫ -> (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u1, u4} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instInfSetHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => s i))) (iInf.{u1, u4} (Ideal.{u1} A _inst_1) (Submodule.instInfSetSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) Œ∫ (fun (i : Œ∫) => HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i)))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_infi HomogeneousIdeal.toIdeal_iInf‚Çì'. -/
@[simp]
theorem toIdeal_iInf {Œ∫ : Sort _} (s : Œ∫ ‚Üí HomogeneousIdeal ùíú) :
    (‚®Ö i, s i).toIdeal = ‚®Ö i, (s i).toIdeal := by rw [iInf, to_ideal_Inf, iInf_range]
#align homogeneous_ideal.to_ideal_infi HomogeneousIdeal.toIdeal_iInf

/- warning: homogeneous_ideal.to_ideal_supr‚ÇÇ -> HomogeneousIdeal.toIdeal_iSup‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {Œ∫' : Œ∫ -> Sort.{u5}} (s : forall (i : Œ∫), (Œ∫' i) -> (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u3, u4} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => iSup.{u3, u5} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (Œ∫' i) (fun (j : Œ∫' i) => s i j)))) (iSup.{u3, u4} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œ∫ (fun (i : Œ∫) => iSup.{u3, u5} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (Œ∫' i) (fun (j : Œ∫' i) => HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i j))))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u5}} {Œ∫' : Œ∫ -> Sort.{u4}} (s : forall (i : Œ∫), (Œ∫' i) -> (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iSup.{u1, u5} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupSetHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => iSup.{u1, u4} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupSetHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (Œ∫' i) (fun (j : Œ∫' i) => s i j)))) (iSup.{u1, u5} (Ideal.{u1} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Ideal.{u1} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} A _inst_1) (Submodule.completeLattice.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)))) Œ∫ (fun (i : Œ∫) => iSup.{u1, u4} (Ideal.{u1} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Ideal.{u1} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} A _inst_1) (Submodule.completeLattice.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)))) (Œ∫' i) (fun (j : Œ∫' i) => HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i j))))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_supr‚ÇÇ HomogeneousIdeal.toIdeal_iSup‚ÇÇ‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem toIdeal_iSup‚ÇÇ {Œ∫ : Sort _} {Œ∫' : Œ∫ ‚Üí Sort _} (s : ‚àÄ i, Œ∫' i ‚Üí HomogeneousIdeal ùíú) :
    (‚®Ü (i) (j), s i j).toIdeal = ‚®Ü (i) (j), (s i j).toIdeal := by simp_rw [to_ideal_supr]
#align homogeneous_ideal.to_ideal_supr‚ÇÇ HomogeneousIdeal.toIdeal_iSup‚ÇÇ

/- warning: homogeneous_ideal.to_ideal_infi‚ÇÇ -> HomogeneousIdeal.toIdeal_iInf‚ÇÇ is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u4}} {Œ∫' : Œ∫ -> Sort.{u5}} (s : forall (i : Œ∫), (Œ∫' i) -> (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u3, u4} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasInf.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => iInf.{u3, u5} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasInf.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (Œ∫' i) (fun (j : Œ∫' i) => s i j)))) (iInf.{u3, u4} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) Œ∫ (fun (i : Œ∫) => iInf.{u3, u5} (Ideal.{u3} A _inst_1) (Submodule.hasInf.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) (Œ∫' i) (fun (j : Œ∫' i) => HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i j))))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {Œ∫ : Sort.{u5}} {Œ∫' : Œ∫ -> Sort.{u4}} (s : forall (i : Œ∫), (Œ∫' i) -> (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)), Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (iInf.{u1, u5} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instInfSetHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œ∫ (fun (i : Œ∫) => iInf.{u1, u4} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instInfSetHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (Œ∫' i) (fun (j : Œ∫' i) => s i j)))) (iInf.{u1, u5} (Ideal.{u1} A _inst_1) (Submodule.instInfSetSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) Œ∫ (fun (i : Œ∫) => iInf.{u1, u4} (Ideal.{u1} A _inst_1) (Submodule.instInfSetSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)) (Œ∫' i) (fun (j : Œ∫' i) => HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (s i j))))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_infi‚ÇÇ HomogeneousIdeal.toIdeal_iInf‚ÇÇ‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem toIdeal_iInf‚ÇÇ {Œ∫ : Sort _} {Œ∫' : Œ∫ ‚Üí Sort _} (s : ‚àÄ i, Œ∫' i ‚Üí HomogeneousIdeal ùíú) :
    (‚®Ö (i) (j), s i j).toIdeal = ‚®Ö (i) (j), (s i j).toIdeal := by simp_rw [to_ideal_infi]
#align homogeneous_ideal.to_ideal_infi‚ÇÇ HomogeneousIdeal.toIdeal_iInf‚ÇÇ

/- warning: homogeneous_ideal.eq_top_iff -> HomogeneousIdeal.eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Iff (Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) I (Top.top.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasTop.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (Top.top.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasTop.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Iff (Eq.{succ u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) I (Top.top.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instTopHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (Top.top.{u1} (Ideal.{u1} A _inst_1) (Submodule.instTopSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1))))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.eq_top_iff HomogeneousIdeal.eq_top_iff‚Çì'. -/
@[simp]
theorem eq_top_iff (I : HomogeneousIdeal ùíú) : I = ‚ä§ ‚Üî I.toIdeal = ‚ä§ :=
  toIdeal_injective.eq_iff.symm
#align homogeneous_ideal.eq_top_iff HomogeneousIdeal.eq_top_iff

/- warning: homogeneous_ideal.eq_bot_iff -> HomogeneousIdeal.eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Iff (Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) I (Bot.bot.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasBot.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (Bot.bot.{u3} (Ideal.{u3} A _inst_1) (Submodule.hasBot.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Iff (Eq.{succ u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) I (Bot.bot.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instBotHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))) (Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (Bot.bot.{u1} (Ideal.{u1} A _inst_1) (Submodule.instBotSubmodule.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1))))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.eq_bot_iff HomogeneousIdeal.eq_bot_iff‚Çì'. -/
@[simp]
theorem eq_bot_iff (I : HomogeneousIdeal ùíú) : I = ‚ä• ‚Üî I.toIdeal = ‚ä• :=
  toIdeal_injective.eq_iff.symm
#align homogeneous_ideal.eq_bot_iff HomogeneousIdeal.eq_bot_iff

instance : CompleteLattice (HomogeneousIdeal ùíú) :=
  toIdeal_injective.CompleteLattice _ toIdeal_sup toIdeal_inf toIdeal_sSup toIdeal_sInf toIdeal_top
    toIdeal_bot

instance : Add (HomogeneousIdeal ùíú) :=
  ‚ü®(¬∑ ‚äî ¬∑)‚ü©

/- warning: homogeneous_ideal.to_ideal_add -> HomogeneousIdeal.toIdeal_add is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (HAdd.hAdd.{u3, u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (instHAdd.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasAdd.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) I J)) (HAdd.hAdd.{u3, u3, u3} (Ideal.{u3} A _inst_1) (Ideal.{u3} A _inst_1) (Ideal.{u3} A _inst_1) (instHAdd.{u3} (Ideal.{u3} A _inst_1) (AddZeroClass.toHasAdd.{u3} (Ideal.{u3} A _inst_1) (AddMonoid.toAddZeroClass.{u3} (Ideal.{u3} A _inst_1) (AddCommMonoid.toAddMonoid.{u3} (Ideal.{u3} A _inst_1) (Submodule.pointwiseAddCommMonoid.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (HAdd.hAdd.{u1, u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (instHAdd.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instAddHomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) I J)) (HAdd.hAdd.{u1, u1, u1} (Ideal.{u1} A _inst_1) (Ideal.{u1} A _inst_1) (Ideal.{u1} A _inst_1) (instHAdd.{u1} (Ideal.{u1} A _inst_1) (AddZeroClass.toAdd.{u1} (Ideal.{u1} A _inst_1) (AddMonoid.toAddZeroClass.{u1} (Ideal.{u1} A _inst_1) (AddCommMonoid.toAddMonoid.{u1} (Ideal.{u1} A _inst_1) (Submodule.pointwiseAddCommMonoid.{u1, u1} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))) (Semiring.toModule.{u1} A _inst_1)))))) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_add HomogeneousIdeal.toIdeal_add‚Çì'. -/
@[simp]
theorem toIdeal_add (I J : HomogeneousIdeal ùíú) : (I + J).toIdeal = I.toIdeal + J.toIdeal :=
  rfl
#align homogeneous_ideal.to_ideal_add HomogeneousIdeal.toIdeal_add

instance : Inhabited (HomogeneousIdeal ùíú) where default := ‚ä•

end HomogeneousIdeal

end Semiring

section CommSemiring

variable [CommSemiring A]

variable [DecidableEq Œπ] [AddMonoid Œπ]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] {ùíú : Œπ ‚Üí œÉ} [GradedRing ùíú]

variable (I : Ideal A)

include A

/- warning: ideal.is_homogeneous.mul -> Ideal.IsHomogeneous.mul is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : CommSemiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú] {I : Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)} {J : Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)}, (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) -> (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (HMul.hMul.{u3, u3, u3} (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (instHMul.{u3} (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.hasMul.{u3} A _inst_1)) I J))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : CommSemiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú] {I : Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)} {J : Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)}, (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) -> (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (HMul.hMul.{u3, u3, u3} (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (instHMul.{u3} (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.instMulIdealToSemiring.{u3} A _inst_1)) I J))
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.mul Ideal.IsHomogeneous.mul‚Çì'. -/
theorem Ideal.IsHomogeneous.mul {I J : Ideal A} (HI : I.Homogeneous ùíú) (HJ : J.Homogeneous ùíú) :
    (I * J).Homogeneous ùíú :=
  by
  rw [Ideal.IsHomogeneous.iff_exists] at HI HJ‚ä¢
  obtain ‚ü®‚ü®s‚ÇÅ, rfl‚ü©, ‚ü®s‚ÇÇ, rfl‚ü©‚ü© := HI, HJ
  rw [Ideal.span_mul_span']
  exact ‚ü®s‚ÇÅ * s‚ÇÇ, congr_arg _ <| (Set.image_mul (homogeneous_submonoid ùíú).Subtype).symm‚ü©
#align ideal.is_homogeneous.mul Ideal.IsHomogeneous.mul

variable {ùíú}

instance : Mul (HomogeneousIdeal ùíú)
    where mul I J := ‚ü®I.toIdeal * J.toIdeal, I.Homogeneous.mul J.Homogeneous‚ü©

/- warning: homogeneous_ideal.to_ideal_mul -> HomogeneousIdeal.toIdeal_mul is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : CommSemiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u3} (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (HMul.hMul.{u3, u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (instHMul.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasMul.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) I J)) (HMul.hMul.{u3, u3, u3} (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (instHMul.{u3} (Ideal.{u3} A (CommSemiring.toSemiring.{u3} A _inst_1)) (Ideal.hasMul.{u3} A _inst_1)) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A (CommSemiring.toSemiring.{u3} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A _inst_1)))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (J : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u1} (Ideal.{u1} A (CommSemiring.toSemiring.{u1} A _inst_1)) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (HMul.hMul.{u1, u1, u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (instHMul.{u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (instMulHomogeneousIdealToSemiring.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) I J)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} A (CommSemiring.toSemiring.{u1} A _inst_1)) (Ideal.{u1} A (CommSemiring.toSemiring.{u1} A _inst_1)) (Ideal.{u1} A (CommSemiring.toSemiring.{u1} A _inst_1)) (instHMul.{u1} (Ideal.{u1} A (CommSemiring.toSemiring.{u1} A _inst_1)) (Ideal.instMulIdealToSemiring.{u1} A _inst_1)) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A (CommSemiring.toSemiring.{u1} A _inst_1) _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_mul HomogeneousIdeal.toIdeal_mul‚Çì'. -/
@[simp]
theorem HomogeneousIdeal.toIdeal_mul (I J : HomogeneousIdeal ùíú) :
    (I * J).toIdeal = I.toIdeal * J.toIdeal :=
  rfl
#align homogeneous_ideal.to_ideal_mul HomogeneousIdeal.toIdeal_mul

end CommSemiring

end Operations

/-! ### Homogeneous core

Note that many results about the homogeneous core came earlier in this file, as they are helpful
for building the lattice structure. -/


section HomogeneousCore

open HomogeneousIdeal

variable [Semiring A] [DecidableEq Œπ] [AddMonoid Œπ]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] (ùíú : Œπ ‚Üí œÉ) [GradedRing ùíú]

variable (I : Ideal A)

include A

/- warning: ideal.homogeneous_core.gc -> Ideal.homogeneousCore.gc is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisConnection.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.partialOrder.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisConnection.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousCore.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_core.gc Ideal.homogeneousCore.gc‚Çì'. -/
theorem Ideal.homogeneousCore.gc : GaloisConnection toIdeal (Ideal.homogeneousCore ùíú) := fun I J =>
  ‚ü®fun H => I.toIdeal_homogeneousCore_eq_self ‚ñ∏ Ideal.homogeneousCore_mono ùíú H, fun H =>
    le_trans H (Ideal.homogeneousCore'_le _ _)‚ü©
#align ideal.homogeneous_core.gc Ideal.homogeneousCore.gc

/- warning: ideal.homogeneous_core.gi -> Ideal.homogeneousCore.gi is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisCoinsertion.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.partialOrder.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
but is expected to have type
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisCoinsertion.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_core.gi Ideal.homogeneousCore.gi‚Çì'. -/
/-- `to_ideal : homogeneous_ideal ùíú ‚Üí ideal A` and `ideal.homogeneous_core ùíú` forms a galois
coinsertion-/
def Ideal.homogeneousCore.gi : GaloisCoinsertion toIdeal (Ideal.homogeneousCore ùíú)
    where
  choice I HI :=
    ‚ü®I, le_antisymm (I.toIdeal_homogeneousCore_le ùíú) HI ‚ñ∏ HomogeneousIdeal.isHomogeneous _‚ü©
  gc := Ideal.homogeneousCore.gc ùíú
  u_l_le I := Ideal.homogeneousCore'_le _ _
  choice_eq I H := le_antisymm H (I.toIdeal_homogeneousCore_le _)
#align ideal.homogeneous_core.gi Ideal.homogeneousCore.gi

/- warning: ideal.homogeneous_core_eq_Sup -> Ideal.homogeneousCore_eq_sSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousCore.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (SupSet.sSup.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (setOf.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toHasLe.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) I)))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousCore.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) (SupSet.sSup.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupSetHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (setOf.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (J : HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) I)))
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_core_eq_Sup Ideal.homogeneousCore_eq_sSup‚Çì'. -/
theorem Ideal.homogeneousCore_eq_sSup :
    I.homogeneousCore ùíú = sSup { J : HomogeneousIdeal ùíú | J.toIdeal ‚â§ I } :=
  Eq.symm <| IsLUB.sSup_eq <| (Ideal.homogeneousCore.gc ùíú).isGreatest_u.IsLUB
#align ideal.homogeneous_core_eq_Sup Ideal.homogeneousCore_eq_sSup

/- warning: ideal.homogeneous_core'_eq_Sup -> Ideal.homogeneousCore'_eq_sSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (Ideal.{u3} A _inst_1) (Ideal.homogeneousCore'.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 ùíú I) (SupSet.sSup.{u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (setOf.{u3} (Ideal.{u3} A _inst_1) (fun (J : Ideal.{u3} A _inst_1) => And (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) (LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toHasLe.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) J I))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (Ideal.{u3} A _inst_1) (Ideal.homogeneousCore'.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 ùíú I) (SupSet.sSup.{u3} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (setOf.{u3} (Ideal.{u3} A _inst_1) (fun (J : Ideal.{u3} A _inst_1) => And (Ideal.IsHomogeneous.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J) (LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) J I))))
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_core'_eq_Sup Ideal.homogeneousCore'_eq_sSup‚Çì'. -/
theorem Ideal.homogeneousCore'_eq_sSup :
    I.homogeneousCore' ùíú = sSup { J : Ideal A | J.Homogeneous ùíú ‚àß J ‚â§ I } :=
  by
  refine' (IsLUB.sSup_eq _).symm
  apply IsGreatest.isLUB
  have coe_mono : Monotone (to_ideal : HomogeneousIdeal ùíú ‚Üí Ideal A) := fun x y => id
  convert coe_mono.map_is_greatest (Ideal.homogeneousCore.gc ùíú).isGreatest_u using 1
  ext
  rw [mem_image, mem_set_of_eq]
  refine'
    ‚ü®fun hI => ‚ü®‚ü®x, hI.1‚ü©, ‚ü®hI.2, rfl‚ü©‚ü©, by rintro ‚ü®x, ‚ü®hx, rfl‚ü©‚ü© <;> exact ‚ü®x.is_homogeneous, hx‚ü©‚ü©
#align ideal.homogeneous_core'_eq_Sup Ideal.homogeneousCore'_eq_sSup

end HomogeneousCore

/-! ### Homogeneous hulls -/


section HomogeneousHull

open HomogeneousIdeal

variable [Semiring A] [DecidableEq Œπ] [AddMonoid Œπ]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] (ùíú : Œπ ‚Üí œÉ) [GradedRing ùíú]

variable (I : Ideal A)

include A

#print Ideal.homogeneousHull /-
/-- For any `I : ideal A`, not necessarily homogeneous, `I.homogeneous_hull ùíú` is
the smallest homogeneous ideal containing `I`. -/
def Ideal.homogeneousHull : HomogeneousIdeal ùíú :=
  ‚ü®Ideal.span { r : A | ‚àÉ (i : Œπ)(x : I), (DirectSum.decompose ùíú (x : A) i : A) = r },
    by
    refine' Ideal.homogeneous_span _ _ fun x hx => _
    obtain ‚ü®i, x, rfl‚ü© := hx
    apply SetLike.homogeneous_coe‚ü©
#align ideal.homogeneous_hull Ideal.homogeneousHull
-/

/- warning: ideal.le_to_ideal_homogeneous_hull -> Ideal.le_toIdeal_homogeneousHull is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toHasLe.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) I (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.homogeneousHull.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I))
Case conversion may be inaccurate. Consider using '#align ideal.le_to_ideal_homogeneous_hull Ideal.le_toIdeal_homogeneousHull‚Çì'. -/
theorem Ideal.le_toIdeal_homogeneousHull : I ‚â§ (Ideal.homogeneousHull ùíú I).toIdeal :=
  by
  intro r hr
  classical
    rw [‚Üê DirectSum.sum_support_decompose ùíú r]
    refine' Ideal.sum_mem _ _
    intro j hj
    apply Ideal.subset_span
    use j
    use ‚ü®r, hr‚ü©
    rfl
#align ideal.le_to_ideal_homogeneous_hull Ideal.le_toIdeal_homogeneousHull

/- warning: ideal.homogeneous_hull_mono -> Ideal.homogeneousHull_mono is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Monotone.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.partialOrder.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], Monotone.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Ideal.homogeneousHull.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_hull_mono Ideal.homogeneousHull_mono‚Çì'. -/
theorem Ideal.homogeneousHull_mono : Monotone (Ideal.homogeneousHull ùíú) := fun I J I_le_J =>
  by
  apply Ideal.span_mono
  rintro r ‚ü®hr1, ‚ü®x, hx‚ü©, rfl‚ü©
  refine' ‚ü®hr1, ‚ü®‚ü®x, I_le_J hx‚ü©, rfl‚ü©‚ü©
#align ideal.homogeneous_hull_mono Ideal.homogeneousHull_mono

variable {I ùíú}

/- warning: ideal.is_homogeneous.to_ideal_homogeneous_hull_eq_self -> Ideal.IsHomogeneous.toIdeal_homogeneousHull_eq_self is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {I : Ideal.{u3} A _inst_1}, (Ideal.IsHomogeneous.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I)) I)
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] {I : Ideal.{u1} A _inst_1}, (Ideal.IsHomogeneous.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I) -> (Eq.{succ u1} (Ideal.{u1} A _inst_1) (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.homogeneousHull.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I)) I)
Case conversion may be inaccurate. Consider using '#align ideal.is_homogeneous.to_ideal_homogeneous_hull_eq_self Ideal.IsHomogeneous.toIdeal_homogeneousHull_eq_self‚Çì'. -/
theorem Ideal.IsHomogeneous.toIdeal_homogeneousHull_eq_self (h : I.Homogeneous ùíú) :
    (Ideal.homogeneousHull ùíú I).toIdeal = I :=
  by
  apply le_antisymm _ (Ideal.le_toIdeal_homogeneousHull _ _)
  apply Ideal.span_le.2
  rintro _ ‚ü®i, x, rfl‚ü©
  exact h _ x.prop
#align ideal.is_homogeneous.to_ideal_homogeneous_hull_eq_self Ideal.IsHomogeneous.toIdeal_homogeneousHull_eq_self

/- warning: homogeneous_ideal.homogeneous_hull_to_ideal_eq_self -> HomogeneousIdeal.homogeneousHull_toIdeal_eq_self is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I)) I
but is expected to have type
  forall {Œπ : Type.{u3}} {œÉ : Type.{u2}} {A : Type.{u1}} [_inst_1 : Semiring.{u1} A] [_inst_2 : DecidableEq.{succ u3} Œπ] [_inst_3 : AddMonoid.{u3} Œπ] [_inst_4 : SetLike.{u2, u1} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u1} œÉ A (AddMonoid.toAddZeroClass.{u1} A (AddMonoidWithOne.toAddMonoid.{u1} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} A (NonAssocSemiring.toAddCommMonoidWithOne.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_1))))) _inst_4] {ùíú : Œπ -> œÉ} [_inst_6 : GradedRing.{u3, u1, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6), Eq.{succ u1} (HomogeneousIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousHull.{u3, u2, u1} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 (HomogeneousIdeal.toIdeal.{u3, u2, u1} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 I)) I
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.homogeneous_hull_to_ideal_eq_self HomogeneousIdeal.homogeneousHull_toIdeal_eq_self‚Çì'. -/
@[simp]
theorem HomogeneousIdeal.homogeneousHull_toIdeal_eq_self (I : HomogeneousIdeal ùíú) :
    I.toIdeal.homogeneousHull ùíú = I :=
  HomogeneousIdeal.toIdeal_injective <| I.Homogeneous.toIdeal_homogeneousHull_eq_self
#align homogeneous_ideal.homogeneous_hull_to_ideal_eq_self HomogeneousIdeal.homogeneousHull_toIdeal_eq_self

variable (I ùíú)

/- warning: ideal.to_ideal_homogeneous_hull_eq_supr -> Ideal.toIdeal_homogeneousHull_eq_iSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I)) (iSup.{u3, succ u1} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œπ (fun (i : Œπ) => Ideal.span.{u3} A _inst_1 (Set.image.{u3, u3} A A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.homogeneousHull.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I)) (iSup.{u3, succ u2} (Ideal.{u3} A _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) Œπ (fun (i : Œπ) => Ideal.span.{u3} A _inst_1 (Set.image.{u3, u3} A A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I))))
Case conversion may be inaccurate. Consider using '#align ideal.to_ideal_homogeneous_hull_eq_supr Ideal.toIdeal_homogeneousHull_eq_iSup‚Çì'. -/
theorem Ideal.toIdeal_homogeneousHull_eq_iSup :
    (I.homogeneousHull ùíú).toIdeal = ‚®Ü i, Ideal.span (GradedRing.proj ùíú i '' I) :=
  by
  rw [‚Üê Ideal.span_iUnion]
  apply congr_arg Ideal.span _
  ext1
  simp only [Set.mem_iUnion, Set.mem_image, mem_set_of_eq, GradedRing.proj_apply, SetLike.exists,
    exists_prop, Subtype.coe_mk, SetLike.mem_coe]
#align ideal.to_ideal_homogeneous_hull_eq_supr Ideal.toIdeal_homogeneousHull_eq_iSup

/- warning: ideal.homogeneous_hull_eq_supr -> Ideal.homogeneousHull_eq_iSup is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I) (iSup.{u3, succ u1} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasSup.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œπ (fun (i : Œπ) => HomogeneousIdeal.mk.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.span.{u3} A _inst_1 (Set.image.{u3, u3} A A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I))) (Ideal.homogeneous_span.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Set.image.{u3, u3} A A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I)) (fun (x : A) (H : Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x (Set.image.{u3, u3} A A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I))) => Exists.dcases_on.{succ u3} A (fun (x_1 : A) => And (Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x_1 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I)) (Eq.{succ u3} A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x)) (fun (H : Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x (Set.image.{u3, u3} A A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I))) => SetLike.Homogeneous.{u1, u3, u2} Œπ A œÉ _inst_4 ùíú x) H (fun (x_1 : A) (H_h : And (Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x_1 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I)) (Eq.{succ u3} A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x)) => And.dcasesOn.{0} (Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x_1 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I)) (Eq.{succ u3} A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x) (fun (H_h : And (Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x_1 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I)) (Eq.{succ u3} A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x)) => SetLike.Homogeneous.{u1, u3, u2} Œπ A œÉ _inst_4 ùíú x) H_h (fun (H_h_left : Membership.Mem.{u3, u3} A (Set.{u3} A) (Set.hasMem.{u3} A) x_1 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Ideal.{u3} A _inst_1) (Set.{u3} A) (HasLiftT.mk.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (CoeTC‚Çì.coe.{succ u3, succ u3} (Ideal.{u3} A _inst_1) (Set.{u3} A) (SetLike.Set.hasCoeT.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I)) (H_h_right : Eq.{succ u3} A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x) => Eq.ndrec.{0, succ u3} A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) (fun (x : A) => SetLike.Homogeneous.{u1, u3, u2} Œπ A œÉ _inst_4 ùíú x) (SetLike.homogeneous_coe.{u1, u3, u2} Œπ A œÉ _inst_4 ùíú i (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A (coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u2} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))) (fun (_x : AddMonoidHom.{u3, u3} A (coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u2} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))) => A -> (coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i))) (AddMonoidHom.hasCoeToFun.{u3, u3} A (coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u2} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))) (AddMonoidHom.comp.{u3, max u1 u3, u3} A (Dfinsupp.{u1, u3} Œπ (fun (i : Œπ) => (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (fun (i : Œπ) => AddZeroClass.toHasZero.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) ((fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) i))))) ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (Dfinsupp.addZeroClass.{u1, u3} Œπ (fun (i : Œπ) => (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (fun (i : Œπ) => AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) ((fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) i)))) (AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) ((fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) i))) (Dfinsupp.evalAddMonoidHom.{u1, u3} Œπ (fun (i : Œπ) => (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (fun (i : Œπ) => AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) i) ((fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) i))) i) (RingHom.toAddMonoidHom.{u3, max u1 u3} A (DirectSum.{u1, u3} Œπ (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (DirectSum.{u1, u3} Œπ (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (DirectSum.semiring.{u1, u3} Œπ (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) _inst_3 (SetLike.gsemiring.{u1, u2, u3} Œπ œÉ A (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) _inst_3 _inst_1 _inst_4 _inst_5 (fun (i : Œπ) => ùíú i) (GradedRing.proj._proof_1.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6)))) (RingEquiv.toRingHom.{u3, max u1 u3} A (DirectSum.{u1, u3} Œπ (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (DirectSum.{u1, u3} Œπ (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (DirectSum.semiring.{u1, u3} Œπ (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) (fun (i : Œπ) => coeSort.{succ u2, succ (succ u3)} œÉ Type.{u3} (SetLike.hasCoeToSort.{u2, u3} œÉ A _inst_4) (ùíú i)) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) _inst_3 (SetLike.gsemiring.{u1, u2, u3} Œπ œÉ A (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) _inst_3 _inst_1 _inst_4 _inst_5 (fun (i : Œπ) => ùíú i) (GradedRing.proj._proof_1.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6)))) (DirectSum.decomposeRingEquiv.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6)))) x_1)) x H_h_right))))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousHull.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I) (iSup.{u3, succ u2} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instSupSetHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) Œπ (fun (i : Œπ) => HomogeneousIdeal.mk.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Ideal.span.{u3} A _inst_1 (Set.image.{u3, u3} A A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I))) (Ideal.homogeneous_span.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 (Set.image.{u3, u3} A A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I)) (fun (x : A) (H : Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x (Set.image.{u3, u3} A A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I))) => Exists.casesOn.{succ u3} A (fun (x_1 : A) => And (Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x_1 (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I)) (Eq.{succ u3} A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x)) (fun (H : Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x (Set.image.{u3, u3} A A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i)) (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I))) => SetLike.Homogeneous.{u2, u3, u1} Œπ A œÉ _inst_4 ùíú x) H (fun (x_1 : A) (H_h : And (Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x_1 (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I)) (Eq.{succ u3} A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x)) => And.casesOn.{0} (Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x_1 (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I)) (Eq.{succ u3} A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x) (fun (H_h : And (Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x_1 (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I)) (Eq.{succ u3} A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x)) => SetLike.Homogeneous.{u2, u3, u1} Œπ A œÉ _inst_4 ùíú x) H_h (fun (H_h_left : Membership.mem.{u3, u3} A (Set.{u3} A) (Set.instMembershipSet.{u3} A) x_1 (SetLike.coe.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)) I)) (H_h_right : Eq.{succ u3} A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) x) => Eq.ndrec.{0, succ u3} A (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6 i) x_1) (fun (x : A) => SetLike.Homogeneous.{u2, u3, u1} Œπ A œÉ _inst_4 ùíú x) (SetLike.homogeneous_coe.{u2, u1, u3} Œπ A œÉ _inst_4 ùíú i (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A (Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u1} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : A) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A (Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u1} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))) A (Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} (Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (AddSubmonoidClass.toAddZeroClass.{u3, u1} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A (Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u1} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))) A (Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u1} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i)) (AddMonoidHom.addMonoidHomClass.{u3, u3} A (Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddSubmonoidClass.toAddZeroClass.{u3, u1} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) œÉ _inst_4 _inst_5 (ùíú i))))) (AddMonoidHom.comp.{u3, max u2 u3, u3} A (Dfinsupp.{u2, u3} Œπ (fun (i : Œπ) => (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (fun (i : Œπ) => AddZeroClass.toZero.{u3} ((fun (i : Œπ) => (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i))))) ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (Dfinsupp.addZeroClass.{u2, u3} Œπ (fun (i : Œπ) => (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (fun (i : Œπ) => AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)))) (AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i))) (Dfinsupp.evalAddMonoidHom.{u2, u3} Œπ (fun (i : Œπ) => (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (fun (i : Œπ) => AddMonoid.toAddZeroClass.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) i) (AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i))) i) (RingHom.toAddMonoidHom.{u3, max u2 u3} A (DirectSum.{u2, u3} Œπ (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (DirectSum.{u2, u3} Œπ (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (DirectSum.semiring.{u2, u3} Œπ (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) _inst_3 (SetLike.gsemiring.{u2, u1, u3} Œπ œÉ A _inst_3 _inst_1 _inst_4 _inst_5 (fun (i : Œπ) => ùíú i) (GradedRing.proj.proof_1.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6)))) (RingEquiv.toRingHom.{u3, max u2 u3} A (DirectSum.{u2, u3} Œπ (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (DirectSum.{u2, u3} Œπ (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i)) (DirectSum.semiring.{u2, u3} Œπ (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) (fun (i : Œπ) => Subtype.{succ u3} A (fun (x : A) => Membership.mem.{u3, u1} A œÉ (SetLike.instMembership.{u1, u3} œÉ A _inst_4) x (ùíú i))) (fun (i : Œπ) => AddCommMonoid.ofSubmonoidOnSemiring.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú i) _inst_3 (SetLike.gsemiring.{u2, u1, u3} Œπ œÉ A _inst_3 _inst_1 _inst_4 _inst_5 (fun (i : Œπ) => ùíú i) (GradedRing.proj.proof_1.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6)))) (DirectSum.decomposeRingEquiv.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => (fun (a : Œπ) (b : Œπ) => _inst_2 a b) a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú _inst_6)))) x_1)) x H_h_right))))))
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_hull_eq_supr Ideal.homogeneousHull_eq_iSup‚Çì'. -/
theorem Ideal.homogeneousHull_eq_iSup :
    I.homogeneousHull ùíú =
      ‚®Ü i,
        ‚ü®Ideal.span (GradedRing.proj ùíú i '' I),
          Ideal.homogeneous_span ùíú _
            (by
              rintro _ ‚ü®x, -, rfl‚ü©
              apply SetLike.homogeneous_coe)‚ü© :=
  by
  ext1
  rw [Ideal.toIdeal_homogeneousHull_eq_iSup, to_ideal_supr]
  rfl
#align ideal.homogeneous_hull_eq_supr Ideal.homogeneousHull_eq_iSup

end HomogeneousHull

section GaloisConnection

open HomogeneousIdeal

variable [Semiring A] [DecidableEq Œπ] [AddMonoid Œπ]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] (ùíú : Œπ ‚Üí œÉ) [GradedRing ùíú]

include A

/- warning: ideal.homogeneous_hull.gc -> Ideal.homogeneousHull.gc is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisConnection.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.partialOrder.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisConnection.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Ideal.homogeneousHull.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_hull.gc Ideal.homogeneousHull.gc‚Çì'. -/
theorem Ideal.homogeneousHull.gc : GaloisConnection (Ideal.homogeneousHull ùíú) toIdeal := fun I J =>
  ‚ü®le_trans (Ideal.le_toIdeal_homogeneousHull _ _), fun H =>
    J.homogeneousHull_toIdeal_eq_self ‚ñ∏ Ideal.homogeneousHull_mono ùíú H‚ü©
#align ideal.homogeneous_hull.gc Ideal.homogeneousHull.gc

/- warning: ideal.homogeneous_hull.gi -> Ideal.homogeneousHull.gi is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisInsertion.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.partialOrder.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
but is expected to have type
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú], GaloisInsertion.{u3, u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) (PartialOrder.toPreorder.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_hull.gi Ideal.homogeneousHull.gi‚Çì'. -/
/-- `ideal.homogeneous_hull ùíú` and `to_ideal : homogeneous_ideal ùíú ‚Üí ideal A` form a galois
insertion-/
def Ideal.homogeneousHull.gi : GaloisInsertion (Ideal.homogeneousHull ùíú) toIdeal
    where
  choice I H := ‚ü®I, le_antisymm H (I.le_toIdeal_homogeneousHull ùíú) ‚ñ∏ isHomogeneous _‚ü©
  gc := Ideal.homogeneousHull.gc ùíú
  le_l_u I := Ideal.le_toIdeal_homogeneousHull _ _
  choice_eq I H := le_antisymm (I.le_toIdeal_homogeneousHull ùíú) H
#align ideal.homogeneous_hull.gi Ideal.homogeneousHull.gi

/- warning: ideal.homogeneous_hull_eq_Inf -> Ideal.homogeneousHull_eq_sInf is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : AddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousHull.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I) (InfSet.sInf.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.hasInf.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (setOf.{u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (J : HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toHasLe.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (SetLike.partialOrder.{u3, u3} (Ideal.{u3} A _inst_1) A (Submodule.setLike.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1))))) I (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : AddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_1 _inst_4 _inst_5 ùíú] (I : Ideal.{u3} A _inst_1), Eq.{succ u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (Ideal.homogeneousHull.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6 I) (InfSet.sInf.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (HomogeneousIdeal.instInfSetHomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6) (setOf.{u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) (fun (J : HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6) => LE.le.{u3} (Ideal.{u3} A _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} A _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A _inst_1) (Submodule.completeLattice.{u3, u3} A A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))) (Semiring.toModule.{u3} A _inst_1)))))) I (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_6 J))))
Case conversion may be inaccurate. Consider using '#align ideal.homogeneous_hull_eq_Inf Ideal.homogeneousHull_eq_sInf‚Çì'. -/
theorem Ideal.homogeneousHull_eq_sInf (I : Ideal A) :
    Ideal.homogeneousHull ùíú I = sInf { J : HomogeneousIdeal ùíú | I ‚â§ J.toIdeal } :=
  Eq.symm <| IsGLB.sInf_eq <| (Ideal.homogeneousHull.gc ùíú).isLeast_l.IsGLB
#align ideal.homogeneous_hull_eq_Inf Ideal.homogeneousHull_eq_sInf

end GaloisConnection

section IrrelevantIdeal

variable [Semiring A]

variable [DecidableEq Œπ]

variable [CanonicallyOrderedAddMonoid Œπ]

variable [SetLike œÉ A] [AddSubmonoidClass œÉ A] (ùíú : Œπ ‚Üí œÉ) [GradedRing ùíú]

include A

open GradedRing SetLike.GradedMonoid DirectSum

#print HomogeneousIdeal.irrelevant /-
/-- For a graded ring `‚®Å·µ¢ ùíú·µ¢` graded by a `canonically_ordered_add_monoid Œπ`, the irrelevant ideal
refers to `‚®Å_{i>0} ùíú·µ¢`, or equivalently `{a | a‚ÇÄ = 0}`. This definition is used in `Proj`
construction where `Œπ` is always `‚Ñï` so the irrelevant ideal is simply elements with `0` as
0-th coordinate.

# Future work
Here in the definition, `Œπ` is assumed to be `canonically_ordered_add_monoid`. However, the notion
of irrelevant ideal makes sense in a more general setting by defining it as the ideal of elements
with `0` as i-th coordinate for all `i ‚â§ 0`, i.e. `{a | ‚àÄ (i : Œπ), i ‚â§ 0 ‚Üí a·µ¢ = 0}`.
-/
def HomogeneousIdeal.irrelevant : HomogeneousIdeal ùíú :=
  ‚ü®(GradedRing.projZeroRingHom ùíú).ker, fun i r (hr : (decompose ùíú r 0 : A) = 0) =>
    by
    change (decompose ùíú (decompose ùíú r _ : A) 0 : A) = 0
    by_cases h : i = 0
    ¬∑ rw [h, hr, decompose_zero, zero_apply, ZeroMemClass.coe_zero]
    ¬∑ rw [decompose_of_mem_ne ùíú (SetLike.coe_mem _) h]‚ü©
#align homogeneous_ideal.irrelevant HomogeneousIdeal.irrelevant
-/

/- warning: homogeneous_ideal.mem_irrelevant_iff -> HomogeneousIdeal.mem_irrelevant_iff is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : CanonicallyOrderedAddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))) _inst_1 _inst_4 _inst_5 ùíú] (a : A), Iff (Membership.Mem.{u3, u3} A (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))) _inst_6) (SetLike.hasMem.{u3, u3} (HomogeneousIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))) _inst_6) A (HomogeneousIdeal.setLike.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))) _inst_6)) a (HomogeneousIdeal.irrelevant.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Eq.{succ u3} A (coeFn.{succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (fun (_x : AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) => A -> A) (AddMonoidHom.hasCoeToFun.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (GradedRing.proj.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))) _inst_1 _inst_4 _inst_5 ùíú _inst_6 (OfNat.ofNat.{u1} Œπ 0 (OfNat.mk.{u1} Œπ 0 (Zero.zero.{u1} Œπ (AddZeroClass.toHasZero.{u1} Œπ (AddMonoid.toAddZeroClass.{u1} Œπ (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))))))))) a) (OfNat.ofNat.{u3} A 0 (OfNat.mk.{u3} A 0 (Zero.zero.{u3} A (MulZeroClass.toHasZero.{u3} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))))))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : CanonicallyOrderedAddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))) _inst_1 _inst_4 _inst_5 ùíú] (a : A), Iff (Membership.mem.{u3, u3} A (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))) _inst_6) (SetLike.instMembership.{u3, u3} (HomogeneousIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))) _inst_6) A (HomogeneousIdeal.setLike.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))) _inst_6)) a (HomogeneousIdeal.irrelevant.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) a) (FunLike.coe.{succ u3, succ u3, succ u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) _x) (AddHomClass.toFunLike.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddZeroClass.toAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{u3, u3, u3} (AddMonoidHom.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))) A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u3, u3} A A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1)))))))) (GradedRing.proj.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))) _inst_1 _inst_4 _inst_5 ùíú _inst_6 (OfNat.ofNat.{u2} Œπ 0 (Zero.toOfNat0.{u2} Œπ (AddMonoid.toZero.{u2} Œπ (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))))))) a) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) a) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) a) (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) a) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => A) a) _inst_1)))))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.mem_irrelevant_iff HomogeneousIdeal.mem_irrelevant_iff‚Çì'. -/
@[simp]
theorem HomogeneousIdeal.mem_irrelevant_iff (a : A) :
    a ‚àà HomogeneousIdeal.irrelevant ùíú ‚Üî proj ùíú 0 a = 0 :=
  Iff.rfl
#align homogeneous_ideal.mem_irrelevant_iff HomogeneousIdeal.mem_irrelevant_iff

/- warning: homogeneous_ideal.to_ideal_irrelevant -> HomogeneousIdeal.toIdeal_irrelevant is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {œÉ : Type.{u2}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u1} Œπ] [_inst_3 : CanonicallyOrderedAddMonoid.{u1} Œπ] [_inst_4 : SetLike.{u2, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u2, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u1, u3, u2} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))) _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u1, u2, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u1} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u1} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} Œπ _inst_3))) _inst_6 (HomogeneousIdeal.irrelevant.{u1, u2, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (RingHom.ker.{u3, u3, u3} A A (RingHom.{u3, u3} A A (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{u3} A _inst_1)) _inst_1 _inst_1 (RingHom.ringHomClass.{u3, u3} A A (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{u3} A _inst_1)) (GradedRing.projZeroRingHom.{u1, u3, u2} Œπ A œÉ _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))
but is expected to have type
  forall {Œπ : Type.{u2}} {œÉ : Type.{u1}} {A : Type.{u3}} [_inst_1 : Semiring.{u3} A] [_inst_2 : DecidableEq.{succ u2} Œπ] [_inst_3 : CanonicallyOrderedAddMonoid.{u2} Œπ] [_inst_4 : SetLike.{u1, u3} œÉ A] [_inst_5 : AddSubmonoidClass.{u1, u3} œÉ A (AddMonoid.toAddZeroClass.{u3} A (AddMonoidWithOne.toAddMonoid.{u3} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} A (NonAssocSemiring.toAddCommMonoidWithOne.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_1))))) _inst_4] (ùíú : Œπ -> œÉ) [_inst_6 : GradedRing.{u2, u3, u1} Œπ A œÉ (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))) _inst_1 _inst_4 _inst_5 ùíú], Eq.{succ u3} (Ideal.{u3} A _inst_1) (HomogeneousIdeal.toIdeal.{u2, u1, u3} Œπ œÉ A _inst_1 _inst_4 _inst_5 ùíú (fun (a : Œπ) (b : Œπ) => _inst_2 a b) (AddCommMonoid.toAddMonoid.{u2} Œπ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Œπ (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} Œπ _inst_3))) _inst_6 (HomogeneousIdeal.irrelevant.{u2, u1, u3} Œπ œÉ A _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6)) (RingHom.ker.{u3, u3, u3} A A (RingHom.{u3, u3} A A (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{u3} A _inst_1)) _inst_1 _inst_1 (RingHom.instRingHomClassRingHom.{u3, u3} A A (Semiring.toNonAssocSemiring.{u3} A _inst_1) (Semiring.toNonAssocSemiring.{u3} A _inst_1)) (GradedRing.projZeroRingHom.{u2, u3, u1} Œπ A œÉ _inst_1 (fun (a : Œπ) (b : Œπ) => _inst_2 a b) _inst_3 _inst_4 _inst_5 ùíú _inst_6))
Case conversion may be inaccurate. Consider using '#align homogeneous_ideal.to_ideal_irrelevant HomogeneousIdeal.toIdeal_irrelevant‚Çì'. -/
@[simp]
theorem HomogeneousIdeal.toIdeal_irrelevant :
    (HomogeneousIdeal.irrelevant ùíú).toIdeal = (GradedRing.projZeroRingHom ùíú).ker :=
  rfl
#align homogeneous_ideal.to_ideal_irrelevant HomogeneousIdeal.toIdeal_irrelevant

end IrrelevantIdeal

