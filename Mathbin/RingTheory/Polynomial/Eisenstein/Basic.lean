/-
Copyright (c) 2022 Riccardo Brasca. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca

! This file was ported from Lean 3 source module ring_theory.polynomial.eisenstein.basic
! leanprover-community/mathlib commit 2032a878972d5672e7c27c957e7a6e297b044973
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.EisensteinCriterion
import Mathbin.RingTheory.Polynomial.ScaleRoots

/-!
# Eisenstein polynomials
Given an ideal `ùìü` of a commutative semiring `R`, we say that a polynomial `f : R[X]` is
*Eisenstein at `ùìü`* if `f.leading_coeff ‚àâ ùìü`, `‚àÄ n, n < f.nat_degree ‚Üí f.coeff n ‚àà ùìü` and
`f.coeff 0 ‚àâ ùìü ^ 2`. In this file we gather miscellaneous results about Eisenstein polynomials.

## Main definitions
* `polynomial.is_eisenstein_at f ùìü`: the property of being Eisenstein at `ùìü`.

## Main results
* `polynomial.is_eisenstein_at.irreducible`: if a primitive `f` satisfies `f.is_eisenstein_at ùìü`,
  where `ùìü.is_prime`, then `f` is irreducible.

## Implementation details
We also define a notion `is_weakly_eisenstein_at` requiring only that
`‚àÄ n < f.nat_degree ‚Üí f.coeff n ‚àà ùìü`. This makes certain results slightly more general and it is
useful since it is sometimes better behaved (for example it is stable under `polynomial.map`).

-/


universe u v w z

variable {R : Type u}

open Ideal Algebra Finset

open BigOperators Polynomial

namespace Polynomial

#print Polynomial.IsWeaklyEisensteinAt /-
/-- Given an ideal `ùìü` of a commutative semiring `R`, we say that a polynomial `f : R[X]`
is *weakly Eisenstein at `ùìü`* if `‚àÄ n, n < f.nat_degree ‚Üí f.coeff n ‚àà ùìü`. -/
@[mk_iff]
structure IsWeaklyEisensteinAt [CommSemiring R] (f : R[X]) (ùìü : Ideal R) : Prop where
  Mem : ‚àÄ {n}, n < f.natDegree ‚Üí f.coeff n ‚àà ùìü
#align polynomial.is_weakly_eisenstein_at Polynomial.IsWeaklyEisensteinAt
-/

#print Polynomial.IsEisensteinAt /-
/-- Given an ideal `ùìü` of a commutative semiring `R`, we say that a polynomial `f : R[X]`
is *Eisenstein at `ùìü`* if `f.leading_coeff ‚àâ ùìü`, `‚àÄ n, n < f.nat_degree ‚Üí f.coeff n ‚àà ùìü` and
`f.coeff 0 ‚àâ ùìü ^ 2`. -/
@[mk_iff]
structure IsEisensteinAt [CommSemiring R] (f : R[X]) (ùìü : Ideal R) : Prop where
  leading : f.leadingCoeff ‚àâ ùìü
  Mem : ‚àÄ {n}, n < f.natDegree ‚Üí f.coeff n ‚àà ùìü
  not_mem : f.coeff 0 ‚àâ ùìü ^ 2
#align polynomial.is_eisenstein_at Polynomial.IsEisensteinAt
-/

namespace IsWeaklyEisensteinAt

section CommSemiring

variable [CommSemiring R] {ùìü : Ideal R} {f : R[X]} (hf : f.IsWeaklyEisensteinAt ùìü)

include hf

/- warning: polynomial.is_weakly_eisenstein_at.map -> Polynomial.IsWeaklyEisensteinAt.map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ùìü : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.IsWeaklyEisensteinAt.{u1} R _inst_1 f ùìü) -> (forall {A : Type.{u2}} [_inst_2 : CommRing.{u2} A] (œÜ : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))), Polynomial.IsWeaklyEisensteinAt.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2) (Polynomial.map.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) œÜ f) (Ideal.map.{u1, u2, max u1 u2} R A (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (RingHom.ringHomClass.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) œÜ ùìü))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ùìü : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.IsWeaklyEisensteinAt.{u1} R _inst_1 f ùìü) -> (forall {A : Type.{u2}} [_inst_2 : CommRing.{u2} A] (œÜ : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))), Polynomial.IsWeaklyEisensteinAt.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2) (Polynomial.map.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) œÜ f) (Ideal.map.{u1, u2, max u1 u2} R A (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) œÜ ùìü))
Case conversion may be inaccurate. Consider using '#align polynomial.is_weakly_eisenstein_at.map Polynomial.IsWeaklyEisensteinAt.map‚Çì'. -/
theorem map {A : Type v} [CommRing A] (œÜ : R ‚Üí+* A) : (f.map œÜ).IsWeaklyEisensteinAt (ùìü.map œÜ) :=
  by
  refine' (is_weakly_eisenstein_at_iff _ _).2 fun n hn => _
  rw [coeff_map]
  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn (nat_degree_map_le _ _)))
#align polynomial.is_weakly_eisenstein_at.map Polynomial.IsWeaklyEisensteinAt.map

end CommSemiring

section CommRing

variable [CommRing R] {ùìü : Ideal R} {f : R[X]} (hf : f.IsWeaklyEisensteinAt ùìü)

variable {S : Type v} [CommRing S] [Algebra R S]

section Principal

variable {p : R}

-- mathport name: exprP
local notation "P" => Submodule.span R {p}

#print Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree /-
theorem exists_mem_adjoin_mul_eq_pow_natDegree {x : S} (hx : aeval x f = 0) (hmo : f.Monic)
    (hf : f.IsWeaklyEisensteinAt P) :
    ‚àÉ y ‚àà adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ (f.map (algebraMap R S)).natDegree :=
  by
  rw [aeval_def, Polynomial.eval‚ÇÇ_eq_eval_map, eval_eq_sum_range, range_add_one,
    sum_insert not_mem_range_self, sum_range, (hmo.map (algebraMap R S)).coeff_natDegree,
    one_mul] at hx
  replace hx := eq_neg_of_add_eq_zero_left hx
  have : ‚àÄ n < f.nat_degree, p ‚à£ f.coeff n :=
    by
    intro n hn
    refine' mem_span_singleton.1 (by simpa using hf.mem hn)
  choose! œÜ hœÜ using this
  conv_rhs at hx =>
    congr
    congr
    skip
    ext
    rw [[anonymous], coeff_map, hœÜ i.1 (lt_of_lt_of_le i.2 (nat_degree_map_le _ _)),
      RingHom.map_mul, mul_assoc]
  rw [hx, ‚Üê mul_sum, neg_eq_neg_one_mul, ‚Üê mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]
  refine'
    ‚ü®-1 * ‚àë i : Fin (f.map (algebraMap R S)).natDegree, (algebraMap R S) (œÜ i.1) * x ^ i.1, _, rfl‚ü©
  exact
    Subalgebra.mul_mem _ (Subalgebra.neg_mem _ (Subalgebra.one_mem _))
      (Subalgebra.sum_mem _ fun i hi =>
        Subalgebra.mul_mem _ (Subalgebra.algebraMap_mem _ _)
          (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))
#align polynomial.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree
-/

#print Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le /-
theorem exists_mem_adjoin_mul_eq_pow_natDegree_le {x : S} (hx : aeval x f = 0) (hmo : f.Monic)
    (hf : f.IsWeaklyEisensteinAt P) :
    ‚àÄ i,
      (f.map (algebraMap R S)).natDegree ‚â§ i ‚Üí
        ‚àÉ y ‚àà adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ i :=
  by
  intro i hi
  obtain ‚ü®k, hk‚ü© := exists_add_of_le hi
  rw [hk, pow_add]
  obtain ‚ü®y, hy, H‚ü© := exists_mem_adjoin_mul_eq_pow_nat_degree hx hmo hf
  refine' ‚ü®y * x ^ k, _, _‚ü©
  ¬∑ exact Subalgebra.mul_mem _ hy (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)
  ¬∑ rw [‚Üê mul_assoc _ y, H]
#align polynomial.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le
-/

end Principal

include hf

/- warning: polynomial.is_weakly_eisenstein_at.pow_nat_degree_le_of_root_of_monic_mem -> Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_root_of_monic_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {ùìü : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {f : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.IsWeaklyEisensteinAt.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) f ùìü) -> (forall {x : R}, (Polynomial.IsRoot.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f x) -> (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f) -> (forall (i : Nat), (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f) i) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) x i) ùìü)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {ùìü : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {f : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.IsWeaklyEisensteinAt.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) f ùìü) -> (forall {x : R}, (Polynomial.IsRoot.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f x) -> (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f) -> (forall (i : Nat), (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f) i) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) x i) ùìü)))
Case conversion may be inaccurate. Consider using '#align polynomial.is_weakly_eisenstein_at.pow_nat_degree_le_of_root_of_monic_mem Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_root_of_monic_mem‚Çì'. -/
theorem pow_natDegree_le_of_root_of_monic_mem {x : R} (hroot : IsRoot f x) (hmo : f.Monic) :
    ‚àÄ i, f.natDegree ‚â§ i ‚Üí x ^ i ‚àà ùìü := by
  intro i hi
  obtain ‚ü®k, hk‚ü© := exists_add_of_le hi
  rw [hk, pow_add]
  suffices x ^ f.nat_degree ‚àà ùìü by exact mul_mem_right (x ^ k) ùìü this
  rw [is_root.def, eval_eq_sum_range, Finset.range_add_one,
    Finset.sum_insert Finset.not_mem_range_self, Finset.sum_range, hmo.coeff_nat_degree, one_mul] at
    hroot
  rw [eq_neg_of_add_eq_zero_left hroot, neg_mem_iff]
  refine' Submodule.sum_mem _ fun i hi => mul_mem_right _ _ (hf.mem (Fin.is_lt i))
#align polynomial.is_weakly_eisenstein_at.pow_nat_degree_le_of_root_of_monic_mem Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_root_of_monic_mem

#print Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_aeval_zero_of_monic_mem_map /-
theorem pow_natDegree_le_of_aeval_zero_of_monic_mem_map {x : S} (hx : aeval x f = 0)
    (hmo : f.Monic) :
    ‚àÄ i, (f.map (algebraMap R S)).natDegree ‚â§ i ‚Üí x ^ i ‚àà ùìü.map (algebraMap R S) :=
  by
  suffices x ^ (f.map (algebraMap R S)).natDegree ‚àà ùìü.map (algebraMap R S)
    by
    intro i hi
    obtain ‚ü®k, hk‚ü© := exists_add_of_le hi
    rw [hk, pow_add]
    refine' mul_mem_right _ _ this
  rw [aeval_def, eval‚ÇÇ_eq_eval_map, ‚Üê is_root.def] at hx
  refine' pow_nat_degree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le
#align polynomial.is_weakly_eisenstein_at.pow_nat_degree_le_of_aeval_zero_of_monic_mem_map Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_aeval_zero_of_monic_mem_map
-/

end CommRing

end IsWeaklyEisensteinAt

section ScaleRoots

variable {A : Type _} [CommRing R] [CommRing A]

#print Polynomial.scaleRoots.isWeaklyEisensteinAt /-
theorem scaleRoots.isWeaklyEisensteinAt (p : R[X]) {x : R} {P : Ideal R} (hP : x ‚àà P) :
    (scaleRoots p x).IsWeaklyEisensteinAt P :=
  by
  refine' ‚ü®fun i hi => _‚ü©
  rw [coeff_scale_roots]
  rw [nat_degree_scale_roots, ‚Üê tsub_pos_iff_lt] at hi
  exact Ideal.mul_mem_left _ _ (Ideal.pow_mem_of_mem P hP _ hi)
#align polynomial.scale_roots.is_weakly_eisenstein_at Polynomial.scaleRoots.isWeaklyEisensteinAt
-/

/- warning: polynomial.dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero -> Polynomial.dvd_pow_natDegree_of_eval‚ÇÇ_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] {f : RingHom.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))}, (Function.Injective.{succ u1, succ u2} R A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (fun (_x : RingHom.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f)) -> (forall {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (forall (x : R) (y : R) (z : A), (Eq.{succ u2} A (Polynomial.eval‚ÇÇ.{u1, u2} R A (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) f z p) (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) -> (Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (fun (_x : RingHom.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f x) z) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (fun (_x : RingHom.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f y)) -> (Dvd.Dvd.{u1} R (semigroupDvd.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_1)))))) x (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) y (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)))))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] {f : RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))}, (Function.Injective.{succ u2, succ u1} R A (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))))) f)) -> (forall {p : Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))}, (Polynomial.Monic.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) p) -> (forall (x : R) (y : R) (z : A), (Eq.{succ u1} A (Polynomial.eval‚ÇÇ.{u2, u1} R A (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) f z p) (OfNat.ofNat.{u1} A 0 (Zero.toOfNat0.{u1} A (CommMonoidWithZero.toZero.{u1} A (CommSemiring.toCommMonoidWithZero.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) (CommRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) _inst_2))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))))) f x) z) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))))) f y)) -> (Dvd.dvd.{u2} R (semigroupDvd.{u2} R (SemigroupWithZero.toSemigroup.{u2} R (NonUnitalSemiring.toSemigroupWithZero.{u2} R (NonUnitalRing.toNonUnitalSemiring.{u2} R (NonUnitalCommRing.toNonUnitalRing.{u2} R (CommRing.toNonUnitalCommRing.{u2} R _inst_1)))))) x (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) y (Polynomial.natDegree.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) p)))))
Case conversion may be inaccurate. Consider using '#align polynomial.dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero Polynomial.dvd_pow_natDegree_of_eval‚ÇÇ_eq_zero‚Çì'. -/
theorem dvd_pow_natDegree_of_eval‚ÇÇ_eq_zero {f : R ‚Üí+* A} (hf : Function.Injective f) {p : R[X]}
    (hp : p.Monic) (x y : R) (z : A) (h : p.eval‚ÇÇ f z = 0) (hz : f x * z = f y) :
    x ‚à£ y ^ p.natDegree :=
  by
  rw [‚Üê nat_degree_scale_roots p x, ‚Üê Ideal.mem_span_singleton]
  refine'
    (scale_roots.is_weakly_eisenstein_at _
          (ideal.mem_span_singleton.mpr <| dvd_refl x)).pow_natDegree_le_of_root_of_monic_mem
      _ ((monic_scale_roots_iff x).mpr hp) _ le_rfl
  rw [injective_iff_map_eq_zero'] at hf
  have := scale_roots_eval‚ÇÇ_eq_zero f h
  rwa [hz, Polynomial.eval‚ÇÇ_at_apply, hf] at this
#align polynomial.dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero Polynomial.dvd_pow_natDegree_of_eval‚ÇÇ_eq_zero

/- warning: polynomial.dvd_pow_nat_degree_of_aeval_eq_zero -> Polynomial.dvd_pow_natDegree_of_aeval_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_4 : Nontrivial.{u2} A] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)))))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (forall (x : R) (y : R) (z : A), (Eq.{succ u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AlgHom.{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) A (CommRing.toCommSemiring.{u1} R _inst_1) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Polynomial.algebraOfAlgebra.{u1, u1} R R (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) _inst_3) (fun (_x : AlgHom.{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) A (CommRing.toCommSemiring.{u1} R _inst_1) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Polynomial.algebraOfAlgebra.{u1, u1} R R (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) _inst_3) => (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) -> A) ([anonymous].{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) A (CommRing.toCommSemiring.{u1} R _inst_1) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Polynomial.algebraOfAlgebra.{u1, u1} R R (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) _inst_3) (Polynomial.aeval.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 z) p) (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) -> (Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) z (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (algebraMap.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) x)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (algebraMap.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) y)) -> (Dvd.Dvd.{u1} R (semigroupDvd.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_1)))))) x (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) y (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))] [_inst_4 : Nontrivial.{u1} A] [_inst_5 : NoZeroSMulDivisors.{u2, u1} R A (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CommMonoidWithZero.toZero.{u1} A (CommSemiring.toCommMonoidWithZero.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))) (Algebra.toSMul.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_3)] {p : Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))}, (Polynomial.Monic.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) p) -> (forall (x : R) (y : R) (z : A), (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => A) p) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_3) (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (fun (_x : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => A) _x) (SMulHomClass.toFunLike.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_3) R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (SMulZeroClass.toSMul.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (DistribSMul.toSMulZeroClass.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (DistribMulAction.toDistribSMul.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))))) (Module.toDistribMulAction.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (Algebra.toModule.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (SMulZeroClass.toSMul.{u2, u1} R A (AddMonoid.toZero.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))))) (DistribSMul.toSMulZeroClass.{u2, u1} R A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))))) (DistribMulAction.toDistribSMul.{u2, u1} R A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))) (Module.toDistribMulAction.{u2, u1} R A (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_3))))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_3) R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))))) (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))) (Module.toDistribMulAction.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (Algebra.toModule.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{u2, u1} R A (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_3)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_3) R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) (Module.toDistribMulAction.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (Algebra.toModule.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{u2, u1} R A (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_3)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u2, u1, max u1 u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_3 (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_3) (AlgHom.algHomClass.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) A (CommRing.toCommSemiring.{u2} R _inst_1) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) (Polynomial.algebraOfAlgebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_3))))) (Polynomial.aeval.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_3 z) p) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => A) p) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => A) p) (CommMonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => A) p) (CommSemiring.toCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => A) p) (CommRing.toCommSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) => A) p) _inst_2)))))) -> (Eq.{succ u1} A (HMul.hMul.{u1, u1, u1} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) x) A (instHMul.{u1} A (NonUnitalNonAssocRing.toMul.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) z (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))))) (algebraMap.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_3) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))))) (algebraMap.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_3) y)) -> (Dvd.dvd.{u2} R (semigroupDvd.{u2} R (SemigroupWithZero.toSemigroup.{u2} R (NonUnitalSemiring.toSemigroupWithZero.{u2} R (NonUnitalRing.toNonUnitalSemiring.{u2} R (NonUnitalCommRing.toNonUnitalRing.{u2} R (CommRing.toNonUnitalCommRing.{u2} R _inst_1)))))) x (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) y (Polynomial.natDegree.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) p))))
Case conversion may be inaccurate. Consider using '#align polynomial.dvd_pow_nat_degree_of_aeval_eq_zero Polynomial.dvd_pow_natDegree_of_aeval_eq_zero‚Çì'. -/
theorem dvd_pow_natDegree_of_aeval_eq_zero [Algebra R A] [Nontrivial A] [NoZeroSMulDivisors R A]
    {p : R[X]} (hp : p.Monic) (x y : R) (z : A) (h : Polynomial.aeval z p = 0)
    (hz : z * algebraMap R A x = algebraMap R A y) : x ‚à£ y ^ p.natDegree :=
  dvd_pow_natDegree_of_eval‚ÇÇ_eq_zero (NoZeroSMulDivisors.algebraMap_injective R A) hp x y z h
    ((mul_comm _ _).trans hz)
#align polynomial.dvd_pow_nat_degree_of_aeval_eq_zero Polynomial.dvd_pow_natDegree_of_aeval_eq_zero

end ScaleRoots

namespace IsEisensteinAt

section CommSemiring

variable [CommSemiring R] {ùìü : Ideal R} {f : R[X]} (hf : f.IsEisensteinAt ùìü)

/- warning: polynomial.monic.leading_coeff_not_mem -> Polynomial.IsEisensteinAt.Polynomial.Monic.leadingCoeff_not_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ùìü : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Ne.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ùìü (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Not (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Polynomial.leadingCoeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) ùìü))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ùìü : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Ne.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ùìü (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Not (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Polynomial.leadingCoeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) ùìü))
Case conversion may be inaccurate. Consider using '#align polynomial.monic.leading_coeff_not_mem Polynomial.IsEisensteinAt.Polynomial.Monic.leadingCoeff_not_mem‚Çì'. -/
theorem Polynomial.IsEisensteinAt.Polynomial.Monic.leadingCoeff_not_mem (hf : f.Monic) (h : ùìü ‚â† ‚ä§) :
    ¬¨f.leadingCoeff ‚àà ùìü :=
  hf.leadingCoeff.symm ‚ñ∏ (Ideal.ne_top_iff_one _).1 h
#align polynomial.monic.leading_coeff_not_mem Polynomial.IsEisensteinAt.Polynomial.Monic.leadingCoeff_not_mem

/- warning: polynomial.monic.is_eisenstein_at_of_mem_of_not_mem -> Polynomial.IsEisensteinAt.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ùìü : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Ne.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ùìü (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (forall {n : Nat}, (LT.lt.{0} Nat Nat.hasLt n (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f)) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f n) ùìü)) -> (Not (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) ùìü (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> (Polynomial.IsEisensteinAt.{u1} R _inst_1 f ùìü)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ùìü : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Ne.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ùìü (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (forall {n : Nat}, (LT.lt.{0} Nat instLTNat n (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f)) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f n) ùìü)) -> (Not (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) ùìü (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) -> (Polynomial.IsEisensteinAt.{u1} R _inst_1 f ùìü)
Case conversion may be inaccurate. Consider using '#align polynomial.monic.is_eisenstein_at_of_mem_of_not_mem Polynomial.IsEisensteinAt.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem‚Çì'. -/
theorem Polynomial.IsEisensteinAt.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem (hf : f.Monic)
    (h : ùìü ‚â† ‚ä§) (hmem : ‚àÄ {n}, n < f.natDegree ‚Üí f.coeff n ‚àà ùìü) (hnot_mem : f.coeff 0 ‚àâ ùìü ^ 2) :
    f.IsEisensteinAt ùìü :=
  { leading := hf.leadingCoeff_not_mem h
    Mem := fun n hn => hmem hn
    not_mem := hnot_mem }
#align polynomial.monic.is_eisenstein_at_of_mem_of_not_mem Polynomial.IsEisensteinAt.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem

include hf

#print Polynomial.IsEisensteinAt.isWeaklyEisensteinAt /-
theorem isWeaklyEisensteinAt : IsWeaklyEisensteinAt f ùìü :=
  ‚ü®fun _ => hf.Mem‚ü©
#align polynomial.is_eisenstein_at.is_weakly_eisenstein_at Polynomial.IsEisensteinAt.isWeaklyEisensteinAt
-/

#print Polynomial.IsEisensteinAt.coeff_mem /-
theorem coeff_mem {n : ‚Ñï} (hn : n ‚â† f.natDegree) : f.coeff n ‚àà ùìü :=
  by
  cases ne_iff_lt_or_gt.1 hn
  ¬∑ exact hf.mem h
  ¬∑ rw [coeff_eq_zero_of_nat_degree_lt h]
    exact Ideal.zero_mem _
#align polynomial.is_eisenstein_at.coeff_mem Polynomial.IsEisensteinAt.coeff_mem
-/

end CommSemiring

section IsDomain

variable [CommRing R] [IsDomain R] {ùìü : Ideal R} {f : R[X]} (hf : f.IsEisensteinAt ùìü)

/- warning: polynomial.is_eisenstein_at.irreducible -> Polynomial.IsEisensteinAt.irreducible is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {ùìü : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {f : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.IsEisensteinAt.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) f ùìü) -> (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) ùìü) -> (Polynomial.IsPrimitive.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) f) -> (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f)) -> (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) f)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {ùìü : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {f : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.IsEisensteinAt.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) f ùìü) -> (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) ùìü) -> (Polynomial.IsPrimitive.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) f) -> (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f)) -> (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) f)
Case conversion may be inaccurate. Consider using '#align polynomial.is_eisenstein_at.irreducible Polynomial.IsEisensteinAt.irreducible‚Çì'. -/
/-- If a primitive `f` satisfies `f.is_eisenstein_at ùìü`, where `ùìü.is_prime`, then `f` is
irreducible. -/
theorem irreducible (hprime : ùìü.IsPrime) (hu : f.IsPrimitive) (hfd0 : 0 < f.natDegree) :
    Irreducible f :=
  irreducible_of_eisenstein_criterion hprime hf.leading (fun n hn => hf.Mem (coe_lt_degree.1 hn))
    (natDegree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu
#align polynomial.is_eisenstein_at.irreducible Polynomial.IsEisensteinAt.irreducible

end IsDomain

end IsEisensteinAt

end Polynomial

