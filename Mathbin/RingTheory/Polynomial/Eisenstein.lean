/-
Copyright (c) 2022 Riccardo Brasca. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca
-/
import Mathbin.RingTheory.EisensteinCriterion
import Mathbin.RingTheory.IntegrallyClosed
import Mathbin.RingTheory.Norm
import Mathbin.RingTheory.Polynomial.Cyclotomic.Basic

/-!
# Eisenstein polynomials
Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]` is
*Eisenstein at `ğ“Ÿ`* if `f.leading_coeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ` and
`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. In this file we gather miscellaneous results about Eisenstein polynomials.

## Main definitions
* `polynomial.is_eisenstein_at f ğ“Ÿ`: the property of being Eisenstein at `ğ“Ÿ`.

## Main results
* `polynomial.is_eisenstein_at.irreducible`: if a primitive `f` satisfies `f.is_eisenstein_at ğ“Ÿ`,
  where `ğ“Ÿ.is_prime`, then `f` is irreducible.
* `mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at`: let `K` be the field of fraction
  of an integrally closed domain `R` and let `L` be a separable extension of `K`, generated by an
  integral power basis `B` such that the minimal polynomial of `B.gen` is Eisenstein at `p`. Given
  `z : L` integral over `R`, if `p ^ n â€¢ z âˆˆ adjoin R {B.gen}`, then `z âˆˆ adjoin R {B.gen}`.
  Together with `algebra.discr_mul_is_integral_mem_adjoin` this result often allows to compute the
  ring of integers of `L`.

## Implementation details
We also define a notion `is_weakly_eisenstein_at` requiring only that
`âˆ€ n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ`. This makes certain results slightly more general and it is
useful since it is sometimes better behaved (for example it is stable under `polynomial.map`).

-/


universe u v w z

variable {R : Type u}

open Ideal Algebra Finset

open BigOperators Polynomial

namespace Polynomial

/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`
is *weakly Eisenstein at `ğ“Ÿ`* if `âˆ€ n, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ`. -/
@[mk_iff]
structure IsWeaklyEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where
  Mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ
#align polynomial.is_weakly_eisenstein_at Polynomial.IsWeaklyEisensteinAt

/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`
is *Eisenstein at `ğ“Ÿ`* if `f.leading_coeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ` and
`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. -/
@[mk_iff]
structure IsEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where
  leading : f.leadingCoeff âˆ‰ ğ“Ÿ
  Mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ
  not_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2
#align polynomial.is_eisenstein_at Polynomial.IsEisensteinAt

namespace IsWeaklyEisensteinAt

section CommSemiring

variable [CommSemiring R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsWeaklyEisensteinAt ğ“Ÿ)

include hf

theorem map {A : Type v} [CommRing A] (Ï† : R â†’+* A) : (f.map Ï†).IsWeaklyEisensteinAt (ğ“Ÿ.map Ï†) := by
  refine' (is_weakly_eisenstein_at_iff _ _).2 fun n hn => _
  rw [coeff_map]
  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn (nat_degree_map_le _ _)))
#align polynomial.is_weakly_eisenstein_at.map Polynomial.IsWeaklyEisensteinAt.map

end CommSemiring

section CommRing

variable [CommRing R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsWeaklyEisensteinAt ğ“Ÿ)

variable {S : Type v} [CommRing S] [Algebra R S]

section Principal

variable {p : R}

-- mathport name: exprP
local notation "P" => Submodule.span R {p}

theorem exists_mem_adjoin_mul_eq_pow_nat_degree {x : S} (hx : aeval x f = 0) (hmo : f.Monic)
    (hf : f.IsWeaklyEisensteinAt P) :
    âˆƒ y âˆˆ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ (f.map (algebraMap R S)).natDegree := by
  rw [aeval_def, Polynomial.evalâ‚‚_eq_eval_map, eval_eq_sum_range, range_add_one, sum_insert not_mem_range_self,
    sum_range, (hmo.map (algebraMap R S)).coeff_nat_degree, one_mul] at hx
  replace hx := eq_neg_of_add_eq_zero_left hx
  have : âˆ€ n < f.nat_degree, p âˆ£ f.coeff n := by
    intro n hn
    refine' mem_span_singleton.1 (by simpa using hf.mem hn)
  choose! Ï† hÏ† using this
  conv_rhs at hx =>
  congr
  congr
  skip
  ext
  rw [Fin.coe_eq_val, coeff_map, hÏ† i.1 (lt_of_lt_of_le i.2 (nat_degree_map_le _ _)), RingHom.map_mul, mul_assoc]
  rw [hx, â† mul_sum, neg_eq_neg_one_mul, â† mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]
  refine' âŸ¨-1 * âˆ‘ i : Fin (f.map (algebraMap R S)).natDegree, (algebraMap R S) (Ï† i.1) * x ^ i.1, _, rflâŸ©
  exact
    Subalgebra.mul_mem _ (Subalgebra.neg_mem _ (Subalgebra.one_mem _))
      (Subalgebra.sum_mem _ fun i hi =>
        Subalgebra.mul_mem _ (Subalgebra.algebra_map_mem _ _)
          (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))
#align
  polynomial.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_nat_degree

theorem exists_mem_adjoin_mul_eq_pow_nat_degree_le {x : S} (hx : aeval x f = 0) (hmo : f.Monic)
    (hf : f.IsWeaklyEisensteinAt P) :
    âˆ€ i, (f.map (algebraMap R S)).natDegree â‰¤ i â†’ âˆƒ y âˆˆ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ i := by
  intro i hi
  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi
  rw [hk, pow_add]
  obtain âŸ¨y, hy, HâŸ© := exists_mem_adjoin_mul_eq_pow_nat_degree hx hmo hf
  refine' âŸ¨y * x ^ k, _, _âŸ©
  Â· exact Subalgebra.mul_mem _ hy (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)
    
  Â· rw [â† mul_assoc _ y, H]
    
#align
  polynomial.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_nat_degree_le

end Principal

include hf

theorem pow_nat_degree_le_of_root_of_monic_mem {x : R} (hroot : IsRoot f x) (hmo : f.Monic) :
    âˆ€ i, f.natDegree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ := by
  intro i hi
  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi
  rw [hk, pow_add]
  suffices x ^ f.nat_degree âˆˆ ğ“Ÿ by exact mul_mem_right (x ^ k) ğ“Ÿ this
  rw [is_root.def, eval_eq_sum_range, Finset.range_add_one, Finset.sum_insert Finset.not_mem_range_self,
    Finset.sum_range, hmo.coeff_nat_degree, one_mul] at hroot
  rw [eq_neg_of_add_eq_zero_left hroot, neg_mem_iff]
  refine' Submodule.sum_mem _ fun i hi => mul_mem_right _ _ (hf.mem (Fin.is_lt i))
#align
  polynomial.is_weakly_eisenstein_at.pow_nat_degree_le_of_root_of_monic_mem Polynomial.IsWeaklyEisensteinAt.pow_nat_degree_le_of_root_of_monic_mem

theorem pow_nat_degree_le_of_aeval_zero_of_monic_mem_map {x : S} (hx : aeval x f = 0) (hmo : f.Monic) :
    âˆ€ i, (f.map (algebraMap R S)).natDegree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ.map (algebraMap R S) := by
  suffices x ^ (f.map (algebraMap R S)).natDegree âˆˆ ğ“Ÿ.map (algebraMap R S) by
    intro i hi
    obtain âŸ¨k, hkâŸ© := exists_add_of_le hi
    rw [hk, pow_add]
    refine' mul_mem_right _ _ this
  rw [aeval_def, evalâ‚‚_eq_eval_map, â† is_root.def] at hx
  refine' pow_nat_degree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le
#align
  polynomial.is_weakly_eisenstein_at.pow_nat_degree_le_of_aeval_zero_of_monic_mem_map Polynomial.IsWeaklyEisensteinAt.pow_nat_degree_le_of_aeval_zero_of_monic_mem_map

end CommRing

end IsWeaklyEisensteinAt

section ScaleRoots

variable {A : Type _} [CommRing R] [CommRing A]

theorem scaleRoots.is_weakly_eisenstein_at (p : R[X]) {x : R} {P : Ideal R} (hP : x âˆˆ P) :
    (scaleRoots p x).IsWeaklyEisensteinAt P := by
  refine' âŸ¨fun i hi => _âŸ©
  rw [coeff_scale_roots]
  rw [nat_degree_scale_roots, â† tsub_pos_iff_lt] at hi
  exact Ideal.mul_mem_left _ _ (Ideal.pow_mem_of_mem P hP _ hi)
#align polynomial.scale_roots.is_weakly_eisenstein_at Polynomial.scaleRoots.is_weakly_eisenstein_at

theorem dvd_pow_nat_degree_of_evalâ‚‚_eq_zero {f : R â†’+* A} (hf : Function.Injective f) {p : R[X]} (hp : p.Monic)
    (x y : R) (z : A) (h : p.evalâ‚‚ f z = 0) (hz : f x * z = f y) : x âˆ£ y ^ p.natDegree := by
  rw [â† nat_degree_scale_roots p x, â† Ideal.mem_span_singleton]
  refine'
    (scale_roots.is_weakly_eisenstein_at _
          (ideal.mem_span_singleton.mpr $ dvd_refl x)).pow_nat_degree_le_of_root_of_monic_mem
      _ ((monic_scale_roots_iff x).mpr hp) _ le_rfl
  rw [injective_iff_map_eq_zero'] at hf
  have := scale_roots_evalâ‚‚_eq_zero f h
  rwa [hz, Polynomial.evalâ‚‚_at_apply, hf] at this
#align polynomial.dvd_pow_nat_degree_of_evalâ‚‚_eq_zero Polynomial.dvd_pow_nat_degree_of_evalâ‚‚_eq_zero

theorem dvd_pow_nat_degree_of_aeval_eq_zero [Algebra R A] [Nontrivial A] [NoZeroSmulDivisors R A] {p : R[X]}
    (hp : p.Monic) (x y : R) (z : A) (h : Polynomial.aeval z p = 0) (hz : z * algebraMap R A x = algebraMap R A y) :
    x âˆ£ y ^ p.natDegree :=
  dvd_pow_nat_degree_of_evalâ‚‚_eq_zero (NoZeroSmulDivisors.algebra_map_injective R A) hp x y z h
    ((mul_comm _ _).trans hz)
#align polynomial.dvd_pow_nat_degree_of_aeval_eq_zero Polynomial.dvd_pow_nat_degree_of_aeval_eq_zero

end ScaleRoots

namespace IsEisensteinAt

section CommSemiring

variable [CommSemiring R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsEisensteinAt ğ“Ÿ)

theorem _root_.polynomial.monic.leading_coeff_not_mem (hf : f.Monic) (h : ğ“Ÿ â‰  âŠ¤) : Â¬f.leadingCoeff âˆˆ ğ“Ÿ :=
  hf.leadingCoeff.symm â–¸ (Ideal.ne_top_iff_one _).1 h
#align
  polynomial.is_eisenstein_at._root_.polynomial.monic.leading_coeff_not_mem polynomial.is_eisenstein_at._root_.polynomial.monic.leading_coeff_not_mem

theorem _root_.polynomial.monic.is_eisenstein_at_of_mem_of_not_mem (hf : f.Monic) (h : ğ“Ÿ â‰  âŠ¤)
    (hmem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ) (hnot_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2) : f.IsEisensteinAt ğ“Ÿ :=
  { leading := hf.leading_coeff_not_mem h, Mem := fun n hn => hmem hn, not_mem := hnot_mem }
#align
  polynomial.is_eisenstein_at._root_.polynomial.monic.is_eisenstein_at_of_mem_of_not_mem polynomial.is_eisenstein_at._root_.polynomial.monic.is_eisenstein_at_of_mem_of_not_mem

include hf

theorem is_weakly_eisenstein_at : IsWeaklyEisensteinAt f ğ“Ÿ :=
  âŸ¨fun _ => hf.MemâŸ©
#align polynomial.is_eisenstein_at.is_weakly_eisenstein_at Polynomial.IsEisensteinAt.is_weakly_eisenstein_at

theorem coeff_mem {n : â„•} (hn : n â‰  f.natDegree) : f.coeff n âˆˆ ğ“Ÿ := by
  cases ne_iff_lt_or_gt.1 hn
  Â· exact hf.mem h
    
  Â· rw [coeff_eq_zero_of_nat_degree_lt h]
    exact Ideal.zero_mem _
    
#align polynomial.is_eisenstein_at.coeff_mem Polynomial.IsEisensteinAt.coeff_mem

end CommSemiring

section IsDomain

variable [CommRing R] [IsDomain R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsEisensteinAt ğ“Ÿ)

/-- If a primitive `f` satisfies `f.is_eisenstein_at ğ“Ÿ`, where `ğ“Ÿ.is_prime`, then `f` is
irreducible. -/
theorem irreducible (hprime : ğ“Ÿ.IsPrime) (hu : f.IsPrimitive) (hfd0 : 0 < f.natDegree) : Irreducible f :=
  irreducible_of_eisenstein_criterion hprime hf.leading (fun n hn => hf.Mem (coe_lt_degree.1 hn))
    (nat_degree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu
#align polynomial.is_eisenstein_at.irreducible Polynomial.IsEisensteinAt.irreducible

end IsDomain

end IsEisensteinAt

end Polynomial

section Cyclotomic

variable (p : â„•)

-- mathport name: exprğ“Ÿ
local notation "ğ“Ÿ" => Submodule.span â„¤ {p}

open Polynomial

theorem cyclotomicCompXAddOneIsEisensteinAt [hp : Fact p.Prime] : ((cyclotomic p â„¤).comp (X + 1)).IsEisensteinAt ğ“Ÿ := by
  refine'
    monic.is_eisenstein_at_of_mem_of_not_mem _
      (Ideal.IsPrime.ne_top $
        (Ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 $ Nat.prime_iff_prime_int.1 hp.out)
      (fun i hi => _) _
  Â· rw [show (X + 1 : â„¤[X]) = X + C 1 by simp]
    refine' (cyclotomic.monic p â„¤).comp (monic_X_add_C 1) fun h => _
    rw [nat_degree_X_add_C] at h
    exact zero_ne_one h.symm
    
  Â· rw [cyclotomic_prime, geom_sum_X_comp_X_add_one_eq_sum, â† lcoeff_apply, LinearMap.map_sum]
    conv =>
    congr
    congr
    skip
    ext
    rw [lcoeff_apply, â† C_eq_nat_cast, â† monomial_eq_C_mul_X, coeff_monomial]
    rw [nat_degree_comp, show (X + 1 : â„¤[X]) = X + C 1 by simp, nat_degree_X_add_C, mul_one, nat_degree_cyclotomic,
      Nat.totient_prime hp.out] at hi
    simp only [lt_of_lt_of_le hi (Nat.sub_le _ _), sum_ite_eq', mem_range, if_true, Ideal.submodule_span_eq,
      Ideal.mem_span_singleton]
    exact Int.coe_nat_dvd.2 (Nat.Prime.dvd_choose_self (Nat.succ_pos i) (lt_tsub_iff_right.1 hi) hp.out)
    
  Â· rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime, eval_add, eval_X, eval_one, zero_add, eval_geom_sum,
      one_geom_sum, Ideal.submodule_span_eq, Ideal.span_singleton_pow, Ideal.mem_span_singleton]
    intro h
    obtain âŸ¨k, hkâŸ© := Int.coe_nat_dvd.1 h
    rw [â† mul_assoc, mul_one, mul_assoc] at hk
    nth_rw 0 [â† Nat.mul_one p]  at hk
    rw [mul_right_inj' hp.out.ne_zero] at hk
    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)
    
#align cyclotomic_comp_X_add_one_is_eisenstein_at cyclotomicCompXAddOneIsEisensteinAt

theorem cyclotomicPrimePowCompXAddOneIsEisensteinAt [hp : Fact p.Prime] (n : â„•) :
    ((cyclotomic (p ^ (n + 1)) â„¤).comp (X + 1)).IsEisensteinAt ğ“Ÿ := by
  refine'
    monic.is_eisenstein_at_of_mem_of_not_mem _
      (Ideal.IsPrime.ne_top $
        (Ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 $ Nat.prime_iff_prime_int.1 hp.out)
      _ _
  Â· rw [show (X + 1 : â„¤[X]) = X + C 1 by simp]
    refine' (cyclotomic.monic _ â„¤).comp (monic_X_add_C 1) fun h => _
    rw [nat_degree_X_add_C] at h
    exact zero_ne_one h.symm
    
  Â· induction' n with n hn
    Â· intro i hi
      rw [zero_add, pow_one] at hiâŠ¢
      exact (cyclotomicCompXAddOneIsEisensteinAt p).Mem hi
      
    Â· intro i hi
      rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, â† Zmod.int_coe_zmod_eq_zero_iff_dvd, â†
        Int.coe_cast_ring_hom, â† coeff_map, map_comp, map_cyclotomic, Polynomial.map_add, map_X, Polynomial.map_one,
        pow_add, pow_one, cyclotomic_mul_prime_dvd_eq_pow, pow_comp, â† Zmod.expand_card, coeff_expand hp.out.pos]
      Â· simp only [ite_eq_right_iff]
        rintro âŸ¨k, hkâŸ©
        rw [nat_degree_comp, show (X + 1 : â„¤[X]) = X + C 1 by simp, nat_degree_X_add_C, mul_one, nat_degree_cyclotomic,
          Nat.totient_prime_pow hp.out (Nat.succ_pos _), Nat.succ_sub_one] at hn hi
        rw [hk, pow_succ, mul_assoc] at hi
        rw [hk, mul_comm, Nat.mul_div_cancel _ hp.out.pos]
        replace hn := hn (lt_of_mul_lt_mul_left' hi)
        rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, â† Zmod.int_coe_zmod_eq_zero_iff_dvd, â†
          Int.coe_cast_ring_hom, â† coeff_map] at hn
        simpa [map_comp] using hn
        
      Â· exact âŸ¨p ^ n, by rw [pow_succ]âŸ©
        
      
    
  Â· rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime_pow_eq_geom_sum hp.out, eval_add, eval_X, eval_one,
      zero_add, eval_finset_sum]
    simp only [eval_pow, eval_X, one_pow, sum_const, card_range, Nat.smul_one_eq_coe, submodule_span_eq,
      Ideal.submodule_span_eq, Ideal.span_singleton_pow, Ideal.mem_span_singleton]
    intro h
    obtain âŸ¨k, hkâŸ© := Int.coe_nat_dvd.1 h
    rw [â† mul_assoc, mul_one, mul_assoc] at hk
    nth_rw 0 [â† Nat.mul_one p]  at hk
    rw [mul_right_inj' hp.out.ne_zero] at hk
    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)
    
#align cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at cyclotomicPrimePowCompXAddOneIsEisensteinAt

end Cyclotomic

section IsIntegral

variable {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L]

variable [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [IsSeparable K L]

variable [IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R]

-- mathport name: exprğ“Ÿ
local notation "ğ“Ÿ" => Submodule.span R {p}

open IsIntegrallyClosed PowerBasis Nat Polynomial IsScalarTower

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable
extension of `K`, generated by an integral power basis `B` such that the minimal polynomial of
`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that
`aeval B.gen Q = p â€¢ z`, then `p âˆ£ Q.coeff 0`. -/
theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at {B : PowerBasis K L} (hp : Prime p)
    (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p â€¢ z) (hzint : IsIntegral R z)
    (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) : p âˆ£ Q.coeff 0 := by
  -- First define some abbreviations.
  letI := B.finite_dimensional
  let P := minpoly R B.gen
  obtain âŸ¨n, hnâŸ© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.nat_degree_minpoly
  have deg_R_P : P.nat_degree = B.dim := by
    rw [â† deg_K_P, minpoly.gcd_domain_eq_field_fractions' K hBint,
      (minpoly.monic hBint).nat_degree_map (algebraMap R K)]
  choose! f hf using
    hei.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).nat_degree_map, deg_R_P] at hf
  -- The Eisenstein condition shows that `p` divides `Q.coeff 0`
  -- if `p^n.succ` divides the following multiple of `Q.coeff 0^n.succ`:
  suffices p ^ n.succ âˆ£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm â–¸ Ideal.mem_span_singleton.2 h)
    refine' Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd hp (_ : _ ^ n.succ âˆ£ _) hndiv
    convert (IsUnit.dvd_mul_right âŸ¨(-1) ^ (n.succ * n), rflâŸ©).mpr this using 1
    push_cast
    ring_nf
    simp [pow_right_comm _ _ 2]
  -- We claim the quotient of `Q^n * _` by `p^n` is the following `r`:
  have aux : âˆ€ i âˆˆ (range (Q.nat_degree + 1)).erase 0, B.dim â‰¤ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum : IsIntegral R (z * B.gen ^ n - âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, Q.coeff x â€¢ f (x + n)) :=
    by
    refine'
      isIntegralSub (isIntegralMul hzint (IsIntegral.pow hBint _)) (IsIntegral.sum _ fun i hi => isIntegralSmul _ _)
    exact adjoin_le_integral_closure hBint (hf _ (aux i hi)).1
  obtain âŸ¨r, hrâŸ© := is_integral_iff.1 (is_integral_norm K hintsum)
  use r
  -- Do the computation in `K` so we can work in terms of `z` instead of `r`.
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  -- Both sides are actually norms:
  calc
    _ = norm K (Q.coeff 0 â€¢ B.gen ^ n) := _
    _ = norm K (p â€¢ (z * B.gen ^ n) - âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, p â€¢ Q.coeff x â€¢ f (x + n)) :=
      congr_arg (norm K) (eq_sub_of_add_eq _)
    _ = _ := _
    
  Â· simp only [Algebra.smul_def, algebra_map_apply R K L, Algebra.norm_algebra_map, _root_.map_mul, _root_.map_pow,
      finrank_K_L, power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.gcd_domain_eq_field_fractions' K hBint,
      coeff_map, â† hn]
    ring
    
  swap
  Â· simp_rw [â† smul_sum, â† smul_sub, Algebra.smul_def p, algebra_map_apply R K L, _root_.map_mul,
      Algebra.norm_algebra_map, finrank_K_L, hr, â† hn]
    
  calc
    _ = (Q.coeff 0 â€¢ 1 + âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) * B.gen ^ n := _
    _ = (Q.coeff 0 â€¢ B.gen ^ 0 + âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) * B.gen ^ n := by
      rw [pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := _
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
    
  Â· have : âˆ€ i âˆˆ (range (Q.nat_degree + 1)).erase 0, Q.coeff i â€¢ (B.gen ^ i * B.gen ^ n) = p â€¢ Q.coeff i â€¢ f (i + n) :=
      by
      intro i hi
      rw [â† pow_add, â† (hf _ (aux i hi)).2, â† Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
    
  Â· rw [aeval_eq_sum_range, Finset.add_sum_erase (range (Q.nat_degree + 1)) fun i => Q.coeff i â€¢ B.gen ^ i]
    simp
    
#align
  dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at

theorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type _} [CommSemiring A] [CommRing B] [Algebra A B]
    [NoZeroSmulDivisors A B] {Q : A[X]} {p : A} {x z : B} (hp : p â‰  0)
    (hQ : âˆ€ i âˆˆ range (Q.natDegree + 1), p âˆ£ Q.coeff i) (hz : aeval x Q = p â€¢ z) : z âˆˆ adjoin A ({x} : Set B) := by
  choose! f hf using hQ
  rw [aeval_eq_sum_range, sum_range] at hz
  conv_lhs at hz =>
  congr
  skip
  ext
  rw [hf i (mem_range.2 (Fin.is_lt i)), â† smul_smul]
  rw [â† smul_sum] at hz
  rw [â† smul_right_injective _ hp hz]
  exact
    Subalgebra.sum_mem _ fun _ _ =>
      Subalgebra.smul_mem _ (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _) _
#align mem_adjoin_of_dvd_coeff_of_dvd_aeval mem_adjoin_of_dvd_coeff_of_dvd_aeval

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable
extension of `K`, generated by an integral power basis `B` such that the minimal polynomial of
`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p â€¢ z âˆˆ adjoin R {B.gen}`, then
`z âˆˆ adjoin R {B.gen}`. -/
theorem mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at {B : PowerBasis K L} (hp : Prime p)
    (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z) (hz : p â€¢ z âˆˆ adjoin R ({B.gen} : Set L))
    (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) : z âˆˆ adjoin R ({B.gen} : Set L) := by
  -- First define some abbreviations.
  have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm â–¸ Ideal.mem_span_singleton.2 h)
  letI := FiniteDimensional B
  set P := minpoly R B.gen with hP
  obtain âŸ¨n, hnâŸ© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSmulDivisors R L := NoZeroSmulDivisors.trans R K L
  let Pâ‚ := P.map (algebraMap R L)
  -- There is a polynomial `Q` such that `p â€¢ z = aeval B.gen Q`. We can assume that
  -- `Q.degree < P.degree` and `Q â‰  0`.
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain âŸ¨Qâ‚, hQâŸ© := hz
  set Q := Qâ‚ %â‚˜ P with hQâ‚
  replace hQ : aeval B.gen Q = p â€¢ z
  Â· rw [â† mod_by_monic_add_div Qâ‚ (minpoly.monic hBint)] at hQ
    simpa using hQ
    
  by_cases hQzero:Q = 0
  Â· simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H Hâ‚
    Â· have : Function.Injective (algebraMap R L) := by
        rw [algebra_map_eq R K L]
        exact (algebraMap K L).Injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
      
    Â· rw [Hâ‚]
      exact Subalgebra.zero_mem _
      
    
  -- It is enough to prove that all coefficients of `Q` are divisible by `p`, by induction.
  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at`.
  refine' mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => _) hQ
  refine' Nat.case_strong_induction_on i _ fun j hind => _
  Â· intro H
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at hp hBint hQ hzint hei
    
  Â· intro hj
    refine' hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv
    exact n
    -- Two technical results we will need about `P.nat_degree` and `Q.nat_degree`.
    have H := degree_mod_by_monic_lt Qâ‚ (minpoly.monic hBint)
    rw [â† hQâ‚, â† hP] at H
    replace H :=
      Nat.lt_iff_add_one_le.1
        (lt_of_lt_of_le
          (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj))) (lt_succ_self _))
          (Nat.lt_iff_add_one_le.1 ((nat_degree_lt_nat_degree_iff hQzero).2 H)))
    rw [add_assoc] at H
    have Hj : Q.nat_degree + 1 = j + 1 + (Q.nat_degree - j) := by
      rw [â† add_comm 1, â† add_comm 1, add_assoc, add_right_inj, â†
        Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm, Nat.add_sub_cancel]
    -- By induction hypothesis we can find `g : â„• â†’ R` such that
    -- `k âˆˆ range (j + 1) â†’ Q.coeff k â€¢ B.gen ^ k = (algebra_map R L) p * g k â€¢ B.gen ^ k`-
    choose! g hg using hind
    replace hg : âˆ€ k âˆˆ range (j + 1), Q.coeff k â€¢ B.gen ^ k = algebraMap R L p * g k â€¢ B.gen ^ k
    Â· intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
          (mem_range_succ_iff.2 (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
      
    -- Since `minpoly R B.gen` is Eiseinstein, we can find `f : â„• â†’ L` such that
    -- `(map (algebra_map R L) (minpoly R B.gen)).nat_degree â‰¤ i` implies `f i âˆˆ adjoin R {B.gen}`
    -- and `(algebra_map R L) p * f i = B.gen ^ i`. We will also need `hfâ‚`, a reformulation of this
    -- property.
    choose! f hf using
      is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)
        hei.is_weakly_eisenstein_at
    have hfâ‚ :
      âˆ€ k âˆˆ (range (Q.nat_degree - j)).erase 0,
        Q.coeff (j + 1 + k) â€¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.nat_degree - (j + 2)) =
          (algebraMap R L) p * Q.coeff (j + 1 + k) â€¢ f (k + P.nat_degree - 1) :=
      by
      intro k hk
      rw [smul_mul_assoc, â† pow_add, â† Nat.add_sub_assoc H, â† add_assoc j 1 1, add_comm (j + 1) 1, add_assoc (j + 1),
        add_comm _ (k + P.nat_degree), Nat.add_sub_add_right, â† (hf (k + P.nat_degree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).nat_degree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      Â· exact Nat.zero_le _
        
      Â· refine' one_le_iff_ne_zero.2 fun h => _
        rw [h] at hk
        simpa using hk
        
      Â· infer_instance
        
    -- The Eisenstein condition shows that `p` divides `Q.coeff j`
    -- if `p^n.succ` divides the following multiple of `Q.coeff (succ j)^n.succ`:
    suffices p ^ n.succ âˆ£ Q.coeff (succ j) ^ n.succ * (minpoly R B.gen).coeff 0 ^ (succ j + (P.nat_degree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, â† Nat.add_sub_assoc H, â† add_assoc, add_comm (j + 1), Nat.add_sub_add_left, â†
        Nat.add_sub_assoc, Nat.add_sub_add_left, hP, â† (minpoly.monic hBint).nat_degree_map (algebraMap R K), â†
        minpoly.gcd_domain_eq_field_fractions' K hBint, nat_degree_minpoly, hn, Nat.sub_one, Nat.pred_succ]
      linarith
    -- Using `hQ : aeval B.gen Q = p â€¢ z`, we write `p â€¢ z` as a sum of terms of degree less than
    -- `j+1`, that are multiples of `p` by induction, and terms of degree at least `j+1`.
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_add_left_embedding _ _), sum_congr rfl hg,
      add_comm] at hQ
    -- We multiply this equality by `B.gen ^ (P.nat_degree-(j+2))`, so we can use `hfâ‚` on the terms
    -- we didn't know were multiples of `p`, and we take the norm on both sides.
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.nat_degree - (j + 2))) hQ
    simp_rw [sum_map, add_left_embedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [â† insert_erase (mem_range.2 (tsub_pos_iff_lt.2 $ Nat.lt_of_succ_lt_succ $ mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hfâ‚, â† mul_sum, â† mul_sum, add_assoc, â† mul_add,
      smul_mul_assoc, â† pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    -- We obtain an equality of elements of `K`, but everything is integral, so we can move to `R`
    -- and simplify `hQ`.
    have hintsum :
      IsIntegral R
        (z * B.gen ^ (P.nat_degree - (j + 2)) -
          ((âˆ‘ x : â„• in (range (Q.nat_degree - j)).erase 0, Q.coeff (j + 1 + x) â€¢ f (x + P.nat_degree - 1)) +
            âˆ‘ x : â„• in range (j + 1), g x â€¢ B.gen ^ x * B.gen ^ (P.nat_degree - (j + 2)))) :=
      by
      refine'
        isIntegralSub (isIntegralMul hzint (IsIntegral.pow hBint _))
          (isIntegralAdd (IsIntegral.sum _ fun k hk => isIntegralSmul _ _)
            (IsIntegral.sum _ fun k hk =>
              isIntegralMul (isIntegralSmul _ (IsIntegral.pow hBint _)) (IsIntegral.pow hBint _)))
      refine' adjoin_le_integral_closure hBint (hf _ _).1
      rw [(minpoly.monic hBint).nat_degree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      Â· exact zero_le _
        
      Â· refine' one_le_iff_ne_zero.2 fun h => _
        rw [h] at hk
        simpa using hk
        
    obtain âŸ¨r, hrâŸ© := is_integral_iff.1 (is_integral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, â† mul_sub, _root_.map_mul, algebra_map_apply R K L, map_pow,
      Algebra.norm_algebra_map, _root_.map_mul, algebra_map_apply R K L, Algebra.norm_algebra_map, finrank B, â† hr,
      power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.gcd_domain_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, â† map_pow, â† map_pow, â† _root_.map_mul, â† map_pow, â† _root_.map_mul,
      â† map_pow, â† _root_.map_mul] at hQ
    -- We can now finish the proof.
    have hppdiv : p ^ B.dim âˆ£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [â† IsFractionRing.injective R K hQ, mul_comm, â† Units.coe_neg_one, mul_pow, â† Units.coe_pow, â† Units.coe_pow,
      mul_assoc, IsUnit.dvd_mul_left _ _ _ âŸ¨_, rflâŸ©, mul_comm, â† Nat.succ_eq_add_one, hn] at hppdiv
    
#align
  mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable
extension of `K`, generated by an integral power basis `B` such that the minimal polynomial of
`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ^ n â€¢ z âˆˆ adjoin R {B.gen}`,
then `z âˆˆ adjoin R {B.gen}`. Together with `algebra.discr_mul_is_integral_mem_adjoin` this result
often allows to compute the ring of integers of `L`. -/
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at {B : PowerBasis K L} (hp : Prime p)
    (hBint : IsIntegral R B.gen) {n : â„•} {z : L} (hzint : IsIntegral R z) (hz : p ^ n â€¢ z âˆˆ adjoin R ({B.gen} : Set L))
    (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) : z âˆˆ adjoin R ({B.gen} : Set L) := by
  induction' n with n hn
  Â· simpa using hz
    
  Â· rw [pow_succ, mul_smul] at hz
    exact hn (mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at hp hBint (isIntegralSmul _ hzint) hz hei)
    
#align
  mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at

end IsIntegral

