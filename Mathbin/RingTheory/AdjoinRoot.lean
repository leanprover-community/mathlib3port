import Mathbin.Data.Polynomial.FieldDivision 
import Mathbin.LinearAlgebra.FiniteDimensional 
import Mathbin.RingTheory.Adjoin.Basic 
import Mathbin.RingTheory.PowerBasis 
import Mathbin.RingTheory.PrincipalIdealDomain

/-!
# Adjoining roots of polynomials

This file defines the commutative ring `adjoin_root f`, the ring R[X]/(f) obtained from a
commutative ring `R` and a polynomial `f : R[X]`. If furthermore `R` is a field and `f` is
irreducible, the field structure on `adjoin_root f` is constructed.

## Main definitions and results

The main definitions are in the `adjoin_root` namespace.

*  `mk f : polynomial R →+* adjoin_root f`, the natural ring homomorphism.

*  `of f : R →+* adjoin_root f`, the natural ring homomorphism.

* `root f : adjoin_root f`, the image of X in R[X]/(f).

* `lift (i : R →+* S) (x : S) (h : f.eval₂ i x = 0) : (adjoin_root f) →+* S`, the ring
  homomorphism from R[X]/(f) to S extending `i : R →+* S` and sending `X` to `x`.

* `lift_hom (x : S) (hfx : aeval x f = 0) : adjoin_root f →ₐ[R] S`, the algebra
  homomorphism from R[X]/(f) to S extending `algebra_map R S` and sending `X` to `x`

* `equiv : (adjoin_root f →ₐ[F] E) ≃ {x // x ∈ (f.map (algebra_map F E)).roots}` a
  bijection between algebra homomorphisms from `adjoin_root` and roots of `f` in `S`

-/


noncomputable theory

open_locale Classical

open_locale BigOperators

universe u v w

variable {R : Type u} {S : Type v} {K : Type w}

open Polynomial Ideal

/-- Adjoin a root of a polynomial `f` to a commutative ring `R`. We define the new ring
as the quotient of `polynomial R` by the principal ideal generated by `f`. -/
def AdjoinRoot [CommRingₓ R] (f : Polynomial R) : Type u :=
  Ideal.Quotient (span {f} : Ideal (Polynomial R))

namespace AdjoinRoot

section CommRingₓ

variable [CommRingₓ R] (f : Polynomial R)

instance : CommRingₓ (AdjoinRoot f) :=
  Ideal.Quotient.commRing _

instance : Inhabited (AdjoinRoot f) :=
  ⟨0⟩

instance : DecidableEq (AdjoinRoot f) :=
  Classical.decEq _

/-- Ring homomorphism from `R[x]` to `adjoin_root f` sending `X` to the `root`. -/
def mk : Polynomial R →+* AdjoinRoot f :=
  Ideal.Quotient.mk _

@[elab_as_eliminator]
theorem induction_on {C : AdjoinRoot f → Prop} (x : AdjoinRoot f) (ih : ∀ p : Polynomial R, C (mk f p)) : C x :=
  Quotientₓ.induction_on' x ih

/-- Embedding of the original ring `R` into `adjoin_root f`. -/
def of : R →+* AdjoinRoot f :=
  (mk f).comp C

instance [CommSemiringₓ S] [Algebra S R] : Algebra S (AdjoinRoot f) :=
  Ideal.Quotient.algebra S

instance [CommSemiringₓ S] [CommSemiringₓ K] [HasScalar S K] [Algebra S R] [Algebra K R] [IsScalarTower S K R] :
  IsScalarTower S K (AdjoinRoot f) :=
  Submodule.Quotient.is_scalar_tower _ _

instance [CommSemiringₓ S] [CommSemiringₓ K] [Algebra S R] [Algebra K R] [SmulCommClass S K R] :
  SmulCommClass S K (AdjoinRoot f) :=
  Submodule.Quotient.smul_comm_class _ _

@[simp]
theorem algebra_map_eq : algebraMap R (AdjoinRoot f) = of f :=
  rfl

variable (S)

theorem algebra_map_eq' [CommSemiringₓ S] [Algebra S R] : algebraMap S (AdjoinRoot f) = (of f).comp (algebraMap S R) :=
  rfl

variable {S}

/-- The adjoined root. -/
def root : AdjoinRoot f :=
  mk f X

variable {f}

instance adjoin_root.has_coe_t : CoeTₓ R (AdjoinRoot f) :=
  ⟨of f⟩

@[simp]
theorem mk_eq_mk {g h : Polynomial R} : mk f g = mk f h ↔ f ∣ g - h :=
  Ideal.Quotient.eq.trans Ideal.mem_span_singleton

@[simp]
theorem mk_self : mk f f = 0 :=
  Quotientₓ.sound'
    (mem_span_singleton.2$
      by 
        simp )

@[simp]
theorem mk_C (x : R) : mk f (C x) = x :=
  rfl

@[simp]
theorem mk_X : mk f X = root f :=
  rfl

@[simp]
theorem aeval_eq (p : Polynomial R) : aeval (root f) p = mk f p :=
  Polynomial.induction_on p
    (fun x =>
      by 
        rw [aeval_C]
        rfl)
    (fun p q ihp ihq =>
      by 
        rw [AlgHom.map_add, RingHom.map_add, ihp, ihq])
    fun n x ih =>
      by 
        rw [AlgHom.map_mul, aeval_C, AlgHom.map_pow, aeval_X, RingHom.map_mul, mk_C, RingHom.map_pow, mk_X]
        rfl

theorem adjoin_root_eq_top : Algebra.adjoin R ({root f} : Set (AdjoinRoot f)) = ⊤ :=
  Algebra.eq_top_iff.2$
    fun x => induction_on f x$ fun p => (Algebra.adjoin_singleton_eq_range_aeval R (root f)).symm ▸ ⟨p, aeval_eq p⟩

@[simp]
theorem eval₂_root (f : Polynomial R) : f.eval₂ (of f) (root f) = 0 :=
  by 
    rw [←algebra_map_eq, ←aeval_def, aeval_eq, mk_self]

theorem is_root_root (f : Polynomial R) : is_root (f.map (of f)) (root f) :=
  by 
    rw [is_root, eval_map, eval₂_root]

theorem is_algebraic_root (hf : f ≠ 0) : IsAlgebraic R (root f) :=
  ⟨f, hf, eval₂_root f⟩

variable [CommRingₓ S]

/-- Lift a ring homomorphism `i : R →+* S` to `adjoin_root f →+* S`. -/
def lift (i : R →+* S) (x : S) (h : f.eval₂ i x = 0) : AdjoinRoot f →+* S :=
  by 
    apply Ideal.Quotient.lift _ (eval₂_ring_hom i x)
    intro g H 
    rcases mem_span_singleton.1 H with ⟨y, hy⟩
    rw [hy, RingHom.map_mul, coe_eval₂_ring_hom, h, zero_mul]

variable {i : R →+* S} {a : S} (h : f.eval₂ i a = 0)

@[simp]
theorem lift_mk (g : Polynomial R) : lift i a h (mk f g) = g.eval₂ i a :=
  Ideal.Quotient.lift_mk _ _ _

@[simp]
theorem lift_root : lift i a h (root f) = a :=
  by 
    rw [root, lift_mk, eval₂_X]

@[simp]
theorem lift_of {x : R} : lift i a h x = i x :=
  by 
    rw [←mk_C x, lift_mk, eval₂_C]

@[simp]
theorem lift_comp_of : (lift i a h).comp (of f) = i :=
  RingHom.ext$ fun _ => @lift_of _ _ _ _ _ _ _ h _

variable (f) [Algebra R S]

/-- Produce an algebra homomorphism `adjoin_root f →ₐ[R] S` sending `root f` to
a root of `f` in `S`. -/
def lift_hom (x : S) (hfx : aeval x f = 0) : AdjoinRoot f →ₐ[R] S :=
  { lift (algebraMap R S) x hfx with commutes' := fun r => show lift _ _ hfx r = _ from lift_of hfx }

@[simp]
theorem coe_lift_hom (x : S) (hfx : aeval x f = 0) :
  (lift_hom f x hfx : AdjoinRoot f →+* S) = lift (algebraMap R S) x hfx :=
  rfl

-- error in RingTheory.AdjoinRoot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[simp] theorem aeval_alg_hom_eq_zero (ϕ : «expr →ₐ[ ] »(adjoin_root f, R, S)) : «expr = »(aeval (ϕ (root f)) f, 0) :=
begin
  have [ident h] [":", expr «expr = »(ϕ.to_ring_hom.comp (of f), algebra_map R S)] [":=", expr ring_hom.ext_iff.mpr ϕ.commutes],
  rw ["[", expr aeval_def, ",", "<-", expr h, ",", "<-", expr ring_hom.map_zero ϕ.to_ring_hom, ",", "<-", expr eval₂_root f, ",", expr hom_eval₂, "]"] [],
  refl
end

@[simp]
theorem lift_hom_eq_alg_hom (f : Polynomial R) (ϕ : AdjoinRoot f →ₐ[R] S) :
  lift_hom f (ϕ (root f)) (aeval_alg_hom_eq_zero f ϕ) = ϕ :=
  by 
    suffices  : ϕ.equalizer (lift_hom f (ϕ (root f)) (aeval_alg_hom_eq_zero f ϕ)) = ⊤
    ·
      exact (AlgHom.ext fun x => (set_like.ext_iff.mp this x).mpr Algebra.mem_top).symm 
    rw [eq_top_iff, ←adjoin_root_eq_top, Algebra.adjoin_le_iff, Set.singleton_subset_iff]
    exact (@lift_root _ _ _ _ _ _ _ (aeval_alg_hom_eq_zero f ϕ)).symm

variable (hfx : aeval a f = 0)

@[simp]
theorem lift_hom_mk {g : Polynomial R} : lift_hom f a hfx (mk f g) = aeval a g :=
  lift_mk hfx g

@[simp]
theorem lift_hom_root : lift_hom f a hfx (root f) = a :=
  lift_root hfx

@[simp]
theorem lift_hom_of {x : R} : lift_hom f a hfx (of f x) = algebraMap _ _ x :=
  lift_of hfx

end CommRingₓ

section Irreducible

variable [Field K] {f : Polynomial K} [Irreducible f]

instance is_maximal_span : is_maximal (span {f} : Ideal (Polynomial K)) :=
  PrincipalIdealRing.is_maximal_of_irreducible ‹Irreducible f›

noncomputable instance Field : Field (AdjoinRoot f) :=
  { AdjoinRoot.commRing f, Ideal.Quotient.field (span {f} : Ideal (Polynomial K)) with  }

theorem coe_injective : Function.Injective (coeₓ : K → AdjoinRoot f) :=
  (of f).Injective

variable (f)

theorem mul_div_root_cancel :
  ((X - C (root f))*f.map (of f) / (X - C (root f)) : Polynomial (AdjoinRoot f)) = f.map (of f) :=
  mul_div_eq_iff_is_root.2$ is_root_root _

end Irreducible

section PowerBasis

variable [CommRingₓ R] {g : Polynomial R}

theorem is_integral_root' (hg : g.monic) : IsIntegral R (root g) :=
  ⟨g, hg, eval₂_root g⟩

/-- `adjoin_root.mod_by_monic_hom` sends the equivalence class of `f` mod `g` to `f %ₘ g`.

This is a well-defined right inverse to `adjoin_root.mk`, see `adjoin_root.mk_left_inverse`. -/
def mod_by_monic_hom [Nontrivial R] (hg : g.monic) : AdjoinRoot g →ₗ[R] Polynomial R :=
  (Submodule.liftq _ (Polynomial.modByMonicHom hg)
        fun f hf : f ∈ (Ideal.span {g}).restrictScalars R =>
          (mem_ker_mod_by_monic hg).mpr (Ideal.mem_span_singleton.mp hf)).comp$
    (Submodule.Quotient.restrictScalarsEquiv R (Ideal.span {g} : Ideal (Polynomial R))).symm.toLinearMap

@[simp]
theorem mod_by_monic_hom_mk [Nontrivial R] (hg : g.monic) (f : Polynomial R) : mod_by_monic_hom hg (mk g f) = f %ₘ g :=
  rfl

theorem mk_left_inverse [Nontrivial R] (hg : g.monic) : Function.LeftInverse (mk g) (mod_by_monic_hom hg) :=
  fun f =>
    induction_on g f$
      fun f =>
        by 
          rw [mod_by_monic_hom_mk hg, mk_eq_mk, mod_by_monic_eq_sub_mul_div _ hg, sub_sub_cancel_left, dvd_neg]
          apply dvd_mul_right

theorem mk_surjective [Nontrivial R] (hg : g.monic) : Function.Surjective (mk g) :=
  (mk_left_inverse hg).Surjective

-- error in RingTheory.AdjoinRoot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The elements `1, root g, ..., root g ^ (d - 1)` form a basis for `adjoin_root g`,
where `g` is a monic polynomial of degree `d`. -/
@[simps #[]]
def power_basis_aux' [nontrivial R] (hg : g.monic) : basis (fin g.nat_degree) R (adjoin_root g) :=
basis.of_equiv_fun { to_fun := λ f i, (mod_by_monic_hom hg f).coeff i,
  inv_fun := λ c, «expr $ »(mk g, «expr∑ , »((i : fin g.nat_degree), monomial i (c i))),
  map_add' := λ
  f₁
  f₂, «expr $ »(funext, λ
   i, by simp [] [] ["only"] ["[", expr (mod_by_monic_hom hg).map_add, ",", expr coeff_add, ",", expr pi.add_apply, "]"] [] []),
  map_smul' := λ
  f₁
  f₂, «expr $ »(funext, λ
   i, by simp [] [] ["only"] ["[", expr (mod_by_monic_hom hg).map_smul, ",", expr coeff_smul, ",", expr pi.smul_apply, ",", expr ring_hom.id_apply, "]"] [] []),
  left_inv := λ
  f, induction_on g f (λ
   f, «expr $ »(eq.symm, «expr $ »(mk_eq_mk.mpr, by { simp [] [] ["only"] ["[", expr mod_by_monic_hom_mk, ",", expr sum_mod_by_monic_coeff hg degree_le_nat_degree, "]"] [] [],
       rw ["[", expr mod_by_monic_eq_sub_mul_div _ hg, ",", expr sub_sub_cancel, "]"] [],
       exact [expr dvd_mul_right _ _] }))),
  right_inv := λ
  x, «expr $ »(funext, λ i, begin
     simp [] [] ["only"] ["[", expr mod_by_monic_hom_mk, "]"] [] [],
     rw ["[", expr (mod_by_monic_eq_self_iff hg).mpr, ",", expr finset_sum_coeff, ",", expr finset.sum_eq_single i, "]"] []; try { simp [] [] ["only"] ["[", expr coeff_monomial, ",", expr eq_self_iff_true, ",", expr if_true, "]"] [] [] },
     { intros [ident j, "_", ident hj],
       exact [expr if_neg (fin.coe_injective.ne hj)] },
     { intros [],
       have [] [] [":=", expr finset.mem_univ i],
       contradiction },
     { refine [expr (degree_sum_le _ _).trans_lt ((finset.sup_lt_iff _).mpr (λ j _, _))],
       { exact [expr bot_lt_iff_ne_bot.mpr (mt degree_eq_bot.mp hg.ne_zero)] },
       { refine [expr (degree_monomial_le _ _).trans_lt _],
         rw ["[", expr degree_eq_nat_degree hg.ne_zero, ",", expr with_bot.coe_lt_coe, "]"] [],
         exact [expr j.2] } }
   end) }

-- error in RingTheory.AdjoinRoot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The power basis `1, root g, ..., root g ^ (d - 1)` for `adjoin_root g`,
where `g` is a monic polynomial of degree `d`. -/
@[simps #[]]
def power_basis' [nontrivial R] (hg : g.monic) : power_basis R (adjoin_root g) :=
{ gen := root g,
  dim := g.nat_degree,
  basis := power_basis_aux' hg,
  basis_eq_pow := λ i, begin
    simp [] [] ["only"] ["[", expr power_basis_aux', ",", expr basis.coe_of_equiv_fun, ",", expr linear_equiv.coe_symm_mk, "]"] [] [],
    rw [expr finset.sum_eq_single i] [],
    { rw ["[", expr function.update_same, ",", expr monomial_one_right_eq_X_pow, ",", expr (mk g).map_pow, ",", expr mk_X, "]"] [] },
    { intros [ident j, "_", ident hj],
      rw ["<-", expr monomial_zero_right _] [],
      convert [] [expr congr_arg _ (function.update_noteq hj _ _)] [] },
    { intros [],
      have [] [] [":=", expr finset.mem_univ i],
      contradiction }
  end }

variable [Field K] {f : Polynomial K}

theorem is_integral_root (hf : f ≠ 0) : IsIntegral K (root f) :=
  (is_algebraic_iff_is_integral _).mp (is_algebraic_root hf)

-- error in RingTheory.AdjoinRoot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem minpoly_root
(hf : «expr ≠ »(f, 0)) : «expr = »(minpoly K (root f), «expr * »(f, C «expr ⁻¹»(f.leading_coeff))) :=
begin
  have [ident f'_monic] [":", expr monic _] [":=", expr monic_mul_leading_coeff_inv hf],
  refine [expr (minpoly.unique K _ f'_monic _ _).symm],
  { rw ["[", expr alg_hom.map_mul, ",", expr aeval_eq, ",", expr mk_self, ",", expr zero_mul, "]"] [] },
  intros [ident q, ident q_monic, ident q_aeval],
  have [ident commutes] [":", expr «expr = »((lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q), mk f)] [],
  { ext [] [] [],
    { simp [] [] ["only"] ["[", expr ring_hom.comp_apply, ",", expr mk_C, ",", expr lift_of, "]"] [] [],
      refl },
    { simp [] [] ["only"] ["[", expr ring_hom.comp_apply, ",", expr mk_X, ",", expr lift_root, "]"] [] [] } },
  rw ["[", expr degree_eq_nat_degree f'_monic.ne_zero, ",", expr degree_eq_nat_degree q_monic.ne_zero, ",", expr with_bot.coe_le_coe, ",", expr nat_degree_mul hf, ",", expr nat_degree_C, ",", expr add_zero, "]"] [],
  apply [expr nat_degree_le_of_dvd],
  { have [] [":", expr «expr = »(mk f q, 0)] [],
    by rw ["[", "<-", expr commutes, ",", expr ring_hom.comp_apply, ",", expr mk_self, ",", expr ring_hom.map_zero, "]"] [],
    rwa ["[", "<-", expr ideal.mem_span_singleton, ",", "<-", expr ideal.quotient.eq_zero_iff_mem, "]"] [] },
  { exact [expr q_monic.ne_zero] },
  { rwa ["[", expr ne.def, ",", expr C_eq_zero, ",", expr inv_eq_zero, ",", expr leading_coeff_eq_zero, "]"] [] }
end

-- error in RingTheory.AdjoinRoot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The elements `1, root f, ..., root f ^ (d - 1)` form a basis for `adjoin_root f`,
where `f` is an irreducible polynomial over a field of degree `d`. -/
def power_basis_aux (hf : «expr ≠ »(f, 0)) : basis (fin f.nat_degree) K (adjoin_root f) :=
begin
  set [] [ident f'] [] [":="] [expr «expr * »(f, C «expr ⁻¹»(f.leading_coeff))] ["with", ident f'_def],
  have [ident deg_f'] [":", expr «expr = »(f'.nat_degree, f.nat_degree)] [],
  { rw ["[", expr nat_degree_mul hf, ",", expr nat_degree_C, ",", expr add_zero, "]"] [],
    { rwa ["[", expr ne.def, ",", expr C_eq_zero, ",", expr inv_eq_zero, ",", expr leading_coeff_eq_zero, "]"] [] } },
  have [ident minpoly_eq] [":", expr «expr = »(minpoly K (root f), f')] [":=", expr minpoly_root hf],
  apply [expr @basis.mk _ _ _ (λ i : fin f.nat_degree, «expr ^ »(root f, i.val))],
  { rw ["[", "<-", expr deg_f', ",", "<-", expr minpoly_eq, "]"] [],
    exact [expr (is_integral_root hf).linear_independent_pow] },
  { rw [expr _root_.eq_top_iff] [],
    rintros [ident y, "-"],
    rw ["[", "<-", expr deg_f', ",", "<-", expr minpoly_eq, "]"] [],
    apply [expr (is_integral_root hf).mem_span_pow],
    obtain ["⟨", ident g, "⟩", ":=", expr y],
    use [expr g],
    rw [expr aeval_eq] [],
    refl }
end

/-- The power basis `1, root f, ..., root f ^ (d - 1)` for `adjoin_root f`,
where `f` is an irreducible polynomial over a field of degree `d`. -/
@[simps]
def PowerBasis (hf : f ≠ 0) : PowerBasis K (AdjoinRoot f) :=
  { gen := root f, dim := f.nat_degree, Basis := power_basis_aux hf, basis_eq_pow := Basis.mk_apply _ _ }

theorem minpoly_power_basis_gen (hf : f ≠ 0) : minpoly K (PowerBasis hf).gen = f*C (f.leading_coeff⁻¹) :=
  by 
    rw [power_basis_gen, minpoly_root hf]

theorem minpoly_power_basis_gen_of_monic (hf : f.monic) (hf' : f ≠ 0 := hf.ne_zero) :
  minpoly K (PowerBasis hf').gen = f :=
  by 
    rw [minpoly_power_basis_gen hf', hf.leading_coeff, inv_one, C.map_one, mul_oneₓ]

end PowerBasis

section Equiv

section IsDomain

variable [CommRingₓ R] [IsDomain R] [CommRingₓ S] [IsDomain S] [Algebra R S]

variable (g : Polynomial R) (pb : _root_.power_basis R S)

/-- If `S` is an extension of `R` with power basis `pb` and `g` is a monic polynomial over `R`
such that `pb.gen` has a minimal polynomial `g`, then `S` is isomorphic to `adjoin_root g`.

Compare `power_basis.equiv_of_root`, which would require
`h₂ : aeval pb.gen (minpoly R (root g)) = 0`; that minimal polynomial is not
guaranteed to be identical to `g`. -/
@[simps (config := { fullyApplied := ff })]
def equiv' (h₁ : aeval (root g) (minpoly R pb.gen) = 0) (h₂ : aeval pb.gen g = 0) : AdjoinRoot g ≃ₐ[R] S :=
  { AdjoinRoot.liftHom g pb.gen h₂ with toFun := AdjoinRoot.liftHom g pb.gen h₂, invFun := pb.lift (root g) h₁,
    left_inv :=
      fun x =>
        induction_on g x$
          fun f =>
            by 
              rw [lift_hom_mk, pb.lift_aeval, aeval_eq],
    right_inv :=
      fun x =>
        by 
          obtain ⟨f, hf, rfl⟩ := pb.exists_eq_aeval x 
          rw [pb.lift_aeval, aeval_eq, lift_hom_mk] }

@[simp]
theorem equiv'_to_alg_hom (h₁ : aeval (root g) (minpoly R pb.gen) = 0) (h₂ : aeval pb.gen g = 0) :
  (equiv' g pb h₁ h₂).toAlgHom = AdjoinRoot.liftHom g pb.gen h₂ :=
  rfl

@[simp]
theorem equiv'_symm_to_alg_hom (h₁ : aeval (root g) (minpoly R pb.gen) = 0) (h₂ : aeval pb.gen g = 0) :
  (equiv' g pb h₁ h₂).symm.toAlgHom = pb.lift (root g) h₁ :=
  rfl

end IsDomain

section Field

variable (K) (L F : Type _) [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L]

variable (pb : _root_.power_basis F K)

/-- If `L` is a field extension of `F` and `f` is a polynomial over `F` then the set
of maps from `F[x]/(f)` into `L` is in bijection with the set of roots of `f` in `L`. -/
def Equiv (f : Polynomial F) (hf : f ≠ 0) : (AdjoinRoot f →ₐ[F] L) ≃ { x // x ∈ (f.map (algebraMap F L)).roots } :=
  (PowerBasis hf).liftEquiv'.trans
    ((Equiv.refl _).subtypeEquiv
      fun x =>
        by 
          rw [power_basis_gen, minpoly_root hf, Polynomial.map_mul, roots_mul, Polynomial.map_C, roots_C, add_zeroₓ,
            Equiv.refl_apply]
          ·
            rw [←Polynomial.map_mul]
            exact map_monic_ne_zero (monic_mul_leading_coeff_inv hf))

end Field

end Equiv

end AdjoinRoot

