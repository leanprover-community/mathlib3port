/-
Copyright Â© 2020 NicolÃ² Cavalleri. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: NicolÃ² Cavalleri, Andrew Yang

! This file was ported from Lean 3 source module ring_theory.derivation
! leanprover-community/mathlib commit 26f081a2fb920140ed5bc5cc5344e84bcc7cb2b2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.Adjoin.Basic
import Mathbin.Algebra.Lie.OfAssociative
import Mathbin.RingTheory.Ideal.Cotangent
import Mathbin.RingTheory.IsTensorProduct

/-!
# Derivations

This file defines derivation. A derivation `D` from the `R`-algebra `A` to the `A`-module `M` is an
`R`-linear map that satisfy the Leibniz rule `D (a * b) = a * D b + D a * b`.

## Main results

- `derivation`: The type of `R`-derivations from `A` to `M`. This has an `A`-module structure.
- `derivation.llcomp`: We may compose linear maps and derivations to obtain a derivation,
  and the composition is bilinear.
- `derivation.lie_algebra`: The `R`-derivations from `A` to `A` form an lie algebra over `R`.
- `derivation_to_square_zero_equiv_lift`: The `R`-derivations from `A` into a square-zero ideal `I`
  of `B` corresponds to the lifts `A â†’â‚[R] B` of the map `A â†’â‚[R] B â§¸ I`.
- `kaehler_differential`: The module of kaehler differentials. For an `R`-algebra `S`, we provide
  the notation `Î©[Sâ„R]` for `kaehler_differential R S`.
  Note that the slash is `\textfractionsolidus`.
- `kaehler_differential.D`: The derivation into the module of kaehler differentials.
- `kaehler_differential.span_range_derivation`: The image of `D` spans `Î©[Sâ„R]` as an `S`-module.
- `kaehler_differential.linear_map_equiv_derivation`:
  The isomorphism `Hom_R(Î©[Sâ„R], M) â‰ƒâ‚—[S] Der_R(S, M)`.
- `kaehler_differential.quot_ker_total_equiv`: An alternative description of `Î©[Sâ„R]` as `S` copies
  of `S` with kernel (`kaehler_differential.ker_total`) generated by the relations:
  1. `dx + dy = d(x + y)`
  2. `x dy + y dx = d(x * y)`
  3. `dr = 0` for `r âˆˆ R`
- `kaehler_differential.map`: Given a map between the arrows `R â†’ A` and `S â†’ B`, we have an
  `A`-linear map `Î©[Aâ„R] â†’ Î©[Bâ„S]`.

## Future project

- Generalize derivations into bimodules.
- Define a `is_kaehler_differential` predicate.

-/


open Algebra

open BigOperators

/-- `D : derivation R A M` is an `R`-linear map from `A` to `M` that satisfies the `leibniz`
equality. We also require that `D 1 = 0`. See `derivation.mk'` for a constructor that deduces this
assumption from the Leibniz rule when `M` is cancellative.

TODO: update this when bimodules are defined. -/
@[protect_proj]
structure Derivation (R : Type _) (A : Type _) [CommSemiring R] [CommSemiring A] [Algebra R A]
  (M : Type _) [AddCommMonoid M] [Module A M] [Module R M] extends A â†’â‚—[R] M where
  map_one_eq_zero' : to_linear_map 1 = 0
  leibniz' (a b : A) : to_linear_map (a * b) = a â€¢ to_linear_map b + b â€¢ to_linear_map a
#align derivation Derivation

/-- The `linear_map` underlying a `derivation`. -/
add_decl_doc Derivation.toLinearMap

namespace Derivation

section

variable {R : Type _} [CommSemiring R]

variable {A : Type _} [CommSemiring A] [Algebra R A]

variable {M : Type _} [AddCommMonoid M] [Module A M] [Module R M]

variable (D : Derivation R A M) {D1 D2 : Derivation R A M} (r : R) (a b : A)

instance : AddMonoidHomClass (Derivation R A M) A M
    where
  coe D := D.toFun
  coe_injective' D1 D2 h := by
    cases D1
    cases D2
    congr
    exact FunLike.coe_injective h
  map_add D := D.toLinearMap.map_add'
  map_zero D := D.toLinearMap.map_zero

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (Derivation R A M) fun _ => A â†’ M :=
  âŸ¨fun D => D.toLinearMap.toFunâŸ©

-- Not a simp lemma because it can be proved via `coe_fn_coe` + `to_linear_map_eq_coe`
theorem to_fun_eq_coe : D.toFun = â‡‘D :=
  rfl
#align derivation.to_fun_eq_coe Derivation.to_fun_eq_coe

instance hasCoeToLinearMap : Coe (Derivation R A M) (A â†’â‚—[R] M) :=
  âŸ¨fun D => D.toLinearMapâŸ©
#align derivation.has_coe_to_linear_map Derivation.hasCoeToLinearMap

@[simp]
theorem to_linear_map_eq_coe : D.toLinearMap = D :=
  rfl
#align derivation.to_linear_map_eq_coe Derivation.to_linear_map_eq_coe

@[simp]
theorem mk_coe (f : A â†’â‚—[R] M) (hâ‚ hâ‚‚) : ((âŸ¨f, hâ‚, hâ‚‚âŸ© : Derivation R A M) : A â†’ M) = f :=
  rfl
#align derivation.mk_coe Derivation.mk_coe

@[simp, norm_cast]
theorem coe_fn_coe (f : Derivation R A M) : â‡‘(f : A â†’â‚—[R] M) = f :=
  rfl
#align derivation.coe_fn_coe Derivation.coe_fn_coe

theorem coe_injective : @Function.Injective (Derivation R A M) (A â†’ M) coeFn :=
  FunLike.coe_injective
#align derivation.coe_injective Derivation.coe_injective

@[ext]
theorem ext (H : âˆ€ a, D1 a = D2 a) : D1 = D2 :=
  FunLike.ext _ _ H
#align derivation.ext Derivation.ext

theorem congr_fun (h : D1 = D2) (a : A) : D1 a = D2 a :=
  FunLike.congr_fun h a
#align derivation.congr_fun Derivation.congr_fun

protected theorem map_add : D (a + b) = D a + D b :=
  map_add D a b
#align derivation.map_add Derivation.map_add

protected theorem map_zero : D 0 = 0 :=
  map_zero D
#align derivation.map_zero Derivation.map_zero

@[simp]
theorem map_smul : D (r â€¢ a) = r â€¢ D a :=
  D.toLinearMap.map_smul r a
#align derivation.map_smul Derivation.map_smul

@[simp]
theorem leibniz : D (a * b) = a â€¢ D b + b â€¢ D a :=
  D.leibniz' _ _
#align derivation.leibniz Derivation.leibniz

theorem map_sum {Î¹ : Type _} (s : Finset Î¹) (f : Î¹ â†’ A) : D (âˆ‘ i in s, f i) = âˆ‘ i in s, D (f i) :=
  D.toLinearMap.map_sum
#align derivation.map_sum Derivation.map_sum

@[simp]
theorem map_smul_of_tower {S : Type _} [HasSmul S A] [HasSmul S M]
    [LinearMap.CompatibleSmul A M S R] (D : Derivation R A M) (r : S) (a : A) :
    D (r â€¢ a) = r â€¢ D a :=
  D.toLinearMap.map_smul_of_tower r a
#align derivation.map_smul_of_tower Derivation.map_smul_of_tower

@[simp]
theorem map_one_eq_zero : D 1 = 0 :=
  D.map_one_eq_zero'
#align derivation.map_one_eq_zero Derivation.map_one_eq_zero

@[simp]
theorem map_algebra_map : D (algebraMap R A r) = 0 := by
  rw [â† mul_one r, RingHom.map_mul, RingHom.map_one, â† smul_def, map_smul, map_one_eq_zero,
    smul_zero]
#align derivation.map_algebra_map Derivation.map_algebra_map

@[simp]
theorem map_coe_nat (n : â„•) : D (n : A) = 0 := by
  rw [â† nsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]
#align derivation.map_coe_nat Derivation.map_coe_nat

@[simp]
theorem leibniz_pow (n : â„•) : D (a ^ n) = n â€¢ a ^ (n - 1) â€¢ D a :=
  by
  induction' n with n ihn
  Â· rw [pow_zero, map_one_eq_zero, zero_smul]
  Â· rcases(zero_le n).eq_or_lt with (rfl | hpos)
    Â· rw [pow_one, one_smul, pow_zero, one_smul]
    Â· have : a * a ^ (n - 1) = a ^ n := by rw [â† pow_succ, Nat.sub_add_cancel hpos]
      simp only [pow_succ, leibniz, ihn, smul_comm a n, smul_smul a, add_smul, this,
        Nat.succ_eq_add_one, Nat.add_succ_sub_one, add_zero, one_nsmul]
#align derivation.leibniz_pow Derivation.leibniz_pow

theorem eq_on_adjoin {s : Set A} (h : Set.EqOn D1 D2 s) : Set.EqOn D1 D2 (adjoin R s) := fun x hx =>
  Algebra.adjoin_induction hx h (fun r => (D1.map_algebra_map r).trans (D2.map_algebra_map r).symm)
    (fun x y hx hy => by simp only [map_add, *]) fun x y hx hy => by simp only [leibniz, *]
#align derivation.eq_on_adjoin Derivation.eq_on_adjoin

/-- If adjoin of a set is the whole algebra, then any two derivations equal on this set are equal
on the whole algebra. -/
theorem ext_of_adjoin_eq_top (s : Set A) (hs : adjoin R s = âŠ¤) (h : Set.EqOn D1 D2 s) : D1 = D2 :=
  ext fun a => eq_on_adjoin h <| hs.symm â–¸ trivial
#align derivation.ext_of_adjoin_eq_top Derivation.ext_of_adjoin_eq_top

-- Data typeclasses
instance : Zero (Derivation R A M) :=
  âŸ¨{  toLinearMap := 0
      map_one_eq_zero' := rfl
      leibniz' := fun a b => by simp only [add_zero, LinearMap.zero_apply, smul_zero] }âŸ©

@[simp]
theorem coe_zero : â‡‘(0 : Derivation R A M) = 0 :=
  rfl
#align derivation.coe_zero Derivation.coe_zero

@[simp]
theorem coe_zero_linear_map : â†‘(0 : Derivation R A M) = (0 : A â†’â‚—[R] M) :=
  rfl
#align derivation.coe_zero_linear_map Derivation.coe_zero_linear_map

theorem zero_apply (a : A) : (0 : Derivation R A M) a = 0 :=
  rfl
#align derivation.zero_apply Derivation.zero_apply

instance : Add (Derivation R A M) :=
  âŸ¨fun D1 D2 =>
    { toLinearMap := D1 + D2
      map_one_eq_zero' := by simp
      leibniz' := fun a b => by
        simp only [leibniz, LinearMap.add_apply, coe_fn_coe, smul_add, add_add_add_comm] }âŸ©

@[simp]
theorem coe_add (D1 D2 : Derivation R A M) : â‡‘(D1 + D2) = D1 + D2 :=
  rfl
#align derivation.coe_add Derivation.coe_add

@[simp]
theorem coe_add_linear_map (D1 D2 : Derivation R A M) : â†‘(D1 + D2) = (D1 + D2 : A â†’â‚—[R] M) :=
  rfl
#align derivation.coe_add_linear_map Derivation.coe_add_linear_map

theorem add_apply : (D1 + D2) a = D1 a + D2 a :=
  rfl
#align derivation.add_apply Derivation.add_apply

instance : Inhabited (Derivation R A M) :=
  âŸ¨0âŸ©

section Scalar

variable {S : Type _} [Monoid S] [DistribMulAction S M] [SMulCommClass R S M] [SMulCommClass S A M]

instance (priority := 100) : HasSmul S (Derivation R A M) :=
  âŸ¨fun r D =>
    { toLinearMap := r â€¢ D
      map_one_eq_zero' := by rw [LinearMap.smul_apply, coe_fn_coe, D.map_one_eq_zero, smul_zero]
      leibniz' := fun a b => by
        simp only [LinearMap.smul_apply, coe_fn_coe, leibniz, smul_add, smul_comm r] }âŸ©

@[simp]
theorem coe_smul (r : S) (D : Derivation R A M) : â‡‘(r â€¢ D) = r â€¢ D :=
  rfl
#align derivation.coe_smul Derivation.coe_smul

@[simp]
theorem coe_smul_linear_map (r : S) (D : Derivation R A M) : â†‘(r â€¢ D) = (r â€¢ D : A â†’â‚—[R] M) :=
  rfl
#align derivation.coe_smul_linear_map Derivation.coe_smul_linear_map

theorem smul_apply (r : S) (D : Derivation R A M) : (r â€¢ D) a = r â€¢ D a :=
  rfl
#align derivation.smul_apply Derivation.smul_apply

instance : AddCommMonoid (Derivation R A M) :=
  coe_injective.AddCommMonoid _ coe_zero coe_add fun _ _ => rfl

/-- `coe_fn` as an `add_monoid_hom`. -/
def coeFnAddMonoidHom : Derivation R A M â†’+ A â†’ M
    where
  toFun := coeFn
  map_zero' := coe_zero
  map_add' := coe_add
#align derivation.coe_fn_add_monoid_hom Derivation.coeFnAddMonoidHom

instance (priority := 100) : DistribMulAction S (Derivation R A M) :=
  Function.Injective.distribMulAction coeFnAddMonoidHom coe_injective coe_smul

instance [DistribMulAction Sáµáµ’áµ– M] [IsCentralScalar S M] : IsCentralScalar S (Derivation R A M)
    where op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _

end Scalar

instance (priority := 100) {S : Type _} [Semiring S] [Module S M] [SMulCommClass R S M]
    [SMulCommClass S A M] : Module S (Derivation R A M) :=
  Function.Injective.module S coeFnAddMonoidHom coe_injective coe_smul

instance [IsScalarTower R A M] : IsScalarTower R A (Derivation R A M) :=
  âŸ¨fun x y z => ext fun a => smul_assoc _ _ _âŸ©

section PushForward

variable {N : Type _} [AddCommMonoid N] [Module A N] [Module R N] [IsScalarTower R A M]
  [IsScalarTower R A N]

variable (f : M â†’â‚—[A] N) (e : M â‰ƒâ‚—[A] N)

/-- We can push forward derivations using linear maps, i.e., the composition of a derivation with a
linear map is a derivation. Furthermore, this operation is linear on the spaces of derivations. -/
def LinearMap.compDer : Derivation R A M â†’â‚—[R] Derivation R A N
    where
  toFun D :=
    { toLinearMap := (f : M â†’â‚—[R] N).comp (D : A â†’â‚—[R] M)
      map_one_eq_zero' := by simp only [LinearMap.comp_apply, coe_fn_coe, map_one_eq_zero, map_zero]
      leibniz' := fun a b => by
        simp only [coe_fn_coe, LinearMap.comp_apply, LinearMap.map_add, leibniz,
          LinearMap.coe_coe_is_scalar_tower, LinearMap.map_smul] }
  map_add' Dâ‚ Dâ‚‚ := by
    ext
    exact LinearMap.map_add _ _ _
  map_smul' r D := by
    ext
    exact LinearMap.map_smul _ _ _
#align linear_map.comp_der LinearMap.compDer

@[simp]
theorem coe_to_linear_map_comp : (f.compDer D : A â†’â‚—[R] N) = (f : M â†’â‚—[R] N).comp (D : A â†’â‚—[R] M) :=
  rfl
#align derivation.coe_to_linear_map_comp Derivation.coe_to_linear_map_comp

@[simp]
theorem coe_comp : (f.compDer D : A â†’ N) = (f : M â†’â‚—[R] N).comp (D : A â†’â‚—[R] M) :=
  rfl
#align derivation.coe_comp Derivation.coe_comp

/-- The composition of a derivation with a linear map as a bilinear map -/
@[simps]
def llcomp : (M â†’â‚—[A] N) â†’â‚—[A] Derivation R A M â†’â‚—[R] Derivation R A N
    where
  toFun f := f.compDer
  map_add' fâ‚ fâ‚‚ := by
    ext
    rfl
  map_smul' r D := by
    ext
    rfl
#align derivation.llcomp Derivation.llcomp

/-- Pushing a derivation foward through a linear equivalence is an equivalence. -/
def LinearEquiv.compDer : Derivation R A M â‰ƒâ‚—[R] Derivation R A N :=
  { e.toLinearMap.compDer with
    invFun := e.symm.toLinearMap.compDer
    left_inv := fun D => by
      ext a
      exact e.symm_apply_apply (D a)
    right_inv := fun D => by
      ext a
      exact e.apply_symm_apply (D a) }
#align linear_equiv.comp_der LinearEquiv.compDer

end PushForward

section RestrictScalars

variable {S : Type _} [CommSemiring S]

variable [Algebra S A] [Module S M] [LinearMap.CompatibleSmul A M R S]

variable (R)

/-- If `A` is both an `R`-algebra and an `S`-algebra; `M` is both an `R`-module and an `S`-module,
then an `S`-derivation `A â†’ M` is also an `R`-derivation if it is also `R`-linear. -/
protected def restrictScalars (d : Derivation S A M) : Derivation R A M
    where
  map_one_eq_zero' := d.map_one_eq_zero
  leibniz' := d.leibniz
  toLinearMap := d.toLinearMap.restrictScalars R
#align derivation.restrict_scalars Derivation.restrictScalars

end RestrictScalars

end

section Cancel

variable {R : Type _} [CommSemiring R] {A : Type _} [CommSemiring A] [Algebra R A] {M : Type _}
  [AddCancelCommMonoid M] [Module R M] [Module A M]

/-- Define `derivation R A M` from a linear map when `M` is cancellative by verifying the Leibniz
rule. -/
def mk' (D : A â†’â‚—[R] M) (h : âˆ€ a b, D (a * b) = a â€¢ D b + b â€¢ D a) : Derivation R A M
    where
  toLinearMap := D
  map_one_eq_zero' := add_right_eq_self.1 <| by simpa only [one_smul, one_mul] using (h 1 1).symm
  leibniz' := h
#align derivation.mk' Derivation.mk'

@[simp]
theorem coe_mk' (D : A â†’â‚—[R] M) (h) : â‡‘(mk' D h) = D :=
  rfl
#align derivation.coe_mk' Derivation.coe_mk'

@[simp]
theorem coe_mk'_linear_map (D : A â†’â‚—[R] M) (h) : (mk' D h : A â†’â‚—[R] M) = D :=
  rfl
#align derivation.coe_mk'_linear_map Derivation.coe_mk'_linear_map

end Cancel

section

variable {R : Type _} [CommRing R]

variable {A : Type _} [CommRing A] [Algebra R A]

section

variable {M : Type _} [AddCommGroup M] [Module A M] [Module R M]

variable (D : Derivation R A M) {D1 D2 : Derivation R A M} (r : R) (a b : A)

protected theorem map_neg : D (-a) = -D a :=
  map_neg D a
#align derivation.map_neg Derivation.map_neg

protected theorem map_sub : D (a - b) = D a - D b :=
  map_sub D a b
#align derivation.map_sub Derivation.map_sub

@[simp]
theorem map_coe_int (n : â„¤) : D (n : A) = 0 := by
  rw [â† zsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]
#align derivation.map_coe_int Derivation.map_coe_int

theorem leibniz_of_mul_eq_one {a b : A} (h : a * b = 1) : D a = -a ^ 2 â€¢ D b :=
  by
  rw [neg_smul]
  refine' eq_neg_of_add_eq_zero_left _
  calc
    D a + a ^ 2 â€¢ D b = a â€¢ b â€¢ D a + a â€¢ a â€¢ D b := by simp only [smul_smul, h, one_smul, sq]
    _ = a â€¢ D (a * b) := by rw [leibniz, smul_add, add_comm]
    _ = 0 := by rw [h, map_one_eq_zero, smul_zero]
    
#align derivation.leibniz_of_mul_eq_one Derivation.leibniz_of_mul_eq_one

theorem leibniz_inv_of [Invertible a] : D (â…Ÿ a) = -â…Ÿ a ^ 2 â€¢ D a :=
  D.leibniz_of_mul_eq_one <| invOf_mul_self a
#align derivation.leibniz_inv_of Derivation.leibniz_inv_of

theorem leibniz_inv {K : Type _} [Field K] [Module K M] [Algebra R K] (D : Derivation R K M)
    (a : K) : D aâ»Â¹ = -aâ»Â¹ ^ 2 â€¢ D a :=
  by
  rcases eq_or_ne a 0 with (rfl | ha)
  Â· simp
  Â· exact D.leibniz_of_mul_eq_one (inv_mul_cancel ha)
#align derivation.leibniz_inv Derivation.leibniz_inv

instance : Neg (Derivation R A M) :=
  âŸ¨fun D =>
    (mk' (-D)) fun a b => by
      simp only [LinearMap.neg_apply, smul_neg, neg_add_rev, leibniz, coe_fn_coe, add_comm]âŸ©

@[simp]
theorem coe_neg (D : Derivation R A M) : â‡‘(-D) = -D :=
  rfl
#align derivation.coe_neg Derivation.coe_neg

@[simp]
theorem coe_neg_linear_map (D : Derivation R A M) : â†‘(-D) = (-D : A â†’â‚—[R] M) :=
  rfl
#align derivation.coe_neg_linear_map Derivation.coe_neg_linear_map

theorem neg_apply : (-D) a = -D a :=
  rfl
#align derivation.neg_apply Derivation.neg_apply

instance : Sub (Derivation R A M) :=
  âŸ¨fun D1 D2 =>
    (mk' (D1 - D2 : A â†’â‚—[R] M)) fun a b => by
      simp only [LinearMap.sub_apply, leibniz, coe_fn_coe, smul_sub, add_sub_add_comm]âŸ©

@[simp]
theorem coe_sub (D1 D2 : Derivation R A M) : â‡‘(D1 - D2) = D1 - D2 :=
  rfl
#align derivation.coe_sub Derivation.coe_sub

@[simp]
theorem coe_sub_linear_map (D1 D2 : Derivation R A M) : â†‘(D1 - D2) = (D1 - D2 : A â†’â‚—[R] M) :=
  rfl
#align derivation.coe_sub_linear_map Derivation.coe_sub_linear_map

theorem sub_apply : (D1 - D2) a = D1 a - D2 a :=
  rfl
#align derivation.sub_apply Derivation.sub_apply

instance : AddCommGroup (Derivation R A M) :=
  coe_injective.AddCommGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => rfl) fun _ _ => rfl

end

section LieStructures

/-! # Lie structures -/


variable (D : Derivation R A A) {D1 D2 : Derivation R A A} (r : R) (a b : A)

/-- The commutator of derivations is again a derivation. -/
instance : Bracket (Derivation R A A) (Derivation R A A) :=
  âŸ¨fun D1 D2 =>
    (mk' â…(D1 : Module.EndCat R A), (D2 : Module.EndCat R A)â†) fun a b =>
      by
      simp only [Ring.lie_def, map_add, id.smul_eq_mul, LinearMap.mul_apply, leibniz, coe_fn_coe,
        LinearMap.sub_apply]
      ringâŸ©

@[simp]
theorem commutator_coe_linear_map :
    â†‘â…D1, D2â† = â…(D1 : Module.EndCat R A), (D2 : Module.EndCat R A)â† :=
  rfl
#align derivation.commutator_coe_linear_map Derivation.commutator_coe_linear_map

theorem commutator_apply : â…D1, D2â† a = D1 (D2 a) - D2 (D1 a) :=
  rfl
#align derivation.commutator_apply Derivation.commutator_apply

instance : LieRing (Derivation R A A)
    where
  add_lie d e f := by
    ext a
    simp only [commutator_apply, add_apply, map_add]
    ring
  lie_add d e f := by
    ext a
    simp only [commutator_apply, add_apply, map_add]
    ring
  lie_self d := by
    ext a
    simp only [commutator_apply, add_apply, map_add]
    ring_nf
  leibniz_lie d e f := by
    ext a
    simp only [commutator_apply, add_apply, sub_apply, map_sub]
    ring

instance : LieAlgebra R (Derivation R A A) :=
  { Derivation.module with
    lie_smul := fun r d e => by
      ext a
      simp only [commutator_apply, map_smul, smul_sub, smul_apply] }

end LieStructures

end

end Derivation

section ToSquareZero

universe u v w

variable {R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [CommSemiring A] [CommRing B]

variable [Algebra R A] [Algebra R B] (I : Ideal B) (hI : I ^ 2 = âŠ¥)

/-- If `fâ‚ fâ‚‚ : A â†’â‚[R] B` are two lifts of the same `A â†’â‚[R] B â§¸ I`,
  we may define a map `fâ‚ - fâ‚‚ : A â†’â‚—[R] I`. -/
def diffToIdealOfQuotientCompEq (fâ‚ fâ‚‚ : A â†’â‚[R] B)
    (e : (Ideal.Quotient.mkâ‚ R I).comp fâ‚ = (Ideal.Quotient.mkâ‚ R I).comp fâ‚‚) : A â†’â‚—[R] I :=
  LinearMap.codRestrict (I.restrictScalars _) (fâ‚.toLinearMap - fâ‚‚.toLinearMap)
    (by
      intro x
      change fâ‚ x - fâ‚‚ x âˆˆ I
      rw [â† Ideal.Quotient.eq, â† Ideal.Quotient.mkâ‚_eq_mk R, â† AlgHom.comp_apply, e]
      rfl)
#align diff_to_ideal_of_quotient_comp_eq diffToIdealOfQuotientCompEq

@[simp]
theorem diff_to_ideal_of_quotient_comp_eq_apply (fâ‚ fâ‚‚ : A â†’â‚[R] B)
    (e : (Ideal.Quotient.mkâ‚ R I).comp fâ‚ = (Ideal.Quotient.mkâ‚ R I).comp fâ‚‚) (x : A) :
    ((diffToIdealOfQuotientCompEq I fâ‚ fâ‚‚ e) x : B) = fâ‚ x - fâ‚‚ x :=
  rfl
#align diff_to_ideal_of_quotient_comp_eq_apply diff_to_ideal_of_quotient_comp_eq_apply

variable [Algebra A B] [IsScalarTower R A B]

include hI

/-- Given a tower of algebras `R â†’ A â†’ B`, and a square-zero `I : ideal B`, each lift `A â†’â‚[R] B`
of the canonical map `A â†’â‚[R] B â§¸ I` corresponds to a `R`-derivation from `A` to `I`. -/
def derivationToSquareZeroOfLift (f : A â†’â‚[R] B)
    (e : (Ideal.Quotient.mkâ‚ R I).comp f = IsScalarTower.toAlgHom R A (B â§¸ I)) : Derivation R A I :=
  by
  refine'
    {
      diffToIdealOfQuotientCompEq I f (IsScalarTower.toAlgHom R A B)
        _ with
      map_one_eq_zero' := _
      leibniz' := _ }
  Â· rw [e]
    ext
    rfl
  Â· ext
    change f 1 - algebraMap A B 1 = 0
    rw [map_one, map_one, sub_self]
  Â· intro x y
    let F :=
      diffToIdealOfQuotientCompEq I f (IsScalarTower.toAlgHom R A B)
        (by
          rw [e]
          ext
          rfl)
    have : (f x - algebraMap A B x) * (f y - algebraMap A B y) = 0 :=
      by
      rw [â† Ideal.mem_bot, â† hI, pow_two]
      convert Ideal.mul_mem_mul (F x).2 (F y).2 using 1
    ext
    dsimp only [Submodule.coe_add, Submodule.coe_mk, LinearMap.coe_mk,
      diff_to_ideal_of_quotient_comp_eq_apply, Submodule.coe_smul_of_tower,
      IsScalarTower.coe_to_alg_hom', LinearMap.to_fun_eq_coe]
    simp only [map_mul, sub_mul, mul_sub, Algebra.smul_def] at thisâŠ¢
    rw [sub_eq_iff_eq_add, sub_eq_iff_eq_add] at this
    rw [this]
    ring
#align derivation_to_square_zero_of_lift derivationToSquareZeroOfLift

theorem derivation_to_square_zero_of_lift_apply (f : A â†’â‚[R] B)
    (e : (Ideal.Quotient.mkâ‚ R I).comp f = IsScalarTower.toAlgHom R A (B â§¸ I)) (x : A) :
    (derivationToSquareZeroOfLift I hI f e x : B) = f x - algebraMap A B x :=
  rfl
#align derivation_to_square_zero_of_lift_apply derivation_to_square_zero_of_lift_apply

/-- Given a tower of algebras `R â†’ A â†’ B`, and a square-zero `I : ideal B`, each `R`-derivation
from `A` to `I` corresponds to a lift `A â†’â‚[R] B` of the canonical map `A â†’â‚[R] B â§¸ I`. -/
def liftOfDerivationToSquareZero (f : Derivation R A I) : A â†’â‚[R] B :=
  {
    (I.restrictScalars R).Subtype.comp f.toLinearMap +
      (IsScalarTower.toAlgHom R A
          B).toLinearMap with
    map_one' :=
      show (f 1 : B) + algebraMap A B 1 = 1 by
        rw [map_one, f.map_one_eq_zero, Submodule.coe_zero, zero_add]
    map_mul' := fun x y =>
      by
      have : (f x : B) * f y = 0 :=
        by
        rw [â† Ideal.mem_bot, â† hI, pow_two]
        convert Ideal.mul_mem_mul (f x).2 (f y).2 using 1
      dsimp
      simp only [map_mul, f.leibniz, add_mul, mul_add, Submodule.coe_add,
        Submodule.coe_smul_of_tower, Algebra.smul_def, this]
      ring
    commutes' := fun r => by
      dsimp
      simp [â† IsScalarTower.algebra_map_apply R A B r]
    map_zero' :=
      ((I.restrictScalars R).Subtype.comp f.toLinearMap +
          (IsScalarTower.toAlgHom R A B).toLinearMap).map_zero }
#align lift_of_derivation_to_square_zero liftOfDerivationToSquareZero

theorem lift_of_derivation_to_square_zero_apply (f : Derivation R A I) (x : A) :
    liftOfDerivationToSquareZero I hI f x = f x + algebraMap A B x :=
  rfl
#align lift_of_derivation_to_square_zero_apply lift_of_derivation_to_square_zero_apply

@[simp]
theorem lift_of_derivation_to_square_zero_mk_apply (d : Derivation R A I) (x : A) :
    Ideal.Quotient.mk I (liftOfDerivationToSquareZero I hI d x) = algebraMap A (B â§¸ I) x :=
  by
  rw [lift_of_derivation_to_square_zero_apply, map_add,
    ideal.quotient.eq_zero_iff_mem.mpr (d x).Prop, zero_add]
  rfl
#align lift_of_derivation_to_square_zero_mk_apply lift_of_derivation_to_square_zero_mk_apply

/-- Given a tower of algebras `R â†’ A â†’ B`, and a square-zero `I : ideal B`,
there is a 1-1 correspondance between `R`-derivations from `A` to `I` and
lifts `A â†’â‚[R] B` of the canonical map `A â†’â‚[R] B â§¸ I`. -/
@[simps]
def derivationToSquareZeroEquivLift :
    Derivation R A I â‰ƒ
      { f : A â†’â‚[R] B // (Ideal.Quotient.mkâ‚ R I).comp f = IsScalarTower.toAlgHom R A (B â§¸ I) } :=
  by
  refine'
    âŸ¨fun d => âŸ¨liftOfDerivationToSquareZero I hI d, _âŸ©, fun f =>
      (derivationToSquareZeroOfLift I hI f.1 f.2 : _), _, _âŸ©
  Â· ext x
    exact lift_of_derivation_to_square_zero_mk_apply I hI d x
  Â· intro d
    ext x
    exact add_sub_cancel (d x : B) (algebraMap A B x)
  Â· rintro âŸ¨f, hfâŸ©
    ext x
    exact sub_add_cancel (f x) (algebraMap A B x)
#align derivation_to_square_zero_equiv_lift derivationToSquareZeroEquivLift

end ToSquareZero

section KaehlerDifferential

open TensorProduct

variable (R S : Type _) [CommRing R] [CommRing S] [Algebra R S]

/-- The kernel of the multiplication map `S âŠ—[R] S â†’â‚[R] S`. -/
abbrev KaehlerDifferential.ideal : Ideal (S âŠ—[R] S) :=
  RingHom.ker (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S)
#align kaehler_differential.ideal KaehlerDifferential.ideal

variable {S}

theorem KaehlerDifferential.one_smul_sub_smul_one_mem_ideal (a : S) :
    (1 : S) âŠ—â‚œ[R] a - a âŠ—â‚œ[R] (1 : S) âˆˆ KaehlerDifferential.ideal R S := by simp [RingHom.mem_ker]
#align
  kaehler_differential.one_smul_sub_smul_one_mem_ideal KaehlerDifferential.one_smul_sub_smul_one_mem_ideal

variable {R}

variable {M : Type _} [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower R S M]

/-- For a `R`-derivation `S â†’ M`, this is the map `S âŠ—[R] S â†’â‚—[S] M` sending `s âŠ—â‚œ t â†¦ s â€¢ D t`. -/
def Derivation.tensorProductTo (D : Derivation R S M) : S âŠ—[R] S â†’â‚—[S] M :=
  TensorProduct.AlgebraTensorModule.lift ((LinearMap.lsmul S (S â†’â‚—[R] M)).flip D.toLinearMap)
#align derivation.tensor_product_to Derivation.tensorProductTo

theorem Derivation.tensor_product_to_tmul (D : Derivation R S M) (s t : S) :
    D.tensorProductTo (s âŠ—â‚œ t) = s â€¢ D t :=
  TensorProduct.lift.tmul s t
#align derivation.tensor_product_to_tmul Derivation.tensor_product_to_tmul

theorem Derivation.tensor_product_to_mul (D : Derivation R S M) (x y : S âŠ—[R] S) :
    D.tensorProductTo (x * y) =
      TensorProduct.lmul' R x â€¢ D.tensorProductTo y +
        TensorProduct.lmul' R y â€¢ D.tensorProductTo x :=
  by
  apply TensorProduct.induction_on x
  Â· rw [zero_mul, map_zero, map_zero, zero_smul, smul_zero, add_zero]
  swap;
  Â· rintro
    simp only [add_mul, map_add, add_smul, *, smul_add]
    rw [add_add_add_comm]
  intro xâ‚ xâ‚‚
  apply TensorProduct.induction_on y
  Â· rw [mul_zero, map_zero, map_zero, zero_smul, smul_zero, add_zero]
  swap;
  Â· rintro
    simp only [mul_add, map_add, add_smul, *, smul_add]
    rw [add_add_add_comm]
  intro x y
  simp only [tensor_product.tmul_mul_tmul, Derivation.tensorProductTo,
    TensorProduct.AlgebraTensorModule.lift_apply, TensorProduct.lift.tmul',
    tensor_product.lmul'_apply_tmul]
  dsimp
  rw [D.leibniz]
  simp only [smul_smul, smul_add, mul_comm (x * y) xâ‚, mul_right_comm xâ‚ xâ‚‚, â† mul_assoc]
#align derivation.tensor_product_to_mul Derivation.tensor_product_to_mul

variable (R S)

/-- The kernel of `S âŠ—[R] S â†’â‚[R] S` is generated by `1 âŠ— s - s âŠ— 1` as a `S`-module. -/
theorem KaehlerDifferential.submodule_span_range_eq_ideal :
    Submodule.span S (Set.range fun s : S => (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S)) =
      (KaehlerDifferential.ideal R S).restrictScalars S :=
  by
  apply le_antisymm
  Â· rw [Submodule.span_le]
    rintro _ âŸ¨s, rflâŸ©
    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _
  Â· rintro x (hx : _ = _)
    have : x - tensor_product.lmul' R x âŠ—â‚œ[R] (1 : S) = x := by
      rw [hx, TensorProduct.zero_tmul, sub_zero]
    rw [â† this]
    clear this hx
    apply TensorProduct.induction_on x <;> clear x
    Â· rw [map_zero, TensorProduct.zero_tmul, sub_zero]
      exact zero_mem _
    Â· intro x y
      convert_to x â€¢ (1 âŠ—â‚œ y - y âŠ—â‚œ 1) âˆˆ _
      Â·
        rw [tensor_product.lmul'_apply_tmul, smul_sub, TensorProduct.smul_tmul',
          TensorProduct.smul_tmul', smul_eq_mul, smul_eq_mul, mul_one]
      Â· refine' Submodule.smul_mem _ x _
        apply Submodule.subset_span
        exact Set.mem_range_self y
    Â· intro x y hx hy
      rw [map_add, TensorProduct.add_tmul, â† sub_add_sub_comm]
      exact add_mem hx hy
#align
  kaehler_differential.submodule_span_range_eq_ideal KaehlerDifferential.submodule_span_range_eq_ideal

theorem KaehlerDifferential.span_range_eq_ideal :
    Ideal.span (Set.range fun s : S => (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S)) =
      KaehlerDifferential.ideal R S :=
  by
  apply le_antisymm
  Â· rw [Ideal.span_le]
    rintro _ âŸ¨s, rflâŸ©
    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _
  Â· change (KaehlerDifferential.ideal R S).restrictScalars S â‰¤ (Ideal.span _).restrictScalars S
    rw [â† KaehlerDifferential.submodule_span_range_eq_ideal, Ideal.span]
    conv_rhs => rw [â† Submodule.span_span_of_tower S]
    exact Submodule.subset_span
#align kaehler_differential.span_range_eq_ideal KaehlerDifferential.span_range_eq_ideal

/- ./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] tensor_product(S, R, S) -/
/-- The module of KÃ¤hler differentials (Kahler differentials, Kaehler differentials).
This is implemented as `I / I ^ 2` with `I` the kernel of the multiplication map `S âŠ—[R] S â†’â‚[R] S`.
To view elements as a linear combination of the form `s â€¢ D s'`, use
`kaehler_differential.tensor_product_to_surjective` and `derivation.tensor_product_to_tmul`.

We also provide the notation `Î©[Sâ„R]` for `kaehler_differential R S`.
Note that the slash is `\textfractionsolidus`.
-/
def KaehlerDifferential : Type _ :=
  (KaehlerDifferential.ideal R S).Cotangent deriving AddCommGroup,
  Â«./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] tensor_product(S, R, S)Â»
#align kaehler_differential KaehlerDifferential

-- mathport name: Â«exprÎ©[ â„ ]Â»
notation:100 "Î©[" S "â„" R "]" => KaehlerDifferential R S

instance : Nonempty (Î©[Sâ„R]) :=
  âŸ¨0âŸ©

instance KaehlerDifferential.module' {R' : Type _} [CommRing R'] [Algebra R' S] :
    Module R' (Î©[Sâ„R]) :=
  (Module.compHom (KaehlerDifferential.ideal R S).Cotangent (algebraMap R' S) : _)
#align kaehler_differential.module' KaehlerDifferential.module'

instance : IsScalarTower S (S âŠ—[R] S) (Î©[Sâ„R]) :=
  Ideal.Cotangent.is_scalar_tower _

instance KaehlerDifferential.is_scalar_tower_of_tower {Râ‚ Râ‚‚ : Type _} [CommRing Râ‚] [CommRing Râ‚‚]
    [Algebra Râ‚ S] [Algebra Râ‚‚ S] [Algebra Râ‚ Râ‚‚] [IsScalarTower Râ‚ Râ‚‚ S] :
    IsScalarTower Râ‚ Râ‚‚ (Î©[Sâ„R]) :=
  by
  convert RestrictScalars.is_scalar_tower Râ‚ Râ‚‚ (Î©[Sâ„R]) using 1
  ext (x m)
  show algebraMap Râ‚ S x â€¢ m = algebraMap Râ‚‚ S (algebraMap Râ‚ Râ‚‚ x) â€¢ m
  rw [â† IsScalarTower.algebra_map_apply]
#align kaehler_differential.is_scalar_tower_of_tower KaehlerDifferential.is_scalar_tower_of_tower

instance KaehlerDifferential.is_scalar_tower' : IsScalarTower R (S âŠ—[R] S) (Î©[Sâ„R]) :=
  by
  convert RestrictScalars.is_scalar_tower R (S âŠ—[R] S) (Î©[Sâ„R]) using 1
  ext (x m)
  show algebraMap R S x â€¢ m = algebraMap R (S âŠ—[R] S) x â€¢ m
  simp_rw [IsScalarTower.algebra_map_apply R S (S âŠ—[R] S), IsScalarTower.algebra_map_smul]
#align kaehler_differential.is_scalar_tower' KaehlerDifferential.is_scalar_tower'

/-- The quotient map `I â†’ Î©[Sâ„R]` with `I` being the kernel of `S âŠ—[R] S â†’ S`. -/
def KaehlerDifferential.fromIdeal : KaehlerDifferential.ideal R S â†’â‚—[S âŠ—[R] S] Î©[Sâ„R] :=
  (KaehlerDifferential.ideal R S).toCotangent
#align kaehler_differential.from_ideal KaehlerDifferential.fromIdeal

/-- (Implementation) The underlying linear map of the derivation into `Î©[Sâ„R]`. -/
def KaehlerDifferential.dLinearMap : S â†’â‚—[R] Î©[Sâ„R] :=
  ((KaehlerDifferential.fromIdeal R S).restrictScalars R).comp
    ((TensorProduct.includeRight.toLinearMap - TensorProduct.includeLeft.toLinearMap :
            S â†’â‚—[R] S âŠ—[R] S).codRestrict
        ((KaehlerDifferential.ideal R S).restrictScalars R)
        (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R) :
      _ â†’â‚—[R] _)
#align kaehler_differential.D_linear_map KaehlerDifferential.dLinearMap

theorem KaehlerDifferential.D_linear_map_apply (s : S) :
    KaehlerDifferential.dLinearMap R S s =
      (KaehlerDifferential.ideal R S).toCotangent
        âŸ¨1 âŠ—â‚œ s - s âŠ—â‚œ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R sâŸ© :=
  rfl
#align kaehler_differential.D_linear_map_apply KaehlerDifferential.D_linear_map_apply

/-- The universal derivation into `Î©[Sâ„R]`. -/
def KaehlerDifferential.d : Derivation R S (Î©[Sâ„R]) :=
  {
    KaehlerDifferential.dLinearMap R
      S with
    map_one_eq_zero' := by
      dsimp [KaehlerDifferential.D_linear_map_apply]
      rw [Ideal.to_cotangent_eq_zero, Subtype.coe_mk, sub_self]
      exact zero_mem _
    leibniz' := fun a b => by
      dsimp [KaehlerDifferential.D_linear_map_apply]
      rw [â† LinearMap.map_smul_of_tower, â† LinearMap.map_smul_of_tower, â† map_add,
        Ideal.to_cotangent_eq, pow_two]
      convert
        Submodule.mul_mem_mul (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R a : _)
          (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R b : _) using
        1
      simp only [AddSubgroupClass.coe_sub, Submodule.coe_add, Submodule.coe_mk,
        tensor_product.tmul_mul_tmul, mul_sub, sub_mul, mul_comm b, Submodule.coe_smul_of_tower,
        smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]
      ring_nf }
#align kaehler_differential.D KaehlerDifferential.d

theorem KaehlerDifferential.D_apply (s : S) :
    KaehlerDifferential.d R S s =
      (KaehlerDifferential.ideal R S).toCotangent
        âŸ¨1 âŠ—â‚œ s - s âŠ—â‚œ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R sâŸ© :=
  rfl
#align kaehler_differential.D_apply KaehlerDifferential.D_apply

theorem KaehlerDifferential.span_range_derivation :
    Submodule.span S (Set.range <| KaehlerDifferential.d R S) = âŠ¤ :=
  by
  rw [_root_.eq_top_iff]
  rintro x -
  obtain âŸ¨âŸ¨x, hxâŸ©, rflâŸ© := Ideal.to_cotangent_surjective _ x
  have : x âˆˆ (KaehlerDifferential.ideal R S).restrictScalars S := hx
  rw [â† KaehlerDifferential.submodule_span_range_eq_ideal] at this
  suffices
    âˆƒ hx,
      (KaehlerDifferential.ideal R S).toCotangent âŸ¨x, hxâŸ© âˆˆ
        Submodule.span S (Set.range <| KaehlerDifferential.d R S)
    by exact this.some_spec
  apply Submodule.span_induction this
  Â· rintro _ âŸ¨x, rflâŸ©
    refine' âŸ¨KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x, _âŸ©
    apply Submodule.subset_span
    exact âŸ¨x, KaehlerDifferential.D_linear_map_apply R S xâŸ©
  Â· exact âŸ¨zero_mem _, zero_mem _âŸ©
  Â· rintro x y âŸ¨hxâ‚, hxâ‚‚âŸ© âŸ¨hyâ‚, hyâ‚‚âŸ©
    exact âŸ¨add_mem hxâ‚ hyâ‚, add_mem hxâ‚‚ hyâ‚‚âŸ©
  Â· rintro r x âŸ¨hxâ‚, hxâ‚‚âŸ©
    exact
      âŸ¨((KaehlerDifferential.ideal R S).restrictScalars S).smul_mem r hxâ‚,
        Submodule.smul_mem _ r hxâ‚‚âŸ©
#align kaehler_differential.span_range_derivation KaehlerDifferential.span_range_derivation

variable {R S}

/-- The linear map from `Î©[Sâ„R]`, associated with a derivation. -/
def Derivation.liftKaehlerDifferential (D : Derivation R S M) : Î©[Sâ„R] â†’â‚—[S] M :=
  by
  refine'
    ((KaehlerDifferential.ideal R S â€¢ âŠ¤ :
              Submodule (S âŠ—[R] S) (KaehlerDifferential.ideal R S)).restrictScalars
          S).liftq
      _ _
  Â· exact D.tensor_product_to.comp ((KaehlerDifferential.ideal R S).Subtype.restrictScalars S)
  Â· intro x hx
    change _ = _
    apply Submodule.smulInductionOn hx <;> clear hx x
    Â· rintro x (hx : _ = _) âŸ¨y, hy : _ = _âŸ© -
      dsimp
      rw [Derivation.tensor_product_to_mul, hx, hy, zero_smul, zero_smul, zero_add]
    Â· intro x y ex ey
      rw [map_add, ex, ey, zero_add]
#align derivation.lift_kaehler_differential Derivation.liftKaehlerDifferential

theorem Derivation.lift_kaehler_differential_apply (D : Derivation R S M) (x) :
    D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x) =
      D.tensorProductTo x :=
  rfl
#align derivation.lift_kaehler_differential_apply Derivation.lift_kaehler_differential_apply

theorem Derivation.lift_kaehler_differential_comp (D : Derivation R S M) :
    D.liftKaehlerDifferential.compDer (KaehlerDifferential.d R S) = D :=
  by
  ext a
  dsimp [KaehlerDifferential.D_apply]
  refine' (D.lift_kaehler_differential_apply _).trans _
  rw [Subtype.coe_mk, map_sub, Derivation.tensor_product_to_tmul, Derivation.tensor_product_to_tmul,
    one_smul, D.map_one_eq_zero, smul_zero, sub_zero]
#align derivation.lift_kaehler_differential_comp Derivation.lift_kaehler_differential_comp

@[simp]
theorem Derivation.lift_kaehler_differential_comp_D (D' : Derivation R S M) (x : S) :
    D'.liftKaehlerDifferential (KaehlerDifferential.d R S x) = D' x :=
  Derivation.congr_fun D'.lift_kaehler_differential_comp x
#align derivation.lift_kaehler_differential_comp_D Derivation.lift_kaehler_differential_comp_D

@[ext]
theorem Derivation.lift_kaehler_differential_unique (f f' : Î©[Sâ„R] â†’â‚—[S] M)
    (hf : f.compDer (KaehlerDifferential.d R S) = f'.compDer (KaehlerDifferential.d R S)) :
    f = f' := by
  apply LinearMap.ext
  intro x
  have : x âˆˆ Submodule.span S (Set.range <| KaehlerDifferential.d R S) :=
    by
    rw [KaehlerDifferential.span_range_derivation]
    trivial
  apply Submodule.span_induction this
  Â· rintro _ âŸ¨x, rflâŸ©
    exact congr_arg (fun D : Derivation R S M => D x) hf
  Â· rw [map_zero, map_zero]
  Â· intro x y hx hy
    rw [map_add, map_add, hx, hy]
  Â· intro a x e
    rw [map_smul, map_smul, e]
#align derivation.lift_kaehler_differential_unique Derivation.lift_kaehler_differential_unique

variable (R S)

theorem Derivation.lift_kaehler_differential_D :
    (KaehlerDifferential.d R S).liftKaehlerDifferential = LinearMap.id :=
  Derivation.lift_kaehler_differential_unique _ _
    (KaehlerDifferential.d R S).lift_kaehler_differential_comp
#align derivation.lift_kaehler_differential_D Derivation.lift_kaehler_differential_D

variable {R S}

theorem KaehlerDifferential.D_tensor_product_to (x : KaehlerDifferential.ideal R S) :
    (KaehlerDifferential.d R S).tensorProductTo x = (KaehlerDifferential.ideal R S).toCotangent x :=
  by
  rw [â† Derivation.lift_kaehler_differential_apply, Derivation.lift_kaehler_differential_D]
  rfl
#align kaehler_differential.D_tensor_product_to KaehlerDifferential.D_tensor_product_to

variable (R S)

theorem KaehlerDifferential.tensor_product_to_surjective :
    Function.Surjective (KaehlerDifferential.d R S).tensorProductTo :=
  by
  intro x; obtain âŸ¨x, rflâŸ© := (KaehlerDifferential.ideal R S).to_cotangent_surjective x
  exact âŸ¨x, KaehlerDifferential.D_tensor_product_to xâŸ©
#align
  kaehler_differential.tensor_product_to_surjective KaehlerDifferential.tensor_product_to_surjective

/-- The `S`-linear maps from `Î©[Sâ„R]` to `M` are (`S`-linearly) equivalent to `R`-derivations
from `S` to `M`.  -/
def KaehlerDifferential.linearMapEquivDerivation : (Î©[Sâ„R] â†’â‚—[S] M) â‰ƒâ‚—[S] Derivation R S M :=
  {
    Derivation.llcomp.flip <|
      KaehlerDifferential.d R
        S with
    invFun := Derivation.liftKaehlerDifferential
    left_inv := fun f =>
      Derivation.lift_kaehler_differential_unique _ _ (Derivation.lift_kaehler_differential_comp _)
    right_inv := Derivation.lift_kaehler_differential_comp }
#align kaehler_differential.linear_map_equiv_derivation KaehlerDifferential.linearMapEquivDerivation

/-- The quotient ring of `S âŠ— S â§¸ J ^ 2` by `Î©[Sâ„R]` is isomorphic to `S`. -/
def KaehlerDifferential.quotientCotangentIdealRingEquiv :
    (S âŠ— S â§¸ KaehlerDifferential.ideal R S ^ 2) â§¸ (KaehlerDifferential.ideal R S).cotangentIdeal â‰ƒ+*
      S :=
  by
  have :
    Function.RightInverse tensor_product.include_left
      (â†‘(tensor_product.lmul' R : S âŠ—[R] S â†’â‚[R] S) : S âŠ—[R] S â†’+* S) :=
    by
    intro x
    rw [AlgHom.coe_to_ring_hom, â† AlgHom.comp_apply, tensor_product.lmul'_comp_include_left]
    rfl
  refine' (Ideal.quotCotangent _).trans _
  refine' (Ideal.quotEquivOfEq _).trans (RingHom.quotientKerEquivOfRightInverse this)
  ext
  rfl
#align
  kaehler_differential.quotient_cotangent_ideal_ring_equiv KaehlerDifferential.quotientCotangentIdealRingEquiv

/-- The quotient ring of `S âŠ— S â§¸ J ^ 2` by `Î©[Sâ„R]` is isomorphic to `S` as an `S`-algebra. -/
def KaehlerDifferential.quotientCotangentIdeal :
    ((S âŠ— S â§¸ KaehlerDifferential.ideal R S ^ 2) â§¸
        (KaehlerDifferential.ideal R S).cotangentIdeal) â‰ƒâ‚[S]
      S :=
  { KaehlerDifferential.quotientCotangentIdealRingEquiv R S with
    commutes' := (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).apply_symm_apply }
#align kaehler_differential.quotient_cotangent_ideal KaehlerDifferential.quotientCotangentIdeal

theorem KaehlerDifferential.End_equiv_aux (f : S â†’â‚[R] S âŠ— S â§¸ KaehlerDifferential.ideal R S ^ 2) :
    (Ideal.Quotient.mkâ‚ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =
        IsScalarTower.toAlgHom R S _ â†”
      (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift.comp f = AlgHom.id R S :=
  by
  rw [AlgHom.ext_iff, AlgHom.ext_iff]
  apply forall_congr'
  intro x
  have eâ‚ :
    (tensor_product.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift (f x) =
      KaehlerDifferential.quotientCotangentIdealRingEquiv R S
        (Ideal.Quotient.mk (KaehlerDifferential.ideal R S).cotangentIdeal <| f x) :=
    by
    generalize f x = y
    obtain âŸ¨y, rflâŸ© := Ideal.Quotient.mk_surjective y
    rfl
  have eâ‚‚ :
    x = KaehlerDifferential.quotientCotangentIdealRingEquiv R S (IsScalarTower.toAlgHom R S _ x) :=
    ((tensor_product.lmul'_apply_tmul x 1).trans (mul_one x)).symm
  constructor
  Â· intro e
    exact
      (eâ‚.trans
            (@RingEquiv.congr_arg _ _ _ _ _ _
              (KaehlerDifferential.quotientCotangentIdealRingEquiv R S) _ _ e)).trans
        eâ‚‚.symm
  Â· intro e
    apply (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).Injective
    exact eâ‚.symm.trans (e.trans eâ‚‚)
#align kaehler_differential.End_equiv_aux KaehlerDifferential.End_equiv_aux

-- This has type
-- `derivation R S Î©[ S / R ] â‰ƒâ‚—[R] derivation R S (kaehler_differential.ideal R S).cotangent_ideal`
-- But lean times-out if this is given explicitly.
/-- Derivations into `Î©[Sâ„R]` is equivalent to derivations
into `(kaehler_differential.ideal R S).cotangent_ideal` -/
noncomputable def KaehlerDifferential.endEquivDerivation' :=
  @LinearEquiv.compDer R _ _ _ _ (Î©[Sâ„R]) _ _ _ _ _ _ _ _ _
    ((KaehlerDifferential.ideal R S).cotangentEquivIdeal.restrictScalars S)
#align kaehler_differential.End_equiv_derivation' KaehlerDifferential.endEquivDerivation'

/-- (Implementation) An `equiv` version of `kaehler_differential.End_equiv_aux`.
Used in `kaehler_differential.End_equiv`. -/
def KaehlerDifferential.endEquivAuxEquiv :
    { f //
        (Ideal.Quotient.mkâ‚ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =
          IsScalarTower.toAlgHom R S _ } â‰ƒ
      { f // (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift.comp f = AlgHom.id R S } :=
  (Equiv.refl _).subtypeEquiv (KaehlerDifferential.End_equiv_aux R S)
#align kaehler_differential.End_equiv_aux_equiv KaehlerDifferential.endEquivAuxEquiv

/--
The endomorphisms of `Î©[Sâ„R]` corresponds to sections of the surjection `S âŠ—[R] S â§¸ J ^ 2 â†’â‚[R] S`,
with `J` being the kernel of the multiplication map `S âŠ—[R] S â†’â‚[R] S`.
-/
noncomputable def KaehlerDifferential.endEquiv :
    Module.EndCat S (Î©[Sâ„R]) â‰ƒ
      { f // (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift.comp f = AlgHom.id R S } :=
  (KaehlerDifferential.linearMapEquivDerivation R S).toEquiv.trans <|
    (KaehlerDifferential.endEquivDerivation' R S).toEquiv.trans <|
      (derivationToSquareZeroEquivLift (KaehlerDifferential.ideal R S).cotangentIdeal
            (KaehlerDifferential.ideal R S).cotangent_ideal_square).trans <|
        KaehlerDifferential.endEquivAuxEquiv R S
#align kaehler_differential.End_equiv KaehlerDifferential.endEquiv

section Presentation

open KaehlerDifferential (d)

open Finsupp (single)

/-- The `S`-submodule of `S â†’â‚€ S` (the direct sum of copies of `S` indexed by `S`) generated by
the relations:
1. `dx + dy = d(x + y)`
2. `x dy + y dx = d(x * y)`
3. `dr = 0` for `r âˆˆ R`
where `db` is the unit in the copy of `S` with index `b`.

This is the kernel of the surjection `finsupp.total S Î©[Sâ„R] S (kaehler_differential.D R S)`.
See `kaehler_differential.ker_total_eq` and `kaehler_differential.total_surjective`.
-/
noncomputable def KaehlerDifferential.kerTotal : Submodule S (S â†’â‚€ S) :=
  Submodule.span S
    (((Set.range fun x : S Ã— S => single x.1 1 + single x.2 1 - single (x.1 + x.2) 1) âˆª
        Set.range fun x : S Ã— S => single x.2 x.1 + single x.1 x.2 - single (x.1 * x.2) 1) âˆª
      Set.range fun x : R => single (algebraMap R S x) 1)
#align kaehler_differential.ker_total KaehlerDifferential.kerTotal

-- mathport name: Â«expr ğ–£ Â»
local notation x "ğ–£" y => (KaehlerDifferential.kerTotal R S).mkq (single y x)

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `KaehlerDifferential.ker_total_mkq_single_add [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y `z] [] [] ")")]
       (Term.typeSpec
        ":"
        (Â«term_=_Â»
         (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" (Â«term_+_Â» `x "+" `y))
         "="
         (Â«term_+_Â»
          (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" `x)
          "+"
          (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" `y)))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_add)
              ","
              (Tactic.rwRule [] `eq_comm)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `sub_eq_zero)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_sub)
              ","
              (Tactic.rwRule [] `Submodule.mkq_apply)
              ","
              (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)]
             "]")
            [])
           []
           (Mathlib.Tactic.tacticSimp_rw__
            "simp_rw"
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.Â«â† Â» "â†"))]
               (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z]))
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_add)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_sub)]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.app
             `Submodule.smul_mem
             [(Term.hole "_")
              (Term.hole "_")
              (Term.app
               `Submodule.subset_span
               [(Â«term_<|_Â»
                 `Or.inl
                 "<|"
                 (Â«term_<|_Â»
                  `Or.inl
                  "<|"
                  (Term.anonymousCtor
                   "âŸ¨"
                   [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
                   "âŸ©")))])]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_add)
             ","
             (Tactic.rwRule [] `eq_comm)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `sub_eq_zero)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_sub)
             ","
             (Tactic.rwRule [] `Submodule.mkq_apply)
             ","
             (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)]
            "]")
           [])
          []
          (Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z]))
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_add)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_sub)]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.app
            `Submodule.smul_mem
            [(Term.hole "_")
             (Term.hole "_")
             (Term.app
              `Submodule.subset_span
              [(Â«term_<|_Â»
                `Or.inl
                "<|"
                (Â«term_<|_Â»
                 `Or.inl
                 "<|"
                 (Term.anonymousCtor
                  "âŸ¨"
                  [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
                  "âŸ©")))])]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app
        `Submodule.smul_mem
        [(Term.hole "_")
         (Term.hole "_")
         (Term.app
          `Submodule.subset_span
          [(Â«term_<|_Â»
            `Or.inl
            "<|"
            (Â«term_<|_Â»
             `Or.inl
             "<|"
             (Term.anonymousCtor
              "âŸ¨"
              [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
              "âŸ©")))])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.smul_mem
       [(Term.hole "_")
        (Term.hole "_")
        (Term.app
         `Submodule.subset_span
         [(Â«term_<|_Â»
           `Or.inl
           "<|"
           (Â«term_<|_Â»
            `Or.inl
            "<|"
            (Term.anonymousCtor
             "âŸ¨"
             [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
             "âŸ©")))])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.subset_span
       [(Â«term_<|_Â»
         `Or.inl
         "<|"
         (Â«term_<|_Â»
          `Or.inl
          "<|"
          (Term.anonymousCtor
           "âŸ¨"
           [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
           "âŸ©")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«term_<|_Â»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«term_<|_Â»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_<|_Â»
       `Or.inl
       "<|"
       (Â«term_<|_Â»
        `Or.inl
        "<|"
        (Term.anonymousCtor
         "âŸ¨"
         [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
         "âŸ©")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_<|_Â»
       `Or.inl
       "<|"
       (Term.anonymousCtor
        "âŸ¨"
        [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
        "âŸ©"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "âŸ¨"
       [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
       "âŸ©")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 10 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
      `Or.inl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 10 >? 10, (some 10, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
      `Or.inl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 10, (some 10, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Â«term_<|_Â»
      `Or.inl
      "<|"
      (Â«term_<|_Â»
       `Or.inl
       "<|"
       (Term.anonymousCtor
        "âŸ¨"
        [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
        "âŸ©")))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.subset_span
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `Submodule.subset_span
      [(Term.paren
        "("
        (Â«term_<|_Â»
         `Or.inl
         "<|"
         (Â«term_<|_Â»
          `Or.inl
          "<|"
          (Term.anonymousCtor
           "âŸ¨"
           [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
           "âŸ©")))
        ")")])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.smul_mem
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z]))
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_add)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_sub)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `z
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finsupp.smul_single_one
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_add)
         ","
         (Tactic.rwRule [] `eq_comm)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `sub_eq_zero)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_sub)
         ","
         (Tactic.rwRule [] `Submodule.mkq_apply)
         ","
         (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.Quotient.mk_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.mkq_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `eq_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Â«term_=_Â»
       (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" (Â«term_+_Â» `x "+" `y))
       "="
       (Â«term_+_Â»
        (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" `x)
        "+"
        (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" `y)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_+_Â»
       (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" `x)
       "+"
       (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" `y))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" `y)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.Â«term_ğ–£_Â»', expected 'RingTheory.Derivation.term_ğ–£_._@.RingTheory.Derivation._hyg.703'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  KaehlerDifferential.ker_total_mkq_single_add
  ( x y z ) : z ğ–£ x + y = z ğ–£ x + z ğ–£ y
  :=
    by
      rw
          [
            â† map_add
              ,
              eq_comm
              ,
              â† sub_eq_zero
              ,
              â† map_sub
              ,
              Submodule.mkq_apply
              ,
              Submodule.Quotient.mk_eq_zero
            ]
        simp_rw [ â† Finsupp.smul_single_one _ z , â† smul_add , â† smul_sub ]
        exact Submodule.smul_mem _ _ Submodule.subset_span Or.inl <| Or.inl <| âŸ¨ âŸ¨ _ , _ âŸ© , rfl âŸ©
#align kaehler_differential.ker_total_mkq_single_add KaehlerDifferential.ker_total_mkq_single_add

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `KaehlerDifferential.ker_total_mkq_single_mul [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y `z] [] [] ")")]
       (Term.typeSpec
        ":"
        (Â«term_=_Â»
         (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" (Â«term_*_Â» `x "*" `y))
         "="
         (Â«term_+_Â»
          (RingTheory.Derivation.Â«term_ğ–£_Â» (Â«term_*_Â» `z "*" `x) "ğ–£" `y)
          "+"
          (RingTheory.Derivation.Â«term_ğ–£_Â» (Â«term_*_Â» `z "*" `y) "ğ–£" `x)))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_add)
              ","
              (Tactic.rwRule [] `eq_comm)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `sub_eq_zero)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_sub)
              ","
              (Tactic.rwRule [] `Submodule.mkq_apply)
              ","
              (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)]
             "]")
            [])
           []
           (Mathlib.Tactic.tacticSimp_rw__
            "simp_rw"
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.Â«â† Â» "â†"))]
               (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z]))
              ","
              (Tactic.rwRule
               [(patternIgnore (token.Â«â† Â» "â†"))]
               (Term.app (Term.explicit "@" `smul_eq_mul) [(Term.hole "_") (Term.hole "_") `z]))
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `Finsupp.smul_single)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_add)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_sub)]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.app
             `Submodule.smul_mem
             [(Term.hole "_")
              (Term.hole "_")
              (Term.app
               `Submodule.subset_span
               [(Â«term_<|_Â»
                 `Or.inl
                 "<|"
                 (Â«term_<|_Â»
                  `Or.inr
                  "<|"
                  (Term.anonymousCtor
                   "âŸ¨"
                   [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
                   "âŸ©")))])]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_add)
             ","
             (Tactic.rwRule [] `eq_comm)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `sub_eq_zero)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_sub)
             ","
             (Tactic.rwRule [] `Submodule.mkq_apply)
             ","
             (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)]
            "]")
           [])
          []
          (Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z]))
             ","
             (Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.app (Term.explicit "@" `smul_eq_mul) [(Term.hole "_") (Term.hole "_") `z]))
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `Finsupp.smul_single)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_add)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_sub)]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.app
            `Submodule.smul_mem
            [(Term.hole "_")
             (Term.hole "_")
             (Term.app
              `Submodule.subset_span
              [(Â«term_<|_Â»
                `Or.inl
                "<|"
                (Â«term_<|_Â»
                 `Or.inr
                 "<|"
                 (Term.anonymousCtor
                  "âŸ¨"
                  [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
                  "âŸ©")))])]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app
        `Submodule.smul_mem
        [(Term.hole "_")
         (Term.hole "_")
         (Term.app
          `Submodule.subset_span
          [(Â«term_<|_Â»
            `Or.inl
            "<|"
            (Â«term_<|_Â»
             `Or.inr
             "<|"
             (Term.anonymousCtor
              "âŸ¨"
              [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
              "âŸ©")))])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.smul_mem
       [(Term.hole "_")
        (Term.hole "_")
        (Term.app
         `Submodule.subset_span
         [(Â«term_<|_Â»
           `Or.inl
           "<|"
           (Â«term_<|_Â»
            `Or.inr
            "<|"
            (Term.anonymousCtor
             "âŸ¨"
             [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
             "âŸ©")))])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.subset_span
       [(Â«term_<|_Â»
         `Or.inl
         "<|"
         (Â«term_<|_Â»
          `Or.inr
          "<|"
          (Term.anonymousCtor
           "âŸ¨"
           [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
           "âŸ©")))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«term_<|_Â»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«term_<|_Â»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_<|_Â»
       `Or.inl
       "<|"
       (Â«term_<|_Â»
        `Or.inr
        "<|"
        (Term.anonymousCtor
         "âŸ¨"
         [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
         "âŸ©")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_<|_Â»
       `Or.inr
       "<|"
       (Term.anonymousCtor
        "âŸ¨"
        [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
        "âŸ©"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor
       "âŸ¨"
       [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
       "âŸ©")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 10 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
      `Or.inr
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 10 >? 10, (some 10, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
      `Or.inl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 10, (some 10, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Â«term_<|_Â»
      `Or.inl
      "<|"
      (Â«term_<|_Â»
       `Or.inr
       "<|"
       (Term.anonymousCtor
        "âŸ¨"
        [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
        "âŸ©")))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.subset_span
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `Submodule.subset_span
      [(Term.paren
        "("
        (Â«term_<|_Â»
         `Or.inl
         "<|"
         (Â«term_<|_Â»
          `Or.inr
          "<|"
          (Term.anonymousCtor
           "âŸ¨"
           [(Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," (Term.hole "_")] "âŸ©") "," `rfl]
           "âŸ©")))
        ")")])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.smul_mem
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z]))
         ","
         (Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.app (Term.explicit "@" `smul_eq_mul) [(Term.hole "_") (Term.hole "_") `z]))
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `Finsupp.smul_single)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_add)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `smul_sub)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.smul_single
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Term.explicit "@" `smul_eq_mul) [(Term.hole "_") (Term.hole "_") `z])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `z
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.explicit "@" `smul_eq_mul)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `smul_eq_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024,
     term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Finsupp.smul_single_one [(Term.hole "_") `z])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `z
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finsupp.smul_single_one
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_add)
         ","
         (Tactic.rwRule [] `eq_comm)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `sub_eq_zero)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `map_sub)
         ","
         (Tactic.rwRule [] `Submodule.mkq_apply)
         ","
         (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.Quotient.mk_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.mkq_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sub_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `eq_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Â«term_=_Â»
       (RingTheory.Derivation.Â«term_ğ–£_Â» `z "ğ–£" (Â«term_*_Â» `x "*" `y))
       "="
       (Â«term_+_Â»
        (RingTheory.Derivation.Â«term_ğ–£_Â» (Â«term_*_Â» `z "*" `x) "ğ–£" `y)
        "+"
        (RingTheory.Derivation.Â«term_ğ–£_Â» (Â«term_*_Â» `z "*" `y) "ğ–£" `x)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_+_Â»
       (RingTheory.Derivation.Â«term_ğ–£_Â» (Â«term_*_Â» `z "*" `x) "ğ–£" `y)
       "+"
       (RingTheory.Derivation.Â«term_ğ–£_Â» (Â«term_*_Â» `z "*" `y) "ğ–£" `x))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (RingTheory.Derivation.Â«term_ğ–£_Â» (Â«term_*_Â» `z "*" `y) "ğ–£" `x)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.Â«term_ğ–£_Â»', expected 'RingTheory.Derivation.term_ğ–£_._@.RingTheory.Derivation._hyg.703'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  KaehlerDifferential.ker_total_mkq_single_mul
  ( x y z ) : z ğ–£ x * y = z * x ğ–£ y + z * y ğ–£ x
  :=
    by
      rw
          [
            â† map_add
              ,
              eq_comm
              ,
              â† sub_eq_zero
              ,
              â† map_sub
              ,
              Submodule.mkq_apply
              ,
              Submodule.Quotient.mk_eq_zero
            ]
        simp_rw
          [
            â† Finsupp.smul_single_one _ z
              ,
              â† @ smul_eq_mul _ _ z
              ,
              â† Finsupp.smul_single
              ,
              â† smul_add
              ,
              â† smul_sub
            ]
        exact Submodule.smul_mem _ _ Submodule.subset_span Or.inl <| Or.inr <| âŸ¨ âŸ¨ _ , _ âŸ© , rfl âŸ©
#align kaehler_differential.ker_total_mkq_single_mul KaehlerDifferential.ker_total_mkq_single_mul

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `KaehlerDifferential.ker_total_mkq_single_algebra_map [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x `y] [] [] ")")]
       (Term.typeSpec
        ":"
        (Â«term_=_Â»
         (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" (Term.app `algebraMap [`R `S `x]))
         "="
         (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `Submodule.mkq_apply)
              ","
              (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)
              ","
              (Tactic.rwRule
               [(patternIgnore (token.Â«â† Â» "â†"))]
               (Term.app `Finsupp.smul_single_one [(Term.hole "_") `y]))]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.app
             `Submodule.smul_mem
             [(Term.hole "_")
              (Term.hole "_")
              (Term.app
               `Submodule.subset_span
               [(Â«term_<|_Â»
                 `Or.inr
                 "<|"
                 (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))])]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `Submodule.mkq_apply)
             ","
             (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)
             ","
             (Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.app `Finsupp.smul_single_one [(Term.hole "_") `y]))]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.app
            `Submodule.smul_mem
            [(Term.hole "_")
             (Term.hole "_")
             (Term.app
              `Submodule.subset_span
              [(Â«term_<|_Â»
                `Or.inr
                "<|"
                (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))])]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app
        `Submodule.smul_mem
        [(Term.hole "_")
         (Term.hole "_")
         (Term.app
          `Submodule.subset_span
          [(Â«term_<|_Â» `Or.inr "<|" (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.smul_mem
       [(Term.hole "_")
        (Term.hole "_")
        (Term.app
         `Submodule.subset_span
         [(Â«term_<|_Â» `Or.inr "<|" (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.subset_span
       [(Â«term_<|_Â» `Or.inr "<|" (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«term_<|_Â»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«term_<|_Â»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_<|_Â» `Or.inr "<|" (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 10 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
      `Or.inr
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 10, (some 10, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Â«term_<|_Â» `Or.inr "<|" (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.subset_span
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `Submodule.subset_span
      [(Term.paren
        "("
        (Â«term_<|_Â» `Or.inr "<|" (Term.anonymousCtor "âŸ¨" [(Term.hole "_") "," `rfl] "âŸ©"))
        ")")])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.smul_mem
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `Submodule.mkq_apply)
         ","
         (Tactic.rwRule [] `Submodule.Quotient.mk_eq_zero)
         ","
         (Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.app `Finsupp.smul_single_one [(Term.hole "_") `y]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Finsupp.smul_single_one [(Term.hole "_") `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finsupp.smul_single_one
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.Quotient.mk_eq_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.mkq_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Â«term_=_Â»
       (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" (Term.app `algebraMap [`R `S `x]))
       "="
       (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" (Term.app `algebraMap [`R `S `x]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.Â«term_ğ–£_Â»', expected 'RingTheory.Derivation.term_ğ–£_._@.RingTheory.Derivation._hyg.703'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  KaehlerDifferential.ker_total_mkq_single_algebra_map
  ( x y ) : y ğ–£ algebraMap R S x = 0
  :=
    by
      rw [ Submodule.mkq_apply , Submodule.Quotient.mk_eq_zero , â† Finsupp.smul_single_one _ y ]
        exact Submodule.smul_mem _ _ Submodule.subset_span Or.inr <| âŸ¨ _ , rfl âŸ©
#align
  kaehler_differential.ker_total_mkq_single_algebra_map KaehlerDifferential.ker_total_mkq_single_algebra_map

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `KaehlerDifferential.ker_total_mkq_single_algebra_map_one [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [] [] ")")]
       (Term.typeSpec
        ":"
        (Â«term_=_Â» (RingTheory.Derivation.Â«term_ğ–£_Â» `x "ğ–£" (num "1")) "=" (num "0"))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule
               [(patternIgnore (token.Â«â† Â» "â†"))]
               (Term.proj (Term.app `algebraMap [`R `S]) "." `map_one))
              ","
              (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_algebra_map)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.proj (Term.app `algebraMap [`R `S]) "." `map_one))
             ","
             (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_algebra_map)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.proj (Term.app `algebraMap [`R `S]) "." `map_one))
         ","
         (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_algebra_map)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `KaehlerDifferential.ker_total_mkq_single_algebra_map
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj (Term.app `algebraMap [`R `S]) "." `map_one)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `algebraMap [`R `S])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `S
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `R
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `algebraMap
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `algebraMap [`R `S]) ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Â«term_=_Â» (RingTheory.Derivation.Â«term_ğ–£_Â» `x "ğ–£" (num "1")) "=" (num "0"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "0")
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (RingTheory.Derivation.Â«term_ğ–£_Â» `x "ğ–£" (num "1"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.Â«term_ğ–£_Â»', expected 'RingTheory.Derivation.term_ğ–£_._@.RingTheory.Derivation._hyg.703'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  KaehlerDifferential.ker_total_mkq_single_algebra_map_one
  ( x ) : x ğ–£ 1 = 0
  := by rw [ â† algebraMap R S . map_one , KaehlerDifferential.ker_total_mkq_single_algebra_map ]
#align
  kaehler_differential.ker_total_mkq_single_algebra_map_one KaehlerDifferential.ker_total_mkq_single_algebra_map_one

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `KaehlerDifferential.ker_total_mkq_single_smul [])
      (Command.declSig
       [(Term.explicitBinder "(" [`r] [":" `R] [] ")") (Term.explicitBinder "(" [`x `y] [] [] ")")]
       (Term.typeSpec
        ":"
        (Â«term_=_Â»
         (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" (Algebra.Group.Defs.Â«term_â€¢_Â» `r " â€¢ " `x))
         "="
         (Algebra.Group.Defs.Â«term_â€¢_Â» `r " â€¢ " (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" `x)))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `Algebra.smul_def)
              ","
              (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_mul)
              ","
              (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_algebra_map)
              ","
              (Tactic.rwRule [] `add_zero)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `LinearMap.map_smul_of_tower)
              ","
              (Tactic.rwRule [] `Finsupp.smul_single)
              ","
              (Tactic.rwRule [] `mul_comm)
              ","
              (Tactic.rwRule [] `Algebra.smul_def)]
             "]")
            [])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `Algebra.smul_def)
             ","
             (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_mul)
             ","
             (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_algebra_map)
             ","
             (Tactic.rwRule [] `add_zero)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `LinearMap.map_smul_of_tower)
             ","
             (Tactic.rwRule [] `Finsupp.smul_single)
             ","
             (Tactic.rwRule [] `mul_comm)
             ","
             (Tactic.rwRule [] `Algebra.smul_def)]
            "]")
           [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `Algebra.smul_def)
         ","
         (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_mul)
         ","
         (Tactic.rwRule [] `KaehlerDifferential.ker_total_mkq_single_algebra_map)
         ","
         (Tactic.rwRule [] `add_zero)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `LinearMap.map_smul_of_tower)
         ","
         (Tactic.rwRule [] `Finsupp.smul_single)
         ","
         (Tactic.rwRule [] `mul_comm)
         ","
         (Tactic.rwRule [] `Algebra.smul_def)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Algebra.smul_def
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `mul_comm
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.smul_single
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `LinearMap.map_smul_of_tower
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `add_zero
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `KaehlerDifferential.ker_total_mkq_single_algebra_map
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `KaehlerDifferential.ker_total_mkq_single_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Algebra.smul_def
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Â«term_=_Â»
       (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" (Algebra.Group.Defs.Â«term_â€¢_Â» `r " â€¢ " `x))
       "="
       (Algebra.Group.Defs.Â«term_â€¢_Â» `r " â€¢ " (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" `x)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.Â«term_â€¢_Â» `r " â€¢ " (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" `x))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (RingTheory.Derivation.Â«term_ğ–£_Â» `y "ğ–£" `x)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.Â«term_ğ–£_Â»', expected 'RingTheory.Derivation.term_ğ–£_._@.RingTheory.Derivation._hyg.703'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  KaehlerDifferential.ker_total_mkq_single_smul
  ( r : R ) ( x y ) : y ğ–£ r â€¢ x = r â€¢ y ğ–£ x
  :=
    by
      rw
        [
          Algebra.smul_def
            ,
            KaehlerDifferential.ker_total_mkq_single_mul
            ,
            KaehlerDifferential.ker_total_mkq_single_algebra_map
            ,
            add_zero
            ,
            â† LinearMap.map_smul_of_tower
            ,
            Finsupp.smul_single
            ,
            mul_comm
            ,
            Algebra.smul_def
          ]
#align kaehler_differential.ker_total_mkq_single_smul KaehlerDifferential.ker_total_mkq_single_smul

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The (universal) derivation into `(S â†’â‚€ S) â§¸ kaehler_differential.ker_total R S`. -/")]
      []
      []
      [(Command.noncomputable "noncomputable")]
      []
      [])
     (Command.def
      "def"
      (Command.declId `KaehlerDifferential.derivationQuotKerTotal [])
      (Command.optDeclSig
       []
       [(Term.typeSpec
         ":"
         (Term.app
          `Derivation
          [`R
           `S
           (Algebra.Quotient.Â«term_â§¸_Â»
            (Data.Finsupp.Defs.Â«term_â†’â‚€_Â» `S " â†’â‚€ " `S)
            " â§¸ "
            (Term.app `KaehlerDifferential.kerTotal [`R `S]))]))])
      (Command.whereStructInst
       "where"
       [(Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl `toFun [`x] [] ":=" (RingTheory.Derivation.Â«term_ğ–£_Â» (num "1") "ğ–£" `x))))
        []
        (Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `map_add'
           [`x `y]
           []
           ":="
           (Term.app
            `KaehlerDifferential.ker_total_mkq_single_add
            [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")]))))
        []
        (Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `map_smul'
           [`r `s]
           []
           ":="
           (Term.app
            `KaehlerDifferential.ker_total_mkq_single_smul
            [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")]))))
        []
        (Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `map_one_eq_zero'
           []
           []
           ":="
           (Term.app
            `KaehlerDifferential.ker_total_mkq_single_algebra_map_one
            [(Term.hole "_") (Term.hole "_") (Term.hole "_")]))))
        []
        (Command.whereStructField
         (Term.letDecl
          (Term.letIdDecl
           `leibniz'
           [`a `b]
           []
           ":="
           (Term.app
            (Term.proj
             (Term.app
              `KaehlerDifferential.ker_total_mkq_single_mul
              [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")])
             "."
             `trans)
            [(Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Mathlib.Tactic.tacticSimp_rw__
                  "simp_rw"
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule
                     [(patternIgnore (token.Â«â† Â» "â†"))]
                     (Term.app
                      `Finsupp.smul_single_one
                      [(Term.hole "_")
                       (Term.typeAscription
                        "("
                        (Â«term_*_Â» (num "1") "*" (Term.hole "_"))
                        ":"
                        [`S]
                        ")")]))]
                   "]")
                  [])
                 []
                 (Tactic.dsimp "dsimp" [] [] [] [] [])
                 []
                 (Tactic.simp "simp" [] [] [] [] [])])))]))))]
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValSimple'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.whereStructInst', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj
        (Term.app
         `KaehlerDifferential.ker_total_mkq_single_mul
         [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")])
        "."
        `trans)
       [(Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Mathlib.Tactic.tacticSimp_rw__
             "simp_rw"
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule
                [(patternIgnore (token.Â«â† Â» "â†"))]
                (Term.app
                 `Finsupp.smul_single_one
                 [(Term.hole "_")
                  (Term.typeAscription
                   "("
                   (Â«term_*_Â» (num "1") "*" (Term.hole "_"))
                   ":"
                   [`S]
                   ")")]))]
              "]")
             [])
            []
            (Tactic.dsimp "dsimp" [] [] [] [] [])
            []
            (Tactic.simp "simp" [] [] [] [] [])])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.app
               `Finsupp.smul_single_one
               [(Term.hole "_")
                (Term.typeAscription "(" (Â«term_*_Â» (num "1") "*" (Term.hole "_")) ":" [`S] ")")]))]
            "]")
           [])
          []
          (Tactic.dsimp "dsimp" [] [] [] [] [])
          []
          (Tactic.simp "simp" [] [] [] [] [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp "simp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.dsimp "dsimp" [] [] [] [] [])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.app
           `Finsupp.smul_single_one
           [(Term.hole "_")
            (Term.typeAscription "(" (Â«term_*_Â» (num "1") "*" (Term.hole "_")) ":" [`S] ")")]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Finsupp.smul_single_one
       [(Term.hole "_")
        (Term.typeAscription "(" (Â«term_*_Â» (num "1") "*" (Term.hole "_")) ":" [`S] ")")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription "(" (Â«term_*_Â» (num "1") "*" (Term.hole "_")) ":" [`S] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `S
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Â«term_*_Â» (num "1") "*" (Term.hole "_"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 71 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 70, term))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 70 >? 1024, (none, [anonymous]) <=? (some 70, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 70, (some 71, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Finsupp.smul_single_one
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0,
     tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(Mathlib.Tactic.tacticSimp_rw__
          "simp_rw"
          (Tactic.rwRuleSeq
           "["
           [(Tactic.rwRule
             [(patternIgnore (token.Â«â† Â» "â†"))]
             (Term.app
              `Finsupp.smul_single_one
              [(Term.hole "_")
               (Term.typeAscription "(" (Â«term_*_Â» (num "1") "*" (Term.hole "_")) ":" [`S] ")")]))]
           "]")
          [])
         []
         (Tactic.dsimp "dsimp" [] [] [] [] [])
         []
         (Tactic.simp "simp" [] [] [] [] [])])))
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj
       (Term.app
        `KaehlerDifferential.ker_total_mkq_single_mul
        [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")])
       "."
       `trans)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app
       `KaehlerDifferential.ker_total_mkq_single_mul
       [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `KaehlerDifferential.ker_total_mkq_single_mul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `KaehlerDifferential.ker_total_mkq_single_mul
      [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `KaehlerDifferential.ker_total_mkq_single_algebra_map_one
       [(Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `KaehlerDifferential.ker_total_mkq_single_algebra_map_one
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `KaehlerDifferential.ker_total_mkq_single_smul
       [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `KaehlerDifferential.ker_total_mkq_single_smul
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `KaehlerDifferential.ker_total_mkq_single_add
       [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `KaehlerDifferential.ker_total_mkq_single_add
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (RingTheory.Derivation.Â«term_ğ–£_Â» (num "1") "ğ–£" `x)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.Â«term_ğ–£_Â»', expected 'RingTheory.Derivation.term_ğ–£_._@.RingTheory.Derivation._hyg.703'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letPatDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.letIdDecl', expected 'Lean.Parser.Term.letEqnsDecl'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The (universal) derivation into `(S â†’â‚€ S) â§¸ kaehler_differential.ker_total R S`. -/
    noncomputable
  def
    KaehlerDifferential.derivationQuotKerTotal
    : Derivation R S S â†’â‚€ S â§¸ KaehlerDifferential.kerTotal R S
    where
      toFun x := 1 ğ–£ x
        map_add' x y := KaehlerDifferential.ker_total_mkq_single_add _ _ _ _ _
        map_smul' r s := KaehlerDifferential.ker_total_mkq_single_smul _ _ _ _ _
        map_one_eq_zero' := KaehlerDifferential.ker_total_mkq_single_algebra_map_one _ _ _
        leibniz'
          a b
          :=
          KaehlerDifferential.ker_total_mkq_single_mul _ _ _ _ _ . trans
            by simp_rw [ â† Finsupp.smul_single_one _ ( 1 * _ : S ) ] dsimp simp
#align kaehler_differential.derivation_quot_ker_total KaehlerDifferential.derivationQuotKerTotal

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `KaehlerDifferential.derivation_quot_ker_total_apply [])
      (Command.declSig
       [(Term.explicitBinder "(" [`x] [] [] ")")]
       (Term.typeSpec
        ":"
        (Â«term_=_Â»
         (Term.app `KaehlerDifferential.derivationQuotKerTotal [`R `S `x])
         "="
         (RingTheory.Derivation.Â«term_ğ–£_Â» (num "1") "ğ–£" `x))))
      (Command.declValSimple ":=" `rfl [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `rfl
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Â«term_=_Â»
       (Term.app `KaehlerDifferential.derivationQuotKerTotal [`R `S `x])
       "="
       (RingTheory.Derivation.Â«term_ğ–£_Â» (num "1") "ğ–£" `x))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (RingTheory.Derivation.Â«term_ğ–£_Â» (num "1") "ğ–£" `x)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.Â«term_ğ–£_Â»', expected 'RingTheory.Derivation.term_ğ–£_._@.RingTheory.Derivation._hyg.703'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  KaehlerDifferential.derivation_quot_ker_total_apply
  ( x ) : KaehlerDifferential.derivationQuotKerTotal R S x = 1 ğ–£ x
  := rfl
#align
  kaehler_differential.derivation_quot_ker_total_apply KaehlerDifferential.derivation_quot_ker_total_apply

theorem KaehlerDifferential.derivation_quot_ker_total_lift_comp_total :
    (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp
        (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.d R S)) =
      Submodule.mkq _ :=
  by
  apply Finsupp.lhom_ext
  intro a b
  conv_rhs => rw [â† Finsupp.smul_single_one a b, LinearMap.map_smul]
  simp [KaehlerDifferential.derivation_quot_ker_total_apply]
#align
  kaehler_differential.derivation_quot_ker_total_lift_comp_total KaehlerDifferential.derivation_quot_ker_total_lift_comp_total

theorem KaehlerDifferential.ker_total_eq :
    (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.d R S)).ker =
      KaehlerDifferential.kerTotal R S :=
  by
  apply le_antisymm
  Â· conv_rhs => rw [â† (KaehlerDifferential.kerTotal R S).ker_mkq]
    rw [â† KaehlerDifferential.derivation_quot_ker_total_lift_comp_total]
    exact LinearMap.ker_le_ker_comp _ _
  Â· rw [KaehlerDifferential.kerTotal, Submodule.span_le]
    rintro _ ((âŸ¨âŸ¨x, yâŸ©, rflâŸ© | âŸ¨âŸ¨x, yâŸ©, rflâŸ©) | âŸ¨x, rflâŸ©) <;> dsimp <;> simp [LinearMap.mem_ker]
#align kaehler_differential.ker_total_eq KaehlerDifferential.ker_total_eq

theorem KaehlerDifferential.total_surjective :
    Function.Surjective (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.d R S)) := by
  rw [â† LinearMap.range_eq_top, Finsupp.range_total, KaehlerDifferential.span_range_derivation]
#align kaehler_differential.total_surjective KaehlerDifferential.total_surjective

/-- `Î©[Sâ„R]` is isomorphic to `S` copies of `S` with kernel `kaehler_differential.ker_total`. -/
@[simps]
noncomputable def KaehlerDifferential.quotKerTotalEquiv :
    ((S â†’â‚€ S) â§¸ KaehlerDifferential.kerTotal R S) â‰ƒâ‚—[S] Î©[Sâ„R] :=
  {
    (KaehlerDifferential.kerTotal R S).liftq
      (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.d R S))
      (KaehlerDifferential.ker_total_eq R
          S).ge with
    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential
    left_inv := by
      intro x
      obtain âŸ¨x, rflâŸ© := Submodule.mkq_surjective _ x
      exact
        LinearMap.congr_fun (KaehlerDifferential.derivation_quot_ker_total_lift_comp_total R S : _)
          x
    right_inv := by
      intro x
      obtain âŸ¨x, rflâŸ© := KaehlerDifferential.total_surjective R S x
      erw [LinearMap.congr_fun
          (KaehlerDifferential.derivation_quot_ker_total_lift_comp_total R S : _) x]
      rfl }
#align kaehler_differential.quot_ker_total_equiv KaehlerDifferential.quotKerTotalEquiv

theorem KaehlerDifferential.quot_ker_total_equiv_symm_comp_D :
    (KaehlerDifferential.quotKerTotalEquiv R S).symm.toLinearMap.compDer
        (KaehlerDifferential.d R S) =
      KaehlerDifferential.derivationQuotKerTotal R S :=
  by convert (KaehlerDifferential.derivationQuotKerTotal R S).lift_kaehler_differential_comp using 0
#align
  kaehler_differential.quot_ker_total_equiv_symm_comp_D KaehlerDifferential.quot_ker_total_equiv_symm_comp_D

variable (A B : Type _) [CommRing A] [CommRing B] [Algebra R A] [Algebra S B] [Algebra R B]

variable [Algebra A B] [IsScalarTower R S B] [IsScalarTower R A B]

-- mathport name: exprfinsupp_map
-- The map `(A â†’â‚€ A) â†’â‚—[A] (B â†’â‚€ B)`
local notation "finsupp_map" =>
  (Finsupp.mapRange.linearMap (Algebra.ofId A B).toLinearMap).comp
    (Finsupp.lmapDomain A A (algebraMap A B))

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `KaehlerDifferential.ker_total_map [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`h]
         [":" (Term.app `Function.Surjective [(Term.app `algebraMap [`A `B])])]
         []
         ")")]
       (Term.typeSpec
        ":"
        (Â«term_=_Â»
         (Order.Basic.Â«term_âŠ”_Â»
          (Term.app
           (Term.proj (Term.app `KaehlerDifferential.kerTotal [`R `A]) "." `map)
           [(RingTheory.Derivation.termfinsupp_map "finsupp_map")])
          " âŠ” "
          (Term.app
           `Submodule.span
           [`A
            (Term.app
             `Set.range
             [(Term.fun
               "fun"
               (Term.basicFun
                [`x]
                [(Term.typeSpec ":" `S)]
                "=>"
                (Term.app
                 `single
                 [(Term.app `algebraMap [`S `B `x])
                  (Term.typeAscription "(" (num "1") ":" [`B] ")")])))])]))
         "="
         (Term.app
          (Term.proj (Term.app `KaehlerDifferential.kerTotal [`S `B]) "." `restrictScalars)
          [(Term.hole "_")]))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `KaehlerDifferential.kerTotal)
              ","
              (Tactic.rwRule [] `Submodule.map_span)
              ","
              (Tactic.rwRule [] `KaehlerDifferential.kerTotal)
              ","
              (Tactic.rwRule
               [(patternIgnore (token.Â«â† Â» "â†"))]
               (Term.app
                `Submodule.span_eq_restrict_scalars
                [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") `h]))]
             "]")
            [])
           []
           (Mathlib.Tactic.tacticSimp_rw__
            "simp_rw"
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `Set.image_union)
              ","
              (Tactic.rwRule [] `Submodule.span_union)
              ","
              (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `Set.image_univ)
              ","
              (Tactic.rwRule [] `Set.image_image)
              ","
              (Tactic.rwRule [] `Set.image_univ)
              ","
              (Tactic.rwRule [] `map_sub)
              ","
              (Tactic.rwRule [] `map_add)]
             "]")
            [])
           []
           (Tactic.simp
            "simp"
            []
            []
            ["only"]
            ["["
             [(Tactic.simpLemma [] [] `LinearMap.comp_apply)
              ","
              (Tactic.simpLemma [] [] `Finsupp.mapRange.linear_map_apply)
              ","
              (Tactic.simpLemma [] [] `Finsupp.map_range_single)
              ","
              (Tactic.simpLemma [] [] `Finsupp.lmap_domain_apply)
              ","
              (Tactic.simpLemma [] [] `Finsupp.map_domain_single)
              ","
              (Tactic.simpLemma [] [] `AlgHom.to_linear_map_apply)
              ","
              (Tactic.simpLemma [] [] `Algebra.of_id_apply)
              ","
              (Tactic.simpLemma
               []
               [(patternIgnore (token.Â«â† Â» "â†"))]
               `IsScalarTower.algebra_map_apply)
              ","
              (Tactic.simpLemma [] [] `map_one)
              ","
              (Tactic.simpLemma [] [] `map_add)
              ","
              (Tactic.simpLemma [] [] `map_mul)]
             "]"]
            [])
           []
           (Mathlib.Tactic.tacticSimp_rw__
            "simp_rw"
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `sup_assoc)
              ","
              (Tactic.rwRule
               [(patternIgnore (token.Â«â† Â» "â†"))]
               (Term.proj (Term.app `h.prod_map [`h]) "." `range_comp))]
             "]")
            [])
           []
           (Tactic.congr "congr" [(num "3")])
           []
           (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `sup_eq_right)] "]") [])
           []
           (Tactic.apply "apply" `Submodule.span_mono)
           []
           (Mathlib.Tactic.tacticSimp_rw__
            "simp_rw"
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] (Term.app `IsScalarTower.algebra_map_apply [`R `S `B]))]
             "]")
            [])
           []
           (Tactic.exact
            "exact"
            (Term.app
             `Set.range_comp_subset_range
             [(Term.app `algebraMap [`R `S])
              (Term.fun
               "fun"
               (Term.basicFun
                [`x]
                []
                "=>"
                (Term.app
                 `single
                 [(Term.app `algebraMap [`S `B `x])
                  (Term.typeAscription "(" (num "1") ":" [`B] ")")])))]))])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `KaehlerDifferential.kerTotal)
             ","
             (Tactic.rwRule [] `Submodule.map_span)
             ","
             (Tactic.rwRule [] `KaehlerDifferential.kerTotal)
             ","
             (Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.app
               `Submodule.span_eq_restrict_scalars
               [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") `h]))]
            "]")
           [])
          []
          (Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `Set.image_union)
             ","
             (Tactic.rwRule [] `Submodule.span_union)
             ","
             (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `Set.image_univ)
             ","
             (Tactic.rwRule [] `Set.image_image)
             ","
             (Tactic.rwRule [] `Set.image_univ)
             ","
             (Tactic.rwRule [] `map_sub)
             ","
             (Tactic.rwRule [] `map_add)]
            "]")
           [])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `LinearMap.comp_apply)
             ","
             (Tactic.simpLemma [] [] `Finsupp.mapRange.linear_map_apply)
             ","
             (Tactic.simpLemma [] [] `Finsupp.map_range_single)
             ","
             (Tactic.simpLemma [] [] `Finsupp.lmap_domain_apply)
             ","
             (Tactic.simpLemma [] [] `Finsupp.map_domain_single)
             ","
             (Tactic.simpLemma [] [] `AlgHom.to_linear_map_apply)
             ","
             (Tactic.simpLemma [] [] `Algebra.of_id_apply)
             ","
             (Tactic.simpLemma
              []
              [(patternIgnore (token.Â«â† Â» "â†"))]
              `IsScalarTower.algebra_map_apply)
             ","
             (Tactic.simpLemma [] [] `map_one)
             ","
             (Tactic.simpLemma [] [] `map_add)
             ","
             (Tactic.simpLemma [] [] `map_mul)]
            "]"]
           [])
          []
          (Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] `sup_assoc)
             ","
             (Tactic.rwRule
              [(patternIgnore (token.Â«â† Â» "â†"))]
              (Term.proj (Term.app `h.prod_map [`h]) "." `range_comp))]
            "]")
           [])
          []
          (Tactic.congr "congr" [(num "3")])
          []
          (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `sup_eq_right)] "]") [])
          []
          (Tactic.apply "apply" `Submodule.span_mono)
          []
          (Mathlib.Tactic.tacticSimp_rw__
           "simp_rw"
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] (Term.app `IsScalarTower.algebra_map_apply [`R `S `B]))]
            "]")
           [])
          []
          (Tactic.exact
           "exact"
           (Term.app
            `Set.range_comp_subset_range
            [(Term.app `algebraMap [`R `S])
             (Term.fun
              "fun"
              (Term.basicFun
               [`x]
               []
               "=>"
               (Term.app
                `single
                [(Term.app `algebraMap [`S `B `x])
                 (Term.typeAscription "(" (num "1") ":" [`B] ")")])))]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app
        `Set.range_comp_subset_range
        [(Term.app `algebraMap [`R `S])
         (Term.fun
          "fun"
          (Term.basicFun
           [`x]
           []
           "=>"
           (Term.app
            `single
            [(Term.app `algebraMap [`S `B `x])
             (Term.typeAscription "(" (num "1") ":" [`B] ")")])))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Set.range_comp_subset_range
       [(Term.app `algebraMap [`R `S])
        (Term.fun
         "fun"
         (Term.basicFun
          [`x]
          []
          "=>"
          (Term.app
           `single
           [(Term.app `algebraMap [`S `B `x]) (Term.typeAscription "(" (num "1") ":" [`B] ")")])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x]
        []
        "=>"
        (Term.app
         `single
         [(Term.app `algebraMap [`S `B `x]) (Term.typeAscription "(" (num "1") ":" [`B] ")")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `single
       [(Term.app `algebraMap [`S `B `x]) (Term.typeAscription "(" (num "1") ":" [`B] ")")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription "(" (num "1") ":" [`B] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `B
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.app `algebraMap [`S `B `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `B
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `S
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `algebraMap
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `algebraMap [`S `B `x]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `single
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.app `algebraMap [`R `S])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `S
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `R
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `algebraMap
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `algebraMap [`R `S]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Set.range_comp_subset_range
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] (Term.app `IsScalarTower.algebra_map_apply [`R `S `B]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `IsScalarTower.algebra_map_apply [`R `S `B])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `B
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `S
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `R
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `IsScalarTower.algebra_map_apply
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.apply "apply" `Submodule.span_mono)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.span_mono
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `sup_eq_right)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sup_eq_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.congr "congr" [(num "3")])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `sup_assoc)
         ","
         (Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.proj (Term.app `h.prod_map [`h]) "." `range_comp))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj (Term.app `h.prod_map [`h]) "." `range_comp)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `h.prod_map [`h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h.prod_map
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `h.prod_map [`h]) ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `sup_assoc
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `LinearMap.comp_apply)
         ","
         (Tactic.simpLemma [] [] `Finsupp.mapRange.linear_map_apply)
         ","
         (Tactic.simpLemma [] [] `Finsupp.map_range_single)
         ","
         (Tactic.simpLemma [] [] `Finsupp.lmap_domain_apply)
         ","
         (Tactic.simpLemma [] [] `Finsupp.map_domain_single)
         ","
         (Tactic.simpLemma [] [] `AlgHom.to_linear_map_apply)
         ","
         (Tactic.simpLemma [] [] `Algebra.of_id_apply)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.Â«â† Â» "â†"))] `IsScalarTower.algebra_map_apply)
         ","
         (Tactic.simpLemma [] [] `map_one)
         ","
         (Tactic.simpLemma [] [] `map_add)
         ","
         (Tactic.simpLemma [] [] `map_mul)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_one
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `IsScalarTower.algebra_map_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Algebra.of_id_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `AlgHom.to_linear_map_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.map_domain_single
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.lmap_domain_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.map_range_single
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Finsupp.mapRange.linear_map_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `LinearMap.comp_apply
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticSimp_rw__
       "simp_rw"
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `Set.image_union)
         ","
         (Tactic.rwRule [] `Submodule.span_union)
         ","
         (Tactic.rwRule [(patternIgnore (token.Â«â† Â» "â†"))] `Set.image_univ)
         ","
         (Tactic.rwRule [] `Set.image_image)
         ","
         (Tactic.rwRule [] `Set.image_univ)
         ","
         (Tactic.rwRule [] `map_sub)
         ","
         (Tactic.rwRule [] `map_add)]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_add
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `map_sub
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Set.image_univ
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Set.image_image
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Set.image_univ
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.span_union
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Set.image_union
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq
        "["
        [(Tactic.rwRule [] `KaehlerDifferential.kerTotal)
         ","
         (Tactic.rwRule [] `Submodule.map_span)
         ","
         (Tactic.rwRule [] `KaehlerDifferential.kerTotal)
         ","
         (Tactic.rwRule
          [(patternIgnore (token.Â«â† Â» "â†"))]
          (Term.app
           `Submodule.span_eq_restrict_scalars
           [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") `h]))]
        "]")
       [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.span_eq_restrict_scalars
       [(Term.hole "_") (Term.hole "_") (Term.hole "_") (Term.hole "_") `h])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.span_eq_restrict_scalars
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `KaehlerDifferential.kerTotal
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Submodule.map_span
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `KaehlerDifferential.kerTotal
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Â«term_=_Â»
       (Order.Basic.Â«term_âŠ”_Â»
        (Term.app
         (Term.proj (Term.app `KaehlerDifferential.kerTotal [`R `A]) "." `map)
         [(RingTheory.Derivation.termfinsupp_map "finsupp_map")])
        " âŠ” "
        (Term.app
         `Submodule.span
         [`A
          (Term.app
           `Set.range
           [(Term.fun
             "fun"
             (Term.basicFun
              [`x]
              [(Term.typeSpec ":" `S)]
              "=>"
              (Term.app
               `single
               [(Term.app `algebraMap [`S `B `x])
                (Term.typeAscription "(" (num "1") ":" [`B] ")")])))])]))
       "="
       (Term.app
        (Term.proj (Term.app `KaehlerDifferential.kerTotal [`S `B]) "." `restrictScalars)
        [(Term.hole "_")]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj (Term.app `KaehlerDifferential.kerTotal [`S `B]) "." `restrictScalars)
       [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.app `KaehlerDifferential.kerTotal [`S `B]) "." `restrictScalars)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `KaehlerDifferential.kerTotal [`S `B])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `B
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `S
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `KaehlerDifferential.kerTotal
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `KaehlerDifferential.kerTotal [`S `B])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Order.Basic.Â«term_âŠ”_Â»
       (Term.app
        (Term.proj (Term.app `KaehlerDifferential.kerTotal [`R `A]) "." `map)
        [(RingTheory.Derivation.termfinsupp_map "finsupp_map")])
       " âŠ” "
       (Term.app
        `Submodule.span
        [`A
         (Term.app
          `Set.range
          [(Term.fun
            "fun"
            (Term.basicFun
             [`x]
             [(Term.typeSpec ":" `S)]
             "=>"
             (Term.app
              `single
              [(Term.app `algebraMap [`S `B `x])
               (Term.typeAscription "(" (num "1") ":" [`B] ")")])))])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Submodule.span
       [`A
        (Term.app
         `Set.range
         [(Term.fun
           "fun"
           (Term.basicFun
            [`x]
            [(Term.typeSpec ":" `S)]
            "=>"
            (Term.app
             `single
             [(Term.app `algebraMap [`S `B `x])
              (Term.typeAscription "(" (num "1") ":" [`B] ")")])))])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `Set.range
       [(Term.fun
         "fun"
         (Term.basicFun
          [`x]
          [(Term.typeSpec ":" `S)]
          "=>"
          (Term.app
           `single
           [(Term.app `algebraMap [`S `B `x]) (Term.typeAscription "(" (num "1") ":" [`B] ")")])))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x]
        [(Term.typeSpec ":" `S)]
        "=>"
        (Term.app
         `single
         [(Term.app `algebraMap [`S `B `x]) (Term.typeAscription "(" (num "1") ":" [`B] ")")])))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `single
       [(Term.app `algebraMap [`S `B `x]) (Term.typeAscription "(" (num "1") ":" [`B] ")")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeAscription', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription "(" (num "1") ":" [`B] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `B
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (num "1")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
      (Term.app `algebraMap [`S `B `x])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `B
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `S
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `algebraMap
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `algebraMap [`S `B `x]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `single
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `S
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1023, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Set.range
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      `Set.range
      [(Term.fun
        "fun"
        (Term.basicFun
         [`x]
         [(Term.typeSpec ":" `S)]
         "=>"
         (Term.app
          `single
          [(Term.paren "(" (Term.app `algebraMap [`S `B `x]) ")")
           (Term.typeAscription "(" (num "1") ":" [`B] ")")])))])
     ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `A
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Submodule.span
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 69 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 68, term))
      (Term.app
       (Term.proj (Term.app `KaehlerDifferential.kerTotal [`R `A]) "." `map)
       [(RingTheory.Derivation.termfinsupp_map "finsupp_map")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.termfinsupp_map', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.termfinsupp_map', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (RingTheory.Derivation.termfinsupp_map "finsupp_map")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'RingTheory.Derivation.termfinsupp_map', expected 'RingTheory.Derivation.termfinsupp_map._@.RingTheory.Derivation._hyg.746'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  KaehlerDifferential.ker_total_map
  ( h : Function.Surjective algebraMap A B )
    :
      KaehlerDifferential.kerTotal R A . map finsupp_map
          âŠ”
          Submodule.span A Set.range fun x : S => single algebraMap S B x ( 1 : B )
        =
        KaehlerDifferential.kerTotal S B . restrictScalars _
  :=
    by
      rw
          [
            KaehlerDifferential.kerTotal
              ,
              Submodule.map_span
              ,
              KaehlerDifferential.kerTotal
              ,
              â† Submodule.span_eq_restrict_scalars _ _ _ _ h
            ]
        simp_rw
          [
            Set.image_union
              ,
              Submodule.span_union
              ,
              â† Set.image_univ
              ,
              Set.image_image
              ,
              Set.image_univ
              ,
              map_sub
              ,
              map_add
            ]
        simp
          only
          [
            LinearMap.comp_apply
              ,
              Finsupp.mapRange.linear_map_apply
              ,
              Finsupp.map_range_single
              ,
              Finsupp.lmap_domain_apply
              ,
              Finsupp.map_domain_single
              ,
              AlgHom.to_linear_map_apply
              ,
              Algebra.of_id_apply
              ,
              â† IsScalarTower.algebra_map_apply
              ,
              map_one
              ,
              map_add
              ,
              map_mul
            ]
        simp_rw [ sup_assoc , â† h.prod_map h . range_comp ]
        congr 3
        rw [ sup_eq_right ]
        apply Submodule.span_mono
        simp_rw [ IsScalarTower.algebra_map_apply R S B ]
        exact Set.range_comp_subset_range algebraMap R S fun x => single algebraMap S B x ( 1 : B )
#align kaehler_differential.ker_total_map KaehlerDifferential.ker_total_map

end Presentation

section ExactSequence

/- We have the commutative diagram
A --â†’ B
â†‘     â†‘
|     |
R --â†’ S -/
variable (A B : Type _) [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]

variable [Algebra A B] [Algebra S B] [IsScalarTower R A B] [IsScalarTower R S B]

variable {R B}

/-- For a tower `R â†’ A â†’ B` and an `R`-derivation `B â†’ M`, we may compose with `A â†’ B` to obtain an
`R`-derivation `A â†’ M`. -/
def Derivation.compAlgebraMap [Module A M] [Module B M] [IsScalarTower A B M]
    (d : Derivation R B M) : Derivation R A M
    where
  map_one_eq_zero' := by simp
  leibniz' a b := by simp
  toLinearMap := d.toLinearMap.comp (IsScalarTower.toAlgHom R A B).toLinearMap
#align derivation.comp_algebra_map Derivation.compAlgebraMap

variable (R B)

/-- The map `Î©[Aâ„R] â†’â‚—[A] Î©[Bâ„R]` given a square
A --â†’ B
â†‘     â†‘
|     |
R --â†’ S -/
def KaehlerDifferential.map : Î©[Aâ„R] â†’â‚—[A] Î©[Bâ„S] :=
  Derivation.liftKaehlerDifferential
    (((KaehlerDifferential.d S B).restrictScalars R).comp_algebra_map A)
#align kaehler_differential.map KaehlerDifferential.map

theorem KaehlerDifferential.map_comp_der :
    (KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.d R A) =
      ((KaehlerDifferential.d S B).restrictScalars R).comp_algebra_map A :=
  Derivation.lift_kaehler_differential_comp _
#align kaehler_differential.map_comp_der KaehlerDifferential.map_comp_der

theorem KaehlerDifferential.map_D (x : A) :
    KaehlerDifferential.map R S A B (KaehlerDifferential.d R A x) =
      KaehlerDifferential.d S B (algebraMap A B x) :=
  Derivation.congr_fun (KaehlerDifferential.map_comp_der R S A B) x
#align kaehler_differential.map_D KaehlerDifferential.map_D

open IsScalarTower (toAlgHom)

theorem KaehlerDifferential.map_surjective_of_surjective
    (h : Function.Surjective (algebraMap A B)) :
    Function.Surjective (KaehlerDifferential.map R S A B) :=
  by
  rw [â† LinearMap.range_eq_top, _root_.eq_top_iff, â† @Submodule.restrict_scalars_top B A, â†
    KaehlerDifferential.span_range_derivation, â† Submodule.span_eq_restrict_scalars _ _ _ _ h,
    Submodule.span_le]
  rintro _ âŸ¨x, rflâŸ©
  obtain âŸ¨y, rflâŸ© := h x
  rw [â† KaehlerDifferential.map_D R S A B]
  exact âŸ¨_, rflâŸ©
#align
  kaehler_differential.map_surjective_of_surjective KaehlerDifferential.map_surjective_of_surjective

/-- The lift of the map `Î©[Aâ„R] â†’â‚—[A] Î©[Bâ„R]` to the base change along `A â†’ B`.
This is the first map in the exact sequence `B âŠ—[A] Î©[Aâ„R] â†’ Î©[Bâ„R] â†’ Î©[Bâ„A] â†’ 0`. -/
noncomputable def KaehlerDifferential.mapBaseChange : B âŠ—[A] Î©[Aâ„R] â†’â‚—[B] Î©[Bâ„R] :=
  (TensorProduct.isBaseChange A (Î©[Aâ„R]) B).lift (KaehlerDifferential.map R R A B)
#align kaehler_differential.map_base_change KaehlerDifferential.mapBaseChange

@[simp]
theorem KaehlerDifferential.map_base_change_tmul (x : B) (y : Î©[Aâ„R]) :
    KaehlerDifferential.mapBaseChange R A B (x âŠ—â‚œ y) = x â€¢ KaehlerDifferential.map R R A B y :=
  by
  conv_lhs => rw [â† mul_one x, â† smul_eq_mul, â† TensorProduct.smul_tmul', LinearMap.map_smul]
  congr 1
  exact IsBaseChange.lift_eq _ _ _
#align kaehler_differential.map_base_change_tmul KaehlerDifferential.map_base_change_tmul

end ExactSequence

end KaehlerDifferential

