import Mathbin.GroupTheory.QuotientGroup 
import Mathbin.RingTheory.DedekindDomain

/-!
# The ideal class group

This file defines the ideal class group `class_group R K` of fractional ideals of `R`
inside `A`'s field of fractions `K`.

## Main definitions
 - `to_principal_ideal` sends an invertible `x : K` to an invertible fractional ideal
 - `class_group` is the quotient of invertible fractional ideals modulo `to_principal_ideal.range`
 - `class_group.mk0` sends a nonzero integral ideal in a Dedekind domain to its class

## Main results
 - `class_group.mk0_eq_mk0_iff` shows the equivalence with the "classical" definition,
   where `I ~ J` iff `x I = y J` for `x y ≠ (0 : R)`
-/


variable{R K L : Type _}[CommRingₓ R]

variable[Field K][Field L][DecidableEq L]

variable[Algebra R K][IsFractionRing R K]

variable[Algebra K L][FiniteDimensional K L]

variable[Algebra R L][IsScalarTower R K L]

open_locale nonZeroDivisors

open IsLocalization IsFractionRing FractionalIdeal Units

section 

variable(R K)

/-- `to_principal_ideal R K x` sends `x ≠ 0 : K` to the fractional `R`-ideal generated by `x` -/
@[irreducible]
def toPrincipalIdeal : Units K →* Units (FractionalIdeal R⁰ K) :=
  { toFun :=
      fun x =>
        ⟨span_singleton _ x, span_singleton _ (x⁻¹),
          by 
            simp only [span_singleton_one, Units.mul_inv', span_singleton_mul_span_singleton],
          by 
            simp only [span_singleton_one, Units.inv_mul', span_singleton_mul_span_singleton]⟩,
    map_mul' :=
      fun x y =>
        ext
          (by 
            simp only [Units.coe_mk, Units.coe_mul, span_singleton_mul_span_singleton]),
    map_one' :=
      ext
        (by 
          simp only [span_singleton_one, Units.coe_mk, Units.coe_one]) }

attribute [local semireducible] toPrincipalIdeal

variable{R K}

@[simp]
theorem coe_to_principal_ideal (x : Units K) : (toPrincipalIdeal R K x : FractionalIdeal R⁰ K) = span_singleton _ x :=
  rfl

@[simp]
theorem to_principal_ideal_eq_iff {I : Units (FractionalIdeal R⁰ K)} {x : Units K} :
  toPrincipalIdeal R K x = I ↔ span_singleton R⁰ (x : K) = I :=
  Units.ext_iff

end 

instance PrincipalIdeals.normal : (toPrincipalIdeal R K).range.Normal :=
  Subgroup.normal_of_comm _

section 

variable(R K)

-- error in RingTheory.ClassGroup: ././Mathport/Syntax/Translate/Basic.lean:704:9: unsupported derive handler comm_group
/-- The ideal class group of `R` in a field of fractions `K`
is the group of invertible fractional ideals modulo the principal ideals. -/
@[derive #[expr comm_group]]
def class_group :=
quotient_group.quotient (to_principal_ideal R K).range

instance  : Inhabited (ClassGroup R K) :=
  ⟨1⟩

variable{R}[IsDomain R]

/-- Send a nonzero integral ideal to an invertible fractional ideal. -/
@[simps]
noncomputable def FractionalIdeal.mk0 [IsDedekindDomain R] : (Ideal R)⁰ →* Units (FractionalIdeal R⁰ K) :=
  { toFun :=
      fun I =>
        Units.mk0 I
          ((FractionalIdeal.coe_to_fractional_ideal_ne_zero (le_reflₓ R⁰)).mpr
            (mem_non_zero_divisors_iff_ne_zero.mp I.2)),
    map_one' :=
      by 
        simp ,
    map_mul' :=
      fun x y =>
        by 
          simp  }

/-- Send a nonzero ideal to the corresponding class in the class group. -/
@[simps]
noncomputable def ClassGroup.mk0 [IsDedekindDomain R] : (Ideal R)⁰ →* ClassGroup R K :=
  (QuotientGroup.mk' _).comp (FractionalIdeal.mk0 K)

variable{K}

theorem QuotientGroup.mk'_eq_mk' {G : Type _} [Groupₓ G] {N : Subgroup G} [hN : N.normal] {x y : G} :
  QuotientGroup.mk' N x = QuotientGroup.mk' N y ↔ ∃ (z : _)(_ : z ∈ N), (x*z) = y :=
  (@Quotientₓ.eq _ (QuotientGroup.leftRel _) _ _).trans
    ⟨fun h : (x⁻¹*y) ∈ N =>
        ⟨_, h,
          by 
            rw [←mul_assocₓ, mul_right_invₓ, one_mulₓ]⟩,
      fun ⟨z, z_mem, eq_y⟩ =>
        by 
          rw [←eq_y]
          show (x⁻¹*x*z) ∈ N 
          rwa [←mul_assocₓ, mul_left_invₓ, one_mulₓ]⟩

theorem ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring [IsDedekindDomain R] {I J : (Ideal R)⁰} :
  ClassGroup.mk0 K I = ClassGroup.mk0 K J ↔ ∃ (x : _)(_ : x ≠ (0 : K)), (span_singleton R⁰ x*I) = J :=
  by 
    simp only [ClassGroup.mk0, MonoidHom.comp_apply, QuotientGroup.mk'_eq_mk']
    split 
    ·
      rintro ⟨_, ⟨x, rfl⟩, hx⟩
      refine' ⟨x, x.ne_zero, _⟩
      simpa only [mul_commₓ, coe_mk0, MonoidHom.to_fun_eq_coe, coe_to_principal_ideal, Units.coe_mul] using
        congr_argₓ (coeₓ : _ → FractionalIdeal R⁰ K) hx
    ·
      rintro ⟨x, hx, eq_J⟩
      refine' ⟨_, ⟨Units.mk0 x hx, rfl⟩, Units.ext _⟩
      simpa only [FractionalIdeal.mk0_apply, Units.coe_mk0, mul_commₓ, coe_to_principal_ideal, coe_coe,
        Units.coe_mul] using eq_J

-- error in RingTheory.ClassGroup: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem class_group.mk0_eq_mk0_iff
[is_dedekind_domain R]
{I
 J : «expr ⁰»(ideal R)} : «expr ↔ »(«expr = »(class_group.mk0 K I, class_group.mk0 K J), «expr∃ , »((x y : R)
  (hx : «expr ≠ »(x, 0))
  (hy : «expr ≠ »(y, 0)), «expr = »(«expr * »(ideal.span {x}, (I : ideal R)), «expr * »(ideal.span {y}, J)))) :=
begin
  refine [expr class_group.mk0_eq_mk0_iff_exists_fraction_ring.trans ⟨_, _⟩],
  { rintros ["⟨", ident z, ",", ident hz, ",", ident h, "⟩"],
    obtain ["⟨", ident x, ",", "⟨", ident y, ",", ident hy, "⟩", ",", ident rfl, "⟩", ":=", expr is_localization.mk'_surjective «expr ⁰»(R) z],
    refine [expr ⟨x, y, _, mem_non_zero_divisors_iff_ne_zero.mp hy, _⟩],
    { rintro [ident hx],
      apply [expr hz],
      rw ["[", expr hx, ",", expr is_fraction_ring.mk'_eq_div, ",", expr (algebra_map R K).map_zero, ",", expr zero_div, "]"] [] },
    { exact [expr (fractional_ideal.mk'_mul_coe_ideal_eq_coe_ideal K hy).mp h] } },
  { rintros ["⟨", ident x, ",", ident y, ",", ident hx, ",", ident hy, ",", ident h, "⟩"],
    have [ident hy'] [":", expr «expr ∈ »(y, «expr ⁰»(R))] [":=", expr mem_non_zero_divisors_iff_ne_zero.mpr hy],
    refine [expr ⟨is_localization.mk' K x ⟨y, hy'⟩, _, _⟩],
    { contrapose ["!"] [ident hx],
      rwa ["[", expr is_localization.mk'_eq_iff_eq_mul, ",", expr zero_mul, ",", "<-", expr (algebra_map R K).map_zero, ",", expr (is_fraction_ring.injective R K).eq_iff, "]"] ["at", ident hx] },
    { exact [expr (fractional_ideal.mk'_mul_coe_ideal_eq_coe_ideal K hy').mpr h] } }
end

-- error in RingTheory.ClassGroup: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem class_group.mk0_surjective
[is_dedekind_domain R] : function.surjective (class_group.mk0 K : «expr ⁰»(ideal R) → class_group R K) :=
begin
  rintros ["⟨", ident I, "⟩"],
  obtain ["⟨", ident a, ",", ident a_ne_zero', ",", ident ha, "⟩", ":=", expr I.1.2],
  have [ident a_ne_zero] [] [":=", expr mem_non_zero_divisors_iff_ne_zero.mp a_ne_zero'],
  have [ident fa_ne_zero] [":", expr «expr ≠ »(algebra_map R K a, 0)] [":=", expr is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors a_ne_zero'],
  refine [expr ⟨⟨{ carrier := {x | «expr ∈ »(«expr * »(«expr ⁻¹»(algebra_map R K a), algebra_map R K x), I.1)},
       .. }, _⟩, _⟩],
  { simp [] [] ["only"] ["[", expr ring_hom.map_zero, ",", expr set.mem_set_of_eq, ",", expr mul_zero, ",", expr ring_hom.map_mul, "]"] [] [],
    exact [expr submodule.zero_mem I] },
  { simp [] [] ["only"] ["[", expr ring_hom.map_add, ",", expr set.mem_set_of_eq, ",", expr mul_zero, ",", expr ring_hom.map_mul, ",", expr mul_add, "]"] [] [],
    exact [expr λ _ _ ha hb, submodule.add_mem I ha hb] },
  { intros [ident c, "_", ident hb],
    simp [] [] ["only"] ["[", expr smul_eq_mul, ",", expr set.mem_set_of_eq, ",", expr mul_zero, ",", expr ring_hom.map_mul, ",", expr mul_add, ",", expr mul_left_comm «expr ⁻¹»(algebra_map R K a), "]"] [] [],
    rw ["<-", expr algebra.smul_def c] [],
    exact [expr submodule.smul_mem I c hb] },
  { rw ["[", expr mem_non_zero_divisors_iff_ne_zero, ",", expr submodule.zero_eq_bot, ",", expr submodule.ne_bot_iff, "]"] [],
    obtain ["⟨", ident x, ",", ident x_ne, ",", ident x_mem, "⟩", ":=", expr exists_ne_zero_mem_is_integer I.ne_zero],
    refine [expr ⟨«expr * »(a, x), _, mul_ne_zero a_ne_zero x_ne⟩],
    change [expr «expr ∈ »(«expr * »(«expr ⁻¹»(algebra_map R K a), algebra_map R K «expr * »(a, x)), I.1)] [] [],
    rwa ["[", expr ring_hom.map_mul, ",", "<-", expr mul_assoc, ",", expr inv_mul_cancel fa_ne_zero, ",", expr one_mul, "]"] [] },
  { symmetry,
    apply [expr quotient.sound],
    refine [expr ⟨units.mk0 (algebra_map R K a) fa_ne_zero, _⟩],
    apply [expr @mul_left_cancel _ _ I],
    rw ["[", "<-", expr mul_assoc, ",", expr mul_right_inv, ",", expr one_mul, ",", expr eq_comm, ",", expr mul_comm I, "]"] [],
    apply [expr units.ext],
    simp [] [] ["only"] ["[", expr monoid_hom.coe_mk, ",", expr subtype.coe_mk, ",", expr ring_hom.map_mul, ",", expr coe_coe, ",", expr units.coe_mul, ",", expr coe_to_principal_ideal, ",", expr coe_mk0, ",", expr fractional_ideal.eq_span_singleton_mul, "]"] [] [],
    split,
    { intros [ident zJ', ident hzJ'],
      obtain ["⟨", ident zJ, ",", ident hzJ, ":", expr «expr ∈ »(«expr * »(«expr ⁻¹»(algebra_map R K a), algebra_map R K zJ), «expr↑ »(I)), ",", ident rfl, "⟩", ":=", expr (mem_coe_ideal «expr ⁰»(R)).mp hzJ'],
      refine [expr ⟨_, hzJ, _⟩],
      rw ["[", "<-", expr mul_assoc, ",", expr mul_inv_cancel fa_ne_zero, ",", expr one_mul, "]"] [] },
    { intros [ident zI', ident hzI'],
      obtain ["⟨", ident y, ",", ident hy, "⟩", ":=", expr ha zI' hzI'],
      rw ["[", "<-", expr algebra.smul_def, ",", expr fractional_ideal.mk0_apply, ",", expr coe_mk0, ",", expr coe_coe, ",", expr mem_coe_ideal, "]"] [],
      refine [expr ⟨y, _, hy⟩],
      show [expr «expr ∈ »(«expr * »(«expr ⁻¹»(algebra_map R K a), algebra_map R K y), (I : fractional_ideal «expr ⁰»(R) K))],
      rwa ["[", expr hy, ",", expr algebra.smul_def, ",", "<-", expr mul_assoc, ",", expr inv_mul_cancel fa_ne_zero, ",", expr one_mul, "]"] [] } }
end

end 

-- error in RingTheory.ClassGroup: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem class_group.mk_eq_one_iff
{I : units (fractional_ideal «expr ⁰»(R) K)} : «expr ↔ »(«expr = »(quotient_group.mk' (to_principal_ideal R K).range I, 1), (I : submodule R K).is_principal) :=
begin
  rw ["[", "<-", expr (quotient_group.mk' _).map_one, ",", expr eq_comm, ",", expr quotient_group.mk'_eq_mk', "]"] [],
  simp [] [] ["only"] ["[", expr exists_prop, ",", expr one_mul, ",", expr exists_eq_right, ",", expr to_principal_ideal_eq_iff, ",", expr monoid_hom.mem_range, ",", expr coe_coe, "]"] [] [],
  refine [expr ⟨λ ⟨x, hx⟩, ⟨⟨x, by rw ["[", "<-", expr hx, ",", expr coe_span_singleton, "]"] []⟩⟩, _⟩],
  unfreezingI { intros [ident hI] },
  obtain ["⟨", ident x, ",", ident hx, "⟩", ":=", expr @submodule.is_principal.principal _ _ _ _ _ _ hI],
  have [ident hx'] [":", expr «expr = »((I : fractional_ideal «expr ⁰»(R) K), span_singleton «expr ⁰»(R) x)] [],
  { apply [expr subtype.coe_injective],
    rw ["[", expr hx, ",", expr coe_span_singleton, "]"] [] },
  refine [expr ⟨units.mk0 x _, _⟩],
  { intro [ident x_eq],
    apply [expr units.ne_zero I],
    simp [] [] [] ["[", expr hx', ",", expr x_eq, "]"] [] [] },
  simp [] [] [] ["[", expr hx', "]"] [] []
end

variable[IsDomain R]

theorem ClassGroup.mk0_eq_one_iff [IsDedekindDomain R] {I : Ideal R} (hI : I ∈ (Ideal R)⁰) :
  ClassGroup.mk0 K ⟨I, hI⟩ = 1 ↔ I.is_principal :=
  ClassGroup.mk_eq_one_iff.trans (coe_submodule_is_principal R K)

/-- The class group of principal ideal domain is finite (in fact a singleton).
TODO: generalize to Dedekind domains -/
instance  [IsPrincipalIdealRing R] : Fintype (ClassGroup R K) :=
  { elems := {1},
    complete :=
      by 
        rintro ⟨I⟩
        rw [Finset.mem_singleton]
        exact class_group.mk_eq_one_iff.mpr (I : FractionalIdeal R⁰ K).IsPrincipal }

/-- The class number of a principal ideal domain is `1`. -/
theorem card_class_group_eq_one [IsPrincipalIdealRing R] : Fintype.card (ClassGroup R K) = 1 :=
  by 
    rw [Fintype.card_eq_one_iff]
    use 1
    rintro ⟨I⟩
    exact class_group.mk_eq_one_iff.mpr (I : FractionalIdeal R⁰ K).IsPrincipal

-- error in RingTheory.ClassGroup: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/
theorem card_class_group_eq_one_iff
[is_dedekind_domain R]
[fintype (class_group R K)] : «expr ↔ »(«expr = »(fintype.card (class_group R K), 1), is_principal_ideal_ring R) :=
begin
  split,
  swap,
  { introsI [],
    convert [] [expr card_class_group_eq_one] [],
    assumption,
    assumption },
  rw [expr fintype.card_eq_one_iff] [],
  rintros ["⟨", ident I, ",", ident hI, "⟩"],
  have [ident eq_one] [":", expr ∀ J : class_group R K, «expr = »(J, 1)] [":=", expr λ J, trans (hI J) (hI 1).symm],
  refine [expr ⟨λ I, _⟩],
  by_cases [expr hI, ":", expr «expr = »(I, «expr⊥»())],
  { rw [expr hI] [],
    exact [expr bot_is_principal] },
  exact [expr (class_group.mk0_eq_one_iff (mem_non_zero_divisors_iff_ne_zero.mpr hI)).mp (eq_one _)]
end

