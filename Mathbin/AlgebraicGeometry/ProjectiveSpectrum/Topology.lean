/-
Copyright (c) 2020 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang, Johan Commelin

! This file was ported from Lean 3 source module algebraic_geometry.projective_spectrum.topology
! leanprover-community/mathlib commit 4280f5f32e16755ec7985ce11e189b6cd6ff6735
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.GradedAlgebra.HomogeneousIdeal
import Mathbin.Topology.Category.Top.Basic
import Mathbin.Topology.Sets.Opens

/-!
# Projective spectrum of a graded ring

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The projective spectrum of a graded commutative ring is the subtype of all homogenous ideals that
are prime and do not contain the irrelevant ideal.
It is naturally endowed with a topology: the Zariski topology.

## Notation
- `R` is a commutative semiring;
- `A` is a commutative ring and an `R`-algebra;
- `ùíú : ‚Ñï ‚Üí submodule R A` is the grading of `A`;

## Main definitions

* `projective_spectrum ùíú`: The projective spectrum of a graded ring `A`, or equivalently, the set of
  all homogeneous ideals of `A` that is both prime and relevant i.e. not containing irrelevant
  ideal. Henceforth, we call elements of projective spectrum *relevant homogeneous prime ideals*.
* `projective_spectrum.zero_locus ùíú s`: The zero locus of a subset `s` of `A`
  is the subset of `projective_spectrum ùíú` consisting of all relevant homogeneous prime ideals that
  contain `s`.
* `projective_spectrum.vanishing_ideal t`: The vanishing ideal of a subset `t` of
  `projective_spectrum ùíú` is the intersection of points in `t` (viewed as relevant homogeneous prime
  ideals).
* `projective_spectrum.Top`: the topological space of `projective_spectrum ùíú` endowed with the
  Zariski topology.
-/


noncomputable section

open DirectSum BigOperators Pointwise

open DirectSum SetLike TopCat TopologicalSpace CategoryTheory Opposite

variable {R A : Type _}

variable [CommSemiring R] [CommRing A] [Algebra R A]

variable (ùíú : ‚Ñï ‚Üí Submodule R A) [GradedAlgebra ùíú]

/- warning: projective_spectrum -> ProjectiveSpectrum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Type.{u2}
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Type.{u2}
Case conversion may be inaccurate. Consider using '#align projective_spectrum ProjectiveSpectrum‚Çì'. -/
/-- The projective spectrum of a graded commutative ring is the subtype of all homogenous ideals
that are prime and do not contain the irrelevant ideal. -/
@[ext, nolint has_nonempty_instance]
structure ProjectiveSpectrum where
  asHomogeneousIdeal : HomogeneousIdeal ùíú
  IsPrime : as_homogeneous_ideal.toIdeal.IsPrime
  not_irrelevant_le : ¬¨HomogeneousIdeal.irrelevant ùíú ‚â§ as_homogeneous_ideal
#align projective_spectrum ProjectiveSpectrum

attribute [instance] ProjectiveSpectrum.isPrime

namespace ProjectiveSpectrum

/- warning: projective_spectrum.zero_locus -> ProjectiveSpectrum.zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], (Set.{u2} A) -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], (Set.{u2} A) -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus ProjectiveSpectrum.zeroLocus‚Çì'. -/
/-- The zero locus of a set `s` of elements of a commutative ring `A` is the set of all relevant
homogeneous prime ideals of the ring that contain the set `s`.

An element `f` of `A` can be thought of as a dependent function on the projective spectrum of `ùíú`.
At a point `x` (a homogeneous prime ideal) the function (i.e., element) `f` takes values in the
quotient ring `A` modulo the prime ideal `x`. In this manner, `zero_locus s` is exactly the subset
of `projective_spectrum ùíú` where all "functions" in `s` vanish simultaneously. -/
def zeroLocus (s : Set A) : Set (ProjectiveSpectrum ùíú) :=
  { x | s ‚äÜ x.asHomogeneousIdeal }
#align projective_spectrum.zero_locus ProjectiveSpectrum.zeroLocus

/- warning: projective_spectrum.mem_zero_locus -> ProjectiveSpectrum.mem_zeroLocus is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_zero_locus ProjectiveSpectrum.mem_zeroLocus‚Çì'. -/
@[simp]
theorem mem_zeroLocus (x : ProjectiveSpectrum ùíú) (s : Set A) :
    x ‚àà zeroLocus ùíú s ‚Üî s ‚äÜ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_zero_locus ProjectiveSpectrum.mem_zeroLocus

/- warning: projective_spectrum.zero_locus_span -> ProjectiveSpectrum.zeroLocus_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_span ProjectiveSpectrum.zeroLocus_span‚Çì'. -/
@[simp]
theorem zeroLocus_span (s : Set A) : zeroLocus ùíú (Ideal.span s) = zeroLocus ùíú s :=
  by
  ext x
  exact (Submodule.gi _ _).gc s x.as_homogeneous_ideal.to_ideal
#align projective_spectrum.zero_locus_span ProjectiveSpectrum.zeroLocus_span

variable {ùíú}

/- warning: projective_spectrum.vanishing_ideal -> ProjectiveSpectrum.vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal ProjectiveSpectrum.vanishingIdeal‚Çì'. -/
/-- The vanishing ideal of a set `t` of points of the projective spectrum of a commutative ring `R`
is the intersection of all the relevant homogeneous prime ideals in the set `t`.

An element `f` of `A` can be thought of as a dependent function on the projective spectrum of `ùíú`.
At a point `x` (a homogeneous prime ideal) the function (i.e., element) `f` takes values in the
quotient ring `A` modulo the prime ideal `x`. In this manner, `vanishing_ideal t` is exactly the
ideal of `A` consisting of all "functions" that vanish on all of `t`. -/
def vanishingIdeal (t : Set (ProjectiveSpectrum ùíú)) : HomogeneousIdeal ùíú :=
  ‚®Ö (x : ProjectiveSpectrum ùíú) (h : x ‚àà t), x.asHomogeneousIdeal
#align projective_spectrum.vanishing_ideal ProjectiveSpectrum.vanishingIdeal

/- warning: projective_spectrum.coe_vanishing_ideal -> ProjectiveSpectrum.coe_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.coe_vanishing_ideal ProjectiveSpectrum.coe_vanishingIdeal‚Çì'. -/
theorem coe_vanishingIdeal (t : Set (ProjectiveSpectrum ùíú)) :
    (vanishingIdeal t : Set A) =
      { f | ‚àÄ x : ProjectiveSpectrum ùíú, x ‚àà t ‚Üí f ‚àà x.asHomogeneousIdeal } :=
  by
  ext f
  rw [vanishing_ideal, SetLike.mem_coe, ‚Üê HomogeneousIdeal.mem_iff, HomogeneousIdeal.toIdeal_iInf,
    Submodule.mem_iInf]
  apply forall_congr' fun x => _
  rw [HomogeneousIdeal.toIdeal_iInf, Submodule.mem_iInf, HomogeneousIdeal.mem_iff]
#align projective_spectrum.coe_vanishing_ideal ProjectiveSpectrum.coe_vanishingIdeal

/- warning: projective_spectrum.mem_vanishing_ideal -> ProjectiveSpectrum.mem_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_vanishing_ideal ProjectiveSpectrum.mem_vanishingIdeal‚Çì'. -/
theorem mem_vanishingIdeal (t : Set (ProjectiveSpectrum ùíú)) (f : A) :
    f ‚àà vanishingIdeal t ‚Üî ‚àÄ x : ProjectiveSpectrum ùíú, x ‚àà t ‚Üí f ‚àà x.asHomogeneousIdeal := by
  rw [‚Üê SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]
#align projective_spectrum.mem_vanishing_ideal ProjectiveSpectrum.mem_vanishingIdeal

/- warning: projective_spectrum.vanishing_ideal_singleton -> ProjectiveSpectrum.vanishingIdeal_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasSingleton.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) x)) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 x)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {ùíú : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ùíú] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4), Eq.{succ u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instSingletonSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) x)) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 x)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_singleton ProjectiveSpectrum.vanishingIdeal_singleton‚Çì'. -/
@[simp]
theorem vanishingIdeal_singleton (x : ProjectiveSpectrum ùíú) :
    vanishingIdeal ({x} : Set (ProjectiveSpectrum ùíú)) = x.asHomogeneousIdeal := by
  simp [vanishing_ideal]
#align projective_spectrum.vanishing_ideal_singleton ProjectiveSpectrum.vanishingIdeal_singleton

/- warning: projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I))) (LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I))) (LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal‚Çì'. -/
theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (ProjectiveSpectrum ùíú)) (I : Ideal A) :
    t ‚äÜ zeroLocus ùíú I ‚Üî I ‚â§ (vanishingIdeal t).toIdeal :=
  ‚ü®fun h f k => (mem_vanishingIdeal _ _).mpr fun x j => (mem_zeroLocus _ _ _).mpr (h j) k, fun h =>
    fun x j =>
    (mem_zeroLocus _ _ _).mpr (le_trans h fun f h => ((mem_vanishingIdeal _ _).mp h) x j)‚ü©
#align projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal

variable (ùíú)

/- warning: projective_spectrum.gc_ideal -> ProjectiveSpectrum.gc_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], GaloisConnection.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.completeBooleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))))))) (fun (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) => HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], GaloisConnection.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instCompleteBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))))))) (fun (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) => HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_ideal ProjectiveSpectrum.gc_ideal‚Çì'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc_ideal :
    @GaloisConnection (Ideal A) (Set (ProjectiveSpectrum ùíú))·µí·µà _ _ (fun I => zeroLocus ùíú I) fun t =>
      (vanishingIdeal t).toIdeal :=
  fun I t => subset_zeroLocus_iff_le_vanishingIdeal t I
#align projective_spectrum.gc_ideal ProjectiveSpectrum.gc_ideal

/- warning: projective_spectrum.gc_set -> ProjectiveSpectrum.gc_set is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_set ProjectiveSpectrum.gc_set‚Çì'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc_set :
    @GaloisConnection (Set A) (Set (ProjectiveSpectrum ùíú))·µí·µà _ _ (fun s => zeroLocus ùíú s) fun t =>
      vanishingIdeal t :=
  by
  have ideal_gc : GaloisConnection Ideal.span coe := (Submodule.gi A _).gc
  simpa [zero_locus_span, Function.comp] using GaloisConnection.compose ideal_gc (gc_ideal ùíú)
#align projective_spectrum.gc_set ProjectiveSpectrum.gc_set

/- warning: projective_spectrum.gc_homogeneous_ideal -> ProjectiveSpectrum.gc_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_homogeneous_ideal ProjectiveSpectrum.gc_homogeneousIdeal‚Çì'. -/
theorem gc_homogeneousIdeal :
    @GaloisConnection (HomogeneousIdeal ùíú) (Set (ProjectiveSpectrum ùíú))·µí·µà _ _
      (fun I => zeroLocus ùíú I) fun t => vanishingIdeal t :=
  fun I t => by
  simpa [show I.to_ideal ‚â§ (vanishing_ideal t).toIdeal ‚Üî I ‚â§ vanishing_ideal t from Iff.rfl] using
    subset_zero_locus_iff_le_vanishing_ideal t I.to_ideal
#align projective_spectrum.gc_homogeneous_ideal ProjectiveSpectrum.gc_homogeneousIdeal

/- warning: projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal‚Çì'. -/
theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (ProjectiveSpectrum ùíú)) (s : Set A) :
    t ‚äÜ zeroLocus ùíú s ‚Üî s ‚äÜ vanishingIdeal t :=
  (gc_set _) s t
#align projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal

/- warning: projective_spectrum.subset_vanishing_ideal_zero_locus -> ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_vanishing_ideal_zero_locus ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus‚Çì'. -/
theorem subset_vanishingIdeal_zeroLocus (s : Set A) : s ‚äÜ vanishingIdeal (zeroLocus ùíú s) :=
  (gc_set _).le_u_l s
#align projective_spectrum.subset_vanishing_ideal_zero_locus ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.ideal_le_vanishing_ideal_zero_locus -> ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus‚Çì'. -/
theorem ideal_le_vanishingIdeal_zeroLocus (I : Ideal A) :
    I ‚â§ (vanishingIdeal (zeroLocus ùíú I)).toIdeal :=
  (gc_ideal _).le_u_l I
#align projective_spectrum.ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus -> ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus‚Çì'. -/
theorem homogeneousIdeal_le_vanishingIdeal_zeroLocus (I : HomogeneousIdeal ùíú) :
    I ‚â§ vanishingIdeal (zeroLocus ùíú I) :=
  (gc_homogeneousIdeal _).le_u_l I
#align projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.subset_zero_locus_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal‚Çì'. -/
theorem subset_zeroLocus_vanishingIdeal (t : Set (ProjectiveSpectrum ùíú)) :
    t ‚äÜ zeroLocus ùíú (vanishingIdeal t) :=
  (gc_ideal _).l_u_le t
#align projective_spectrum.subset_zero_locus_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal

/- warning: projective_spectrum.zero_locus_anti_mono -> ProjectiveSpectrum.zeroLocus_anti_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] {s : Set.{u2} A} {t : Set.{u2} A}, (HasSubset.Subset.{u2} (Set.{u2} A) (Set.hasSubset.{u2} A) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] {s : Set.{u2} A} {t : Set.{u2} A}, (HasSubset.Subset.{u2} (Set.{u2} A) (Set.instHasSubsetSet.{u2} A) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono ProjectiveSpectrum.zeroLocus_anti_mono‚Çì'. -/
theorem zeroLocus_anti_mono {s t : Set A} (h : s ‚äÜ t) : zeroLocus ùíú t ‚äÜ zeroLocus ùíú s :=
  (gc_set _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono ProjectiveSpectrum.zeroLocus_anti_mono

/- warning: projective_spectrum.zero_locus_anti_mono_ideal -> ProjectiveSpectrum.zeroLocus_anti_mono_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] {s : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))} {t : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))}, (LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] {s : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))} {t : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))}, (LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono_ideal ProjectiveSpectrum.zeroLocus_anti_mono_ideal‚Çì'. -/
theorem zeroLocus_anti_mono_ideal {s t : Ideal A} (h : s ‚â§ t) :
    zeroLocus ùíú (t : Set A) ‚äÜ zeroLocus ùíú (s : Set A) :=
  (gc_ideal _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono_ideal ProjectiveSpectrum.zeroLocus_anti_mono_ideal

/- warning: projective_spectrum.zero_locus_anti_mono_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono_homogeneous_ideal ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal‚Çì'. -/
theorem zeroLocus_anti_mono_homogeneousIdeal {s t : HomogeneousIdeal ùíú} (h : s ‚â§ t) :
    zeroLocus ùíú (t : Set A) ‚äÜ zeroLocus ùíú (s : Set A) :=
  (gc_homogeneousIdeal _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono_homogeneous_ideal ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal

/- warning: projective_spectrum.vanishing_ideal_anti_mono -> ProjectiveSpectrum.vanishingIdeal_anti_mono is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_anti_mono ProjectiveSpectrum.vanishingIdeal_anti_mono‚Çì'. -/
theorem vanishingIdeal_anti_mono {s t : Set (ProjectiveSpectrum ùíú)} (h : s ‚äÜ t) :
    vanishingIdeal t ‚â§ vanishingIdeal s :=
  (gc_ideal _).monotone_u h
#align projective_spectrum.vanishing_ideal_anti_mono ProjectiveSpectrum.vanishingIdeal_anti_mono

/- warning: projective_spectrum.zero_locus_bot -> ProjectiveSpectrum.zeroLocus_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Bot.bot.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasBot.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Bot.bot.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instBotSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_bot ProjectiveSpectrum.zeroLocus_bot‚Çì'. -/
theorem zeroLocus_bot : zeroLocus ùíú ((‚ä• : Ideal A) : Set A) = Set.univ :=
  (gc_ideal ùíú).l_bot
#align projective_spectrum.zero_locus_bot ProjectiveSpectrum.zeroLocus_bot

/- warning: projective_spectrum.zero_locus_singleton_zero -> ProjectiveSpectrum.zeroLocus_singleton_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (CommMonoidWithZero.toZero.{u2} A (CommSemiring.toCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_zero ProjectiveSpectrum.zeroLocus_singleton_zero‚Çì'. -/
@[simp]
theorem zeroLocus_singleton_zero : zeroLocus ùíú ({0} : Set A) = Set.univ :=
  zeroLocus_bot _
#align projective_spectrum.zero_locus_singleton_zero ProjectiveSpectrum.zeroLocus_singleton_zero

/- warning: projective_spectrum.zero_locus_empty -> ProjectiveSpectrum.zeroLocus_empty is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.instEmptyCollectionSet.{u2} A))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_empty ProjectiveSpectrum.zeroLocus_empty‚Çì'. -/
@[simp]
theorem zeroLocus_empty : zeroLocus ùíú (‚àÖ : Set A) = Set.univ :=
  (gc_set ùíú).l_bot
#align projective_spectrum.zero_locus_empty ProjectiveSpectrum.zeroLocus_empty

/- warning: projective_spectrum.vanishing_ideal_univ -> ProjectiveSpectrum.vanishingIdeal_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))) (Top.top.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasTop.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))) (Top.top.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instTopHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_univ ProjectiveSpectrum.vanishingIdeal_univ‚Çì'. -/
@[simp]
theorem vanishingIdeal_univ : vanishingIdeal (‚àÖ : Set (ProjectiveSpectrum ùíú)) = ‚ä§ := by
  simpa using (gc_ideal _).u_top
#align projective_spectrum.vanishing_ideal_univ ProjectiveSpectrum.vanishingIdeal_univ

/- warning: projective_spectrum.zero_locus_empty_of_one_mem -> ProjectiveSpectrum.zeroLocus_empty_of_one_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] {s : Set.{u2} A}, (Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) s) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] {s : Set.{u2} A}, (Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) s) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_empty_of_one_mem ProjectiveSpectrum.zeroLocus_empty_of_one_mem‚Çì'. -/
theorem zeroLocus_empty_of_one_mem {s : Set A} (h : (1 : A) ‚àà s) : zeroLocus ùíú s = ‚àÖ :=
  Set.eq_empty_iff_forall_not_mem.mpr fun x hx =>
    (inferInstance : x.asHomogeneousIdeal.toIdeal.IsPrime).ne_top <|
      x.asHomogeneousIdeal.toIdeal.eq_top_iff_one.mpr <| hx h
#align projective_spectrum.zero_locus_empty_of_one_mem ProjectiveSpectrum.zeroLocus_empty_of_one_mem

/- warning: projective_spectrum.zero_locus_singleton_one -> ProjectiveSpectrum.zeroLocus_singleton_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_one ProjectiveSpectrum.zeroLocus_singleton_one‚Çì'. -/
@[simp]
theorem zeroLocus_singleton_one : zeroLocus ùíú ({1} : Set A) = ‚àÖ :=
  zeroLocus_empty_of_one_mem ùíú (Set.mem_singleton (1 : A))
#align projective_spectrum.zero_locus_singleton_one ProjectiveSpectrum.zeroLocus_singleton_one

/- warning: projective_spectrum.zero_locus_univ -> ProjectiveSpectrum.zeroLocus_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Set.univ.{u2} A)) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Set.univ.{u2} A)) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_univ ProjectiveSpectrum.zeroLocus_univ‚Çì'. -/
@[simp]
theorem zeroLocus_univ : zeroLocus ùíú (Set.univ : Set A) = ‚àÖ :=
  zeroLocus_empty_of_one_mem _ (Set.mem_univ 1)
#align projective_spectrum.zero_locus_univ ProjectiveSpectrum.zeroLocus_univ

/- warning: projective_spectrum.zero_locus_sup_ideal -> ProjectiveSpectrum.zeroLocus_sup_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Sup.sup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SemilatticeSup.toHasSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (IdemSemiring.toSemilatticeSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.idemSemiring.{u2, u2} A (CommRing.toCommSemiring.{u2} A _inst_2) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Algebra.id.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Sup.sup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (SemilatticeSup.toSup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_sup_ideal ProjectiveSpectrum.zeroLocus_sup_ideal‚Çì'. -/
theorem zeroLocus_sup_ideal (I J : Ideal A) :
    zeroLocus ùíú ((I ‚äî J : Ideal A) : Set A) = zeroLocus _ I ‚à© zeroLocus _ J :=
  (gc_ideal ùíú).l_sup
#align projective_spectrum.zero_locus_sup_ideal ProjectiveSpectrum.zeroLocus_sup_ideal

/- warning: projective_spectrum.zero_locus_sup_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_sup_homogeneous_ideal ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal‚Çì'. -/
theorem zeroLocus_sup_homogeneousIdeal (I J : HomogeneousIdeal ùíú) :
    zeroLocus ùíú ((I ‚äî J : HomogeneousIdeal ùíú) : Set A) = zeroLocus _ I ‚à© zeroLocus _ J :=
  (gc_homogeneousIdeal ùíú).l_sup
#align projective_spectrum.zero_locus_sup_homogeneous_ideal ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_union -> ProjectiveSpectrum.zeroLocus_union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Union.union.{u2} (Set.{u2} A) (Set.hasUnion.{u2} A) s s')) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s'))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Union.union.{u2} (Set.{u2} A) (Set.instUnionSet.{u2} A) s s')) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s'))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_union ProjectiveSpectrum.zeroLocus_union‚Çì'. -/
theorem zeroLocus_union (s s' : Set A) : zeroLocus ùíú (s ‚à™ s') = zeroLocus _ s ‚à© zeroLocus _ s' :=
  (gc_set ùíú).l_sup
#align projective_spectrum.zero_locus_union ProjectiveSpectrum.zeroLocus_union

/- warning: projective_spectrum.vanishing_ideal_union -> ProjectiveSpectrum.vanishingIdeal_union is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_union ProjectiveSpectrum.vanishingIdeal_union‚Çì'. -/
theorem vanishingIdeal_union (t t' : Set (ProjectiveSpectrum ùíú)) :
    vanishingIdeal (t ‚à™ t') = vanishingIdeal t ‚äì vanishingIdeal t' := by
  ext1 <;> convert(gc_ideal ùíú).u_inf
#align projective_spectrum.vanishing_ideal_union ProjectiveSpectrum.vanishingIdeal_union

/- warning: projective_spectrum.zero_locus_supr_ideal -> ProjectiveSpectrum.zeroLocus_iSup_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] {Œ≥ : Sort.{u3}} (I : Œ≥ -> (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (iSup.{u2, u3} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (ConditionallyCompleteLattice.toHasSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) Œ≥ (fun (i : Œ≥) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) Œ≥ (fun (i : Œ≥) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (I i))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] {Œ≥ : Sort.{u3}} (I : Œ≥ -> (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (iSup.{u2, u3} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (ConditionallyCompleteLattice.toSupSet.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) Œ≥ (fun (i : Œ≥) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) Œ≥ (fun (i : Œ≥) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (I i))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_supr_ideal ProjectiveSpectrum.zeroLocus_iSup_ideal‚Çì'. -/
theorem zeroLocus_iSup_ideal {Œ≥ : Sort _} (I : Œ≥ ‚Üí Ideal A) :
    zeroLocus _ ((‚®Ü i, I i : Ideal A) : Set A) = ‚ãÇ i, zeroLocus ùíú (I i) :=
  (gc_ideal ùíú).l_iSup
#align projective_spectrum.zero_locus_supr_ideal ProjectiveSpectrum.zeroLocus_iSup_ideal

/- warning: projective_spectrum.zero_locus_supr_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_supr_homogeneous_ideal ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal‚Çì'. -/
theorem zeroLocus_iSup_homogeneousIdeal {Œ≥ : Sort _} (I : Œ≥ ‚Üí HomogeneousIdeal ùíú) :
    zeroLocus _ ((‚®Ü i, I i : HomogeneousIdeal ùíú) : Set A) = ‚ãÇ i, zeroLocus ùíú (I i) :=
  (gc_homogeneousIdeal ùíú).l_iSup
#align projective_spectrum.zero_locus_supr_homogeneous_ideal ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_Union -> ProjectiveSpectrum.zeroLocus_iUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] {Œ≥ : Sort.{u3}} (s : Œ≥ -> (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Set.iUnion.{u2, u3} A Œ≥ (fun (i : Œ≥) => s i))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) Œ≥ (fun (i : Œ≥) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (s i)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] {Œ≥ : Sort.{u3}} (s : Œ≥ -> (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Set.iUnion.{u2, u3} A Œ≥ (fun (i : Œ≥) => s i))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) Œ≥ (fun (i : Œ≥) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (s i)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_Union ProjectiveSpectrum.zeroLocus_iUnion‚Çì'. -/
theorem zeroLocus_iUnion {Œ≥ : Sort _} (s : Œ≥ ‚Üí Set A) :
    zeroLocus ùíú (‚ãÉ i, s i) = ‚ãÇ i, zeroLocus ùíú (s i) :=
  (gc_set ùíú).l_iSup
#align projective_spectrum.zero_locus_Union ProjectiveSpectrum.zeroLocus_iUnion

/- warning: projective_spectrum.zero_locus_bUnion -> ProjectiveSpectrum.zeroLocus_bUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Set.iUnion.{u2, succ u2} A (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iUnion.{u2, 0} A (Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) => s')))) (Set.iInter.{u2, succ u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iInter.{u2, 0} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s')))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Set.iUnion.{u2, succ u2} A (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iUnion.{u2, 0} A (Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) => s')))) (Set.iInter.{u2, succ u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iInter.{u2, 0} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s')))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_bUnion ProjectiveSpectrum.zeroLocus_bUnion‚Çì'. -/
theorem zeroLocus_bUnion (s : Set (Set A)) :
    zeroLocus ùíú (‚ãÉ s' ‚àà s, s' : Set A) = ‚ãÇ s' ‚àà s, zeroLocus ùíú s' := by simp only [zero_locus_Union]
#align projective_spectrum.zero_locus_bUnion ProjectiveSpectrum.zeroLocus_bUnion

/- warning: projective_spectrum.vanishing_ideal_Union -> ProjectiveSpectrum.vanishingIdeal_iUnion is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_Union ProjectiveSpectrum.vanishingIdeal_iUnion‚Çì'. -/
theorem vanishingIdeal_iUnion {Œ≥ : Sort _} (t : Œ≥ ‚Üí Set (ProjectiveSpectrum ùíú)) :
    vanishingIdeal (‚ãÉ i, t i) = ‚®Ö i, vanishingIdeal (t i) :=
  HomogeneousIdeal.toIdeal_injective <| by
    convert(gc_ideal ùíú).u_iInf <;> exact HomogeneousIdeal.toIdeal_iInf _
#align projective_spectrum.vanishing_ideal_Union ProjectiveSpectrum.vanishingIdeal_iUnion

/- warning: projective_spectrum.zero_locus_inf -> ProjectiveSpectrum.zeroLocus_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Inf.inf.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasInf.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Inf.inf.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instInfSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_inf ProjectiveSpectrum.zeroLocus_inf‚Çì'. -/
theorem zeroLocus_inf (I J : Ideal A) :
    zeroLocus ùíú ((I ‚äì J : Ideal A) : Set A) = zeroLocus ùíú I ‚à™ zeroLocus ùíú J :=
  Set.ext fun x => x.IsPrime.inf_le
#align projective_spectrum.zero_locus_inf ProjectiveSpectrum.zeroLocus_inf

/- warning: projective_spectrum.union_zero_locus -> ProjectiveSpectrum.union_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s')) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Inf.inf.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasInf.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s'))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s')) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Inf.inf.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instInfSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s'))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.union_zero_locus ProjectiveSpectrum.union_zeroLocus‚Çì'. -/
theorem union_zeroLocus (s s' : Set A) :
    zeroLocus ùíú s ‚à™ zeroLocus ùíú s' = zeroLocus ùíú (Ideal.span s ‚äì Ideal.span s' : Ideal A) :=
  by
  rw [zero_locus_inf]
  simp
#align projective_spectrum.union_zero_locus ProjectiveSpectrum.union_zeroLocus

/- warning: projective_spectrum.zero_locus_mul_ideal -> ProjectiveSpectrum.zeroLocus_mul_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (instHMul.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.hasMul.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTC‚Çì.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (instHMul.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.instMulIdealToSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_mul_ideal ProjectiveSpectrum.zeroLocus_mul_ideal‚Çì'. -/
theorem zeroLocus_mul_ideal (I J : Ideal A) :
    zeroLocus ùíú ((I * J : Ideal A) : Set A) = zeroLocus ùíú I ‚à™ zeroLocus ùíú J :=
  Set.ext fun x => x.IsPrime.mul_le
#align projective_spectrum.zero_locus_mul_ideal ProjectiveSpectrum.zeroLocus_mul_ideal

/- warning: projective_spectrum.zero_locus_mul_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_mul_homogeneous_ideal ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal‚Çì'. -/
theorem zeroLocus_mul_homogeneousIdeal (I J : HomogeneousIdeal ùíú) :
    zeroLocus ùíú ((I * J : HomogeneousIdeal ùíú) : Set A) = zeroLocus ùíú I ‚à™ zeroLocus ùíú J :=
  Set.ext fun x => x.IsPrime.mul_le
#align projective_spectrum.zero_locus_mul_homogeneous_ideal ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_singleton_mul -> ProjectiveSpectrum.zeroLocus_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) f)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) g)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) f)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) g)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_mul ProjectiveSpectrum.zeroLocus_singleton_mul‚Çì'. -/
theorem zeroLocus_singleton_mul (f g : A) :
    zeroLocus ùíú ({f * g} : Set A) = zeroLocus ùíú {f} ‚à™ zeroLocus ùíú {g} :=
  Set.ext fun x => by simpa using x.is_prime.mul_mem_iff_mem_or_mem
#align projective_spectrum.zero_locus_singleton_mul ProjectiveSpectrum.zeroLocus_singleton_mul

/- warning: projective_spectrum.zero_locus_singleton_pow -> ProjectiveSpectrum.zeroLocus_singleton_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f n))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) f)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) f n))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) f)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_pow ProjectiveSpectrum.zeroLocus_singleton_pow‚Çì'. -/
@[simp]
theorem zeroLocus_singleton_pow (f : A) (n : ‚Ñï) (hn : 0 < n) :
    zeroLocus ùíú ({f ^ n} : Set A) = zeroLocus ùíú {f} :=
  Set.ext fun x => by simpa using x.is_prime.pow_mem_iff_mem n hn
#align projective_spectrum.zero_locus_singleton_pow ProjectiveSpectrum.zeroLocus_singleton_pow

/- warning: projective_spectrum.sup_vanishing_ideal_le -> ProjectiveSpectrum.sup_vanishingIdeal_le is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.sup_vanishing_ideal_le ProjectiveSpectrum.sup_vanishingIdeal_le‚Çì'. -/
theorem sup_vanishingIdeal_le (t t' : Set (ProjectiveSpectrum ùíú)) :
    vanishingIdeal t ‚äî vanishingIdeal t' ‚â§ vanishingIdeal (t ‚à© t') :=
  by
  intro r
  rw [‚Üê HomogeneousIdeal.mem_iff, HomogeneousIdeal.toIdeal_sup, mem_vanishing_ideal,
    Submodule.mem_sup]
  rintro ‚ü®f, hf, g, hg, rfl‚ü© x ‚ü®hxt, hxt'‚ü©
  erw [mem_vanishing_ideal] at hf hg
  apply Submodule.add_mem <;> solve_by_elim
#align projective_spectrum.sup_vanishing_ideal_le ProjectiveSpectrum.sup_vanishingIdeal_le

/- warning: projective_spectrum.mem_compl_zero_locus_iff_not_mem -> ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_compl_zero_locus_iff_not_mem ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem‚Çì'. -/
theorem mem_compl_zeroLocus_iff_not_mem {f : A} {I : ProjectiveSpectrum ùíú} :
    I ‚àà (zeroLocus ùíú {f} : Set (ProjectiveSpectrum ùíú))·∂ú ‚Üî f ‚àâ I.asHomogeneousIdeal := by
  rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl
#align projective_spectrum.mem_compl_zero_locus_iff_not_mem ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem

/- warning: projective_spectrum.zariski_topology -> ProjectiveSpectrum.zariskiTopology is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], TopologicalSpace.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], TopologicalSpace.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zariski_topology ProjectiveSpectrum.zariskiTopology‚Çì'. -/
/-- The Zariski topology on the prime spectrum of a commutative ring is defined via the closed sets
of the topology: they are exactly those sets that are the zero locus of a subset of the ring. -/
instance zariskiTopology : TopologicalSpace (ProjectiveSpectrum ùíú) :=
  TopologicalSpace.ofClosed (Set.range (ProjectiveSpectrum.zeroLocus ùíú)) ‚ü®Set.univ, by simp‚ü©
    (by
      intro Zs h
      rw [Set.sInter_eq_iInter]
      let f : Zs ‚Üí Set _ := fun i => Classical.choose (h i.2)
      have hf : ‚àÄ i : Zs, ‚Üëi = zero_locus ùíú (f i) := fun i => (Classical.choose_spec (h i.2)).symm
      simp only [hf]
      exact ‚ü®_, zero_locus_Union ùíú _‚ü©)
    (by
      rintro _ ‚ü®s, rfl‚ü© _ ‚ü®t, rfl‚ü©
      exact ‚ü®_, (union_zero_locus ùíú s t).symm‚ü©)
#align projective_spectrum.zariski_topology ProjectiveSpectrum.zariskiTopology

/- warning: projective_spectrum.Top -> ProjectiveSpectrum.top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], TopCat.{u2}
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], TopCat.{u2}
Case conversion may be inaccurate. Consider using '#align projective_spectrum.Top ProjectiveSpectrum.top‚Çì'. -/
/-- The underlying topology of `Proj` is the projective spectrum of graded ring `A`. -/
def top : TopCat :=
  TopCat.of (ProjectiveSpectrum ùíú)
#align projective_spectrum.Top ProjectiveSpectrum.top

/- warning: projective_spectrum.is_open_iff -> ProjectiveSpectrum.isOpen_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (U : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)), Iff (IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) U) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.booleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) U) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (U : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)), Iff (IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) U) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) U) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_open_iff ProjectiveSpectrum.isOpen_iff‚Çì'. -/
theorem isOpen_iff (U : Set (ProjectiveSpectrum ùíú)) : IsOpen U ‚Üî ‚àÉ s, U·∂ú = zeroLocus ùíú s := by
  simp only [@eq_comm _ (U·∂ú)] <;> rfl
#align projective_spectrum.is_open_iff ProjectiveSpectrum.isOpen_iff

/- warning: projective_spectrum.is_closed_iff_zero_locus -> ProjectiveSpectrum.isClosed_iff_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (Z : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)), Iff (IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) Z) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) Z (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (Z : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)), Iff (IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) Z) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) Z (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_closed_iff_zero_locus ProjectiveSpectrum.isClosed_iff_zeroLocus‚Çì'. -/
theorem isClosed_iff_zeroLocus (Z : Set (ProjectiveSpectrum ùíú)) :
    IsClosed Z ‚Üî ‚àÉ s, Z = zeroLocus ùíú s := by rw [‚Üê isOpen_compl_iff, is_open_iff, compl_compl]
#align projective_spectrum.is_closed_iff_zero_locus ProjectiveSpectrum.isClosed_iff_zeroLocus

/- warning: projective_spectrum.is_closed_zero_locus -> ProjectiveSpectrum.isClosed_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A), IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (s : Set.{u2} A), IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 s)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_closed_zero_locus ProjectiveSpectrum.isClosed_zeroLocus‚Çì'. -/
theorem isClosed_zeroLocus (s : Set A) : IsClosed (zeroLocus ùíú s) :=
  by
  rw [is_closed_iff_zero_locus]
  exact ‚ü®s, rfl‚ü©
#align projective_spectrum.is_closed_zero_locus ProjectiveSpectrum.isClosed_zeroLocus

/- warning: projective_spectrum.zero_locus_vanishing_ideal_eq_closure -> ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_vanishing_ideal_eq_closure ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure‚Çì'. -/
theorem zeroLocus_vanishingIdeal_eq_closure (t : Set (ProjectiveSpectrum ùíú)) :
    zeroLocus ùíú (vanishingIdeal t : Set A) = closure t :=
  by
  apply Set.Subset.antisymm
  ¬∑ rintro x hx t' ‚ü®ht', ht‚ü©
    obtain ‚ü®fs, rfl‚ü© : ‚àÉ s, t' = zero_locus ùíú s := by rwa [is_closed_iff_zero_locus] at ht'
    rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht
    exact Set.Subset.trans ht hx
  ¬∑ rw [(is_closed_zero_locus _ _).closure_subset_iff]
    exact subset_zero_locus_vanishing_ideal ùíú t
#align projective_spectrum.zero_locus_vanishing_ideal_eq_closure ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure

/- warning: projective_spectrum.vanishing_ideal_closure -> ProjectiveSpectrum.vanishingIdeal_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ùíú (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) t)) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ùíú (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) t)) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 t)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_closure ProjectiveSpectrum.vanishingIdeal_closure‚Çì'. -/
theorem vanishingIdeal_closure (t : Set (ProjectiveSpectrum ùíú)) :
    vanishingIdeal (closure t) = vanishingIdeal t :=
  by
  have := (gc_ideal ùíú).u_l_u_eq_u t
  dsimp only at this
  ext1
  erw [zero_locus_vanishing_ideal_eq_closure ùíú t] at this
  exact this
#align projective_spectrum.vanishing_ideal_closure ProjectiveSpectrum.vanishingIdeal_closure

section BasicOpen

/- warning: projective_spectrum.basic_open -> ProjectiveSpectrum.basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], A -> (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], A -> (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open ProjectiveSpectrum.basicOpen‚Çì'. -/
/-- `basic_open r` is the open subset containing all prime ideals not containing `r`. -/
def basicOpen (r : A) : TopologicalSpace.Opens (ProjectiveSpectrum ùíú)
    where
  carrier := { x | r ‚àâ x.asHomogeneousIdeal }
  is_open' := ‚ü®{r}, Set.ext fun x => Set.singleton_subset_iff.trans <| Classical.not_not.symm‚ü©
#align projective_spectrum.basic_open ProjectiveSpectrum.basicOpen

/- warning: projective_spectrum.mem_basic_open -> ProjectiveSpectrum.mem_basicOpen is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_basic_open ProjectiveSpectrum.mem_basicOpen‚Çì'. -/
@[simp]
theorem mem_basicOpen (f : A) (x : ProjectiveSpectrum ùíú) :
    x ‚àà basicOpen ùíú f ‚Üî f ‚àâ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_basic_open ProjectiveSpectrum.mem_basicOpen

/- warning: projective_spectrum.mem_coe_basic_open -> ProjectiveSpectrum.mem_coe_basicOpen is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_coe_basic_open ProjectiveSpectrum.mem_coe_basicOpen‚Çì'. -/
theorem mem_coe_basicOpen (f : A) (x : ProjectiveSpectrum ùíú) :
    x ‚àà (‚Üë(basicOpen ùíú f) : Set (ProjectiveSpectrum ùíú)) ‚Üî f ‚àâ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_coe_basic_open ProjectiveSpectrum.mem_coe_basicOpen

/- warning: projective_spectrum.is_open_basic_open -> ProjectiveSpectrum.isOpen_basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] {a : A}, IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CoeTC‚Çì.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 a))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] {a : A}, IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 a))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_open_basic_open ProjectiveSpectrum.isOpen_basicOpen‚Çì'. -/
theorem isOpen_basicOpen {a : A} : IsOpen (basicOpen ùíú a : Set (ProjectiveSpectrum ùíú)) :=
  (basicOpen ùíú a).IsOpen
#align projective_spectrum.is_open_basic_open ProjectiveSpectrum.isOpen_basicOpen

/- warning: projective_spectrum.basic_open_eq_zero_locus_compl -> ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (r : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CoeTC‚Çì.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 r)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.booleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) r)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (r : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 r)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) r)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_eq_zero_locus_compl ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl‚Çì'. -/
@[simp]
theorem basicOpen_eq_zeroLocus_compl (r : A) :
    (basicOpen ùíú r : Set (ProjectiveSpectrum ùíú)) = zeroLocus ùíú {r}·∂ú :=
  Set.ext fun x => by simpa only [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff]
#align projective_spectrum.basic_open_eq_zero_locus_compl ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl

/- warning: projective_spectrum.basic_open_one -> ProjectiveSpectrum.basicOpen_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2))))))))) (Top.top.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toHasTop.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) (Top.top.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toTop.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_one ProjectiveSpectrum.basicOpen_one‚Çì'. -/
@[simp]
theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
#align projective_spectrum.basic_open_one ProjectiveSpectrum.basicOpen_one

/- warning: projective_spectrum.basic_open_zero -> ProjectiveSpectrum.basicOpen_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) (Bot.bot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toHasBot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (CommMonoidWithZero.toZero.{u2} A (CommSemiring.toCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) (Bot.bot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toBot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_zero ProjectiveSpectrum.basicOpen_zero‚Çì'. -/
@[simp]
theorem basicOpen_zero : basicOpen ùíú (0 : A) = ‚ä• :=
  TopologicalSpace.Opens.ext <| by simp
#align projective_spectrum.basic_open_zero ProjectiveSpectrum.basicOpen_zero

/- warning: projective_spectrum.basic_open_mul -> ProjectiveSpectrum.basicOpen_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (Inf.inf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (SemilatticeInf.toHasInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Lattice.toSemilatticeInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 g))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (Inf.inf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Lattice.toInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 g))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul ProjectiveSpectrum.basicOpen_mul‚Çì'. -/
theorem basicOpen_mul (f g : A) : basicOpen ùíú (f * g) = basicOpen ùíú f ‚äì basicOpen ùíú g :=
  TopologicalSpace.Opens.ext <| by simp [zero_locus_singleton_mul]
#align projective_spectrum.basic_open_mul ProjectiveSpectrum.basicOpen_mul

/- warning: projective_spectrum.basic_open_mul_le_left -> ProjectiveSpectrum.basicOpen_mul_le_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Preorder.toHasLe.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (SetLike.partialOrder.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Preorder.toLE.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul_le_left ProjectiveSpectrum.basicOpen_mul_le_left‚Çì'. -/
theorem basicOpen_mul_le_left (f g : A) : basicOpen ùíú (f * g) ‚â§ basicOpen ùíú f :=
  by
  rw [basic_open_mul ùíú f g]
  exact inf_le_left
#align projective_spectrum.basic_open_mul_le_left ProjectiveSpectrum.basicOpen_mul_le_left

/- warning: projective_spectrum.basic_open_mul_le_right -> ProjectiveSpectrum.basicOpen_mul_le_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Preorder.toHasLe.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (SetLike.partialOrder.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 g)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Preorder.toLE.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 g)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul_le_right ProjectiveSpectrum.basicOpen_mul_le_right‚Çì'. -/
theorem basicOpen_mul_le_right (f g : A) : basicOpen ùíú (f * g) ‚â§ basicOpen ùíú g :=
  by
  rw [basic_open_mul ùíú f g]
  exact inf_le_right
#align projective_spectrum.basic_open_mul_le_right ProjectiveSpectrum.basicOpen_mul_le_right

/- warning: projective_spectrum.basic_open_pow -> ProjectiveSpectrum.basicOpen_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f n)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (f : A) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) f n)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_pow ProjectiveSpectrum.basicOpen_pow‚Çì'. -/
@[simp]
theorem basicOpen_pow (f : A) (n : ‚Ñï) (hn : 0 < n) : basicOpen ùíú (f ^ n) = basicOpen ùíú f :=
  TopologicalSpace.Opens.ext <| by simpa using zero_locus_singleton_pow ùíú f n hn
#align projective_spectrum.basic_open_pow ProjectiveSpectrum.basicOpen_pow

/- warning: projective_spectrum.basic_open_eq_union_of_projection -> ProjectiveSpectrum.basicOpen_eq_union_of_projection is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (f : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f) (iSup.{u2, 1} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ConditionallyCompleteLattice.toHasSup.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))) Nat (fun (i : Nat) => ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) => A -> A) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R A A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (GradedAlgebra.proj.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú _inst_4 i) f)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú] (f : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 f) (iSup.{u2, 1} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ConditionallyCompleteLattice.toSupSet.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)))) Nat (fun (i : Nat) => ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : A) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R A A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (GradedAlgebra.proj.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú _inst_4 i) f)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_eq_union_of_projection ProjectiveSpectrum.basicOpen_eq_union_of_projection‚Çì'. -/
theorem basicOpen_eq_union_of_projection (f : A) :
    basicOpen ùíú f = ‚®Ü i : ‚Ñï, basicOpen ùíú (GradedAlgebra.proj ùíú i f) :=
  TopologicalSpace.Opens.ext <|
    Set.ext fun z => by
      erw [mem_coe_basic_open, TopologicalSpace.Opens.mem_sSup]
      constructor <;> intro hz
      ¬∑ rcases show ‚àÉ i, GradedAlgebra.proj ùíú i f ‚àâ z.as_homogeneous_ideal
            by
            contrapose! hz with H
            classical
              rw [‚Üê DirectSum.sum_support_decompose ùíú f]
              apply Ideal.sum_mem _ fun i hi => H i with
          ‚ü®i, hi‚ü©
        exact ‚ü®basic_open ùíú (GradedAlgebra.proj ùíú i f), ‚ü®i, rfl‚ü©, by rwa [mem_basic_open]‚ü©
      ¬∑ obtain ‚ü®_, ‚ü®i, rfl‚ü©, hz‚ü© := hz
        exact fun rid => hz (z.1.2 i rid)
#align projective_spectrum.basic_open_eq_union_of_projection ProjectiveSpectrum.basicOpen_eq_union_of_projection

/- warning: projective_spectrum.is_topological_basis_basic_opens -> ProjectiveSpectrum.isTopologicalBasis_basic_opens is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú], TopologicalSpace.IsTopologicalBasis.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.range.{u2, succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) A (fun (r : A) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (CoeTC‚Çì.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 r)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ùíú], TopologicalSpace.IsTopologicalBasis.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.range.{u2, succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) A (fun (r : A) => SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4 r)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_topological_basis_basic_opens ProjectiveSpectrum.isTopologicalBasis_basic_opens‚Çì'. -/
theorem isTopologicalBasis_basic_opens :
    TopologicalSpace.IsTopologicalBasis
      (Set.range fun r : A => (basicOpen ùíú r : Set (ProjectiveSpectrum ùíú))) :=
  by
  apply TopologicalSpace.isTopologicalBasis_of_open_of_nhds
  ¬∑ rintro _ ‚ü®r, rfl‚ü©
    exact is_open_basic_open ùíú
  ¬∑ rintro p U hp ‚ü®s, hs‚ü©
    rw [‚Üê compl_compl U, Set.mem_compl_iff, ‚Üê hs, mem_zero_locus, Set.not_subset] at hp
    obtain ‚ü®f, hfs, hfp‚ü© := hp
    refine' ‚ü®basic_open ùíú f, ‚ü®f, rfl‚ü©, hfp, _‚ü©
    rw [‚Üê Set.compl_subset_compl, ‚Üê hs, basic_open_eq_zero_locus_compl, compl_compl]
    exact zero_locus_anti_mono ùíú (set.singleton_subset_iff.mpr hfs)
#align projective_spectrum.is_topological_basis_basic_opens ProjectiveSpectrum.isTopologicalBasis_basic_opens

end BasicOpen

section Order

/-!
## The specialization order

We endow `projective_spectrum ùíú` with a partial order,
where `x ‚â§ y` if and only if `y ‚àà closure {x}`.
-/


instance : PartialOrder (ProjectiveSpectrum ùíú) :=
  PartialOrder.lift asHomogeneousIdeal fun ‚ü®_, _, _‚ü© ‚ü®_, _, _‚ü© => mk.inj_eq.mpr

/- warning: projective_spectrum.as_ideal_le_as_ideal -> ProjectiveSpectrum.as_ideal_le_as_ideal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.as_ideal_le_as_ideal ProjectiveSpectrum.as_ideal_le_as_ideal‚Çì'. -/
@[simp]
theorem as_ideal_le_as_ideal (x y : ProjectiveSpectrum ùíú) :
    x.asHomogeneousIdeal ‚â§ y.asHomogeneousIdeal ‚Üî x ‚â§ y :=
  Iff.rfl
#align projective_spectrum.as_ideal_le_as_ideal ProjectiveSpectrum.as_ideal_le_as_ideal

/- warning: projective_spectrum.as_ideal_lt_as_ideal -> ProjectiveSpectrum.as_ideal_lt_as_ideal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.as_ideal_lt_as_ideal ProjectiveSpectrum.as_ideal_lt_as_ideal‚Çì'. -/
@[simp]
theorem as_ideal_lt_as_ideal (x y : ProjectiveSpectrum ùíú) :
    x.asHomogeneousIdeal < y.asHomogeneousIdeal ‚Üî x < y :=
  Iff.rfl
#align projective_spectrum.as_ideal_lt_as_ideal ProjectiveSpectrum.as_ideal_lt_as_ideal

/- warning: projective_spectrum.le_iff_mem_closure -> ProjectiveSpectrum.le_iff_mem_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ùíú : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ùíú] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (y : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4), Iff (LE.le.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Preorder.toHasLe.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (PartialOrder.toPreorder.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.partialOrder.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) x y) (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) y (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Singleton.singleton.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.hasSingleton.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) x)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ùíú : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ùíú] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (y : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4), Iff (LE.le.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Preorder.toLE.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (PartialOrder.toPreorder.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.instPartialOrderProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4))) x y) (Membership.mem.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instMembershipSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) y (closure.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Singleton.singleton.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) (Set.instSingletonSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ùíú _inst_4)) x)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.le_iff_mem_closure ProjectiveSpectrum.le_iff_mem_closure‚Çì'. -/
theorem le_iff_mem_closure (x y : ProjectiveSpectrum ùíú) :
    x ‚â§ y ‚Üî y ‚àà closure ({x} : Set (ProjectiveSpectrum ùíú)) :=
  by
  rw [‚Üê as_ideal_le_as_ideal, ‚Üê zero_locus_vanishing_ideal_eq_closure, mem_zero_locus,
    vanishing_ideal_singleton]
  simp only [coe_subset_coe, Subtype.coe_le_coe, coe_coe]
#align projective_spectrum.le_iff_mem_closure ProjectiveSpectrum.le_iff_mem_closure

end Order

end ProjectiveSpectrum

