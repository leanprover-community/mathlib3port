/-
Copyright (c) 2020 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang, Johan Commelin

! This file was ported from Lean 3 source module algebraic_geometry.projective_spectrum.topology
! leanprover-community/mathlib commit d39590fc8728fbf6743249802486f8c91ffe07bc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.GradedAlgebra.HomogeneousIdeal
import Mathbin.Topology.Category.Top.Basic
import Mathbin.Topology.Sets.Opens

/-!
# Projective spectrum of a graded ring

The projective spectrum of a graded commutative ring is the subtype of all homogenous ideals that
are prime and do not contain the irrelevant ideal.
It is naturally endowed with a topology: the Zariski topology.

## Notation
- `R` is a commutative semiring;
- `A` is a commutative ring and an `R`-algebra;
- `ð’œ : â„• â†’ submodule R A` is the grading of `A`;

## Main definitions

* `projective_spectrum ð’œ`: The projective spectrum of a graded ring `A`, or equivalently, the set of
  all homogeneous ideals of `A` that is both prime and relevant i.e. not containing irrelevant
  ideal. Henceforth, we call elements of projective spectrum *relevant homogeneous prime ideals*.
* `projective_spectrum.zero_locus ð’œ s`: The zero locus of a subset `s` of `A`
  is the subset of `projective_spectrum ð’œ` consisting of all relevant homogeneous prime ideals that
  contain `s`.
* `projective_spectrum.vanishing_ideal t`: The vanishing ideal of a subset `t` of
  `projective_spectrum ð’œ` is the intersection of points in `t` (viewed as relevant homogeneous prime
  ideals).
* `projective_spectrum.Top`: the topological space of `projective_spectrum ð’œ` endowed with the
  Zariski topology.
-/


noncomputable section

open DirectSum BigOperators Pointwise

open DirectSum SetLike TopCat TopologicalSpace CategoryTheory Opposite

variable {R A : Type _}

variable [CommSemiring R] [CommRing A] [Algebra R A]

variable (ð’œ : â„• â†’ Submodule R A) [GradedAlgebra ð’œ]

/- warning: projective_spectrum -> ProjectiveSpectrum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Type.{u2}
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Type.{u2}
Case conversion may be inaccurate. Consider using '#align projective_spectrum ProjectiveSpectrumâ‚“'. -/
/-- The projective spectrum of a graded commutative ring is the subtype of all homogenous ideals
that are prime and do not contain the irrelevant ideal. -/
@[ext, nolint has_nonempty_instance]
structure ProjectiveSpectrum where
  asHomogeneousIdeal : HomogeneousIdeal ð’œ
  IsPrime : as_homogeneous_ideal.toIdeal.IsPrime
  not_irrelevant_le : Â¬HomogeneousIdeal.irrelevant ð’œ â‰¤ as_homogeneous_ideal
#align projective_spectrum ProjectiveSpectrum

attribute [instance] ProjectiveSpectrum.isPrime

namespace ProjectiveSpectrum

/- warning: projective_spectrum.zero_locus -> ProjectiveSpectrum.zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], (Set.{u2} A) -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], (Set.{u2} A) -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus ProjectiveSpectrum.zeroLocusâ‚“'. -/
/-- The zero locus of a set `s` of elements of a commutative ring `A` is the set of all relevant
homogeneous prime ideals of the ring that contain the set `s`.

An element `f` of `A` can be thought of as a dependent function on the projective spectrum of `ð’œ`.
At a point `x` (a homogeneous prime ideal) the function (i.e., element) `f` takes values in the
quotient ring `A` modulo the prime ideal `x`. In this manner, `zero_locus s` is exactly the subset
of `projective_spectrum ð’œ` where all "functions" in `s` vanish simultaneously. -/
def zeroLocus (s : Set A) : Set (ProjectiveSpectrum ð’œ) :=
  { x | s âŠ† x.asHomogeneousIdeal }
#align projective_spectrum.zero_locus ProjectiveSpectrum.zeroLocus

/- warning: projective_spectrum.mem_zero_locus -> ProjectiveSpectrum.mem_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (s : Set.{u2} A), Iff (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)) (HasSubset.Subset.{u2} (Set.{u2} A) (Set.hasSubset.{u2} A) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4)))) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (s : Set.{u1} A), Iff (Membership.mem.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instMembershipSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x (ProjectiveSpectrum.zeroLocus.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)) (HasSubset.Subset.{u1} (Set.{u1} A) (Set.instHasSubsetSet.{u1} A) s (SetLike.coe.{u1, u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_zero_locus ProjectiveSpectrum.mem_zeroLocusâ‚“'. -/
@[simp]
theorem mem_zeroLocus (x : ProjectiveSpectrum ð’œ) (s : Set A) :
    x âˆˆ zeroLocus ð’œ s â†” s âŠ† x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_zero_locus ProjectiveSpectrum.mem_zeroLocus

/- warning: projective_spectrum.zero_locus_span -> ProjectiveSpectrum.zeroLocus_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_span ProjectiveSpectrum.zeroLocus_spanâ‚“'. -/
@[simp]
theorem zeroLocus_span (s : Set A) : zeroLocus ð’œ (Ideal.span s) = zeroLocus ð’œ s :=
  by
  ext x
  exact (Submodule.gi _ _).gc s x.as_homogeneous_ideal.to_ideal
#align projective_spectrum.zero_locus_span ProjectiveSpectrum.zeroLocus_span

variable {ð’œ}

/- warning: projective_spectrum.vanishing_ideal -> ProjectiveSpectrum.vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal ProjectiveSpectrum.vanishingIdealâ‚“'. -/
/-- The vanishing ideal of a set `t` of points of the projective spectrum of a commutative ring `R`
is the intersection of all the relevant homogeneous prime ideals in the set `t`.

An element `f` of `A` can be thought of as a dependent function on the projective spectrum of `ð’œ`.
At a point `x` (a homogeneous prime ideal) the function (i.e., element) `f` takes values in the
quotient ring `A` modulo the prime ideal `x`. In this manner, `vanishing_ideal t` is exactly the
ideal of `A` consisting of all "functions" that vanish on all of `t`. -/
def vanishingIdeal (t : Set (ProjectiveSpectrum ð’œ)) : HomogeneousIdeal ð’œ :=
  â¨… (x : ProjectiveSpectrum ð’œ) (h : x âˆˆ t), x.asHomogeneousIdeal
#align projective_spectrum.vanishing_ideal ProjectiveSpectrum.vanishingIdeal

/- warning: projective_spectrum.coe_vanishing_ideal -> ProjectiveSpectrum.coe_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (Set.{u2} A) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)) (setOf.{u2} A (fun (f : A) => forall (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x t) -> (Membership.Mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (SetLike.hasMem.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (Set.{u2} A) (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)) (setOf.{u2} A (fun (f : A) => forall (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), (Membership.mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instMembershipSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x t) -> (Membership.mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (SetLike.instMembership.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.coe_vanishing_ideal ProjectiveSpectrum.coe_vanishingIdealâ‚“'. -/
theorem coe_vanishingIdeal (t : Set (ProjectiveSpectrum ð’œ)) :
    (vanishingIdeal t : Set A) =
      { f | âˆ€ x : ProjectiveSpectrum ð’œ, x âˆˆ t â†’ f âˆˆ x.asHomogeneousIdeal } :=
  by
  ext f
  rw [vanishing_ideal, SetLike.mem_coe, â† HomogeneousIdeal.mem_iff, HomogeneousIdeal.toIdeal_iInf,
    Submodule.mem_iInf]
  apply forall_congr' fun x => _
  rw [HomogeneousIdeal.toIdeal_iInf, Submodule.mem_iInf, HomogeneousIdeal.mem_iff]
#align projective_spectrum.coe_vanishing_ideal ProjectiveSpectrum.coe_vanishingIdeal

/- warning: projective_spectrum.mem_vanishing_ideal -> ProjectiveSpectrum.mem_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (f : A), Iff (Membership.Mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (SetLike.hasMem.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)) f (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)) (forall (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x t) -> (Membership.Mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (SetLike.hasMem.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (f : A), Iff (Membership.mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (SetLike.instMembership.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)) f (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)) (forall (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), (Membership.mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instMembershipSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x t) -> (Membership.mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (SetLike.instMembership.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_vanishing_ideal ProjectiveSpectrum.mem_vanishingIdealâ‚“'. -/
theorem mem_vanishingIdeal (t : Set (ProjectiveSpectrum ð’œ)) (f : A) :
    f âˆˆ vanishingIdeal t â†” âˆ€ x : ProjectiveSpectrum ð’œ, x âˆˆ t â†’ f âˆˆ x.asHomogeneousIdeal := by
  rw [â† SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]
#align projective_spectrum.mem_vanishing_ideal ProjectiveSpectrum.mem_vanishingIdeal

/- warning: projective_spectrum.vanishing_ideal_singleton -> ProjectiveSpectrum.vanishingIdeal_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSingleton.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x)) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Eq.{succ u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instSingletonSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x)) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_singleton ProjectiveSpectrum.vanishingIdeal_singletonâ‚“'. -/
@[simp]
theorem vanishingIdeal_singleton (x : ProjectiveSpectrum ð’œ) :
    vanishingIdeal ({x} : Set (ProjectiveSpectrum ð’œ)) = x.asHomogeneousIdeal := by
  simp [vanishing_ideal]
#align projective_spectrum.vanishing_ideal_singleton ProjectiveSpectrum.vanishingIdeal_singleton

/- warning: projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I))) (LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I))) (LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdealâ‚“'. -/
theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (ProjectiveSpectrum ð’œ)) (I : Ideal A) :
    t âŠ† zeroLocus ð’œ I â†” I â‰¤ (vanishingIdeal t).toIdeal :=
  âŸ¨fun h f k => (mem_vanishingIdeal _ _).mpr fun x j => (mem_zeroLocus _ _ _).mpr (h j) k, fun h =>
    fun x j =>
    (mem_zeroLocus _ _ _).mpr (le_trans h fun f h => ((mem_vanishingIdeal _ _).mp h) x j)âŸ©
#align projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal

variable (ð’œ)

/- warning: projective_spectrum.gc_ideal -> ProjectiveSpectrum.gc_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], GaloisConnection.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.completeBooleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))))))) (fun (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) => HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], GaloisConnection.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instCompleteBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))))))) (fun (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) => HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_ideal ProjectiveSpectrum.gc_idealâ‚“'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc_ideal :
    @GaloisConnection (Ideal A) (Set (ProjectiveSpectrum ð’œ))áµ’áµˆ _ _ (fun I => zeroLocus ð’œ I) fun t =>
      (vanishingIdeal t).toIdeal :=
  fun I t => subset_zeroLocus_iff_le_vanishingIdeal t I
#align projective_spectrum.gc_ideal ProjectiveSpectrum.gc_ideal

/- warning: projective_spectrum.gc_set -> ProjectiveSpectrum.gc_set is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], GaloisConnection.{u2, u2} (Set.{u2} A) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (PartialOrder.toPreorder.{u2} (Set.{u2} A) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} A) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} A) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} A) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} A) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} A) (Set.completeBooleanAlgebra.{u2} A))))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.completeBooleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))))))) (fun (s : Set.{u2} A) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], GaloisConnection.{u2, u2} (Set.{u2} A) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (PartialOrder.toPreorder.{u2} (Set.{u2} A) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} A) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} A) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} A) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} A) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} A) (Set.instCompleteBooleanAlgebraSet.{u2} A))))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instCompleteBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))))))) (fun (s : Set.{u2} A) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) => SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_set ProjectiveSpectrum.gc_setâ‚“'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc_set :
    @GaloisConnection (Set A) (Set (ProjectiveSpectrum ð’œ))áµ’áµˆ _ _ (fun s => zeroLocus ð’œ s) fun t =>
      vanishingIdeal t :=
  by
  have ideal_gc : GaloisConnection Ideal.span coe := (Submodule.gi A _).gc
  simpa [zero_locus_span, Function.comp] using GaloisConnection.compose ideal_gc (gc_ideal ð’œ)
#align projective_spectrum.gc_set ProjectiveSpectrum.gc_set

/- warning: projective_spectrum.gc_homogeneous_ideal -> ProjectiveSpectrum.gc_homogeneousIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], GaloisConnection.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.partialOrder.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4)) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.completeBooleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))))))) (fun (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) => ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], GaloisConnection.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4)) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instCompleteBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))))))) (fun (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) => ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_homogeneous_ideal ProjectiveSpectrum.gc_homogeneousIdealâ‚“'. -/
theorem gc_homogeneousIdeal :
    @GaloisConnection (HomogeneousIdeal ð’œ) (Set (ProjectiveSpectrum ð’œ))áµ’áµˆ _ _
      (fun I => zeroLocus ð’œ I) fun t => vanishingIdeal t :=
  fun I t => by
  simpa [show I.to_ideal â‰¤ (vanishing_ideal t).toIdeal â†” I â‰¤ vanishing_ideal t from Iff.rfl] using
    subset_zero_locus_iff_le_vanishing_ideal t I.to_ideal
#align projective_spectrum.gc_homogeneous_ideal ProjectiveSpectrum.gc_homogeneousIdeal

/- warning: projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (s : Set.{u2} A), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)) (HasSubset.Subset.{u2} (Set.{u2} A) (Set.hasSubset.{u2} A) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (s : Set.{u2} A), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)) (HasSubset.Subset.{u2} (Set.{u2} A) (Set.instHasSubsetSet.{u2} A) s (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdealâ‚“'. -/
theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (ProjectiveSpectrum ð’œ)) (s : Set A) :
    t âŠ† zeroLocus ð’œ s â†” s âŠ† vanishingIdeal t :=
  (gc_set _) s t
#align projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal

/- warning: projective_spectrum.subset_vanishing_ideal_zero_locus -> ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A), HasSubset.Subset.{u2} (Set.{u2} A) (Set.hasSubset.{u2} A) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A), HasSubset.Subset.{u2} (Set.{u2} A) (Set.instHasSubsetSet.{u2} A) s (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_vanishing_ideal_zero_locus ProjectiveSpectrum.subset_vanishingIdeal_zeroLocusâ‚“'. -/
theorem subset_vanishingIdeal_zeroLocus (s : Set A) : s âŠ† vanishingIdeal (zeroLocus ð’œ s) :=
  (gc_set _).le_u_l s
#align projective_spectrum.subset_vanishing_ideal_zero_locus ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.ideal_le_vanishing_ideal_zero_locus -> ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocusâ‚“'. -/
theorem ideal_le_vanishingIdeal_zeroLocus (I : Ideal A) :
    I â‰¤ (vanishingIdeal (zeroLocus ð’œ I)).toIdeal :=
  (gc_ideal _).le_u_l I
#align projective_spectrum.ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus -> ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4), LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Preorder.toHasLe.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.partialOrder.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) I (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) I)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4), LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (Preorder.toLE.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) I (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) I)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocusâ‚“'. -/
theorem homogeneousIdeal_le_vanishingIdeal_zeroLocus (I : HomogeneousIdeal ð’œ) :
    I â‰¤ vanishingIdeal (zeroLocus ð’œ I) :=
  (gc_homogeneousIdeal _).le_u_l I
#align projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.subset_zero_locus_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_vanishingIdealâ‚“'. -/
theorem subset_zeroLocus_vanishingIdeal (t : Set (ProjectiveSpectrum ð’œ)) :
    t âŠ† zeroLocus ð’œ (vanishingIdeal t) :=
  (gc_ideal _).l_u_le t
#align projective_spectrum.subset_zero_locus_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal

/- warning: projective_spectrum.zero_locus_anti_mono -> ProjectiveSpectrum.zeroLocus_anti_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {s : Set.{u2} A} {t : Set.{u2} A}, (HasSubset.Subset.{u2} (Set.{u2} A) (Set.hasSubset.{u2} A) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {s : Set.{u2} A} {t : Set.{u2} A}, (HasSubset.Subset.{u2} (Set.{u2} A) (Set.instHasSubsetSet.{u2} A) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono ProjectiveSpectrum.zeroLocus_anti_monoâ‚“'. -/
theorem zeroLocus_anti_mono {s t : Set A} (h : s âŠ† t) : zeroLocus ð’œ t âŠ† zeroLocus ð’œ s :=
  (gc_set _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono ProjectiveSpectrum.zeroLocus_anti_mono

/- warning: projective_spectrum.zero_locus_anti_mono_ideal -> ProjectiveSpectrum.zeroLocus_anti_mono_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {s : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))} {t : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))}, (LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {s : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))} {t : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))}, (LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono_ideal ProjectiveSpectrum.zeroLocus_anti_mono_idealâ‚“'. -/
theorem zeroLocus_anti_mono_ideal {s t : Ideal A} (h : s â‰¤ t) :
    zeroLocus ð’œ (t : Set A) âŠ† zeroLocus ð’œ (s : Set A) :=
  (gc_ideal _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono_ideal ProjectiveSpectrum.zeroLocus_anti_mono_ideal

/- warning: projective_spectrum.zero_locus_anti_mono_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {s : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4} {t : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4}, (LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Preorder.toHasLe.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.partialOrder.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {s : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4} {t : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4}, (LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (Preorder.toLE.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono_homogeneous_ideal ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdealâ‚“'. -/
theorem zeroLocus_anti_mono_homogeneousIdeal {s t : HomogeneousIdeal ð’œ} (h : s â‰¤ t) :
    zeroLocus ð’œ (t : Set A) âŠ† zeroLocus ð’œ (s : Set A) :=
  (gc_homogeneousIdeal _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono_homogeneous_ideal ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal

/- warning: projective_spectrum.vanishing_ideal_anti_mono -> ProjectiveSpectrum.vanishingIdeal_anti_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {s : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)} {t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)}, (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) s t) -> (LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Preorder.toHasLe.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.partialOrder.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ _inst_4))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {s : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)} {t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)}, (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) s t) -> (LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (Preorder.toLE.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_anti_mono ProjectiveSpectrum.vanishingIdeal_anti_monoâ‚“'. -/
theorem vanishingIdeal_anti_mono {s t : Set (ProjectiveSpectrum ð’œ)} (h : s âŠ† t) :
    vanishingIdeal t â‰¤ vanishingIdeal s :=
  (gc_ideal _).monotone_u h
#align projective_spectrum.vanishing_ideal_anti_mono ProjectiveSpectrum.vanishingIdeal_anti_mono

/- warning: projective_spectrum.zero_locus_bot -> ProjectiveSpectrum.zeroLocus_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Bot.bot.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasBot.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Bot.bot.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instBotSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_bot ProjectiveSpectrum.zeroLocus_botâ‚“'. -/
theorem zeroLocus_bot : zeroLocus ð’œ ((âŠ¥ : Ideal A) : Set A) = Set.univ :=
  (gc_ideal ð’œ).l_bot
#align projective_spectrum.zero_locus_bot ProjectiveSpectrum.zeroLocus_bot

/- warning: projective_spectrum.zero_locus_singleton_zero -> ProjectiveSpectrum.zeroLocus_singleton_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (CommMonoidWithZero.toZero.{u2} A (CommSemiring.toCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_zero ProjectiveSpectrum.zeroLocus_singleton_zeroâ‚“'. -/
@[simp]
theorem zeroLocus_singleton_zero : zeroLocus ð’œ ({0} : Set A) = Set.univ :=
  zeroLocus_bot _
#align projective_spectrum.zero_locus_singleton_zero ProjectiveSpectrum.zeroLocus_singleton_zero

/- warning: projective_spectrum.zero_locus_empty -> ProjectiveSpectrum.zeroLocus_empty is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.instEmptyCollectionSet.{u2} A))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_empty ProjectiveSpectrum.zeroLocus_emptyâ‚“'. -/
@[simp]
theorem zeroLocus_empty : zeroLocus ð’œ (âˆ… : Set A) = Set.univ :=
  (gc_set ð’œ).l_bot
#align projective_spectrum.zero_locus_empty ProjectiveSpectrum.zeroLocus_empty

/- warning: projective_spectrum.vanishing_ideal_univ -> ProjectiveSpectrum.vanishingIdeal_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))) (Top.top.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasTop.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))) (Top.top.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instTopHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_univ ProjectiveSpectrum.vanishingIdeal_univâ‚“'. -/
@[simp]
theorem vanishingIdeal_univ : vanishingIdeal (âˆ… : Set (ProjectiveSpectrum ð’œ)) = âŠ¤ := by
  simpa using (gc_ideal _).u_top
#align projective_spectrum.vanishing_ideal_univ ProjectiveSpectrum.vanishingIdeal_univ

/- warning: projective_spectrum.zero_locus_empty_of_one_mem -> ProjectiveSpectrum.zeroLocus_empty_of_one_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {s : Set.{u2} A}, (Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) s) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {s : Set.{u2} A}, (Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) s) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_empty_of_one_mem ProjectiveSpectrum.zeroLocus_empty_of_one_memâ‚“'. -/
theorem zeroLocus_empty_of_one_mem {s : Set A} (h : (1 : A) âˆˆ s) : zeroLocus ð’œ s = âˆ… :=
  Set.eq_empty_iff_forall_not_mem.mpr fun x hx =>
    (inferInstance : x.asHomogeneousIdeal.toIdeal.IsPrime).ne_top <|
      x.asHomogeneousIdeal.toIdeal.eq_top_iff_one.mpr <| hx h
#align projective_spectrum.zero_locus_empty_of_one_mem ProjectiveSpectrum.zeroLocus_empty_of_one_mem

/- warning: projective_spectrum.zero_locus_singleton_one -> ProjectiveSpectrum.zeroLocus_singleton_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_one ProjectiveSpectrum.zeroLocus_singleton_oneâ‚“'. -/
@[simp]
theorem zeroLocus_singleton_one : zeroLocus ð’œ ({1} : Set A) = âˆ… :=
  zeroLocus_empty_of_one_mem ð’œ (Set.mem_singleton (1 : A))
#align projective_spectrum.zero_locus_singleton_one ProjectiveSpectrum.zeroLocus_singleton_one

/- warning: projective_spectrum.zero_locus_univ -> ProjectiveSpectrum.zeroLocus_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.univ.{u2} A)) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.univ.{u2} A)) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_univ ProjectiveSpectrum.zeroLocus_univâ‚“'. -/
@[simp]
theorem zeroLocus_univ : zeroLocus ð’œ (Set.univ : Set A) = âˆ… :=
  zeroLocus_empty_of_one_mem _ (Set.mem_univ 1)
#align projective_spectrum.zero_locus_univ ProjectiveSpectrum.zeroLocus_univ

/- warning: projective_spectrum.zero_locus_sup_ideal -> ProjectiveSpectrum.zeroLocus_sup_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Sup.sup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SemilatticeSup.toHasSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (IdemSemiring.toSemilatticeSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.idemSemiring.{u2, u2} A (CommRing.toCommSemiring.{u2} A _inst_2) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Algebra.id.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Sup.sup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (SemilatticeSup.toSup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_sup_ideal ProjectiveSpectrum.zeroLocus_sup_idealâ‚“'. -/
theorem zeroLocus_sup_ideal (I J : Ideal A) :
    zeroLocus ð’œ ((I âŠ” J : Ideal A) : Set A) = zeroLocus _ I âˆ© zeroLocus _ J :=
  (gc_ideal ð’œ).l_sup
#align projective_spectrum.zero_locus_sup_ideal ProjectiveSpectrum.zeroLocus_sup_ideal

/- warning: projective_spectrum.zero_locus_sup_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (J : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (Sup.sup.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasSup.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (J : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (Sup.sup.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instSupHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_sup_homogeneous_ideal ProjectiveSpectrum.zeroLocus_sup_homogeneousIdealâ‚“'. -/
theorem zeroLocus_sup_homogeneousIdeal (I J : HomogeneousIdeal ð’œ) :
    zeroLocus ð’œ ((I âŠ” J : HomogeneousIdeal ð’œ) : Set A) = zeroLocus _ I âˆ© zeroLocus _ J :=
  (gc_homogeneousIdeal ð’œ).l_sup
#align projective_spectrum.zero_locus_sup_homogeneous_ideal ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_union -> ProjectiveSpectrum.zeroLocus_union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Union.union.{u2} (Set.{u2} A) (Set.hasUnion.{u2} A) s s')) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s'))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Union.union.{u2} (Set.{u2} A) (Set.instUnionSet.{u2} A) s s')) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s'))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_union ProjectiveSpectrum.zeroLocus_unionâ‚“'. -/
theorem zeroLocus_union (s s' : Set A) : zeroLocus ð’œ (s âˆª s') = zeroLocus _ s âˆ© zeroLocus _ s' :=
  (gc_set ð’œ).l_sup
#align projective_spectrum.zero_locus_union ProjectiveSpectrum.zeroLocus_union

/- warning: projective_spectrum.vanishing_ideal_union -> ProjectiveSpectrum.vanishingIdeal_union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (t' : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t t')) (Inf.inf.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasInf.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t'))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (t' : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t t')) (Inf.inf.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instInfHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t'))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_union ProjectiveSpectrum.vanishingIdeal_unionâ‚“'. -/
theorem vanishingIdeal_union (t t' : Set (ProjectiveSpectrum ð’œ)) :
    vanishingIdeal (t âˆª t') = vanishingIdeal t âŠ“ vanishingIdeal t' := by
  ext1 <;> convert(gc_ideal ð’œ).u_inf
#align projective_spectrum.vanishing_ideal_union ProjectiveSpectrum.vanishingIdeal_union

/- warning: projective_spectrum.zero_locus_supr_ideal -> ProjectiveSpectrum.zeroLocus_iSup_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (I : Î³ -> (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (iSup.{u2, u3} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (ConditionallyCompleteLattice.toHasSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) Î³ (fun (i : Î³) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (I i))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (I : Î³ -> (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (iSup.{u2, u3} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (ConditionallyCompleteLattice.toSupSet.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) Î³ (fun (i : Î³) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (I i))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_supr_ideal ProjectiveSpectrum.zeroLocus_iSup_idealâ‚“'. -/
theorem zeroLocus_iSup_ideal {Î³ : Sort _} (I : Î³ â†’ Ideal A) :
    zeroLocus _ ((â¨† i, I i : Ideal A) : Set A) = â‹‚ i, zeroLocus ð’œ (I i) :=
  (gc_ideal ð’œ).l_iSup
#align projective_spectrum.zero_locus_supr_ideal ProjectiveSpectrum.zeroLocus_iSup_ideal

/- warning: projective_spectrum.zero_locus_supr_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (I : Î³ -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (iSup.{u2, u3} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasSup.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4) Î³ (fun (i : Î³) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (I i))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (I : Î³ -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (iSup.{u2, u3} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instSupSetHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4) Î³ (fun (i : Î³) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (I i))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_supr_homogeneous_ideal ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdealâ‚“'. -/
theorem zeroLocus_iSup_homogeneousIdeal {Î³ : Sort _} (I : Î³ â†’ HomogeneousIdeal ð’œ) :
    zeroLocus _ ((â¨† i, I i : HomogeneousIdeal ð’œ) : Set A) = â‹‚ i, zeroLocus ð’œ (I i) :=
  (gc_homogeneousIdeal ð’œ).l_iSup
#align projective_spectrum.zero_locus_supr_homogeneous_ideal ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_Union -> ProjectiveSpectrum.zeroLocus_iUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (s : Î³ -> (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.iUnion.{u2, u3} A Î³ (fun (i : Î³) => s i))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (s i)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (s : Î³ -> (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.iUnion.{u2, u3} A Î³ (fun (i : Î³) => s i))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (s i)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_Union ProjectiveSpectrum.zeroLocus_iUnionâ‚“'. -/
theorem zeroLocus_iUnion {Î³ : Sort _} (s : Î³ â†’ Set A) :
    zeroLocus ð’œ (â‹ƒ i, s i) = â‹‚ i, zeroLocus ð’œ (s i) :=
  (gc_set ð’œ).l_iSup
#align projective_spectrum.zero_locus_Union ProjectiveSpectrum.zeroLocus_iUnion

/- warning: projective_spectrum.zero_locus_bUnion -> ProjectiveSpectrum.zeroLocus_bUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.iUnion.{u2, succ u2} A (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iUnion.{u2, 0} A (Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) => s')))) (Set.iInter.{u2, succ u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iInter.{u2, 0} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s')))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.iUnion.{u2, succ u2} A (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iUnion.{u2, 0} A (Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) => s')))) (Set.iInter.{u2, succ u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iInter.{u2, 0} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s')))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_bUnion ProjectiveSpectrum.zeroLocus_bUnionâ‚“'. -/
theorem zeroLocus_bUnion (s : Set (Set A)) :
    zeroLocus ð’œ (â‹ƒ s' âˆˆ s, s' : Set A) = â‹‚ s' âˆˆ s, zeroLocus ð’œ s' := by simp only [zero_locus_Union]
#align projective_spectrum.zero_locus_bUnion ProjectiveSpectrum.zeroLocus_bUnion

/- warning: projective_spectrum.vanishing_ideal_Union -> ProjectiveSpectrum.vanishingIdeal_iUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (t : Î³ -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.iUnion.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => t i))) (iInf.{u2, u3} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasInf.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (t i)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {Î³ : Sort.{u3}} (t : Î³ -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Set.iUnion.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Î³ (fun (i : Î³) => t i))) (iInf.{u2, u3} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instInfSetHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4) Î³ (fun (i : Î³) => ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (t i)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_Union ProjectiveSpectrum.vanishingIdeal_iUnionâ‚“'. -/
theorem vanishingIdeal_iUnion {Î³ : Sort _} (t : Î³ â†’ Set (ProjectiveSpectrum ð’œ)) :
    vanishingIdeal (â‹ƒ i, t i) = â¨… i, vanishingIdeal (t i) :=
  HomogeneousIdeal.toIdeal_injective <| by
    convert(gc_ideal ð’œ).u_iInf <;> exact HomogeneousIdeal.toIdeal_iInf _
#align projective_spectrum.vanishing_ideal_Union ProjectiveSpectrum.vanishingIdeal_iUnion

/- warning: projective_spectrum.zero_locus_inf -> ProjectiveSpectrum.zeroLocus_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Inf.inf.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasInf.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Inf.inf.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instInfSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_inf ProjectiveSpectrum.zeroLocus_infâ‚“'. -/
theorem zeroLocus_inf (I J : Ideal A) :
    zeroLocus ð’œ ((I âŠ“ J : Ideal A) : Set A) = zeroLocus ð’œ I âˆª zeroLocus ð’œ J :=
  Set.ext fun x => x.IsPrime.inf_le
#align projective_spectrum.zero_locus_inf ProjectiveSpectrum.zeroLocus_inf

/- warning: projective_spectrum.union_zero_locus -> ProjectiveSpectrum.union_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s')) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Inf.inf.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasInf.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s'))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s')) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Inf.inf.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instInfSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s'))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.union_zero_locus ProjectiveSpectrum.union_zeroLocusâ‚“'. -/
theorem union_zeroLocus (s s' : Set A) :
    zeroLocus ð’œ s âˆª zeroLocus ð’œ s' = zeroLocus ð’œ (Ideal.span s âŠ“ Ideal.span s' : Ideal A) :=
  by
  rw [zero_locus_inf]
  simp
#align projective_spectrum.union_zero_locus ProjectiveSpectrum.union_zeroLocus

/- warning: projective_spectrum.zero_locus_mul_ideal -> ProjectiveSpectrum.zeroLocus_mul_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (instHMul.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.hasMul.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (instHMul.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.instMulIdealToSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_mul_ideal ProjectiveSpectrum.zeroLocus_mul_idealâ‚“'. -/
theorem zeroLocus_mul_ideal (I J : Ideal A) :
    zeroLocus ð’œ ((I * J : Ideal A) : Set A) = zeroLocus ð’œ I âˆª zeroLocus ð’œ J :=
  Set.ext fun x => x.IsPrime.mul_le
#align projective_spectrum.zero_locus_mul_ideal ProjectiveSpectrum.zeroLocus_mul_ideal

/- warning: projective_spectrum.zero_locus_mul_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (J : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (HMul.hMul.{u2, u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (instHMul.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasMul.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (CommRing.toCommSemiring.{u2} A _inst_2) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4)) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (I : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (J : HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HMul.hMul.{u2, u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (instHMul.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (instMulHomogeneousIdealToSemiring.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommRing.toCommSemiring.{u2} A _inst_2) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4)) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_mul_homogeneous_ideal ProjectiveSpectrum.zeroLocus_mul_homogeneousIdealâ‚“'. -/
theorem zeroLocus_mul_homogeneousIdeal (I J : HomogeneousIdeal ð’œ) :
    zeroLocus ð’œ ((I * J : HomogeneousIdeal ð’œ) : Set A) = zeroLocus ð’œ I âˆª zeroLocus ð’œ J :=
  Set.ext fun x => x.IsPrime.mul_le
#align projective_spectrum.zero_locus_mul_homogeneous_ideal ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_singleton_mul -> ProjectiveSpectrum.zeroLocus_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) f)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) g)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) f)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) g)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_mul ProjectiveSpectrum.zeroLocus_singleton_mulâ‚“'. -/
theorem zeroLocus_singleton_mul (f g : A) :
    zeroLocus ð’œ ({f * g} : Set A) = zeroLocus ð’œ {f} âˆª zeroLocus ð’œ {g} :=
  Set.ext fun x => by simpa using x.is_prime.mul_mem_iff_mem_or_mem
#align projective_spectrum.zero_locus_singleton_mul ProjectiveSpectrum.zeroLocus_singleton_mul

/- warning: projective_spectrum.zero_locus_singleton_pow -> ProjectiveSpectrum.zeroLocus_singleton_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f n))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) f)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) f n))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) f)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_pow ProjectiveSpectrum.zeroLocus_singleton_powâ‚“'. -/
@[simp]
theorem zeroLocus_singleton_pow (f : A) (n : â„•) (hn : 0 < n) :
    zeroLocus ð’œ ({f ^ n} : Set A) = zeroLocus ð’œ {f} :=
  Set.ext fun x => by simpa using x.is_prime.pow_mem_iff_mem n hn
#align projective_spectrum.zero_locus_singleton_pow ProjectiveSpectrum.zeroLocus_singleton_pow

/- warning: projective_spectrum.sup_vanishing_ideal_le -> ProjectiveSpectrum.sup_vanishingIdeal_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (t' : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Preorder.toHasLe.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.partialOrder.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ _inst_4))) (Sup.sup.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasSup.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t')) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t t'))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (t' : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (Preorder.toLE.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) (Sup.sup.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instSupHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t')) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) t t'))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.sup_vanishing_ideal_le ProjectiveSpectrum.sup_vanishingIdeal_leâ‚“'. -/
theorem sup_vanishingIdeal_le (t t' : Set (ProjectiveSpectrum ð’œ)) :
    vanishingIdeal t âŠ” vanishingIdeal t' â‰¤ vanishingIdeal (t âˆ© t') :=
  by
  intro r
  rw [â† HomogeneousIdeal.mem_iff, HomogeneousIdeal.toIdeal_sup, mem_vanishing_ideal,
    Submodule.mem_sup]
  rintro âŸ¨f, hf, g, hg, rflâŸ© x âŸ¨hxt, hxt'âŸ©
  erw [mem_vanishing_ideal] at hf hg
  apply Submodule.add_mem <;> solve_by_elim
#align projective_spectrum.sup_vanishing_ideal_le ProjectiveSpectrum.sup_vanishingIdeal_le

/- warning: projective_spectrum.mem_compl_zero_locus_iff_not_mem -> ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {f : A} {I : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4}, Iff (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) I (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.booleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) f)))) (Not (Membership.Mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (SetLike.hasMem.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 I)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] {f : A} {I : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4}, Iff (Membership.mem.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instMembershipSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) I (HasCompl.compl.{u1} (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instBooleanAlgebraSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (ProjectiveSpectrum.zeroLocus.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u1, u1} A (Set.{u1} A) (Set.instSingletonSet.{u1} A) f)))) (Not (Membership.mem.{u1, u1} A (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (SetLike.instMembership.{u1, u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 I)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_compl_zero_locus_iff_not_mem ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_memâ‚“'. -/
theorem mem_compl_zeroLocus_iff_not_mem {f : A} {I : ProjectiveSpectrum ð’œ} :
    I âˆˆ (zeroLocus ð’œ {f} : Set (ProjectiveSpectrum ð’œ))á¶œ â†” f âˆ‰ I.asHomogeneousIdeal := by
  rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl
#align projective_spectrum.mem_compl_zero_locus_iff_not_mem ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem

/- warning: projective_spectrum.zariski_topology -> ProjectiveSpectrum.zariskiTopology is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], TopologicalSpace.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], TopologicalSpace.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zariski_topology ProjectiveSpectrum.zariskiTopologyâ‚“'. -/
/-- The Zariski topology on the prime spectrum of a commutative ring is defined via the closed sets
of the topology: they are exactly those sets that are the zero locus of a subset of the ring. -/
instance zariskiTopology : TopologicalSpace (ProjectiveSpectrum ð’œ) :=
  TopologicalSpace.ofClosed (Set.range (ProjectiveSpectrum.zeroLocus ð’œ)) âŸ¨Set.univ, by simpâŸ©
    (by
      intro Zs h
      rw [Set.sInter_eq_iInter]
      let f : Zs â†’ Set _ := fun i => Classical.choose (h i.2)
      have hf : âˆ€ i : Zs, â†‘i = zero_locus ð’œ (f i) := fun i => (Classical.choose_spec (h i.2)).symm
      simp only [hf]
      exact âŸ¨_, zero_locus_Union ð’œ _âŸ©)
    (by
      rintro _ âŸ¨s, rflâŸ© _ âŸ¨t, rflâŸ©
      exact âŸ¨_, (union_zero_locus ð’œ s t).symmâŸ©)
#align projective_spectrum.zariski_topology ProjectiveSpectrum.zariskiTopology

/- warning: projective_spectrum.Top -> ProjectiveSpectrum.top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], TopCat.{u2}
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], TopCat.{u2}
Case conversion may be inaccurate. Consider using '#align projective_spectrum.Top ProjectiveSpectrum.topâ‚“'. -/
/-- The underlying topology of `Proj` is the projective spectrum of graded ring `A`. -/
def top : TopCat :=
  TopCat.of (ProjectiveSpectrum ð’œ)
#align projective_spectrum.Top ProjectiveSpectrum.top

/- warning: projective_spectrum.is_open_iff -> ProjectiveSpectrum.isOpen_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (U : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Iff (IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) U) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.booleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) U) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (U : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Iff (IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) U) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) U) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_open_iff ProjectiveSpectrum.isOpen_iffâ‚“'. -/
theorem isOpen_iff (U : Set (ProjectiveSpectrum ð’œ)) : IsOpen U â†” âˆƒ s, Uá¶œ = zeroLocus ð’œ s := by
  simp only [@eq_comm _ (Uá¶œ)] <;> rfl
#align projective_spectrum.is_open_iff ProjectiveSpectrum.isOpen_iff

/- warning: projective_spectrum.is_closed_iff_zero_locus -> ProjectiveSpectrum.isClosed_iff_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (Z : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Iff (IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Z) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) Z (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (Z : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Iff (IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) Z) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) Z (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_closed_iff_zero_locus ProjectiveSpectrum.isClosed_iff_zeroLocusâ‚“'. -/
theorem isClosed_iff_zeroLocus (Z : Set (ProjectiveSpectrum ð’œ)) :
    IsClosed Z â†” âˆƒ s, Z = zeroLocus ð’œ s := by rw [â† isOpen_compl_iff, is_open_iff, compl_compl]
#align projective_spectrum.is_closed_iff_zero_locus ProjectiveSpectrum.isClosed_iff_zeroLocus

/- warning: projective_spectrum.is_closed_zero_locus -> ProjectiveSpectrum.isClosed_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A), IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (s : Set.{u2} A), IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 s)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_closed_zero_locus ProjectiveSpectrum.isClosed_zeroLocusâ‚“'. -/
theorem isClosed_zeroLocus (s : Set A) : IsClosed (zeroLocus ð’œ s) :=
  by
  rw [is_closed_iff_zero_locus]
  exact âŸ¨s, rflâŸ©
#align projective_spectrum.is_closed_zero_locus ProjectiveSpectrum.isClosed_zeroLocus

/- warning: projective_spectrum.zero_locus_vanishing_ideal_eq_closure -> ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (CoeTCâ‚“.coe.{succ u2, succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)))) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t))) (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) t)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (SetLike.coe.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t))) (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) t)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_vanishing_ideal_eq_closure ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closureâ‚“'. -/
theorem zeroLocus_vanishingIdeal_eq_closure (t : Set (ProjectiveSpectrum ð’œ)) :
    zeroLocus ð’œ (vanishingIdeal t : Set A) = closure t :=
  by
  apply Set.Subset.antisymm
  Â· rintro x hx t' âŸ¨ht', htâŸ©
    obtain âŸ¨fs, rflâŸ© : âˆƒ s, t' = zero_locus ð’œ s := by rwa [is_closed_iff_zero_locus] at ht'
    rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht
    exact Set.Subset.trans ht hx
  Â· rw [(is_closed_zero_locus _ _).closure_subset_iff]
    exact subset_zero_locus_vanishing_ideal ð’œ t
#align projective_spectrum.zero_locus_vanishing_ideal_eq_closure ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure

/- warning: projective_spectrum.vanishing_ideal_closure -> ProjectiveSpectrum.vanishingIdeal_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) t)) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) t)) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 t)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_closure ProjectiveSpectrum.vanishingIdeal_closureâ‚“'. -/
theorem vanishingIdeal_closure (t : Set (ProjectiveSpectrum ð’œ)) :
    vanishingIdeal (closure t) = vanishingIdeal t :=
  by
  have := (gc_ideal ð’œ).u_l_u_eq_u t
  dsimp only at this
  ext1
  erw [zero_locus_vanishing_ideal_eq_closure ð’œ t] at this
  exact this
#align projective_spectrum.vanishing_ideal_closure ProjectiveSpectrum.vanishingIdeal_closure

section BasicOpen

/- warning: projective_spectrum.basic_open -> ProjectiveSpectrum.basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], A -> (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], A -> (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open ProjectiveSpectrum.basicOpenâ‚“'. -/
/-- `basic_open r` is the open subset containing all prime ideals not containing `r`. -/
def basicOpen (r : A) : TopologicalSpace.Opens (ProjectiveSpectrum ð’œ)
    where
  carrier := { x | r âˆ‰ x.asHomogeneousIdeal }
  is_open' := âŸ¨{r}, Set.ext fun x => Set.singleton_subset_iff.trans <| Classical.not_not.symmâŸ©
#align projective_spectrum.basic_open ProjectiveSpectrum.basicOpen

/- warning: projective_spectrum.mem_basic_open -> ProjectiveSpectrum.mem_basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.hasMem.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f)) (Not (Membership.Mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (SetLike.hasMem.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] (f : A) (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (Membership.mem.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.instMembership.{u1, u1} (TopologicalSpace.Opens.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x (ProjectiveSpectrum.basicOpen.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f)) (Not (Membership.mem.{u1, u1} A (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (SetLike.instMembership.{u1, u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_basic_open ProjectiveSpectrum.mem_basicOpenâ‚“'. -/
@[simp]
theorem mem_basicOpen (f : A) (x : ProjectiveSpectrum ð’œ) :
    x âˆˆ basicOpen ð’œ f â†” f âˆ‰ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_basic_open ProjectiveSpectrum.mem_basicOpen

/- warning: projective_spectrum.mem_coe_basic_open -> ProjectiveSpectrum.mem_coe_basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CoeTCâ‚“.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f))) (Not (Membership.Mem.{u2, u2} A (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (SetLike.hasMem.{u2, u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) A (HomogeneousIdeal.setLike.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] (f : A) (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (Membership.mem.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instMembershipSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x (SetLike.coe.{u1, u1} (TopologicalSpace.Opens.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f))) (Not (Membership.mem.{u1, u1} A (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (SetLike.instMembership.{u1, u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) A (HomogeneousIdeal.setLike.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)) f (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_coe_basic_open ProjectiveSpectrum.mem_coe_basicOpenâ‚“'. -/
theorem mem_coe_basicOpen (f : A) (x : ProjectiveSpectrum ð’œ) :
    x âˆˆ (â†‘(basicOpen ð’œ f) : Set (ProjectiveSpectrum ð’œ)) â†” f âˆ‰ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_coe_basic_open ProjectiveSpectrum.mem_coe_basicOpen

/- warning: projective_spectrum.is_open_basic_open -> ProjectiveSpectrum.isOpen_basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] {a : A}, IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CoeTCâ‚“.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 a))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] {a : A}, IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 a))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_open_basic_open ProjectiveSpectrum.isOpen_basicOpenâ‚“'. -/
theorem isOpen_basicOpen {a : A} : IsOpen (basicOpen ð’œ a : Set (ProjectiveSpectrum ð’œ)) :=
  (basicOpen ð’œ a).IsOpen
#align projective_spectrum.is_open_basic_open ProjectiveSpectrum.isOpen_basicOpen

/- warning: projective_spectrum.basic_open_eq_zero_locus_compl -> ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (r : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CoeTCâ‚“.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 r)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.booleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) r)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (r : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 r)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) r)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_eq_zero_locus_compl ProjectiveSpectrum.basicOpen_eq_zeroLocus_complâ‚“'. -/
@[simp]
theorem basicOpen_eq_zeroLocus_compl (r : A) :
    (basicOpen ð’œ r : Set (ProjectiveSpectrum ð’œ)) = zeroLocus ð’œ {r}á¶œ :=
  Set.ext fun x => by simpa only [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff]
#align projective_spectrum.basic_open_eq_zero_locus_compl ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl

/- warning: projective_spectrum.basic_open_one -> ProjectiveSpectrum.basicOpen_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2))))))))) (Top.top.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toHasTop.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) (Top.top.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toTop.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_one ProjectiveSpectrum.basicOpen_oneâ‚“'. -/
@[simp]
theorem basicOpen_one : basicOpen ð’œ (1 : A) = âŠ¤ :=
  TopologicalSpace.Opens.ext <| by simp
#align projective_spectrum.basic_open_one ProjectiveSpectrum.basicOpen_one

/- warning: projective_spectrum.basic_open_zero -> ProjectiveSpectrum.basicOpen_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) (Bot.bot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toHasBot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (CommMonoidWithZero.toZero.{u2} A (CommSemiring.toCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) (Bot.bot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toBot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_zero ProjectiveSpectrum.basicOpen_zeroâ‚“'. -/
@[simp]
theorem basicOpen_zero : basicOpen ð’œ (0 : A) = âŠ¥ :=
  TopologicalSpace.Opens.ext <| by simp
#align projective_spectrum.basic_open_zero ProjectiveSpectrum.basicOpen_zero

/- warning: projective_spectrum.basic_open_mul -> ProjectiveSpectrum.basicOpen_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (Inf.inf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SemilatticeInf.toHasInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Lattice.toSemilatticeInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 g))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (Inf.inf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Lattice.toInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 g))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul ProjectiveSpectrum.basicOpen_mulâ‚“'. -/
theorem basicOpen_mul (f g : A) : basicOpen ð’œ (f * g) = basicOpen ð’œ f âŠ“ basicOpen ð’œ g :=
  TopologicalSpace.Opens.ext <| by simp [zero_locus_singleton_mul]
#align projective_spectrum.basic_open_mul ProjectiveSpectrum.basicOpen_mul

/- warning: projective_spectrum.basic_open_mul_le_left -> ProjectiveSpectrum.basicOpen_mul_le_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Preorder.toHasLe.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.partialOrder.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Preorder.toLE.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul_le_left ProjectiveSpectrum.basicOpen_mul_le_leftâ‚“'. -/
theorem basicOpen_mul_le_left (f g : A) : basicOpen ð’œ (f * g) â‰¤ basicOpen ð’œ f :=
  by
  rw [basic_open_mul ð’œ f g]
  exact inf_le_left
#align projective_spectrum.basic_open_mul_le_left ProjectiveSpectrum.basicOpen_mul_le_left

/- warning: projective_spectrum.basic_open_mul_le_right -> ProjectiveSpectrum.basicOpen_mul_le_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Preorder.toHasLe.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.partialOrder.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 g)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Preorder.toLE.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 g)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul_le_right ProjectiveSpectrum.basicOpen_mul_le_rightâ‚“'. -/
theorem basicOpen_mul_le_right (f g : A) : basicOpen ð’œ (f * g) â‰¤ basicOpen ð’œ g :=
  by
  rw [basic_open_mul ð’œ f g]
  exact inf_le_right
#align projective_spectrum.basic_open_mul_le_right ProjectiveSpectrum.basicOpen_mul_le_right

/- warning: projective_spectrum.basic_open_pow -> ProjectiveSpectrum.basicOpen_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f n)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (f : A) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) f n)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_pow ProjectiveSpectrum.basicOpen_powâ‚“'. -/
@[simp]
theorem basicOpen_pow (f : A) (n : â„•) (hn : 0 < n) : basicOpen ð’œ (f ^ n) = basicOpen ð’œ f :=
  TopologicalSpace.Opens.ext <| by simpa using zero_locus_singleton_pow ð’œ f n hn
#align projective_spectrum.basic_open_pow ProjectiveSpectrum.basicOpen_pow

/- warning: projective_spectrum.basic_open_eq_union_of_projection -> ProjectiveSpectrum.basicOpen_eq_union_of_projection is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (f : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f) (iSup.{u2, 1} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ConditionallyCompleteLattice.toHasSup.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))) Nat (fun (i : Nat) => ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) => A -> A) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R A A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (GradedAlgebra.proj.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ _inst_4 i) f)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ] (f : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 f) (iSup.{u2, 1} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ConditionallyCompleteLattice.toSupSet.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)))) Nat (fun (i : Nat) => ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : A) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R A A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (GradedAlgebra.proj.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ _inst_4 i) f)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_eq_union_of_projection ProjectiveSpectrum.basicOpen_eq_union_of_projectionâ‚“'. -/
theorem basicOpen_eq_union_of_projection (f : A) :
    basicOpen ð’œ f = â¨† i : â„•, basicOpen ð’œ (GradedAlgebra.proj ð’œ i f) :=
  TopologicalSpace.Opens.ext <|
    Set.ext fun z => by
      erw [mem_coe_basic_open, TopologicalSpace.Opens.mem_sSup]
      constructor <;> intro hz
      Â· rcases show âˆƒ i, GradedAlgebra.proj ð’œ i f âˆ‰ z.as_homogeneous_ideal
            by
            contrapose! hz with H
            classical
              rw [â† DirectSum.sum_support_decompose ð’œ f]
              apply Ideal.sum_mem _ fun i hi => H i with
          âŸ¨i, hiâŸ©
        exact âŸ¨basic_open ð’œ (GradedAlgebra.proj ð’œ i f), âŸ¨i, rflâŸ©, by rwa [mem_basic_open]âŸ©
      Â· obtain âŸ¨_, âŸ¨i, rflâŸ©, hzâŸ© := hz
        exact fun rid => hz (z.1.2 i rid)
#align projective_spectrum.basic_open_eq_union_of_projection ProjectiveSpectrum.basicOpen_eq_union_of_projection

/- warning: projective_spectrum.is_topological_basis_basic_opens -> ProjectiveSpectrum.isTopologicalBasis_basic_opens is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ], TopologicalSpace.IsTopologicalBasis.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.range.{u2, succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) A (fun (r : A) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (CoeTCâ‚“.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 r)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 ð’œ], TopologicalSpace.IsTopologicalBasis.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.range.{u2, succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) A (fun (r : A) => SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 r)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_topological_basis_basic_opens ProjectiveSpectrum.isTopologicalBasis_basic_opensâ‚“'. -/
theorem isTopologicalBasis_basic_opens :
    TopologicalSpace.IsTopologicalBasis
      (Set.range fun r : A => (basicOpen ð’œ r : Set (ProjectiveSpectrum ð’œ))) :=
  by
  apply TopologicalSpace.isTopologicalBasis_of_open_of_nhds
  Â· rintro _ âŸ¨r, rflâŸ©
    exact is_open_basic_open ð’œ
  Â· rintro p U hp âŸ¨s, hsâŸ©
    rw [â† compl_compl U, Set.mem_compl_iff, â† hs, mem_zero_locus, Set.not_subset] at hp
    obtain âŸ¨f, hfs, hfpâŸ© := hp
    refine' âŸ¨basic_open ð’œ f, âŸ¨f, rflâŸ©, hfp, _âŸ©
    rw [â† Set.compl_subset_compl, â† hs, basic_open_eq_zero_locus_compl, compl_compl]
    exact zero_locus_anti_mono ð’œ (set.singleton_subset_iff.mpr hfs)
#align projective_spectrum.is_topological_basis_basic_opens ProjectiveSpectrum.isTopologicalBasis_basic_opens

end BasicOpen

section Order

/-!
## The specialization order

We endow `projective_spectrum ð’œ` with a partial order,
where `x â‰¤ y` if and only if `y âˆˆ closure {x}`.
-/


instance : PartialOrder (ProjectiveSpectrum ð’œ) :=
  PartialOrder.lift asHomogeneousIdeal fun âŸ¨_, _, _âŸ© âŸ¨_, _, _âŸ© => mk.inj_eq.mpr

/- warning: projective_spectrum.as_ideal_le_as_ideal -> ProjectiveSpectrum.as_ideal_le_as_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (y : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (LE.le.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (Preorder.toHasLe.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (HomogeneousIdeal.partialOrder.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 y)) (LE.le.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Preorder.toHasLe.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (PartialOrder.toPreorder.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.partialOrder.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x y)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (y : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (LE.le.{u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (Preorder.toLE.{u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ _inst_4))) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 y)) (LE.le.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Preorder.toLE.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (PartialOrder.toPreorder.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.instPartialOrderProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x y)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.as_ideal_le_as_ideal ProjectiveSpectrum.as_ideal_le_as_idealâ‚“'. -/
@[simp]
theorem as_ideal_le_as_ideal (x y : ProjectiveSpectrum ð’œ) :
    x.asHomogeneousIdeal â‰¤ y.asHomogeneousIdeal â†” x â‰¤ y :=
  Iff.rfl
#align projective_spectrum.as_ideal_le_as_ideal ProjectiveSpectrum.as_ideal_le_as_ideal

/- warning: projective_spectrum.as_ideal_lt_as_ideal -> ProjectiveSpectrum.as_ideal_lt_as_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (y : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (LT.lt.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (Preorder.toHasLt.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (PartialOrder.toPreorder.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) _inst_4) (HomogeneousIdeal.partialOrder.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (AddCommMonoid.toAddMonoid.{0} Nat (OrderedAddCommMonoid.toAddCommMonoid.{0} Nat (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{0} Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) ð’œ _inst_4))) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 y)) (LT.lt.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Preorder.toHasLt.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (PartialOrder.toPreorder.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.partialOrder.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x y)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (y : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (LT.lt.{u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (Preorder.toLT.{u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (PartialOrder.toPreorder.{u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instPartialOrderHomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) ð’œ _inst_4))) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 x) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4 y)) (LT.lt.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Preorder.toLT.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (PartialOrder.toPreorder.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.instPartialOrderProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x y)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.as_ideal_lt_as_ideal ProjectiveSpectrum.as_ideal_lt_as_idealâ‚“'. -/
@[simp]
theorem as_ideal_lt_as_ideal (x y : ProjectiveSpectrum ð’œ) :
    x.asHomogeneousIdeal < y.asHomogeneousIdeal â†” x < y :=
  Iff.rfl
#align projective_spectrum.as_ideal_lt_as_ideal ProjectiveSpectrum.as_ideal_lt_as_ideal

/- warning: projective_spectrum.le_iff_mem_closure -> ProjectiveSpectrum.le_iff_mem_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (ð’œ : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (y : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (LE.le.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Preorder.toHasLe.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (PartialOrder.toPreorder.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.partialOrder.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x y) (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) y (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Singleton.singleton.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.hasSingleton.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (ð’œ : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 ð’œ] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (y : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4), Iff (LE.le.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Preorder.toLE.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (PartialOrder.toPreorder.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.instPartialOrderProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4))) x y) (Membership.mem.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instMembershipSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) y (closure.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Singleton.singleton.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) (Set.instSingletonSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 ð’œ _inst_4)) x)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.le_iff_mem_closure ProjectiveSpectrum.le_iff_mem_closureâ‚“'. -/
theorem le_iff_mem_closure (x y : ProjectiveSpectrum ð’œ) :
    x â‰¤ y â†” y âˆˆ closure ({x} : Set (ProjectiveSpectrum ð’œ)) :=
  by
  rw [â† as_ideal_le_as_ideal, â† zero_locus_vanishing_ideal_eq_closure, mem_zero_locus,
    vanishing_ideal_singleton]
  simp only [coe_subset_coe, Subtype.coe_le_coe, coe_coe]
#align projective_spectrum.le_iff_mem_closure ProjectiveSpectrum.le_iff_mem_closure

end Order

end ProjectiveSpectrum

