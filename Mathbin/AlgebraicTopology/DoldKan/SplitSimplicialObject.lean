/-
Copyright (c) 2022 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou

! This file was ported from Lean 3 source module algebraic_topology.dold_kan.split_simplicial_object
! leanprover-community/mathlib commit 31019c2504b17f85af7e0577585fad996935a317
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.AlgebraicTopology.SplitSimplicialObject
import Mathbin.AlgebraicTopology.DoldKan.Degeneracies
import Mathbin.AlgebraicTopology.DoldKan.FunctorN

/-!

# Split simplicial objects in preadditive categories

In this file we define a functor `nondeg_complex : simplicial_object.split C â¥¤ chain_complex C â„•`
when `C` is a preadditive category with finite coproducts, and get an isomorphism
`to_karoubi_nondeg_complex_iso_Nâ‚ : nondeg_complex â‹™ to_karoubi _ â‰… forget C â‹™ dold_kan.Nâ‚`.
-/


noncomputable section

open
  CategoryTheory CategoryTheory.Limits CategoryTheory.Category CategoryTheory.Preadditive CategoryTheory.Idempotents Opposite AlgebraicTopology AlgebraicTopology.DoldKan

open BigOperators Simplicial DoldKan

namespace SimplicialObject

namespace Splitting

variable {C : Type _} [Category C] [HasFiniteCoproducts C] {X : SimplicialObject C}
  (s : Splitting X)

/- warning: simplicial_object.splitting.Ï€_summand -> SimplicialObject.Splitting.Ï€Summand is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Ï€_summand SimplicialObject.Splitting.Ï€Summandâ‚“'. -/
/-- The projection on a summand of the coproduct decomposition given
by a splitting of a simplicial object. -/
def Ï€Summand [HasZeroMorphisms C] {Î” : SimplexCategoryáµ’áµ–} (A : IndexSet Î”) :
    X.obj Î” âŸ¶ s.n A.1.unop.len :=
  by
  refine' (s.iso Î”).inv â‰« sigma.desc fun B => _
  by_cases B = A
  Â·
    exact
      eq_to_hom
        (by
          subst h
          rfl)
  Â· exact 0
#align simplicial_object.splitting.Ï€_summand SimplicialObject.Splitting.Ï€Summand

/- warning: simplicial_object.splitting.Î¹_Ï€_summand_eq_id -> SimplicialObject.Splitting.Î¹_Ï€Summand_eq_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s _inst_3 Î” A)) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s _inst_3 Î” A)) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_Ï€_summand_eq_id SimplicialObject.Splitting.Î¹_Ï€Summand_eq_idâ‚“'. -/
@[simp, reassoc.1]
theorem Î¹_Ï€Summand_eq_id [HasZeroMorphisms C] {Î” : SimplexCategoryáµ’áµ–} (A : IndexSet Î”) :
    s.Î¹Summand A â‰« s.Ï€Summand A = ðŸ™ _ :=
  by
  dsimp [Î¹_summand, Ï€_summand]
  simp only [summand, assoc, is_iso.hom_inv_id_assoc]
  erw [colimit.Î¹_desc, cofan.mk_Î¹_app]
  dsimp
  simp only [eq_self_iff_true, if_true]
#align simplicial_object.splitting.Î¹_Ï€_summand_eq_id SimplicialObject.Splitting.Î¹_Ï€Summand_eq_id

/- warning: simplicial_object.splitting.Î¹_Ï€_summand_eq_zero -> SimplicialObject.Splitting.Î¹_Ï€Summand_eq_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”) (B : SimplicialObject.Splitting.IndexSet Î”), (Ne.{1} (SimplicialObject.Splitting.IndexSet Î”) B A) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B)))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s _inst_3 Î” B)) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 _inst_3 (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B)))))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”) (B : SimplicialObject.Splitting.IndexSet Î”), (Ne.{1} (SimplicialObject.Splitting.IndexSet Î”) B A) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B)))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s _inst_3 Î” B)) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))) 0 (Zero.toOfNat0.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u2, u1} C _inst_1 _inst_3 (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) B))))))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_Ï€_summand_eq_zero SimplicialObject.Splitting.Î¹_Ï€Summand_eq_zeroâ‚“'. -/
@[simp, reassoc.1]
theorem Î¹_Ï€Summand_eq_zero [HasZeroMorphisms C] {Î” : SimplexCategoryáµ’áµ–} (A B : IndexSet Î”)
    (h : B â‰  A) : s.Î¹Summand A â‰« s.Ï€Summand B = 0 :=
  by
  dsimp [Î¹_summand, Ï€_summand]
  simp only [summand, assoc, is_iso.hom_inv_id_assoc]
  erw [colimit.Î¹_desc, cofan.mk_Î¹_app]
  apply dif_neg
  exact h.symm
#align simplicial_object.splitting.Î¹_Ï€_summand_eq_zero SimplicialObject.Splitting.Î¹_Ï€Summand_eq_zero

variable [Preadditive C]

/- warning: simplicial_object.splitting.decomposition_id -> SimplicialObject.Splitting.decomposition_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”)) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”)) (Finset.sum.{u2, 0} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”)) (SimplicialObject.Splitting.IndexSet Î”) (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_3 (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”))) (Finset.univ.{0} (SimplicialObject.Splitting.IndexSet Î”) (SimplicialObject.Splitting.IndexSet.fintype Î”)) (fun (A : SimplicialObject.Splitting.IndexSet Î”) => CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Î” A) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A)))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”)) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”)) (Finset.sum.{u2, 0} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”)) (SimplicialObject.Splitting.IndexSet Î”) (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_3 (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”))) (Finset.univ.{0} (SimplicialObject.Splitting.IndexSet Î”) (SimplicialObject.Splitting.IndexSet.instFintypeIndexSet Î”)) (fun (A : SimplicialObject.Splitting.IndexSet Î”) => CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Î” A) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A)))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.decomposition_id SimplicialObject.Splitting.decomposition_idâ‚“'. -/
theorem decomposition_id (Î” : SimplexCategoryáµ’áµ–) :
    ðŸ™ (X.obj Î”) = âˆ‘ A : IndexSet Î”, s.Ï€Summand A â‰« s.Î¹Summand A :=
  by
  apply s.hom_ext'
  intro A
  rw [comp_id, comp_sum, Finset.sum_eq_single A, Î¹_Ï€_summand_eq_id_assoc]
  Â· intro B hâ‚ hâ‚‚
    rw [s.Î¹_Ï€_summand_eq_zero_assoc _ _ hâ‚‚, zero_comp]
  Â· simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]
#align simplicial_object.splitting.decomposition_id SimplicialObject.Splitting.decomposition_id

/- warning: simplicial_object.splitting.Ïƒ_comp_Ï€_summand_id_eq_zero -> SimplicialObject.Splitting.Ïƒ_comp_Ï€Summand_id_eq_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {n : Nat} (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))))) (CategoryTheory.SimplicialObject.Ïƒ.{u2, u1} C _inst_1 X n i) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)))))))))) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)))))))))) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)))))))))) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)))))))))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {n : Nat} (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) (CategoryTheory.SimplicialObject.Ïƒ.{u2, u1} C _inst_1 X n i) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) 0 (Zero.toOfNat0.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Ïƒ_comp_Ï€_summand_id_eq_zero SimplicialObject.Splitting.Ïƒ_comp_Ï€Summand_id_eq_zeroâ‚“'. -/
@[simp, reassoc.1]
theorem Ïƒ_comp_Ï€Summand_id_eq_zero {n : â„•} (i : Fin (n + 1)) :
    X.Ïƒ i â‰« s.Ï€Summand (IndexSet.id (op [n + 1])) = 0 :=
  by
  apply s.hom_ext'
  intro A
  dsimp only [simplicial_object.Ïƒ]
  rw [comp_zero, s.Î¹_summand_epi_naturality_assoc A (SimplexCategory.Ïƒ i).op, Î¹_Ï€_summand_eq_zero]
  symm
  change Â¬(A.epi_comp (SimplexCategory.Ïƒ i).op).EqId
  rw [index_set.eq_id_iff_len_eq]
  have h := SimplexCategory.len_le_of_epi (inferInstance : epi A.e)
  dsimp at hâŠ¢
  linarith
#align simplicial_object.splitting.Ïƒ_comp_Ï€_summand_id_eq_zero SimplicialObject.Splitting.Ïƒ_comp_Ï€Summand_id_eq_zero

/- warning: simplicial_object.splitting.Î¹_summand_comp_P_infty_eq_zero -> SimplicialObject.Splitting.Î¹Summand_comp_PInfty_eq_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {n : Nat} (A : SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))), (Not (SimplicialObject.Splitting.IndexSet.EqId (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) A)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) A) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n)) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {n : Nat} (A : SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))), (Not (SimplicialObject.Splitting.IndexSet.EqId (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) A)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) A) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n)) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) 0 (Zero.toOfNat0.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_summand_comp_P_infty_eq_zero SimplicialObject.Splitting.Î¹Summand_comp_PInfty_eq_zeroâ‚“'. -/
/-- If a simplicial object `X` in an additive category is split,
then `P_infty` vanishes on all the summands of `X _[n]` which do
not correspond to the identity of `[n]`. -/
theorem Î¹Summand_comp_PInfty_eq_zero {X : SimplicialObject C} (s : SimplicialObject.Splitting X)
    {n : â„•} (A : SimplicialObject.Splitting.IndexSet (op [n])) (hA : Â¬A.EqId) :
    s.Î¹Summand A â‰« PInfty.f n = 0 :=
  by
  rw [SimplicialObject.Splitting.IndexSet.eqId_iff_mono] at hA
  rw [SimplicialObject.Splitting.Î¹Summand_eq, assoc, degeneracy_comp_P_infty X n A.e hA, comp_zero]
#align simplicial_object.splitting.Î¹_summand_comp_P_infty_eq_zero SimplicialObject.Splitting.Î¹Summand_comp_PInfty_eq_zero

/- warning: simplicial_object.splitting.comp_P_infty_eq_zero_iff -> SimplicialObject.Splitting.comp_PInfty_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {Z : C} {n : Nat} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))), Iff (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) Z (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) f (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n)) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Z (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)))))) (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) Z (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) f (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Z (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {Z : C} {n : Nat} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))), Iff (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) Z (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) f (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n)) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) 0 (Zero.toOfNat0.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Z (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n))))) (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) Z (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) f (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))) 0 (Zero.toOfNat0.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) Z (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Z (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))))))))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.comp_P_infty_eq_zero_iff SimplicialObject.Splitting.comp_PInfty_eq_zero_iffâ‚“'. -/
theorem comp_PInfty_eq_zero_iff {Z : C} {n : â„•} (f : Z âŸ¶ X _[n]) :
    f â‰« PInfty.f n = 0 â†” f â‰« s.Ï€Summand (IndexSet.id (op [n])) = 0 :=
  by
  constructor
  Â· intro h
    cases n
    Â· dsimp at h
      rw [comp_id] at h
      rw [h, zero_comp]
    Â· have h' := f â‰«= P_infty_f_add_Q_infty_f (n + 1)
      dsimp at h'
      rw [comp_id, comp_add, h, zero_add] at h'
      rw [â† h', assoc, Q_infty_f, decomposition_Q, preadditive.sum_comp, preadditive.comp_sum,
        Finset.sum_eq_zero]
      intro i hi
      simp only [assoc, Ïƒ_comp_Ï€_summand_id_eq_zero, comp_zero]
  Â· intro h
    rw [â† comp_id f, assoc, s.decomposition_id, preadditive.sum_comp, preadditive.comp_sum,
      Fintype.sum_eq_zero]
    intro A
    by_cases hA : A.eq_id
    Â· dsimp at hA
      subst hA
      rw [assoc, reassoc_of h, zero_comp]
    Â· simp only [assoc, s.Î¹_summand_comp_P_infty_eq_zero A hA, comp_zero]
#align simplicial_object.splitting.comp_P_infty_eq_zero_iff SimplicialObject.Splitting.comp_PInfty_eq_zero_iff

#print SimplicialObject.Splitting.PInfty_comp_Ï€Summand_id /-
@[simp, reassoc.1]
theorem PInfty_comp_Ï€Summand_id (n : â„•) :
    PInfty.f n â‰« s.Ï€Summand (IndexSet.id (op [n])) = s.Ï€Summand (IndexSet.id (op [n])) :=
  by
  conv_rhs => rw [â† id_comp (s.Ï€_summand _)]
  symm
  rw [â† sub_eq_zero, â† sub_comp, â† comp_P_infty_eq_zero_iff, sub_comp, id_comp, P_infty_f_idem,
    sub_self]
#align simplicial_object.splitting.P_infty_comp_Ï€_summand_id SimplicialObject.Splitting.PInfty_comp_Ï€Summand_id
-/

/- warning: simplicial_object.splitting.Ï€_summand_comp_Î¹_summand_comp_P_infty_eq_P_infty -> SimplicialObject.Splitting.Ï€Summand_comp_Î¹Summand_comp_PInfty_eq_PInfty is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n))) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) n) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n))) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_3 X) n)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Ï€_summand_comp_Î¹_summand_comp_P_infty_eq_P_infty SimplicialObject.Splitting.Ï€Summand_comp_Î¹Summand_comp_PInfty_eq_PInftyâ‚“'. -/
@[simp, reassoc.1]
theorem Ï€Summand_comp_Î¹Summand_comp_PInfty_eq_PInfty (n : â„•) :
    s.Ï€Summand (IndexSet.id (op [n])) â‰« s.Î¹Summand (IndexSet.id (op [n])) â‰« PInfty.f n =
      PInfty.f n :=
  by
  conv_rhs => rw [â† id_comp (P_infty.f n)]
  erw [s.decomposition_id, preadditive.sum_comp]
  rw [Fintype.sum_eq_single (index_set.id (op [n])), assoc]
  rintro A (hA : Â¬A.eq_id)
  rw [assoc, s.Î¹_summand_comp_P_infty_eq_zero A hA, comp_zero]
#align simplicial_object.splitting.Ï€_summand_comp_Î¹_summand_comp_P_infty_eq_P_infty SimplicialObject.Splitting.Ï€Summand_comp_Î¹Summand_comp_PInfty_eq_PInfty

#print SimplicialObject.Splitting.d /-
/-- The differentials `s.d i j : s.N i âŸ¶ s.N j` on nondegenerate simplices of a split
simplicial object are induced by the differentials on the alternating face map complex. -/
@[simp]
def d (i j : â„•) : s.n i âŸ¶ s.n j :=
  s.Î¹Summand (IndexSet.id (op [i])) â‰« K[X].d i j â‰« s.Ï€Summand (IndexSet.id (op [j]))
#align simplicial_object.splitting.d SimplicialObject.Splitting.d
-/

/- warning: simplicial_object.splitting.Î¹_summand_comp_d_comp_Ï€_summand_eq_zero -> SimplicialObject.Splitting.Î¹Summand_comp_d_comp_Ï€Summand_eq_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (j : Nat) (k : Nat) (A : SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))), (Not (SimplicialObject.Splitting.IndexSet.EqId (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j)) A)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))))))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j)) A) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) k) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))))))) (HomologicalComplex.d.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) j k) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))))))))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (j : Nat) (k : Nat) (A : SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))), (Not (SimplicialObject.Splitting.IndexSet.EqId (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j)) A)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))))))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j)) A) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) k) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))))))) (HomologicalComplex.d.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_3 X) j k) (SimplicialObject.Splitting.Ï€Summand.{u1, u2} C _inst_1 _inst_2 X s (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))) 0 (Zero.toOfNat0.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk j))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk k)))))))))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_summand_comp_d_comp_Ï€_summand_eq_zero SimplicialObject.Splitting.Î¹Summand_comp_d_comp_Ï€Summand_eq_zeroâ‚“'. -/
theorem Î¹Summand_comp_d_comp_Ï€Summand_eq_zero (j k : â„•) (A : IndexSet (op [j])) (hA : Â¬A.EqId) :
    s.Î¹Summand A â‰« K[X].d j k â‰« s.Ï€Summand (IndexSet.id (op [k])) = 0 :=
  by
  rw [A.eq_id_iff_mono] at hA
  rw [â† assoc, â† s.comp_P_infty_eq_zero_iff, assoc, â† P_infty.comm j k, s.Î¹_summand_eq, assoc,
    degeneracy_comp_P_infty_assoc X j A.e hA, zero_comp, comp_zero]
#align simplicial_object.splitting.Î¹_summand_comp_d_comp_Ï€_summand_eq_zero SimplicialObject.Splitting.Î¹Summand_comp_d_comp_Ï€Summand_eq_zero

#print SimplicialObject.Splitting.nondegComplex /-
/-- If `s` is a splitting of a simplicial object `X` in a preadditive category,
`s.nondeg_complex` is a chain complex which is given in degree `n` by
the nondegenerate `n`-simplices of `X`. -/
@[simps]
def nondegComplex : ChainComplex C â„• where
  pt := s.n
  d := s.d
  shape' i j hij := by simp only [d, K[X].shape i j hij, zero_comp, comp_zero]
  d_comp_d' i j k hij hjk := by
    simp only [d, assoc]
    have eq :
      K[X].d i j â‰« ðŸ™ (X.obj (op [j])) â‰« K[X].d j k â‰« s.Ï€_summand (index_set.id (op [k])) = 0 := by
      erw [id_comp, HomologicalComplex.d_comp_d_assoc, zero_comp]
    rw [s.decomposition_id] at eq
    classical
      rw [Fintype.sum_eq_add_sum_compl (index_set.id (op [j])), add_comp, comp_add, assoc,
        preadditive.sum_comp, preadditive.comp_sum, Finset.sum_eq_zero, add_zero] at eq
      swap
      Â· intro A hA
        simp only [Finset.mem_compl, Finset.mem_singleton] at hA
        simp only [assoc, Î¹_summand_comp_d_comp_Ï€_summand_eq_zero _ _ _ _ hA, comp_zero]
      rw [Eq, comp_zero]
#align simplicial_object.splitting.nondeg_complex SimplicialObject.Splitting.nondegComplex
-/

/- warning: simplicial_object.splitting.to_karoubi_nondeg_complex_iso_Nâ‚ -> SimplicialObject.Splitting.toKaroubiNondegComplexIsoNâ‚ is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1], CategoryTheory.Iso.{u2, max u1 u2} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Functor.obj.{u2, u2, max u1 u2, max u1 u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne)) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.toKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (SimplicialObject.Splitting.nondegComplex.{u1, u2} C _inst_1 _inst_2 X s _inst_3)) (CategoryTheory.Functor.obj.{u2, u2, max u2 u1, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (AlgebraicTopology.DoldKan.Nâ‚.{u1, u2} C _inst_1 _inst_3) X)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) [_inst_3 : CategoryTheory.Preadditive.{u2, u1} C _inst_1], CategoryTheory.Iso.{u2, max u1 u2} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (Prefunctor.obj.{succ u2, succ u2, max u1 u2, max u1 u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, max u1 u2, max u1 u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.toKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))) (SimplicialObject.Splitting.nondegComplex.{u1, u2} C _inst_1 _inst_2 X s _inst_3)) (Prefunctor.obj.{succ u2, succ u2, max u2 u1, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1))) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, max u2 u1, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_3) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (AlgebraicTopology.DoldKan.Nâ‚.{u1, u2} C _inst_1 _inst_3)) X)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.to_karoubi_nondeg_complex_iso_Nâ‚ SimplicialObject.Splitting.toKaroubiNondegComplexIsoNâ‚â‚“'. -/
/-- The chain complex `s.nondeg_complex` attached to a splitting of a simplicial object `X`
becomes isomorphic to the normalized Moore complex `Nâ‚.obj X` defined as a formal direct
factor in the category `karoubi (chain_complex C â„•)`. -/
@[simps]
def toKaroubiNondegComplexIsoNâ‚ : (toKaroubi _).obj s.nondegComplex â‰… Nâ‚.obj X
    where
  Hom :=
    { f :=
        { f := fun n => s.Î¹Summand (IndexSet.id (op [n])) â‰« PInfty.f n
          comm' := fun i j hij => by
            dsimp
            rw [assoc, assoc, assoc, Ï€_summand_comp_Î¹_summand_comp_P_infty_eq_P_infty,
              HomologicalComplex.Hom.comm] }
      comm := by
        ext n
        dsimp
        rw [id_comp, assoc, P_infty_f_idem] }
  inv :=
    { f :=
        { f := fun n => s.Ï€Summand (IndexSet.id (op [n]))
          comm' := fun i j hij => by
            dsimp
            slice_rhs 1 1 => rw [â† id_comp (K[X].d i j)]
            erw [s.decomposition_id]
            rw [sum_comp, sum_comp, Finset.sum_eq_single (index_set.id (op [i])), assoc, assoc]
            Â· intro A h hA
              simp only [assoc, s.Î¹_summand_comp_d_comp_Ï€_summand_eq_zero _ _ _ hA, comp_zero]
            Â· simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff] }
      comm := by
        ext n
        dsimp
        simp only [comp_id, P_infty_comp_Ï€_summand_id] }
  hom_inv_id' := by
    ext n
    simpa only [assoc, P_infty_comp_Ï€_summand_id, karoubi.comp_f, HomologicalComplex.comp_f,
      Î¹_Ï€_summand_eq_id]
  inv_hom_id' := by
    ext n
    simp only [Ï€_summand_comp_Î¹_summand_comp_P_infty_eq_P_infty, karoubi.comp_f,
      HomologicalComplex.comp_f, Nâ‚_obj_p, karoubi.id_eq]
#align simplicial_object.splitting.to_karoubi_nondeg_complex_iso_Nâ‚ SimplicialObject.Splitting.toKaroubiNondegComplexIsoNâ‚

end Splitting

namespace Split

variable {C : Type _} [Category C] [Preadditive C] [HasFiniteCoproducts C]

/- warning: simplicial_object.split.nondeg_complex_functor -> SimplicialObject.Split.nondegComplexFunctor is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u1 u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_3) (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u2 u1, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_3) (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.nondeg_complex_functor SimplicialObject.Split.nondegComplexFunctorâ‚“'. -/
/-- The functor which sends a split simplicial object in a preadditive category to
the chain complex which consists of nondegenerate simplices. -/
@[simps]
def nondegComplexFunctor : Split C â¥¤ ChainComplex C â„•
    where
  obj S := S.s.nondegComplex
  map Sâ‚ Sâ‚‚ Î¦ :=
    { f := Î¦.f
      comm' := fun i j hij => by
        dsimp
        erw [â† Î¹_summand_naturality_symm_assoc Î¦ (splitting.index_set.id (op [i])),
          ((alternating_face_map_complex C).map Î¦.F).comm_assoc i j]
        simp only [assoc]
        congr 2
        apply Sâ‚.s.hom_ext'
        intro A
        dsimp [alternating_face_map_complex]
        erw [Î¹_summand_naturality_symm_assoc Î¦ A]
        by_cases A.eq_id
        Â· dsimp at h
          subst h
          simpa only [splitting.Î¹_Ï€_summand_eq_id, comp_id, splitting.Î¹_Ï€_summand_eq_id_assoc]
        Â· have h' : splitting.index_set.id (op [j]) â‰  A :=
            by
            symm
            exact h
          rw [Sâ‚.s.Î¹_Ï€_summand_eq_zero_assoc _ _ h', Sâ‚‚.s.Î¹_Ï€_summand_eq_zero _ _ h', zero_comp,
            comp_zero] }
#align simplicial_object.split.nondeg_complex_functor SimplicialObject.Split.nondegComplexFunctor

/- warning: simplicial_object.split.to_karoubi_nondeg_complex_functor_iso_Nâ‚ -> SimplicialObject.Split.toKaroubiNondegComplexFunctorIsoNâ‚ is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Iso.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, u2, max u1 u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne)))) (CategoryTheory.Functor.category.{u2, u2, max u1 u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne)))) (CategoryTheory.Functor.comp.{u2, u2, u2, max u1 u2, max u1 u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_3) (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne)) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (SimplicialObject.Split.nondegComplexFunctor.{u1, u2} C _inst_1 _inst_2 _inst_3) (CategoryTheory.Idempotents.toKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne)))) (CategoryTheory.Functor.comp.{u2, u2, u2, max u1 u2, max u2 u1, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (SimplicialObject.Split.forget.{u1, u2} C _inst_1 _inst_3) (AlgebraicTopology.DoldKan.Nâ‚.{u1, u2} C _inst_1 _inst_2))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Iso.{max u1 u2, max (max (max u1 u2) u2 u1) u2} (CategoryTheory.Functor.{u2, u2, max u2 u1, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))) (CategoryTheory.Functor.category.{u2, u2, max u1 u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))) (CategoryTheory.Functor.comp.{u2, u2, u2, max u2 u1, max u2 u1, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_3) (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (SimplicialObject.Split.nondegComplexFunctor.{u1, u2} C _inst_1 _inst_2 _inst_3) (CategoryTheory.Idempotents.toKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))) (CategoryTheory.Functor.comp.{u2, u2, u2, max u1 u2, max u1 u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_3) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (SimplicialObject.Split.forget.{u1, u2} C _inst_1 _inst_3) (AlgebraicTopology.DoldKan.Nâ‚.{u1, u2} C _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.to_karoubi_nondeg_complex_functor_iso_Nâ‚ SimplicialObject.Split.toKaroubiNondegComplexFunctorIsoNâ‚â‚“'. -/
/-- The natural isomorphism (in `karoubi (chain_complex C â„•)`) between the chain complex
of nondegenerate simplices of a split simplicial object and the normalized Moore complex
defined as a formal direct factor of the alternating face map complex. -/
@[simps]
def toKaroubiNondegComplexFunctorIsoNâ‚ :
    nondegComplexFunctor â‹™ toKaroubi (ChainComplex C â„•) â‰… forget C â‹™ DoldKan.Nâ‚ :=
  NatIso.ofComponents (fun S => S.s.toKaroubiNondegComplexIsoNâ‚) fun Sâ‚ Sâ‚‚ Î¦ =>
    by
    ext n
    dsimp
    simp only [karoubi.comp_f, to_karoubi_map_f, HomologicalComplex.comp_f,
      nondeg_complex_functor_map_f, splitting.to_karoubi_nondeg_complex_iso_Nâ‚_hom_f_f, Nâ‚_map_f,
      alternating_face_map_complex.map_f, assoc, P_infty_f_idem_assoc]
    erw [â† split.Î¹_summand_naturality_symm_assoc Î¦ (splitting.index_set.id (op [n]))]
    rw [P_infty_f_naturality]
#align simplicial_object.split.to_karoubi_nondeg_complex_functor_iso_Nâ‚ SimplicialObject.Split.toKaroubiNondegComplexFunctorIsoNâ‚

end Split

end SimplicialObject

