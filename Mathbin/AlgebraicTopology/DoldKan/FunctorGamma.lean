/-
Copyright (c) 2022 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou

! This file was ported from Lean 3 source module algebraic_topology.dold_kan.functor_gamma
! leanprover-community/mathlib commit 9d2f0748e6c50d7a2657c564b1ff2c695b39148d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.AlgebraicTopology.DoldKan.SplitSimplicialObject

/-!

# Construction of the inverse functor of the Dold-Kan equivalence

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.


In this file, we construct the functor `Î“â‚€ : chain_complex C â„• â¥¤ simplicial_object C`
which shall be the inverse functor of the Dold-Kan equivalence in the case of abelian categories,
and more generally pseudoabelian categories.

By definition, when `K` is a chain_complex, `Î“â‚€.obj K` is a simplicial object which
sends `Î” : simplex_categoryáµ’áµ–` to a certain coproduct indexed by the set
`splitting.index_set Î”` whose elements consists of epimorphisms `e : Î”.unop âŸ¶ Î”'.unop`
(with `Î”' : simplex_categoryáµ’áµ–`); the summand attached to such an `e` is `K.X Î”'.unop.len`.
By construction, `Î“â‚€.obj K` is a split simplicial object whose splitting is `Î“â‚€.splitting K`.

We also construct `Î“â‚‚ : karoubi (chain_complex C â„•) â¥¤ karoubi (simplicial_object C)`
which shall be an equivalence for any additive category `C`.

-/


noncomputable section

open
  CategoryTheory CategoryTheory.Category CategoryTheory.Limits SimplexCategory SimplicialObject Opposite CategoryTheory.Idempotents

open Simplicial DoldKan

namespace AlgebraicTopology

namespace DoldKan

variable {C : Type _} [Category C] [Preadditive C] (K K' : ChainComplex C â„•) (f : K âŸ¶ K')
  {Î”'' Î”' Î” : SimplexCategory} (i' : Î”'' âŸ¶ Î”') [Mono i'] (i : Î”' âŸ¶ Î”) [Mono i]

#print AlgebraicTopology.DoldKan.IsÎ´â‚€ /-
/-- `is_Î´â‚€ i` is a simple condition used to check whether a monomorphism `i` in
`simplex_category` identifies to the coface map `Î´ 0`. -/
@[nolint unused_arguments]
def IsÎ´â‚€ {Î” Î”' : SimplexCategory} (i : Î”' âŸ¶ Î”) [Mono i] : Prop :=
  Î”.len = Î”'.len + 1 âˆ§ i.toOrderHom 0 â‰  0
#align algebraic_topology.dold_kan.is_Î´â‚€ AlgebraicTopology.DoldKan.IsÎ´â‚€
-/

namespace IsÎ´â‚€

/- warning: algebraic_topology.dold_kan.is_Î´â‚€.iff -> AlgebraicTopology.DoldKan.IsÎ´â‚€.iff is a dubious translation:
lean 3 declaration is
  forall {j : Nat} {i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))}, Iff (AlgebraicTopology.DoldKan.IsÎ´â‚€ (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SimplexCategory.mk j) (SimplexCategory.Î´ j i) (SimplexCategory.Î´.CategoryTheory.mono j i)) (Eq.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) j (One.one.{0} Nat Nat.hasOne))))))))
but is expected to have type
  forall {j : Nat} {i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) j (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))}, Iff (AlgebraicTopology.DoldKan.IsÎ´â‚€ (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) j (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SimplexCategory.mk j) (SimplexCategory.Î´ j i) (SimplexCategory.instMonoSimplexCategorySmallCategoryMkHAddNatInstHAddInstAddNatOfNatInstOfNatNatÎ´ j i)) (Eq.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) j (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) j (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) j (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) j (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.is_Î´â‚€.iff AlgebraicTopology.DoldKan.IsÎ´â‚€.iffâ‚“'. -/
theorem iff {j : â„•} {i : Fin (j + 2)} : IsÎ´â‚€ (SimplexCategory.Î´ i) â†” i = 0 :=
  by
  constructor
  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©
    by_contra
    exact hâ‚‚ (Fin.succAbove_ne_zero_zero h)
  Â· rintro rfl
    exact âŸ¨rfl, Fin.succ_ne_zero _âŸ©
#align algebraic_topology.dold_kan.is_Î´â‚€.iff AlgebraicTopology.DoldKan.IsÎ´â‚€.iff

/- warning: algebraic_topology.dold_kan.is_Î´â‚€.eq_Î´â‚€ -> AlgebraicTopology.DoldKan.IsÎ´â‚€.eq_Î´â‚€ is a dubious translation:
lean 3 declaration is
  forall {n : Nat} {i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} [_inst_5 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) i], (AlgebraicTopology.DoldKan.IsÎ´â‚€ (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SimplexCategory.mk n) i _inst_5) -> (Eq.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) i (SimplexCategory.Î´ n (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)))))))))
but is expected to have type
  forall {n : Nat} {i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} [_inst_5 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) i], (AlgebraicTopology.DoldKan.IsÎ´â‚€ (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SimplexCategory.mk n) i _inst_5) -> (Eq.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) i (SimplexCategory.Î´ n (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.is_Î´â‚€.eq_Î´â‚€ AlgebraicTopology.DoldKan.IsÎ´â‚€.eq_Î´â‚€â‚“'. -/
theorem eq_Î´â‚€ {n : â„•} {i : [n] âŸ¶ [n + 1]} [Mono i] (hi : IsÎ´â‚€ i) : i = SimplexCategory.Î´ 0 :=
  by
  obtain âŸ¨j, rflâŸ© := SimplexCategory.eq_Î´_of_mono i
  rw [Iff] at hi
  rw [hi]
#align algebraic_topology.dold_kan.is_Î´â‚€.eq_Î´â‚€ AlgebraicTopology.DoldKan.IsÎ´â‚€.eq_Î´â‚€

end IsÎ´â‚€

namespace Î“â‚€

namespace Obj

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand /-
/-- In the definition of `(Î“â‚€.obj K).obj Î”` as a direct sum indexed by `A : splitting.index_set Î”`,
the summand `summand K Î” A` is `K.X A.1.len`. -/
def summand (Î” : SimplexCategoryáµ’áµ–) (A : Splitting.IndexSet Î”) : C :=
  K.pt A.1.unop.len
#align algebraic_topology.dold_kan.Î“â‚€.obj.summand AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand
-/

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚ /-
/-- The functor `Î“â‚€` sends a chain complex `K` to the simplicial object which
sends `Î”` to the direct sum of the objects `summand K Î” A` for all `A : splitting.index_set Î”` -/
def objâ‚‚ (K : ChainComplex C â„•) (Î” : SimplexCategoryáµ’áµ–) [HasFiniteCoproducts C] : C :=
  âˆ fun A : Splitting.IndexSet Î” => summand K Î” A
#align algebraic_topology.dold_kan.Î“â‚€.obj.objâ‚‚ AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚
-/

namespace Termwise

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono /-
/-- A monomorphism `i : Î”' âŸ¶ Î”` induces a morphism `K.X Î”.len âŸ¶ K.X Î”'.len` which
is the identity if `Î” = Î”'`, the differential on the complex `K` if `i = Î´ 0`, and
zero otherwise. -/
def mapMono (K : ChainComplex C â„•) {Î”' Î” : SimplexCategory} (i : Î”' âŸ¶ Î”) [Mono i] :
    K.pt Î”.len âŸ¶ K.pt Î”'.len := by
  by_cases Î” = Î”'
  Â· exact eq_to_hom (by congr )
  Â· by_cases is_Î´â‚€ i
    Â· exact K.d Î”.len Î”'.len
    Â· exact 0
#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono
-/

variable (Î”)

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_id /-
theorem mapMono_id : mapMono K (ðŸ™ Î”) = ðŸ™ _ :=
  by
  unfold map_mono
  simp only [eq_self_iff_true, eq_to_hom_refl, dite_eq_ite, if_true]
#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_id AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_id
-/

variable {Î”}

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_Î´â‚€' -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) {Î”' : SimplexCategory} {Î” : SimplexCategory} (i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”) [_inst_4 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î” i], (AlgebraicTopology.DoldKan.IsÎ´â‚€ Î” Î”' i _inst_4) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”'))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”' Î” i _inst_4) (HomologicalComplex.d.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”) (SimplexCategory.len Î”')))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) {Î”' : SimplexCategory} {Î” : SimplexCategory} (i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”') [_inst_4 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î” Î”' i], (AlgebraicTopology.DoldKan.IsÎ´â‚€ Î”' Î” i _inst_4) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î” Î”' i _inst_4) (HomologicalComplex.d.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”') (SimplexCategory.len Î”)))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_Î´â‚€' AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€'â‚“'. -/
theorem mapMono_Î´â‚€' (hi : IsÎ´â‚€ i) : mapMono K i = K.d Î”.len Î”'.len :=
  by
  unfold map_mono
  classical
    rw [dif_neg, dif_pos hi]
    rintro rfl
    simpa only [self_eq_add_right, Nat.one_ne_zero] using hi.1
#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_Î´â‚€' AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€'

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_Î´â‚€ -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€ is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) {n : Nat}, Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len (SimplexCategory.mk n)))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SimplexCategory.Î´ n (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)))))))) (SimplexCategory.Î´.CategoryTheory.mono n (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))))))))) (HomologicalComplex.d.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) n)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) {n : Nat}, Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len (SimplexCategory.mk n)))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SimplexCategory.Î´ n (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (SimplexCategory.instMonoSimplexCategorySmallCategoryMkHAddNatInstHAddInstAddNatOfNatInstOfNatNatÎ´ n (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (NeZero.succ (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (HomologicalComplex.d.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) n)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_Î´â‚€ AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€â‚“'. -/
@[simp]
theorem mapMono_Î´â‚€ {n : â„•} : mapMono K (Î´ (0 : Fin (n + 2))) = K.d (n + 1) n :=
  mapMono_Î´â‚€' K _ (by rw [is_Î´â‚€.iff])
#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_Î´â‚€ AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_eq_zero -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_eq_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) {Î”' : SimplexCategory} {Î” : SimplexCategory} (i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”) [_inst_4 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î” i], (Ne.{1} SimplexCategory Î” Î”') -> (Not (AlgebraicTopology.DoldKan.IsÎ´â‚€ Î” Î”' i _inst_4)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”'))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”' Î” i _inst_4) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”'))) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”'))) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”'))) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”')))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) {Î”' : SimplexCategory} {Î” : SimplexCategory} (i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”') [_inst_4 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î” Î”' i], (Ne.{1} SimplexCategory Î”' Î”) -> (Not (AlgebraicTopology.DoldKan.IsÎ´â‚€ Î”' Î” i _inst_4)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î” Î”' i _inst_4) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”))) 0 (Zero.toOfNat0.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”))) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”))))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_eq_zero AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_eq_zeroâ‚“'. -/
theorem mapMono_eq_zero (hâ‚ : Î” â‰  Î”') (hâ‚‚ : Â¬IsÎ´â‚€ i) : mapMono K i = 0 :=
  by
  unfold map_mono
  rw [Ne.def] at hâ‚
  split_ifs
  rfl
#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_eq_zero AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_eq_zero

variable {K K'}

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_naturality /-
@[simp, reassoc.1]
theorem mapMono_naturality : mapMono K i â‰« f.f Î”'.len = f.f Î”.len â‰« mapMono K' i :=
  by
  unfold map_mono
  split_ifs
  Â· subst h
    simp only [id_comp, eq_to_hom_refl, comp_id]
  Â· rw [HomologicalComplex.Hom.comm]
  Â· rw [zero_comp, comp_zero]
#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_naturality AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_naturality
-/

variable (K)

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_comp -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) {Î”'' : SimplexCategory} {Î”' : SimplexCategory} {Î” : SimplexCategory} (i' : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”'' Î”') [_inst_3 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”'' Î”' i'] (i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”) [_inst_4 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î” i], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”''))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”)) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”')) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”'')) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”' Î” i _inst_4) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”'' Î”' i' _inst_3)) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”'' Î” (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) Î”'' Î”' Î” i' i) (CategoryTheory.mono_comp.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”'' Î”' Î” i' _inst_3 i _inst_4))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) {Î”'' : SimplexCategory} {Î”' : SimplexCategory} {Î” : SimplexCategory} (i' : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”') (_inst_3 : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”'') [i : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î” Î”' i'] [_inst_4 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î”'' _inst_3], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”'')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”'')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”')) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”)) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”' Î”'' _inst_3 _inst_4) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î” Î”' i' i)) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î” Î”'' (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) Î” Î”' Î”'' i' _inst_3) (CategoryTheory.mono_comp.{0, 0} SimplexCategory SimplexCategory.smallCategory Î” Î”' Î”'' i' i _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_comp AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_compâ‚“'. -/
@[simp, reassoc.1]
theorem mapMono_comp : mapMono K i â‰« mapMono K i' = mapMono K (i' â‰« i) :=
  by
  -- case where i : Î”' âŸ¶ Î” is the identity
  by_cases hâ‚ : Î” = Î”'
  Â· subst hâ‚
    simp only [SimplexCategory.eq_id_of_mono i, comp_id, id_comp, map_mono_id K, eq_to_hom_refl]
  -- case where i' : Î”'' âŸ¶ Î”' is the identity
  by_cases hâ‚‚ : Î”' = Î”''
  Â· subst hâ‚‚
    simp only [SimplexCategory.eq_id_of_mono i', comp_id, id_comp, map_mono_id K, eq_to_hom_refl]
  -- then the RHS is always zero
  obtain âŸ¨k, hkâŸ© := Nat.exists_eq_add_of_lt (len_lt_of_mono i hâ‚)
  obtain âŸ¨k', hk'âŸ© := Nat.exists_eq_add_of_lt (len_lt_of_mono i' hâ‚‚)
  have eq : Î”.len = Î”''.len + (k + k' + 2) := by linarith
  rw [map_mono_eq_zero K (i' â‰« i) _ _]; rotate_left
  Â· by_contra
    simpa only [self_eq_add_right, h] using Eq
  Â· by_contra
    simp only [h.1, add_right_inj] at eq
    linarith
  -- in all cases, the LHS is also zero, either by definition, or because d â‰« d = 0
  by_cases hâ‚ƒ : is_Î´â‚€ i
  Â· by_cases hâ‚„ : is_Î´â‚€ i'
    Â· rw [map_mono_Î´â‚€' K i hâ‚ƒ, map_mono_Î´â‚€' K i' hâ‚„, HomologicalComplex.d_comp_d]
    Â· simp only [map_mono_eq_zero K i' hâ‚‚ hâ‚„, comp_zero]
  Â· simp only [map_mono_eq_zero K i hâ‚ hâ‚ƒ, zero_comp]
#align algebraic_topology.dold_kan.Î“â‚€.obj.termwise.map_mono_comp AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_comp

end Termwise

variable [HasFiniteCoproducts C]

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.map /-
/-- The simplicial morphism on the simplicial object `Î“â‚€.obj K` induced by
a morphism `Î”' â†’ Î”` in `simplex_category` is defined on each summand
associated to an `A : Î“_index_set Î”` in terms of the epi-mono factorisation
of `Î¸ â‰« A.e`. -/
def map (K : ChainComplex C â„•) {Î”' Î” : SimplexCategoryáµ’áµ–} (Î¸ : Î” âŸ¶ Î”') : objâ‚‚ K Î” âŸ¶ objâ‚‚ K Î”' :=
  Sigma.desc fun A =>
    Termwise.mapMono K (image.Î¹ (Î¸.unop â‰« A.e)) â‰« Sigma.Î¹ (summand K Î”') (A.pull Î¸)
#align algebraic_topology.dold_kan.Î“â‚€.obj.map AlgebraicTopology.DoldKan.Î“â‚€.Obj.map
-/

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€ /-
@[reassoc.1]
theorem map_on_summandâ‚€ {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) {Î¸ : Î” âŸ¶ Î”'}
    {Î”'' : SimplexCategory} {e : Î”'.unop âŸ¶ Î”''} {i : Î”'' âŸ¶ A.1.unop} [Epi e] [Mono i]
    (fac : e â‰« i = Î¸.unop â‰« A.e) :
    Sigma.Î¹ (summand K Î”) A â‰« map K Î¸ =
      Termwise.mapMono K i â‰« Sigma.Î¹ (summand K Î”') (Splitting.IndexSet.mk e) :=
  by
  simp only [map, colimit.Î¹_desc, cofan.mk_Î¹_app]
  have h := SimplexCategory.image_eq fac
  subst h
  congr
  Â· exact SimplexCategory.image_Î¹_eq fac
  Â· dsimp only [SimplicialObject.Splitting.IndexSet.pull]
    congr
    exact SimplexCategory.factorThruImage_eq fac
#align algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summandâ‚€ AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€
-/

#print AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€' /-
@[reassoc.1]
theorem map_on_summandâ‚€' {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”') :
    Sigma.Î¹ (summand K Î”) A â‰« map K Î¸ =
      Termwise.mapMono K (image.Î¹ (Î¸.unop â‰« A.e)) â‰« Sigma.Î¹ (summand K _) (A.pull Î¸) :=
  map_on_summandâ‚€ K A (A.fac_pull Î¸)
#align algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summandâ‚€' AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€'
-/

end Obj

variable [HasFiniteCoproducts C]

#print AlgebraicTopology.DoldKan.Î“â‚€.obj /-
/-- The functor `Î“â‚€ : chain_complex C â„• â¥¤ simplicial_object C`, on objects. -/
@[simps]
def obj (K : ChainComplex C â„•) : SimplicialObject C
    where
  obj Î” := Obj.objâ‚‚ K Î”
  map Î” Î”' Î¸ := Obj.map K Î¸
  map_id' Î” := by
    ext A
    cases A
    have fac : A.e â‰« ðŸ™ A.1.unop = (ðŸ™ Î”).unop â‰« A.e := by rw [unop_id, comp_id, id_comp]
    erw [obj.map_on_summandâ‚€ K A fac, obj.termwise.map_mono_id, id_comp, comp_id]
    rcases A with âŸ¨Î”', âŸ¨e, heâŸ©âŸ©
    rfl
  map_comp' Î”'' Î”' Î” Î¸' Î¸ := by
    ext A
    cases A
    have fac : Î¸.unop â‰« Î¸'.unop â‰« A.e = (Î¸' â‰« Î¸).unop â‰« A.e := by rw [unop_comp, assoc]
    rw [â† image.fac (Î¸'.unop â‰« A.e), â† assoc, â†
      image.fac (Î¸.unop â‰« factor_thru_image (Î¸'.unop â‰« A.e)), assoc] at fac
    simpa only [obj.map_on_summandâ‚€'_assoc K A Î¸', obj.map_on_summandâ‚€' K _ Î¸,
      obj.termwise.map_mono_comp_assoc, obj.map_on_summandâ‚€ K A fac]
#align algebraic_topology.dold_kan.Î“â‚€.obj AlgebraicTopology.DoldKan.Î“â‚€.obj
-/

/- warning: algebraic_topology.dold_kan.Î“â‚€.splitting_map_eq_id -> AlgebraicTopology.DoldKan.Î“â‚€.splitting_map_eq_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (fun (n : Nat) => AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) Î” _inst_5) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”)) (SimplicialObject.Splitting.map.{u1, u2} C _inst_1 (fun (n : Nat) => AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (fun (n : Nat) => CategoryTheory.Limits.Sigma.Î¹.{0, u2, u1} (SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚._proof_1.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) _inst_5) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) _inst_5 Î”) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (fun (n : Nat) => AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) Î” _inst_5))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (fun (n : Nat) => AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) Î” _inst_5) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”)) (SimplicialObject.Splitting.map.{u1, u2} C _inst_1 (fun (n : Nat) => AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (fun (n : Nat) => CategoryTheory.Limits.Sigma.Î¹.{0, u2, u1} (SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u2, u1} C _inst_1 (CategoryTheory.Discrete.{0} (SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (CategoryTheory.discreteCategory.{0} (SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (CategoryTheory.Limits.hasColimitsOfShape_discrete.{0, u2, u1} C _inst_1 _inst_5 (SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Finite.of_fintype.{0} (SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (SimplicialObject.Splitting.IndexSet.instFintypeIndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))) (CategoryTheory.Discrete.functor.{u2, 0, u1} C _inst_1 (SimplicialObject.Splitting.IndexSet (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) _inst_5 Î”) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (fun (n : Nat) => AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand.{u1, u2} C _inst_1 _inst_2 K (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) Î” _inst_5))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.splitting_map_eq_id AlgebraicTopology.DoldKan.Î“â‚€.splitting_map_eq_idâ‚“'. -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[] -/
theorem splitting_map_eq_id (Î” : SimplexCategoryáµ’áµ–) :
    SimplicialObject.Splitting.map (Î“â‚€.obj K)
        (fun n : â„• => Sigma.Î¹ (Î“â‚€.Obj.summand K (op [n])) (Splitting.IndexSet.id (op [n]))) Î” =
      ðŸ™ _ :=
  by
  ext A
  trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[]"
  induction Î” using Opposite.rec'
  induction' Î” with n
  dsimp
  simp only [colimit.Î¹_desc, cofan.mk_Î¹_app, comp_id, Î“â‚€.obj_map]
  rw [Î“â‚€.obj.map_on_summandâ‚€ K (SimplicialObject.Splitting.IndexSet.id A.1)
      (show A.e â‰« ðŸ™ _ = A.e.op.unop â‰« ðŸ™ _ by rfl),
    Î“â‚€.obj.termwise.map_mono_id, A.ext']
  apply id_comp
#align algebraic_topology.dold_kan.Î“â‚€.splitting_map_eq_id AlgebraicTopology.DoldKan.Î“â‚€.splitting_map_eq_id

#print AlgebraicTopology.DoldKan.Î“â‚€.splitting /-
/-- By construction, the simplicial `Î“â‚€.obj K` is equipped with a splitting. -/
def splitting (K : ChainComplex C â„•) : SimplicialObject.Splitting (Î“â‚€.obj K)
    where
  n n := K.pt n
  Î¹ n := Sigma.Î¹ (Î“â‚€.Obj.summand K (op [n])) (Splitting.IndexSet.id (op [n]))
  map_is_iso' Î” := by
    rw [Î“â‚€.splitting_map_eq_id]
    apply is_iso.id
#align algebraic_topology.dold_kan.Î“â‚€.splitting AlgebraicTopology.DoldKan.Î“â‚€.splitting
-/

/- warning: algebraic_topology.dold_kan.Î“â‚€.splitting_iso_hom_eq_id -> AlgebraicTopology.DoldKan.Î“â‚€.splitting_iso_hom_eq_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” _inst_5) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”)) (CategoryTheory.Iso.hom.{u2, u1} C _inst_1 (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” _inst_5) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”) (SimplicialObject.Splitting.iso.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”)) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” _inst_5))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” _inst_5) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”)) (CategoryTheory.Iso.hom.{u2, u1} C _inst_1 (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” _inst_5) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”) (SimplicialObject.Splitting.iso.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”)) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” _inst_5))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.splitting_iso_hom_eq_id AlgebraicTopology.DoldKan.Î“â‚€.splitting_iso_hom_eq_idâ‚“'. -/
@[simp]
theorem splitting_iso_hom_eq_id (Î” : SimplexCategoryáµ’áµ–) : ((splitting K).Iso Î”).Hom = ðŸ™ _ :=
  splitting_map_eq_id K Î”
#align algebraic_topology.dold_kan.Î“â‚€.splitting_iso_hom_eq_id AlgebraicTopology.DoldKan.Î“â‚€.splitting_iso_hom_eq_id

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summand -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} {Î”' : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”) (Î¸ : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î” Î”') {Î”'' : SimplexCategory} {e : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') Î”''} {i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))} [_inst_6 : CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') Î”'' e] [_inst_7 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) i], (Eq.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) e i) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A))) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”')) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”') (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î” A) (CategoryTheory.Functor.map.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î” Î”' Î¸)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”'')) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”') (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) i _inst_7) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory (Opposite.unop.{1} SimplexCategory Î”')) (SimplicialObject.Splitting.IndexSet.mk (Opposite.unop.{1} SimplexCategory Î”') Î”'' e _inst_6))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} {Î”' : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”) (Î¸ : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î” Î”') {Î”'' : SimplexCategory} {e : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') Î”''} {i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))} [_inst_6 : CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') Î”'' e] [_inst_7 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) i], (Eq.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) e i) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A))) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”')) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”') (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î” A) (Prefunctor.map.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” Î”' Î¸)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”'')) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory (Opposite.unop.{1} SimplexCategory Î”'))) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”'' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) i _inst_7) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory (Opposite.unop.{1} SimplexCategory Î”')) (SimplicialObject.Splitting.IndexSet.mk (Opposite.unop.{1} SimplexCategory Î”') Î”'' e _inst_6))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summand AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚“'. -/
@[reassoc.1]
theorem Obj.map_on_summand {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”')
    {Î”'' : SimplexCategory} {e : Î”'.unop âŸ¶ Î”''} {i : Î”'' âŸ¶ A.1.unop} [Epi e] [Mono i]
    (fac : e â‰« i = Î¸.unop â‰« A.e) :
    (Î“â‚€.splitting K).Î¹Summand A â‰« (Î“â‚€.obj K).map Î¸ =
      Î“â‚€.Obj.Termwise.mapMono K i â‰« (Î“â‚€.splitting K).Î¹Summand (Splitting.IndexSet.mk e) :=
  by
  dsimp only [SimplicialObject.Splitting.Î¹Summand, SimplicialObject.Splitting.Î¹Coprod]
  simp only [assoc, Î“â‚€.splitting_iso_hom_eq_id, id_comp, comp_id]
  exact Î“â‚€.obj.map_on_summandâ‚€ K A fac
#align algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summand AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summand' -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} {Î”' : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”) (Î¸ : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î” Î”'), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”')) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”') (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î” A) (CategoryTheory.Functor.map.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î” Î”' Î¸)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len (CategoryTheory.Limits.image.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.hasImage.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.CategoryTheory.Limits.hasStrongEpiMonoFactorisations) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”') (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K (CategoryTheory.Limits.image.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.hasImage.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.CategoryTheory.Limits.hasStrongEpiMonoFactorisations) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)))) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.Limits.image.Î¹.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.hasImage.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.CategoryTheory.Limits.hasStrongEpiMonoFactorisations) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)))) (CategoryTheory.Limits.image.Î¹.CategoryTheory.mono.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.hasImage.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.CategoryTheory.Limits.hasStrongEpiMonoFactorisations) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A))))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”' (SimplicialObject.Splitting.IndexSet.pull Î”' Î” A Î¸)))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} {Î”' : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”) (Î¸ : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î” Î”'), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”')) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”') (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î” A) (Prefunctor.map.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î” Î”' Î¸)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len (CategoryTheory.Limits.image.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.has_image.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.instHasStrongEpiMonoFactorisationsSimplexCategorySmallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) Î”') (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K (CategoryTheory.Limits.image.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.has_image.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.instHasStrongEpiMonoFactorisationsSimplexCategorySmallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)))) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.Limits.image.Î¹.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.has_image.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.instHasStrongEpiMonoFactorisationsSimplexCategorySmallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)))) (CategoryTheory.Limits.instMonoImageÎ¹.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (CategoryTheory.Limits.HasImages.has_image.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.instHasStrongEpiMonoFactorisationsSimplexCategorySmallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A))))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) Î”' (SimplicialObject.Splitting.IndexSet.pull Î” A Î”' Î¸)))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summand' AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand'â‚“'. -/
@[reassoc.1]
theorem Obj.map_on_summand' {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”') :
    (splitting K).Î¹Summand A â‰« (obj K).map Î¸ =
      Obj.Termwise.mapMono K (image.Î¹ (Î¸.unop â‰« A.e)) â‰« (splitting K).Î¹Summand (A.pull Î¸) :=
  by
  apply obj.map_on_summand
  apply image.fac
#align algebraic_topology.dold_kan.Î“â‚€.obj.map_on_summand' AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand'

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.map_mono_on_summand_id -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.mapMono_on_summand_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : SimplexCategory} {Î”' : SimplexCategory} (i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”) [_inst_6 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î” i], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”'))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”')) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”))) (CategoryTheory.Functor.map.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”) (Opposite.op.{1} SimplexCategory Î”') (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î” i))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) K (SimplexCategory.len Î”')) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”')) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”' (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))) i _inst_6) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”') (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”'))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : SimplexCategory} {Î”' : SimplexCategory} (i : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”) [_inst_6 : CategoryTheory.Mono.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î” i], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”'))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”')) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”))) (Prefunctor.map.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”) (Opposite.op.{1} SimplexCategory Î”') (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î” i))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”)) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) K (SimplexCategory.len Î”')) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”')) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono.{u1, u2} C _inst_1 _inst_2 K Î”' Î” i _inst_6) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”') (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”'))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.map_mono_on_summand_id AlgebraicTopology.DoldKan.Î“â‚€.Obj.mapMono_on_summand_idâ‚“'. -/
@[reassoc.1]
theorem Obj.mapMono_on_summand_id {Î” Î”' : SimplexCategory} (i : Î”' âŸ¶ Î”) [Mono i] :
    (splitting K).Î¹Summand (Splitting.IndexSet.id (op Î”)) â‰« (obj K).map i.op =
      Obj.Termwise.mapMono K i â‰« (splitting K).Î¹Summand (Splitting.IndexSet.id (op Î”')) :=
  Obj.map_on_summand K (Splitting.IndexSet.id (op Î”)) i.op (rfl : ðŸ™ _ â‰« i = i â‰« ðŸ™ _)
#align algebraic_topology.dold_kan.Î“â‚€.obj.map_mono_on_summand_id AlgebraicTopology.DoldKan.Î“â‚€.Obj.mapMono_on_summand_id

/- warning: algebraic_topology.dold_kan.Î“â‚€.obj.map_epi_on_summand_id -> AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_epi_on_summand_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : SimplexCategory} {Î”' : SimplexCategory} (e : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”) [_inst_6 : CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î” e], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”'))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”')) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”))) (CategoryTheory.Functor.map.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”) (Opposite.op.{1} SimplexCategory Î”') (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î” e))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”') (SimplicialObject.Splitting.IndexSet.mk Î”' Î” e _inst_6))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : SimplexCategory} {Î”' : SimplexCategory} (e : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î”) [_inst_6 : CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory Î”' Î” e], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”'))) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory Î”)) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”)))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”')) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory Î”))) (Prefunctor.map.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory Î”) (Opposite.op.{1} SimplexCategory Î”') (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' Î” e))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory Î”') (SimplicialObject.Splitting.IndexSet.mk Î”' Î” e _inst_6))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€.obj.map_epi_on_summand_id AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_epi_on_summand_idâ‚“'. -/
@[reassoc.1]
theorem Obj.map_epi_on_summand_id {Î” Î”' : SimplexCategory} (e : Î”' âŸ¶ Î”) [Epi e] :
    (Î“â‚€.splitting K).Î¹Summand (Splitting.IndexSet.id (op Î”)) â‰« (Î“â‚€.obj K).map e.op =
      (Î“â‚€.splitting K).Î¹Summand (Splitting.IndexSet.mk e) :=
  by
  simpa only [Î“â‚€.obj.map_on_summand K (splitting.index_set.id (op Î”)) e.op
      (rfl : e â‰« ðŸ™ Î” = e â‰« ðŸ™ Î”),
    Î“â‚€.obj.termwise.map_mono_id] using id_comp _
#align algebraic_topology.dold_kan.Î“â‚€.obj.map_epi_on_summand_id AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_epi_on_summand_id

#print AlgebraicTopology.DoldKan.Î“â‚€.map /-
/-- The functor `Î“â‚€ : chain_complex C â„• â¥¤ simplicial_object C`, on morphisms. -/
@[simps]
def map {K K' : ChainComplex C â„•} (f : K âŸ¶ K') : obj K âŸ¶ obj K'
    where
  app Î” := (Î“â‚€.splitting K).desc Î” fun A => f.f A.1.unop.len â‰« (Î“â‚€.splitting K').Î¹Summand A
  naturality' Î”' Î” Î¸ := by
    apply (Î“â‚€.splitting K).hom_ext'
    intro A
    simp only [(splitting K).Î¹_desc_assoc, obj.map_on_summand'_assoc K _ Î¸, (splitting K).Î¹_desc,
      assoc, obj.map_on_summand' K' _ Î¸]
    apply obj.termwise.map_mono_naturality_assoc
#align algebraic_topology.dold_kan.Î“â‚€.map AlgebraicTopology.DoldKan.Î“â‚€.map
-/

end Î“â‚€

variable [HasFiniteCoproducts C]

/- warning: algebraic_topology.dold_kan.Î“â‚€' -> AlgebraicTopology.DoldKan.Î“â‚€' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u1 u2, max u1 u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne)) (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_5) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_5)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u1 u2, max u2 u1} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))) (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_5) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_5)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚€' AlgebraicTopology.DoldKan.Î“â‚€'â‚“'. -/
/-- The functor `Î“â‚€' : chain_complex C â„• â¥¤ simplicial_object.split C`
that induces `Î“â‚€ : chain_complex C â„• â¥¤ simplicial_object C`, which
shall be the inverse functor of the Dold-Kan equivalence for
abelian or pseudo-abelian categories. -/
@[simps]
def Î“â‚€' : ChainComplex C â„• â¥¤ SimplicialObject.Split C
    where
  obj K := SimplicialObject.Split.mk' (Î“â‚€.splitting K)
  map K K' f :=
    { f := Î“â‚€.map f
      f := f.f
      comm' := fun n => by
        dsimp
        simpa only [â† splitting.Î¹_summand_id, (Î“â‚€.splitting K).Î¹_desc] }
#align algebraic_topology.dold_kan.Î“â‚€' AlgebraicTopology.DoldKan.Î“â‚€'

#print AlgebraicTopology.DoldKan.Î“â‚€ /-
/-- The functor `Î“â‚€ : chain_complex C â„• â¥¤ simplicial_object C`, which is
the inverse functor of the Dold-Kan equivalence when `C` is an abelian
category, or more generally a pseudoabelian category. -/
@[simps]
def Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C :=
  Î“â‚€' â‹™ Split.forget _
#align algebraic_topology.dold_kan.Î“â‚€ AlgebraicTopology.DoldKan.Î“â‚€
-/

/- warning: algebraic_topology.dold_kan.Î“â‚‚ -> AlgebraicTopology.DoldKan.Î“â‚‚ is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u1 u2, max u2 u1} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (HomologicalComplex.CategoryTheory.category.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne))) (CategoryTheory.Idempotents.Karoubi.{max u2 u1, u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1)) (CategoryTheory.Idempotents.Karoubi.CategoryTheory.category.{max u2 u1, u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u1 u2, max u1 u2} (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))) (CategoryTheory.Idempotents.Karoubi.{max u1 u2, u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1)) (CategoryTheory.Idempotents.Karoubi.instCategoryKaroubi.{max u1 u2, u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.Î“â‚‚ AlgebraicTopology.DoldKan.Î“â‚‚â‚“'. -/
/-- The extension of `Î“â‚€ : chain_complex C â„• â¥¤ simplicial_object C`
on the idempotent completions. It shall be an equivalence of categories
for any additive category `C`. -/
@[simps]
def Î“â‚‚ : Karoubi (ChainComplex C â„•) â¥¤ Karoubi (SimplicialObject C) :=
  (CategoryTheory.Idempotents.functorExtensionâ‚‚ _ _).obj Î“â‚€
#align algebraic_topology.dold_kan.Î“â‚‚ AlgebraicTopology.DoldKan.Î“â‚‚

#print AlgebraicTopology.DoldKan.HigherFacesVanish.on_Î“â‚€_summand_id /-
theorem HigherFacesVanish.on_Î“â‚€_summand_id (K : ChainComplex C â„•) (n : â„•) :
    HigherFacesVanish (n + 1) ((Î“â‚€.splitting K).Î¹Summand (Splitting.IndexSet.id (op [n + 1]))) :=
  by
  intro j hj
  have eq := Î“â‚€.obj.map_mono_on_summand_id K (SimplexCategory.Î´ j.succ)
  rw [Î“â‚€.obj.termwise.map_mono_eq_zero K, zero_comp] at eq; rotate_left
  Â· intro h
    exact (Nat.succ_ne_self n) (congr_arg SimplexCategory.len h)
  Â· exact fun h => Fin.succ_ne_zero j (by simpa only [is_Î´â‚€.iff] using h)
  exact Eq
#align algebraic_topology.dold_kan.higher_faces_vanish.on_Î“â‚€_summand_id AlgebraicTopology.DoldKan.HigherFacesVanish.on_Î“â‚€_summand_id
-/

/- warning: algebraic_topology.dold_kan.P_infty_on_Î“â‚€_splitting_summand_eq_self -> AlgebraicTopology.DoldKan.PInfty_on_Î“â‚€_splitting_summand_eq_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) {n : Nat}, Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.x.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) n) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) Nat.hasOne) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) n)) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (K : ChainComplex.{u2, u1, 0} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) {n : Nat}, Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) n)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (HomologicalComplex.X.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) n) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (HomologicalComplex.Hom.f.{u2, u1, 0} Nat C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (ComplexShape.down.{0} Nat (AddRightCancelMonoid.toAddRightCancelSemigroup.{0} Nat (AddCancelMonoid.toAddRightCancelMonoid.{0} Nat (AddCancelCommMonoid.toAddCancelMonoid.{0} Nat (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (AlgebraicTopology.AlternatingFaceMapComplex.obj.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) (AlgebraicTopology.DoldKan.PInfty.{u1, u2} C _inst_1 _inst_2 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K)) n)) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_5 (AlgebraicTopology.DoldKan.Î“â‚€.obj.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (AlgebraicTopology.DoldKan.Î“â‚€.splitting.{u1, u2} C _inst_1 _inst_2 _inst_5 K) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.P_infty_on_Î“â‚€_splitting_summand_eq_self AlgebraicTopology.DoldKan.PInfty_on_Î“â‚€_splitting_summand_eq_selfâ‚“'. -/
@[simp, reassoc.1]
theorem PInfty_on_Î“â‚€_splitting_summand_eq_self (K : ChainComplex C â„•) {n : â„•} :
    (Î“â‚€.splitting K).Î¹Summand (Splitting.IndexSet.id (op [n])) â‰« (PInfty : K[Î“â‚€.obj K] âŸ¶ _).f n =
      (Î“â‚€.splitting K).Î¹Summand (Splitting.IndexSet.id (op [n])) :=
  by
  rw [P_infty_f]
  cases n
  Â· simpa only [P_f_0_eq] using comp_id _
  Â· exact (higher_faces_vanish.on_Î“â‚€_summand_id K n).comp_P_eq_self
#align algebraic_topology.dold_kan.P_infty_on_Î“â‚€_splitting_summand_eq_self AlgebraicTopology.DoldKan.PInfty_on_Î“â‚€_splitting_summand_eq_self

end DoldKan

end AlgebraicTopology

