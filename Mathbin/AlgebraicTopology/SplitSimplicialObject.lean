/-
Copyright (c) 2022 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou

! This file was ported from Lean 3 source module algebraic_topology.split_simplicial_object
! leanprover-community/mathlib commit 4f4a1c875d0baa92ab5d92f3fb1bb258ad9f3e5b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.AlgebraicTopology.SimplicialObject
import Mathbin.CategoryTheory.Limits.Shapes.FiniteProducts

/-!

# Split simplicial objects

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file, we introduce the notion of split simplicial object.
If `C` is a category that has finite coproducts, a splitting
`s : splitting X` of a simplical object `X` in `C` consists
of the datum of a sequence of objects `s.N : â„• â†’ C` (which
we shall refer to as "nondegenerate simplices") and a
sequence of morphisms `s.Î¹ n : s.N n â†’ X _[n]` that have
the property that a certain canonical map identifies `X _[n]`
with the coproduct of objects `s.N i` indexed by all possible
epimorphisms `[n] âŸ¶ [i]` in `simplex_category`. (We do not
assume that the morphisms `s.Î¹ n` are monomorphisms: in the
most common categories, this would be a consequence of the
axioms.)

Simplicial objects equipped with a splitting form a category
`simplicial_object.split C`.

## References
* [Stacks: Splitting simplicial objects] https://stacks.math.columbia.edu/tag/017O

-/


noncomputable section

open CategoryTheory CategoryTheory.Category CategoryTheory.Limits Opposite SimplexCategory

open Simplicial

universe u

variable {C : Type _} [Category C]

namespace SimplicialObject

namespace Splitting

#print SimplicialObject.Splitting.IndexSet /-
/-- The index set which appears in the definition of split simplicial objects. -/
def IndexSet (Î” : SimplexCategoryáµ’áµ–) :=
  Î£Î”' : SimplexCategoryáµ’áµ–, { Î± : Î”.unop âŸ¶ Î”'.unop // Epi Î± }
#align simplicial_object.splitting.index_set SimplicialObject.Splitting.IndexSet
-/

namespace IndexSet

#print SimplicialObject.Splitting.IndexSet.mk /-
/-- The element in `splitting.index_set Î”` attached to an epimorphism `f : Î” âŸ¶ Î”'`. -/
@[simps]
def mk {Î” Î”' : SimplexCategory} (f : Î” âŸ¶ Î”') [Epi f] : IndexSet (op Î”) :=
  âŸ¨op Î”', f, inferInstanceâŸ©
#align simplicial_object.splitting.index_set.mk SimplicialObject.Splitting.IndexSet.mk
-/

variable {Î”' Î” : SimplexCategoryáµ’áµ–} (A : IndexSet Î”) (Î¸ : Î” âŸ¶ Î”')

#print SimplicialObject.Splitting.IndexSet.e /-
/-- The epimorphism in `simplex_category` associated to `A : splitting.index_set Î”` -/
def e :=
  A.2.1
#align simplicial_object.splitting.index_set.e SimplicialObject.Splitting.IndexSet.e
-/

instance : Epi A.e :=
  A.2.2

#print SimplicialObject.Splitting.IndexSet.ext' /-
theorem ext' : A = âŸ¨A.1, âŸ¨A.e, A.2.2âŸ©âŸ© := by tidy
#align simplicial_object.splitting.index_set.ext' SimplicialObject.Splitting.IndexSet.ext'
-/

#print SimplicialObject.Splitting.IndexSet.ext /-
theorem ext (Aâ‚ Aâ‚‚ : IndexSet Î”) (hâ‚ : Aâ‚.1 = Aâ‚‚.1) (hâ‚‚ : Aâ‚.e â‰« eqToHom (by rw [hâ‚]) = Aâ‚‚.e) :
    Aâ‚ = Aâ‚‚ := by
  rcases Aâ‚ with âŸ¨Î”â‚, âŸ¨Î±â‚, hÎ±â‚âŸ©âŸ©
  rcases Aâ‚‚ with âŸ¨Î”â‚‚, âŸ¨Î±â‚‚, hÎ±â‚‚âŸ©âŸ©
  simp only at hâ‚
  subst hâ‚
  simp only [eq_to_hom_refl, comp_id, index_set.e] at hâ‚‚
  simp only [hâ‚‚]
#align simplicial_object.splitting.index_set.ext SimplicialObject.Splitting.IndexSet.ext
-/

instance : Fintype (IndexSet Î”) :=
  Fintype.ofInjective
    (fun A =>
      âŸ¨âŸ¨A.1.unop.len, Nat.lt_succ_iff.mpr (len_le_of_epi (inferInstance : Epi A.e))âŸ©,
        A.e.toOrderHomâŸ© :
      IndexSet Î” â†’ Sigma fun k : Fin (Î”.unop.len + 1) => Fin (Î”.unop.len + 1) â†’ Fin (k + 1))
    (by
      rintro âŸ¨Î”â‚, Î±â‚âŸ© âŸ¨Î”â‚‚, Î±â‚‚âŸ© hâ‚
      induction Î”â‚ using Opposite.rec'
      induction Î”â‚‚ using Opposite.rec'
      simp only at hâ‚
      have hâ‚‚ : Î”â‚ = Î”â‚‚ := by
        ext1
        simpa only [Fin.mk_eq_mk] using hâ‚.1
      subst hâ‚‚
      refine' ext _ _ rfl _
      ext : 2
      exact eq_of_hEq hâ‚.2)

variable (Î”)

#print SimplicialObject.Splitting.IndexSet.id /-
/-- The distinguished element in `splitting.index_set Î”` which corresponds to the
identity of `Î”`. -/
def id : IndexSet Î” :=
  âŸ¨Î”, âŸ¨ðŸ™ _, by infer_instanceâŸ©âŸ©
#align simplicial_object.splitting.index_set.id SimplicialObject.Splitting.IndexSet.id
-/

instance : Inhabited (IndexSet Î”) :=
  âŸ¨id Î”âŸ©

variable {Î”}

#print SimplicialObject.Splitting.IndexSet.EqId /-
/-- The condition that an element `splitting.index_set Î”` is the distinguished
element `splitting.index_set.id Î”`. -/
@[simp]
def EqId : Prop :=
  A = id _
#align simplicial_object.splitting.index_set.eq_id SimplicialObject.Splitting.IndexSet.EqId
-/

#print SimplicialObject.Splitting.IndexSet.eqId_iff_eq /-
theorem eqId_iff_eq : A.EqId â†” A.1 = Î” := by
  constructor
  Â· intro h
    dsimp at h
    rw [h]
    rfl
  Â· intro h
    rcases A with âŸ¨Î”', âŸ¨f, hfâŸ©âŸ©
    simp only at h
    subst h
    refine' ext _ _ rfl _
    Â· haveI := hf
      simp only [eq_to_hom_refl, comp_id]
      exact eq_id_of_epi f
#align simplicial_object.splitting.index_set.eq_id_iff_eq SimplicialObject.Splitting.IndexSet.eqId_iff_eq
-/

#print SimplicialObject.Splitting.IndexSet.eqId_iff_len_eq /-
theorem eqId_iff_len_eq : A.EqId â†” A.1.unop.len = Î”.unop.len :=
  by
  rw [eq_id_iff_eq]
  constructor
  Â· intro h
    rw [h]
  Â· intro h
    rw [â† unop_inj_iff]
    ext
    exact h
#align simplicial_object.splitting.index_set.eq_id_iff_len_eq SimplicialObject.Splitting.IndexSet.eqId_iff_len_eq
-/

#print SimplicialObject.Splitting.IndexSet.eqId_iff_len_le /-
theorem eqId_iff_len_le : A.EqId â†” Î”.unop.len â‰¤ A.1.unop.len :=
  by
  rw [eq_id_iff_len_eq]
  constructor
  Â· intro h
    rw [h]
  Â· exact le_antisymm (len_le_of_epi (inferInstance : epi A.e))
#align simplicial_object.splitting.index_set.eq_id_iff_len_le SimplicialObject.Splitting.IndexSet.eqId_iff_len_le
-/

#print SimplicialObject.Splitting.IndexSet.eqId_iff_mono /-
theorem eqId_iff_mono : A.EqId â†” Mono A.e :=
  by
  constructor
  Â· intro h
    dsimp at h
    subst h
    dsimp only [id, e]
    infer_instance
  Â· intro h
    rw [eq_id_iff_len_le]
    exact len_le_of_mono h
#align simplicial_object.splitting.index_set.eq_id_iff_mono SimplicialObject.Splitting.IndexSet.eqId_iff_mono
-/

#print SimplicialObject.Splitting.IndexSet.epiComp /-
/-- Given `A : index_set Î”â‚`, if `p.unop : unop Î”â‚‚ âŸ¶ unop Î”â‚` is an epi, this
is the obvious element in `A : index_set Î”â‚‚` associated to the composition
of epimorphisms `p.unop â‰« A.e`. -/
@[simps]
def epiComp {Î”â‚ Î”â‚‚ : SimplexCategoryáµ’áµ–} (A : IndexSet Î”â‚) (p : Î”â‚ âŸ¶ Î”â‚‚) [Epi p.unop] :
    IndexSet Î”â‚‚ :=
  âŸ¨A.1, âŸ¨p.unop â‰« A.e, epi_comp _ _âŸ©âŸ©
#align simplicial_object.splitting.index_set.epi_comp SimplicialObject.Splitting.IndexSet.epiComp
-/

/- warning: simplicial_object.splitting.index_set.pull -> SimplicialObject.Splitting.IndexSet.pull is a dubious translation:
lean 3 declaration is
  forall {Î”' : Opposite.{1} SimplexCategory} {Î” : Opposite.{1} SimplexCategory}, (SimplicialObject.Splitting.IndexSet Î”) -> (Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î” Î”') -> (SimplicialObject.Splitting.IndexSet Î”')
but is expected to have type
  forall {Î”' : Opposite.{1} SimplexCategory}, (SimplicialObject.Splitting.IndexSet Î”') -> (forall {A : Opposite.{1} SimplexCategory}, (Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î”' A) -> (SimplicialObject.Splitting.IndexSet A))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.index_set.pull SimplicialObject.Splitting.IndexSet.pullâ‚“'. -/
/-- When `A : index_set Î”` and `Î¸ : Î” â†’ Î”'` is a morphism in `simplex_categoryáµ’áµ–`,
an element in `index_set Î”'` can be defined by using the epi-mono factorisation
of `Î¸.unop â‰« A.e`. -/
def pull : IndexSet Î”' :=
  mk (factorThruImage (Î¸.unop â‰« A.e))
#align simplicial_object.splitting.index_set.pull SimplicialObject.Splitting.IndexSet.pull

/- warning: simplicial_object.splitting.index_set.fac_pull -> SimplicialObject.Splitting.IndexSet.fac_pull is a dubious translation:
lean 3 declaration is
  forall {Î”' : Opposite.{1} SimplexCategory} {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”) (Î¸ : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î” Î”'), Eq.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) (SimplicialObject.Splitting.IndexSet.pull Î”' Î” A Î¸))) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (SimplicialObject.Splitting.IndexSet.e Î”' (SimplicialObject.Splitting.IndexSet.pull Î”' Î” A Î¸)) (CategoryTheory.Limits.image.Î¹.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A)) (SimplicialObject.Splitting.IndexSet.pull._proof_1 Î”' Î” A Î¸))) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î” Î”' Î¸) (SimplicialObject.Splitting.IndexSet.e Î” A))
but is expected to have type
  forall {Î”' : Opposite.{1} SimplexCategory} (Î” : SimplicialObject.Splitting.IndexSet Î”') {A : Opposite.{1} SimplexCategory} (Î¸ : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î”' A), Eq.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) Î”))) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.pull Î”' Î” A Î¸))) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) Î”)) (SimplicialObject.Splitting.IndexSet.e A (SimplicialObject.Splitting.IndexSet.pull Î”' Î” A Î¸)) (CategoryTheory.Limits.image.Î¹.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) Î”)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) Î”)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' A Î¸) (SimplicialObject.Splitting.IndexSet.e Î”' Î”)) (CategoryTheory.Limits.HasImages.has_image.{0, 0} SimplexCategory SimplexCategory.smallCategory (CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations.{0, 0} SimplexCategory SimplexCategory.smallCategory SimplexCategory.instHasStrongEpiMonoFactorisationsSimplexCategorySmallCategory) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) Î”)) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) Î”)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' A Î¸) (SimplicialObject.Splitting.IndexSet.e Î”' Î”))))) (CategoryTheory.CategoryStruct.comp.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory) (Opposite.unop.{1} SimplexCategory A) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”'_1 : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1)) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”') (Opposite.unop.{1} SimplexCategory Î”'_1) Î±)) Î”)) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”' A Î¸) (SimplicialObject.Splitting.IndexSet.e Î”' Î”))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.index_set.fac_pull SimplicialObject.Splitting.IndexSet.fac_pullâ‚“'. -/
@[reassoc]
theorem fac_pull : (A.pull Î¸).e â‰« image.Î¹ (Î¸.unop â‰« A.e) = Î¸.unop â‰« A.e :=
  image.fac _
#align simplicial_object.splitting.index_set.fac_pull SimplicialObject.Splitting.IndexSet.fac_pull

end IndexSet

variable (N : â„• â†’ C) (Î” : SimplexCategoryáµ’áµ–) (X : SimplicialObject C) (Ï† : âˆ€ n, N n âŸ¶ X _[n])

/- warning: simplicial_object.splitting.summand -> SimplicialObject.Splitting.summand is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u_1}} [_inst_1 : CategoryTheory.Category.{u_2, u_1} C], (Nat -> C) -> (forall (Î” : Opposite.{1} SimplexCategory), (SimplicialObject.Splitting.IndexSet Î”) -> C)
but is expected to have type
  forall {C : Type.{u_1}}, (Nat -> C) -> (forall (N : Opposite.{1} SimplexCategory), (SimplicialObject.Splitting.IndexSet N) -> C)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.summand SimplicialObject.Splitting.summandâ‚“'. -/
/-- Given a sequences of objects `N : â„• â†’ C` in a category `C`, this is
a family of objects indexed by the elements `A : splitting.index_set Î”`.
The `Î”`-simplices of a split simplicial objects shall identify to the
coproduct of objects in such a family. -/
@[simp, nolint unused_arguments]
def summand (A : IndexSet Î”) : C :=
  N A.1.unop.len
#align simplicial_object.splitting.summand SimplicialObject.Splitting.summand

variable [HasFiniteCoproducts C]

#print SimplicialObject.Splitting.coprod /-
/-- The coproduct of the family `summand N Î”` -/
@[simp]
def coprod :=
  âˆ summand N Î”
#align simplicial_object.splitting.coprod SimplicialObject.Splitting.coprod
-/

variable {Î”}

#print SimplicialObject.Splitting.Î¹Coprod /-
/-- The inclusion of a summand in the coproduct. -/
@[simp]
def Î¹Coprod (A : IndexSet Î”) : N A.1.unop.len âŸ¶ coprod N Î” :=
  Sigma.Î¹ _ A
#align simplicial_object.splitting.Î¹_coprod SimplicialObject.Splitting.Î¹Coprod
-/

variable {N}

/- warning: simplicial_object.splitting.map -> SimplicialObject.Splitting.map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {N : Nat -> C} (X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1), (forall (n : Nat), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (N n) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) -> (forall [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 N Î” _inst_2) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {N : Nat -> C} (X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1), (forall (n : Nat), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (N n) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) -> (forall [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (Î” : Opposite.{1} SimplexCategory), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 N Î” _inst_2) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.map SimplicialObject.Splitting.mapâ‚“'. -/
/-- The canonical morphism `coprod N Î” âŸ¶ X.obj Î”` attached to a sequence
of objects `N` and a sequence of morphisms `N n âŸ¶ X _[n]`. -/
@[simp]
def map (Î” : SimplexCategoryáµ’áµ–) : coprod N Î” âŸ¶ X.obj Î” :=
  Sigma.desc fun A => Ï† A.1.unop.len â‰« X.map A.e.op
#align simplicial_object.splitting.map SimplicialObject.Splitting.map

end Splitting

variable [HasFiniteCoproducts C]

#print SimplicialObject.Splitting /-
/-- A splitting of a simplicial object `X` consists of the datum of a sequence
of objects `N`, a sequence of morphisms `Î¹ : N n âŸ¶ X _[n]` such that
for all `Î” : simplex_categoryháµ’áµ–`, the canonical map `splitting.map X Î¹ Î”`
is an isomorphism. -/
@[nolint has_nonempty_instance]
structure Splitting (X : SimplicialObject C) where
  n : â„• â†’ C
  Î¹ : âˆ€ n, N n âŸ¶ X _[n]
  map_is_iso' : âˆ€ Î” : SimplexCategoryáµ’áµ–, IsIso (Splitting.map X Î¹ Î”)
#align simplicial_object.splitting SimplicialObject.Splitting
-/

namespace Splitting

variable {X Y : SimplicialObject C} (s : Splitting X)

/- warning: simplicial_object.splitting.map_is_iso -> SimplicialObject.Splitting.map_isIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (Î” : Opposite.{1} SimplexCategory), CategoryTheory.IsIso.{u2, u1} C _inst_1 (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (fun (n : Nat) => SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s n) Î” _inst_2) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (SimplicialObject.Splitting.map.{u1, u2} C _inst_1 (fun (n : Nat) => SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s n) X (SimplicialObject.Splitting.Î¹.{u1, u2} C _inst_1 _inst_2 X s) _inst_2 Î”)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (Î” : Opposite.{1} SimplexCategory), CategoryTheory.IsIso.{u2, u1} C _inst_1 (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (fun (n : Nat) => SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s n) Î” _inst_2) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (SimplicialObject.Splitting.map.{u1, u2} C _inst_1 (fun (n : Nat) => SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s n) X (SimplicialObject.Splitting.Î¹.{u1, u2} C _inst_1 _inst_2 X s) _inst_2 Î”)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.map_is_iso SimplicialObject.Splitting.map_isIsoâ‚“'. -/
instance map_isIso (Î” : SimplexCategoryáµ’áµ–) : IsIso (Splitting.map X s.Î¹ Î”) :=
  s.map_is_iso' Î”
#align simplicial_object.splitting.map_is_iso SimplicialObject.Splitting.map_isIso

/- warning: simplicial_object.splitting.iso -> SimplicialObject.Splitting.iso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (Î” : Opposite.{1} SimplexCategory), CategoryTheory.Iso.{u2, u1} C _inst_1 (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s) Î” _inst_2) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (Î” : Opposite.{1} SimplexCategory), CategoryTheory.Iso.{u2, u1} C _inst_1 (SimplicialObject.Splitting.coprod.{u1, u2} C _inst_1 (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s) Î” _inst_2) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.iso SimplicialObject.Splitting.isoâ‚“'. -/
/-- The isomorphism on simplices given by the axiom `splitting.map_is_iso'` -/
@[simps]
def iso (Î” : SimplexCategoryáµ’áµ–) : coprod s.n Î” â‰… X.obj Î” :=
  asIso (Splitting.map X s.Î¹ Î”)
#align simplicial_object.splitting.iso SimplicialObject.Splitting.iso

/- warning: simplicial_object.splitting.Î¹_summand -> SimplicialObject.Splitting.Î¹Summand is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_summand SimplicialObject.Splitting.Î¹Summandâ‚“'. -/
/-- Via the isomorphism `s.iso Î”`, this is the inclusion of a summand
in the direct sum decomposition given by the splitting `s : splitting X`. -/
def Î¹Summand {Î” : SimplexCategoryáµ’áµ–} (A : IndexSet Î”) : s.n A.1.unop.len âŸ¶ X.obj Î” :=
  Splitting.Î¹Coprod s.n A â‰« (s.Iso Î”).Hom
#align simplicial_object.splitting.Î¹_summand SimplicialObject.Splitting.Î¹Summand

/- warning: simplicial_object.splitting.Î¹_summand_eq -> SimplicialObject.Splitting.Î¹Summand_eq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”)) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (SimplicialObject.Splitting.Î¹.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.map.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))) Î” (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (SimplicialObject.Splitting.IndexSet.e Î” A))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”)) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (Opposite.unop.{1} SimplexCategory Î”))) (SimplicialObject.Splitting.Î¹.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.map.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))) (Opposite.op.{1} SimplexCategory (Opposite.unop.{1} SimplexCategory Î”)) (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (SimplicialObject.Splitting.IndexSet.e Î” A))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_summand_eq SimplicialObject.Splitting.Î¹Summand_eqâ‚“'. -/
@[reassoc]
theorem Î¹Summand_eq {Î” : SimplexCategoryáµ’áµ–} (A : IndexSet Î”) :
    s.Î¹Summand A = s.Î¹ A.1.unop.len â‰« X.map A.e.op :=
  by
  dsimp only [Î¹_summand, iso.hom]
  erw [colimit.Î¹_desc, cofan.mk_Î¹_app]
#align simplicial_object.splitting.Î¹_summand_eq SimplicialObject.Splitting.Î¹Summand_eq

/- warning: simplicial_object.splitting.Î¹_summand_id -> SimplicialObject.Splitting.Î¹Summand_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (SimplicialObject.Splitting.Î¹.{u1, u2} C _inst_1 _inst_2 X s n)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))) (Opposite.unop.{1} SimplexCategory Î”') Î±)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)) (SimplicialObject.Splitting.IndexSet.id (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (SimplicialObject.Splitting.Î¹.{u1, u2} C _inst_1 _inst_2 X s n)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_summand_id SimplicialObject.Splitting.Î¹Summand_idâ‚“'. -/
theorem Î¹Summand_id (n : â„•) : s.Î¹Summand (IndexSet.id (op [n])) = s.Î¹ n :=
  by
  erw [Î¹_summand_eq, X.map_id, comp_id]
  rfl
#align simplicial_object.splitting.Î¹_summand_id SimplicialObject.Splitting.Î¹Summand_id

/- warning: simplicial_object.splitting.Ï† -> SimplicialObject.Splitting.Ï† is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} {Y : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X), (Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) X Y) -> (forall (n : Nat), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s n) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} {Y : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X), (Quiver.Hom.{succ u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1))) X Y) -> (forall (n : Nat), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s n) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Ï† SimplicialObject.Splitting.Ï†â‚“'. -/
/-- As it is stated in `splitting.hom_ext`, a morphism `f : X âŸ¶ Y` from a split
simplicial object to any simplicial object is determined by its restrictions
`s.Ï† f n : s.N n âŸ¶ Y _[n]` to the distinguished summands in each degree `n`. -/
@[simp]
def Ï† (f : X âŸ¶ Y) (n : â„•) : s.n n âŸ¶ Y _[n] :=
  s.Î¹ n â‰« f.app (op [n])
#align simplicial_object.splitting.Ï† SimplicialObject.Splitting.Ï†

/- warning: simplicial_object.splitting.Î¹_summand_comp_app -> SimplicialObject.Splitting.Î¹Summand_comp_app is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} {Y : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (f : Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) X Y) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y Î”)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y Î”) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (CategoryTheory.NatTrans.app.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Y f Î”)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y Î”) (SimplicialObject.Splitting.Ï†.{u1, u2} C _inst_1 _inst_2 X Y s f (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.map.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))) Î” (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (SimplicialObject.Splitting.IndexSet.e Î” A))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} {Y : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (f : Quiver.Hom.{succ u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1))) X Y) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y) Î”)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y) Î”) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (CategoryTheory.NatTrans.app.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Y f Î”)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y) (Opposite.op.{1} SimplexCategory (Opposite.unop.{1} SimplexCategory Î”))) (SimplicialObject.Splitting.Ï†.{u1, u2} C _inst_1 _inst_2 X Y s f (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.map.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A))))) (Opposite.op.{1} SimplexCategory (Opposite.unop.{1} SimplexCategory Î”)) (Quiver.Hom.op.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)) (SimplicialObject.Splitting.IndexSet.e Î” A))))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_summand_comp_app SimplicialObject.Splitting.Î¹Summand_comp_appâ‚“'. -/
@[simp, reassoc]
theorem Î¹Summand_comp_app (f : X âŸ¶ Y) {Î” : SimplexCategoryáµ’áµ–} (A : IndexSet Î”) :
    s.Î¹Summand A â‰« f.app Î” = s.Ï† f A.1.unop.len â‰« Y.map A.e.op := by
  simp only [Î¹_summand_eq_assoc, Ï†, nat_trans.naturality, assoc]
#align simplicial_object.splitting.Î¹_summand_comp_app SimplicialObject.Splitting.Î¹Summand_comp_app

/- warning: simplicial_object.splitting.hom_ext' -> SimplicialObject.Splitting.hom_ext' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Z : C} {Î” : Opposite.{1} SimplexCategory} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) Z) (g : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) Z), (forall (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) Z (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) f) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) Z (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) g)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) Z) f g)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Z : C} {Î” : Opposite.{1} SimplexCategory} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) Z) (g : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) Z), (forall (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) Z (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) f) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) Z (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) g)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) Z) f g)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.hom_ext' SimplicialObject.Splitting.hom_ext'â‚“'. -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[] -/
theorem hom_ext' {Z : C} {Î” : SimplexCategoryáµ’áµ–} (f g : X.obj Î” âŸ¶ Z)
    (h : âˆ€ A : IndexSet Î”, s.Î¹Summand A â‰« f = s.Î¹Summand A â‰« g) : f = g :=
  by
  rw [â† cancel_epi (s.iso Î”).Hom]
  ext A
  trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[]"
  simpa only [Î¹_summand_eq, iso_hom, colimit.Î¹_desc_assoc, cofan.mk_Î¹_app, assoc] using h A
#align simplicial_object.splitting.hom_ext' SimplicialObject.Splitting.hom_ext'

/- warning: simplicial_object.splitting.hom_ext -> SimplicialObject.Splitting.hom_ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} {Y : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (f : Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) X Y) (g : Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) X Y), (forall (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s n) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (SimplicialObject.Splitting.Ï†.{u1, u2} C _inst_1 _inst_2 X Y s f n) (SimplicialObject.Splitting.Ï†.{u1, u2} C _inst_1 _inst_2 X Y s g n)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) X Y) f g)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} {Y : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) (f : Quiver.Hom.{succ u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1))) X Y) (g : Quiver.Hom.{succ u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1))) X Y), (forall (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s n) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 Y) (Opposite.op.{1} SimplexCategory (SimplexCategory.mk n)))) (SimplicialObject.Splitting.Ï†.{u1, u2} C _inst_1 _inst_2 X Y s f n) (SimplicialObject.Splitting.Ï†.{u1, u2} C _inst_1 _inst_2 X Y s g n)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1))) X Y) f g)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.hom_ext SimplicialObject.Splitting.hom_extâ‚“'. -/
theorem hom_ext (f g : X âŸ¶ Y) (h : âˆ€ n : â„•, s.Ï† f n = s.Ï† g n) : f = g :=
  by
  ext Î”
  apply s.hom_ext'
  intro A
  induction Î” using Opposite.rec'
  induction' Î” using SimplexCategory.rec with n
  dsimp
  simp only [s.Î¹_summand_comp_app, h]
#align simplicial_object.splitting.hom_ext SimplicialObject.Splitting.hom_ext

/- warning: simplicial_object.splitting.desc -> SimplicialObject.Splitting.desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Z : C} (Î” : Opposite.{1} SimplexCategory), (forall (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) -> (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) Z)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Z : C} (Î” : Opposite.{1} SimplexCategory), (forall (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) -> (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) Z)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.desc SimplicialObject.Splitting.descâ‚“'. -/
/-- The map `X.obj Î” âŸ¶ Z` obtained by providing a family of morphisms on all the
terms of decomposition given by a splitting `s : splitting X`  -/
def desc {Z : C} (Î” : SimplexCategoryáµ’áµ–) (F : âˆ€ A : IndexSet Î”, s.n A.1.unop.len âŸ¶ Z) :
    X.obj Î” âŸ¶ Z :=
  (s.Iso Î”).inv â‰« Sigma.desc F
#align simplicial_object.splitting.desc SimplicialObject.Splitting.desc

/- warning: simplicial_object.splitting.Î¹_desc -> SimplicialObject.Splitting.Î¹_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Z : C} (Î” : Opposite.{1} SimplexCategory) (F : forall (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”) Z (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (SimplicialObject.Splitting.desc.{u1, u2} C _inst_1 _inst_2 X s Z Î” F)) (F A)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Z : C} (Î” : Opposite.{1} SimplexCategory) (F : forall (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) Z) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”) Z (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î” A) (SimplicialObject.Splitting.desc.{u1, u2} C _inst_1 _inst_2 X s Z Î” F)) (F A)
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_desc SimplicialObject.Splitting.Î¹_descâ‚“'. -/
@[simp, reassoc]
theorem Î¹_desc {Z : C} (Î” : SimplexCategoryáµ’áµ–) (F : âˆ€ A : IndexSet Î”, s.n A.1.unop.len âŸ¶ Z)
    (A : IndexSet Î”) : s.Î¹Summand A â‰« s.desc Î” F = F A :=
  by
  dsimp only [Î¹_summand, desc]
  simp only [assoc, iso.hom_inv_id_assoc, Î¹_coprod]
  erw [colimit.Î¹_desc, cofan.mk_Î¹_app]
#align simplicial_object.splitting.Î¹_desc SimplicialObject.Splitting.Î¹_desc

#print SimplicialObject.Splitting.ofIso /-
/-- A simplicial object that is isomorphic to a split simplicial object is split. -/
@[simps]
def ofIso (e : X â‰… Y) : Splitting Y where
  n := s.n
  Î¹ n := s.Î¹ n â‰« e.Hom.app (op [n])
  map_is_iso' Î” := by
    convert(inferInstance : is_iso ((s.iso Î”).Hom â‰« e.hom.app Î”))
    tidy
#align simplicial_object.splitting.of_iso SimplicialObject.Splitting.ofIso
-/

/- warning: simplicial_object.splitting.Î¹_summand_epi_naturality -> SimplicialObject.Splitting.Î¹Summand_epi_naturality is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Î”â‚ : Opposite.{1} SimplexCategory} {Î”â‚‚ : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”â‚) (p : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î”â‚ Î”â‚‚) [_inst_3 : CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”â‚‚) (Opposite.unop.{1} SimplexCategory Î”â‚) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”â‚ Î”â‚‚ p)], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”â‚‚)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”â‚) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”â‚‚) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î”â‚ A) (CategoryTheory.Functor.map.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X Î”â‚ Î”â‚‚ p)) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î”â‚‚ (SimplicialObject.Splitting.IndexSet.epiComp Î”â‚ Î”â‚‚ A p _inst_3))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {X : CategoryTheory.SimplicialObject.{u2, u1} C _inst_1} (s : SimplicialObject.Splitting.{u1, u2} C _inst_1 _inst_2 X) {Î”â‚ : Opposite.{1} SimplexCategory} {Î”â‚‚ : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”â‚) (p : Quiver.Hom.{1, 0} (Opposite.{1} SimplexCategory) (Quiver.opposite.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory))) Î”â‚ Î”â‚‚) [_inst_3 : CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”â‚‚) (Opposite.unop.{1} SimplexCategory Î”â‚) (Quiver.Hom.unop.{0, 1} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) Î”â‚ Î”â‚‚ p)], Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”â‚‚)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.N.{u1, u2} C _inst_1 _inst_2 X s (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”â‚) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”â‚) (Prefunctor.obj.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”â‚‚) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î”â‚ A) (Prefunctor.map.{1, succ u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 X) Î”â‚ Î”â‚‚ p)) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 X s Î”â‚‚ (SimplicialObject.Splitting.IndexSet.epiComp Î”â‚ Î”â‚‚ A p _inst_3))
Case conversion may be inaccurate. Consider using '#align simplicial_object.splitting.Î¹_summand_epi_naturality SimplicialObject.Splitting.Î¹Summand_epi_naturalityâ‚“'. -/
@[reassoc]
theorem Î¹Summand_epi_naturality {Î”â‚ Î”â‚‚ : SimplexCategoryáµ’áµ–} (A : IndexSet Î”â‚) (p : Î”â‚ âŸ¶ Î”â‚‚)
    [Epi p.unop] : s.Î¹Summand A â‰« X.map p = s.Î¹Summand (A.epi_comp p) :=
  by
  dsimp [Î¹_summand]
  erw [colimit.Î¹_desc, colimit.Î¹_desc, cofan.mk_Î¹_app, cofan.mk_Î¹_app]
  dsimp only [index_set.epi_comp, index_set.e]
  rw [op_comp, X.map_comp, assoc, Quiver.Hom.op_unop]
#align simplicial_object.splitting.Î¹_summand_epi_naturality SimplicialObject.Splitting.Î¹Summand_epi_naturality

end Splitting

variable (C)

#print SimplicialObject.Split /-
/-- The category `simplicial_object.split C` is the category of simplicial objects
in `C` equipped with a splitting, and morphisms are morphisms of simplicial objects
which are compatible with the splittings. -/
@[ext, nolint has_nonempty_instance]
structure Split where
  pt : SimplicialObject C
  s : Splitting X
#align simplicial_object.split SimplicialObject.Split
-/

namespace Split

variable {C}

#print SimplicialObject.Split.mk' /-
/-- The object in `simplicial_object.split C` attached to a splitting `s : splitting X`
of a simplicial object `X`. -/
@[simps]
def mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=
  âŸ¨X, sâŸ©
#align simplicial_object.split.mk' SimplicialObject.Split.mk'
-/

#print SimplicialObject.Split.Hom /-
/-- Morphisms in `simplicial_object.split C` are morphisms of simplicial objects that
are compatible with the splittings. -/
@[nolint has_nonempty_instance]
structure Hom (Sâ‚ Sâ‚‚ : Split C) where
  f : Sâ‚.pt âŸ¶ Sâ‚‚.pt
  f : âˆ€ n : â„•, Sâ‚.s.n n âŸ¶ Sâ‚‚.s.n n
  comm' : âˆ€ n : â„•, Sâ‚.s.Î¹ n â‰« F.app (op [n]) = f n â‰« Sâ‚‚.s.Î¹ n
#align simplicial_object.split.hom SimplicialObject.Split.Hom
-/

/- warning: simplicial_object.split.hom.ext -> SimplicialObject.Split.Hom.ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} (Î¦â‚ : SimplicialObject.Split.Hom.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚) (Î¦â‚‚ : SimplicialObject.Split.Hom.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚), (forall (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) n)) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚ n) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚‚ n)) -> (Eq.{succ u2} (SimplicialObject.Split.Hom.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚) Î¦â‚ Î¦â‚‚)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} (Î¦â‚ : SimplicialObject.Split.Hom.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚) (Î¦â‚‚ : SimplicialObject.Split.Hom.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚), (forall (n : Nat), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) n)) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚ n) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚‚ n)) -> (Eq.{succ u1} (SimplicialObject.Split.Hom.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚) Î¦â‚ Î¦â‚‚)
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.hom.ext SimplicialObject.Split.Hom.extâ‚“'. -/
@[ext]
theorem Hom.ext {Sâ‚ Sâ‚‚ : Split C} (Î¦â‚ Î¦â‚‚ : Hom Sâ‚ Sâ‚‚) (h : âˆ€ n : â„•, Î¦â‚.f n = Î¦â‚‚.f n) : Î¦â‚ = Î¦â‚‚ :=
  by
  rcases Î¦â‚ with âŸ¨Fâ‚, fâ‚, câ‚âŸ©
  rcases Î¦â‚‚ with âŸ¨Fâ‚‚, fâ‚‚, câ‚‚âŸ©
  have h' : fâ‚ = fâ‚‚ := by
    ext
    apply h
  subst h'
  simp only [eq_self_iff_true, and_true_iff]
  apply Sâ‚.s.hom_ext
  intro n
  dsimp
  rw [câ‚, câ‚‚]
#align simplicial_object.split.hom.ext SimplicialObject.Split.Hom.ext

restate_axiom hom.comm'

attribute [simp, reassoc] hom.comm

end Split

instance : Category (Split C) where
  Hom := Split.Hom
  id S :=
    { f := ðŸ™ _
      f := fun n => ðŸ™ _
      comm' := by tidy }
  comp Sâ‚ Sâ‚‚ Sâ‚ƒ Î¦â‚â‚‚ Î¦â‚‚â‚ƒ :=
    { f := Î¦â‚â‚‚.f â‰« Î¦â‚‚â‚ƒ.f
      f := fun n => Î¦â‚â‚‚.f n â‰« Î¦â‚‚â‚ƒ.f n
      comm' := by tidy }

variable {C}

namespace Split

/- warning: simplicial_object.split.congr_F -> SimplicialObject.Split.congr_F is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Î¦â‚ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚} {Î¦â‚‚ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚}, (Eq.{succ u2} (Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) Î¦â‚ Î¦â‚‚) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚)) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚‚))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Î¦â‚ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚} {Î¦â‚‚ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚}, (Eq.{succ u1} (Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) Î¦â‚ Î¦â‚‚) -> (Eq.{succ u1} (forall (n : Nat), Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) n)) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚‚))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.congr_F SimplicialObject.Split.congr_Fâ‚“'. -/
theorem congr_F {Sâ‚ Sâ‚‚ : Split C} {Î¦â‚ Î¦â‚‚ : Sâ‚ âŸ¶ Sâ‚‚} (h : Î¦â‚ = Î¦â‚‚) : Î¦â‚.f = Î¦â‚‚.f := by rw [h]
#align simplicial_object.split.congr_F SimplicialObject.Split.congr_F

/- warning: simplicial_object.split.congr_f -> SimplicialObject.Split.congr_f is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Î¦â‚ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚} {Î¦â‚‚ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚}, (Eq.{succ u2} (Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) Î¦â‚ Î¦â‚‚) -> (forall (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) n)) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚ n) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚‚ n))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Î¦â‚ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚} {Î¦â‚‚ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚}, (Eq.{succ u1} (Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) Î¦â‚ Î¦â‚‚) -> (forall (n : Nat), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) n)) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚ n) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚‚ n))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.congr_f SimplicialObject.Split.congr_fâ‚“'. -/
theorem congr_f {Sâ‚ Sâ‚‚ : Split C} {Î¦â‚ Î¦â‚‚ : Sâ‚ âŸ¶ Sâ‚‚} (h : Î¦â‚ = Î¦â‚‚) (n : â„•) : Î¦â‚.f n = Î¦â‚‚.f n := by
  rw [h]
#align simplicial_object.split.congr_f SimplicialObject.Split.congr_f

/- warning: simplicial_object.split.id_F -> SimplicialObject.Split.id_F is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (S : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2), Eq.{succ u2} (Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 S) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 S)) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 S S (CategoryTheory.CategoryStruct.id.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2)) S)) (CategoryTheory.CategoryStruct.id.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1)) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 S))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] (S : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2), Eq.{succ u1} (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u1, u2} C _inst_1))) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 S) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 S)) (SimplicialObject.Split.Hom.F.{u2, u1} C _inst_1 _inst_2 S S (CategoryTheory.CategoryStruct.id.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2)) S)) (CategoryTheory.CategoryStruct.id.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u1, u2} C _inst_1)) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 S))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.id_F SimplicialObject.Split.id_Fâ‚“'. -/
@[simp]
theorem id_F (S : Split C) : (ðŸ™ S : S âŸ¶ S).f = ðŸ™ S.pt :=
  rfl
#align simplicial_object.split.id_F SimplicialObject.Split.id_F

/- warning: simplicial_object.split.id_f -> SimplicialObject.Split.id_f is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] (S : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 S) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 S) n) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 S) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 S) n)) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 S S (CategoryTheory.CategoryStruct.id.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2)) S) n) (CategoryTheory.CategoryStruct.id.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 S) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 S) n))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] (S : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (n : Nat), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 S) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 S) n) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 S) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 S) n)) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 S S (CategoryTheory.CategoryStruct.id.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2)) S) n) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 S) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 S) n))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.id_f SimplicialObject.Split.id_fâ‚“'. -/
@[simp]
theorem id_f (S : Split C) (n : â„•) : (ðŸ™ S : S âŸ¶ S).f n = ðŸ™ (S.s.n n) :=
  rfl
#align simplicial_object.split.id_f SimplicialObject.Split.id_f

/- warning: simplicial_object.split.comp_F -> SimplicialObject.Split.comp_F is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚ƒ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} (Î¦â‚â‚‚ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) (Î¦â‚‚â‚ƒ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚‚ Sâ‚ƒ), Eq.{succ u2} (Quiver.Hom.{succ u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1))) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚ƒ)) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚ƒ (CategoryTheory.CategoryStruct.comp.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2)) Sâ‚ Sâ‚‚ Sâ‚ƒ Î¦â‚â‚‚ Î¦â‚‚â‚ƒ)) (CategoryTheory.CategoryStruct.comp.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u2, max u2 u1} (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1)) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚ƒ) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚â‚‚) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚‚ Sâ‚ƒ Î¦â‚‚â‚ƒ))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚ƒ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} (Î¦â‚â‚‚ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) (Î¦â‚‚â‚ƒ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚‚ Sâ‚ƒ), Eq.{succ u1} (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u1, u2} C _inst_1))) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚ƒ)) (SimplicialObject.Split.Hom.F.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚ƒ (CategoryTheory.CategoryStruct.comp.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2)) Sâ‚ Sâ‚‚ Sâ‚ƒ Î¦â‚â‚‚ Î¦â‚‚â‚ƒ)) (CategoryTheory.CategoryStruct.comp.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.SimplicialObject.{u1, u2} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u1, u2} C _inst_1)) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚ƒ) (SimplicialObject.Split.Hom.F.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚â‚‚) (SimplicialObject.Split.Hom.F.{u2, u1} C _inst_1 _inst_2 Sâ‚‚ Sâ‚ƒ Î¦â‚‚â‚ƒ))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.comp_F SimplicialObject.Split.comp_Fâ‚“'. -/
@[simp]
theorem comp_F {Sâ‚ Sâ‚‚ Sâ‚ƒ : Split C} (Î¦â‚â‚‚ : Sâ‚ âŸ¶ Sâ‚‚) (Î¦â‚‚â‚ƒ : Sâ‚‚ âŸ¶ Sâ‚ƒ) :
    (Î¦â‚â‚‚ â‰« Î¦â‚‚â‚ƒ).f = Î¦â‚â‚‚.f â‰« Î¦â‚‚â‚ƒ.f :=
  rfl
#align simplicial_object.split.comp_F SimplicialObject.Split.comp_F

/- warning: simplicial_object.split.comp_f -> SimplicialObject.Split.comp_f is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚ƒ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} (Î¦â‚â‚‚ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) (Î¦â‚‚â‚ƒ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚‚ Sâ‚ƒ) (n : Nat), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚ƒ) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚ƒ) n)) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚ƒ (CategoryTheory.CategoryStruct.comp.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2)) Sâ‚ Sâ‚‚ Sâ‚ƒ Î¦â‚â‚‚ Î¦â‚‚â‚ƒ) n) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) n) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚ƒ) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚ƒ) n) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚â‚‚ n) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚‚ Sâ‚ƒ Î¦â‚‚â‚ƒ n))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚ƒ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} (Î¦â‚â‚‚ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) (Î¦â‚‚â‚ƒ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚‚ Sâ‚ƒ) (n : Nat), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚ƒ) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚ƒ) n)) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚ƒ (CategoryTheory.CategoryStruct.comp.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2)) Sâ‚ Sâ‚‚ Sâ‚ƒ Î¦â‚â‚‚ Î¦â‚‚â‚ƒ) n) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) n) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) n) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚ƒ) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚ƒ) n) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦â‚â‚‚ n) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚‚ Sâ‚ƒ Î¦â‚‚â‚ƒ n))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.comp_f SimplicialObject.Split.comp_fâ‚“'. -/
@[simp]
theorem comp_f {Sâ‚ Sâ‚‚ Sâ‚ƒ : Split C} (Î¦â‚â‚‚ : Sâ‚ âŸ¶ Sâ‚‚) (Î¦â‚‚â‚ƒ : Sâ‚‚ âŸ¶ Sâ‚ƒ) (n : â„•) :
    (Î¦â‚â‚‚ â‰« Î¦â‚‚â‚ƒ).f n = Î¦â‚â‚‚.f n â‰« Î¦â‚‚â‚ƒ.f n :=
  rfl
#align simplicial_object.split.comp_f SimplicialObject.Split.comp_f

/- warning: simplicial_object.split.Î¹_summand_naturality_symm -> SimplicialObject.Split.Î¹Summand_naturality_symm is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2} (Î¦ : Quiver.Hom.{succ u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) Î”)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) Î”) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) Î”) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) Î” A) (CategoryTheory.NatTrans.app.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦) Î”)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.n.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.obj.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) Î”) (SimplicialObject.Split.Hom.f.{u1, u2} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦ (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.Î¹Summand.{u1, u2} C _inst_1 _inst_2 (SimplicialObject.Split.x.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u1, u2} C _inst_1 _inst_2 Sâ‚‚) Î” A))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u1, u2} C _inst_1] {Sâ‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} {Sâ‚‚ : SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2} (Î¦ : Quiver.Hom.{succ u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (SimplicialObject.Split.{u2, u1} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u2, u1} C _inst_1 _inst_2))) Sâ‚ Sâ‚‚) {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚)) Î”)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚)) Î”) (Prefunctor.obj.{1, succ u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚)) Î”) (SimplicialObject.Splitting.Î¹Summand.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) Î” A) (CategoryTheory.NatTrans.app.{0, u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.Hom.F.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦) Î”)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.N.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (Prefunctor.obj.{1, succ u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚)) Î”) (SimplicialObject.Split.Hom.f.{u2, u1} C _inst_1 _inst_2 Sâ‚ Sâ‚‚ Î¦ (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (SimplicialObject.Splitting.Î¹Summand.{u2, u1} C _inst_1 _inst_2 (SimplicialObject.Split.X.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) (SimplicialObject.Split.s.{u2, u1} C _inst_1 _inst_2 Sâ‚‚) Î” A))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.Î¹_summand_naturality_symm SimplicialObject.Split.Î¹Summand_naturality_symmâ‚“'. -/
@[simp, reassoc]
theorem Î¹Summand_naturality_symm {Sâ‚ Sâ‚‚ : Split C} (Î¦ : Sâ‚ âŸ¶ Sâ‚‚) {Î” : SimplexCategoryáµ’áµ–}
    (A : Splitting.IndexSet Î”) : Sâ‚.s.Î¹Summand A â‰« Î¦.f.app Î” = Î¦.f A.1.unop.len â‰« Sâ‚‚.s.Î¹Summand A :=
  by rw [Sâ‚.s.Î¹_summand_eq, Sâ‚‚.s.Î¹_summand_eq, assoc, Î¦.F.naturality, â† Î¦.comm_assoc]
#align simplicial_object.split.Î¹_summand_naturality_symm SimplicialObject.Split.Î¹Summand_naturality_symm

variable (C)

/- warning: simplicial_object.split.forget -> SimplicialObject.Split.forget is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u1 u2, max u2 u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1)
but is expected to have type
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], CategoryTheory.Functor.{u2, u2, max u2 u1, max u1 u2} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1)
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.forget SimplicialObject.Split.forgetâ‚“'. -/
/-- The functor `simplicial_object.split C â¥¤ simplicial_object C` which forgets
the splitting. -/
@[simps]
def forget : Split C â¥¤ SimplicialObject C
    where
  obj S := S.pt
  map Sâ‚ Sâ‚‚ Î¦ := Î¦.f
#align simplicial_object.split.forget SimplicialObject.Split.forget

/- warning: simplicial_object.split.eval_N -> SimplicialObject.Split.evalN is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], Nat -> (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2) C _inst_1)
but is expected to have type
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1], Nat -> (CategoryTheory.Functor.{u2, u2, max u2 u1, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_2) C _inst_1)
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.eval_N SimplicialObject.Split.evalNâ‚“'. -/
/-- The functor `simplicial_object.split C â¥¤ C` which sends a simplicial object equipped
with a splitting to its nondegenerate `n`-simplices. -/
@[simps]
def evalN (n : â„•) : Split C â¥¤ C where
  obj S := S.s.n n
  map Sâ‚ Sâ‚‚ Î¦ := Î¦.f n
#align simplicial_object.split.eval_N SimplicialObject.Split.evalN

/- warning: simplicial_object.split.nat_trans_Î¹_summand -> SimplicialObject.Split.natTransÎ¹Summand is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{succ (max u1 u2), max u1 u2} (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2) C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2) C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2) C _inst_1) (CategoryTheory.Functor.category.{u2, u2, max u1 u2, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2) C _inst_1))) (SimplicialObject.Split.evalN.{u1, u2} C _inst_1 _inst_2 (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.comp.{u2, u2, u2, max u1 u2, max u2 u1, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.Split.CategoryTheory.category.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.SimplicialObject.category.{u2, u1} C _inst_1) C _inst_1 (SimplicialObject.Split.forget.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{0, max u2 u1, 0, max u2 u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) (CategoryTheory.Functor.{u2, u2, max u2 u1, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1) (CategoryTheory.Functor.category.{u2, u2, max u2 u1, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1) (CategoryTheory.evaluation.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) Î”))
but is expected to have type
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasFiniteCoproducts.{u2, u1} C _inst_1] {Î” : Opposite.{1} SimplexCategory} (A : SimplicialObject.Splitting.IndexSet Î”), Quiver.Hom.{max (succ u1) (succ u2), max u1 u2} (CategoryTheory.Functor.{u2, u2, max u2 u1, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_2) C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, u2, max u2 u1, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_2) C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, u2, max u2 u1, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_2) C _inst_1) (CategoryTheory.Functor.category.{u2, u2, max u1 u2, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_2) C _inst_1))) (SimplicialObject.Split.evalN.{u1, u2} C _inst_1 _inst_2 (SimplexCategory.len (Opposite.unop.{1} SimplexCategory (Sigma.fst.{0, 0} (Opposite.{1} SimplexCategory) (fun (Î”' : Opposite.{1} SimplexCategory) => Subtype.{1} (Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) (fun (Î± : Quiver.Hom.{1, 0} SimplexCategory (CategoryTheory.CategoryStruct.toQuiver.{0, 0} SimplexCategory (CategoryTheory.Category.toCategoryStruct.{0, 0} SimplexCategory SimplexCategory.smallCategory)) (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”')) => CategoryTheory.Epi.{0, 0} SimplexCategory SimplexCategory.smallCategory (Opposite.unop.{1} SimplexCategory Î”) (Opposite.unop.{1} SimplexCategory Î”') Î±)) A)))) (CategoryTheory.Functor.comp.{u2, u2, u2, max u1 u2, max u1 u2, u1} (SimplicialObject.Split.{u1, u2} C _inst_1 _inst_2) (SimplicialObject.instCategorySplit.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.SimplicialObject.{u2, u1} C _inst_1) (CategoryTheory.instCategorySimplicialObject.{u2, u1} C _inst_1) C _inst_1 (SimplicialObject.Split.forget.{u1, u2} C _inst_1 _inst_2) (Prefunctor.obj.{1, max (succ u1) (succ u2), 0, max u1 u2} (Opposite.{1} SimplexCategory) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.toCategoryStruct.{0, 0} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory))) (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1) (CategoryTheory.Functor.category.{u2, u2, max u1 u2, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{0, max u1 u2, 0, max u1 u2} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) (CategoryTheory.Functor.{u2, u2, max u1 u2, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1) (CategoryTheory.Functor.category.{u2, u2, max u1 u2, u1} (CategoryTheory.Functor.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) (CategoryTheory.Functor.category.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1) C _inst_1) (CategoryTheory.evaluation.{0, u2, 0, u1} (Opposite.{1} SimplexCategory) (CategoryTheory.Category.opposite.{0, 0} SimplexCategory SimplexCategory.smallCategory) C _inst_1)) Î”))
Case conversion may be inaccurate. Consider using '#align simplicial_object.split.nat_trans_Î¹_summand SimplicialObject.Split.natTransÎ¹Summandâ‚“'. -/
/-- The inclusion of each summand in the coproduct decomposition of simplices
in split simplicial objects is a natural transformation of functors
`simplicial_object.split C â¥¤ C` -/
@[simps]
def natTransÎ¹Summand {Î” : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) :
    evalN C A.1.unop.len âŸ¶ forget C â‹™ (evaluation SimplexCategoryáµ’áµ– C).obj Î”
    where
  app S := S.s.Î¹Summand A
  naturality' Sâ‚ Sâ‚‚ Î¦ := (Î¹Summand_naturality_symm Î¦ A).symm
#align simplicial_object.split.nat_trans_Î¹_summand SimplicialObject.Split.natTransÎ¹Summand

end Split

end SimplicialObject

