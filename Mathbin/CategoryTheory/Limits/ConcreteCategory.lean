/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Adam Topaz

! This file was ported from Lean 3 source module category_theory.limits.concrete_category
! leanprover-community/mathlib commit cb3ceec8485239a61ed51d944cb9a95b68c6bafc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.Preserves.Basic
import Mathbin.CategoryTheory.Limits.Types
import Mathbin.CategoryTheory.Limits.Shapes.WidePullbacks
import Mathbin.CategoryTheory.Limits.Shapes.Multiequalizer
import Mathbin.CategoryTheory.ConcreteCategory.Basic
import Mathbin.CategoryTheory.Limits.Shapes.Kernels
import Mathbin.Tactic.ApplyFun

/-!
# Facts about (co)limits of functors into concrete categories

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


universe w v u

open CategoryTheory

namespace CategoryTheory.Limits

attribute [local instance] concrete_category.has_coe_to_fun concrete_category.has_coe_to_sort

section Limits

variable {C : Type u} [Category.{v} C] [ConcreteCategory.{max w v} C] {J : Type w} [SmallCategory J]
  (F : J ⥤ C) [PreservesLimit F (forget C)]

/- warning: category_theory.limits.concrete.to_product_injective_of_is_limit -> CategoryTheory.Limits.Concrete.to_product_injective_of_isLimit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u1 u2, u3, succ (max u1 u2)} C _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_3 F (CategoryTheory.forget.{u3, max u1 u2, u2} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cone.{u1, u2, u1, u3} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) -> (Function.Injective.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) (forall (j : J), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (fun (x : coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) (j : J) => coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j)) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (CategoryTheory.NatTrans.app.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) F (CategoryTheory.Limits.Cone.π.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) j) x))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u2 u1, u3, max (succ u2) (succ u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} J _inst_3 F (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cone.{u1, u2, u1, u3} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) -> (Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) (forall (j : J), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j)) (fun (x : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) (j : J) => Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u3, max (max u1 u2) u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u3, max (max u1 u3) u2} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D))) j) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j) (CategoryTheory.NatTrans.app.{u1, u2, u1, u3} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u3, max (max u1 u2) u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u3, max (max u1 u3) u2} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) F (CategoryTheory.Limits.Cone.π.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) j) x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.to_product_injective_of_is_limit CategoryTheory.Limits.Concrete.to_product_injective_of_isLimitₓ'. -/
theorem Concrete.to_product_injective_of_isLimit {D : Cone F} (hD : IsLimit D) :
    Function.Injective fun (x : D.pt) (j : J) => D.π.app j x :=
  by
  let E := (forget C).mapCone D
  let hE : is_limit E := is_limit_of_preserves _ hD
  let G := Types.limitCone.{w, v} (F ⋙ forget C)
  let hG := Types.limitConeIsLimit.{w, v} (F ⋙ forget C)
  let T : E.X ≅ G.X := hE.cone_point_unique_up_to_iso hG
  change Function.Injective (T.hom ≫ fun x j => G.π.app j x)
  have h : Function.Injective T.hom := by
    intro a b h
    suffices T.inv (T.hom a) = T.inv (T.hom b) by simpa
    rw [h]
  suffices Function.Injective fun (x : G.X) j => G.π.app j x by exact this.comp h
  apply Subtype.ext
#align category_theory.limits.concrete.to_product_injective_of_is_limit CategoryTheory.Limits.Concrete.to_product_injective_of_isLimit

/- warning: category_theory.limits.concrete.is_limit_ext -> CategoryTheory.Limits.Concrete.isLimit_ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u1 u2, u3, succ (max u1 u2)} C _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_3 F (CategoryTheory.forget.{u3, max u1 u2, u2} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cone.{u1, u2, u1, u3} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) -> (forall (x : coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) (y : coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)), (forall (j : J), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j)) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (CategoryTheory.NatTrans.app.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) F (CategoryTheory.Limits.Cone.π.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) j) x) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j)) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) j) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (CategoryTheory.NatTrans.app.{u1, u2, u1, u3} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u2, max u1 u2, u3, max u1 u2 u1 u3} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) F (CategoryTheory.Limits.Cone.π.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) j) y)) -> (Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) x y))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u2 u1, u3, max (succ u2) (succ u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} J _inst_3 F (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cone.{u1, u2, u1, u3} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) -> (forall (x : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) (y : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)), (forall (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j)) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u3, max (max u1 u2) u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u3, max (max u1 u3) u2} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D))) j) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j) (CategoryTheory.NatTrans.app.{u1, u2, u1, u3} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u3, max (max u1 u2) u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u3, max (max u1 u3) u2} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) F (CategoryTheory.Limits.Cone.π.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) j) x) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u3, max (max u1 u2) u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u3, max (max u1 u3) u2} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D))) j) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j) (CategoryTheory.NatTrans.app.{u1, u2, u1, u3} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u3, max (max u1 u2) u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max (max u1 u3) u2} (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u3, max (max u1 u3) u2} C _inst_1 (CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u2, u1, u3} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) F (CategoryTheory.Limits.Cone.π.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D) j) y)) -> (Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cone.pt.{u1, u2, u1, u3} J _inst_3 C _inst_1 F D)) x y))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.is_limit_ext CategoryTheory.Limits.Concrete.isLimit_extₓ'. -/
theorem Concrete.isLimit_ext {D : Cone F} (hD : IsLimit D) (x y : D.pt) :
    (∀ j, D.π.app j x = D.π.app j y) → x = y := fun h =>
  Concrete.to_product_injective_of_isLimit _ hD (funext h)
#align category_theory.limits.concrete.is_limit_ext CategoryTheory.Limits.Concrete.isLimit_ext

/- warning: category_theory.limits.concrete.limit_ext -> CategoryTheory.Limits.Concrete.limit_ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u1 u2, u3, succ (max u1 u2)} C _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_3 F (CategoryTheory.forget.{u3, max u1 u2, u2} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F] (x : coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)) (y : coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)), (forall (j : J), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (CategoryTheory.Limits.limit.π.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5 j) x) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} J _inst_3 C _inst_1 F j)) (CategoryTheory.Limits.limit.π.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5 j) y)) -> (Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)) x y)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u2, u1, u3} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u2 u1, u3, max (succ u2) (succ u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} J _inst_3 F (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F] (x : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)) (y : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)), (forall (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j)) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.limit.π.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5 j) x) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5) (Prefunctor.obj.{succ u1, succ u2, u1, u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.limit.π.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5 j) y)) -> (Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.limit.{u1, u1, u2, u3} J _inst_3 C _inst_1 F _inst_5)) x y)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.limit_ext CategoryTheory.Limits.Concrete.limit_extₓ'. -/
theorem Concrete.limit_ext [HasLimit F] (x y : limit F) :
    (∀ j, limit.π F j x = limit.π F j y) → x = y :=
  Concrete.isLimit_ext F (limit.isLimit _) _ _
#align category_theory.limits.concrete.limit_ext CategoryTheory.Limits.Concrete.limit_ext

section WidePullback

open WidePullback

open WidePullbackShape

#print CategoryTheory.Limits.Concrete.widePullback_ext /-
theorem Concrete.widePullback_ext {B : C} {ι : Type w} {X : ι → C} (f : ∀ j : ι, X j ⟶ B)
    [HasWidePullback B X f] [PreservesLimit (wideCospan B X f) (forget C)]
    (x y : widePullback B X f) (h₀ : base f x = base f y) (h : ∀ j, π f j x = π f j y) : x = y :=
  by
  apply concrete.limit_ext
  rintro (_ | j)
  · exact h₀
  · apply h
#align category_theory.limits.concrete.wide_pullback_ext CategoryTheory.Limits.Concrete.widePullback_ext
-/

#print CategoryTheory.Limits.Concrete.widePullback_ext' /-
theorem Concrete.widePullback_ext' {B : C} {ι : Type w} [Nonempty ι] {X : ι → C}
    (f : ∀ j : ι, X j ⟶ B) [HasWidePullback.{w} B X f]
    [PreservesLimit (wideCospan B X f) (forget C)] (x y : widePullback B X f)
    (h : ∀ j, π f j x = π f j y) : x = y :=
  by
  apply concrete.wide_pullback_ext _ _ _ _ h
  inhabit ι
  simp only [← π_arrow f (Inhabited.default _), comp_apply, h]
#align category_theory.limits.concrete.wide_pullback_ext' CategoryTheory.Limits.Concrete.widePullback_ext'
-/

end WidePullback

section Multiequalizer

#print CategoryTheory.Limits.Concrete.multiequalizer_ext /-
theorem Concrete.multiequalizer_ext {I : MulticospanIndex.{w} C} [HasMultiequalizer I]
    [PreservesLimit I.multicospan (forget C)] (x y : multiequalizer I)
    (h : ∀ t : I.L, Multiequalizer.ι I t x = Multiequalizer.ι I t y) : x = y :=
  by
  apply concrete.limit_ext
  rintro (a | b)
  · apply h
  · rw [← limit.w I.multicospan (walking_multicospan.hom.fst b), comp_apply, comp_apply, h]
#align category_theory.limits.concrete.multiequalizer_ext CategoryTheory.Limits.Concrete.multiequalizer_ext
-/

/- warning: category_theory.limits.concrete.multiequalizer_equiv_aux -> CategoryTheory.Limits.Concrete.multiequalizerEquivAux is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] (I : CategoryTheory.Limits.MulticospanIndex.{u4, u2, u3} C _inst_1), Equiv.{succ (max u4 u1 u2), max 1 (succ u4) (succ (max u1 u2))} (coeSort.{succ (max u4 u1 u2), succ (succ (max u4 u1 u2))} (Set.{max u4 u1 u2} (forall (j : CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)), CategoryTheory.Functor.obj.{u4, max u1 u2, u4, succ (max u1 u2)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.CategoryTheory.smallCategory.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.comp.{u4, u2, max u1 u2, u4, u3, succ (max u1 u2)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.CategoryTheory.smallCategory.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) C _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.MulticospanIndex.multicospan.{u2, u3, u4} C _inst_1 I) (CategoryTheory.forget.{u3, max u1 u2, u2} C _inst_1 _inst_2)) j)) Type.{max u4 u1 u2} (Set.hasCoeToSort.{max u4 u1 u2} (forall (j : CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)), CategoryTheory.Functor.obj.{u4, max u1 u2, u4, succ (max u1 u2)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.CategoryTheory.smallCategory.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.comp.{u4, u2, max u1 u2, u4, u3, succ (max u1 u2)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.CategoryTheory.smallCategory.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) C _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.MulticospanIndex.multicospan.{u2, u3, u4} C _inst_1 I) (CategoryTheory.forget.{u3, max u1 u2, u2} C _inst_1 _inst_2)) j)) (CategoryTheory.Functor.sections.{u4, max u1 u2, u4} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.CategoryTheory.smallCategory.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Functor.comp.{u4, u2, max u1 u2, u4, u3, succ (max u1 u2)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.CategoryTheory.smallCategory.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) C _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.MulticospanIndex.multicospan.{u2, u3, u4} C _inst_1 I) (CategoryTheory.forget.{u3, max u1 u2, u2} C _inst_1 _inst_2)))) (Subtype.{max (succ u4) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u4, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u4, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I i)))))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] (I : CategoryTheory.Limits.MulticospanIndex.{u4, u2, u3} C _inst_1), Equiv.{max (max (succ u2) (succ u1)) (succ u4), max 1 (max (succ u2) (succ u1)) (succ u4)} (Set.Elem.{max (max u2 u1) u4} (forall (j : CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)), Prefunctor.obj.{succ u4, succ (max u2 u1), u4, succ (max u2 u1)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.CategoryStruct.toQuiver.{u4, u4} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Category.toCategoryStruct.{u4, u4} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.instSmallCategoryWalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)))) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u4, max u2 u1, u4, succ (max u2 u1)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.instSmallCategoryWalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.comp.{u4, u2, max u2 u1, u4, u3, max (succ u2) (succ u1)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.instSmallCategoryWalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.MulticospanIndex.multicospan.{u2, u3, u4} C _inst_1 I) (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2))) j) (CategoryTheory.Functor.sections.{u4, max u2 u1, u4} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.instSmallCategoryWalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Functor.comp.{u4, u2, max u2 u1, u4, u3, max (succ u2) (succ u1)} (CategoryTheory.Limits.WalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.instSmallCategoryWalkingMulticospan.{u4} (CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I)) C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.MulticospanIndex.multicospan.{u2, u3, u4} C _inst_1 I) (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)))) (Subtype.{max (max (succ u2) (succ u1)) (succ u4)} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u4, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u4, u2, u3} C _inst_1 I), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i)) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.fst.{u4, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u4, u2, u3} C _inst_1 I i))) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u4, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u4, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.snd.{u4, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u4, u2, u3} C _inst_1 I i)))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.multiequalizer_equiv_aux CategoryTheory.Limits.Concrete.multiequalizerEquivAuxₓ'. -/
/-- An auxiliary equivalence to be used in `multiequalizer_equiv` below.-/
def Concrete.multiequalizerEquivAux (I : MulticospanIndex C) :
    (I.multicospan ⋙ forget C).sections ≃
      { x : ∀ i : I.L, I.left i // ∀ i : I.R, I.fst i (x _) = I.snd i (x _) }
    where
  toFun x :=
    ⟨fun i => x.1 (WalkingMulticospan.left _), fun i =>
      by
      have a := x.2 (walking_multicospan.hom.fst i)
      have b := x.2 (walking_multicospan.hom.snd i)
      rw [← b] at a
      exact a⟩
  invFun x :=
    { val := fun j =>
        match j with
        | walking_multicospan.left a => x.1 _
        | walking_multicospan.right b => I.fst b (x.1 _)
      property := by
        rintro (a | b) (a' | b') (f | f | f)
        · change (I.multicospan.map (𝟙 _)) _ = _
          simp
        · rfl
        · dsimp
          erw [← x.2 b']
          rfl
        · change (I.multicospan.map (𝟙 _)) _ = _
          simp }
  left_inv := by
    intro x; ext (a | b)
    · rfl
    · change _ = x.val _
      rw [← x.2 (walking_multicospan.hom.fst b)]
      rfl
  right_inv := by
    intro x
    ext i
    rfl
#align category_theory.limits.concrete.multiequalizer_equiv_aux CategoryTheory.Limits.Concrete.multiequalizerEquivAux

#print CategoryTheory.Limits.Concrete.multiequalizerEquiv /-
/-- The equivalence between the noncomputable multiequalizer and
and the concrete multiequalizer. -/
noncomputable def Concrete.multiequalizerEquiv (I : MulticospanIndex.{w} C) [HasMultiequalizer I]
    [PreservesLimit I.multicospan (forget C)] :
    (multiequalizer I : C) ≃
      { x : ∀ i : I.L, I.left i // ∀ i : I.R, I.fst i (x _) = I.snd i (x _) } :=
  let h1 := limit.isLimit I.multicospan
  let h2 := isLimitOfPreserves (forget C) h1
  let E := h2.conePointUniqueUpToIso (Types.limitConeIsLimit _)
  Equiv.trans E.toEquiv (Concrete.multiequalizerEquivAux I)
#align category_theory.limits.concrete.multiequalizer_equiv CategoryTheory.Limits.Concrete.multiequalizerEquiv
-/

/- warning: category_theory.limits.concrete.multiequalizer_equiv_apply -> CategoryTheory.Limits.Concrete.multiequalizerEquiv_apply is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] (I : CategoryTheory.Limits.MulticospanIndex.{u1, u2, u3} C _inst_1) [_inst_5 : CategoryTheory.Limits.HasMultiequalizer.{u2, u3, u1} C _inst_1 I] [_inst_6 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u1 u2, u3, succ (max u1 u2)} C _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.WalkingMulticospan.{u1} (CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.CategoryTheory.smallCategory.{u1} (CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.MulticospanIndex.multicospan.{u2, u3, u1} C _inst_1 I) (CategoryTheory.forget.{u3, max u1 u2, u2} C _inst_1 _inst_2)] (x : coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) ((fun (a : Sort.{max 1 (succ u1) (succ (max u1 u2))}) (b : Sort.{max (succ u1) (succ (max u1 u2))}) [self : HasLiftT.{max 1 (succ u1) (succ (max u1 u2)), max (succ u1) (succ (max u1 u2))} a b] => self.0) (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))))) (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (HasLiftT.mk.{max 1 (succ u1) (succ (max u1 u2)), max (succ u1) (succ (max u1 u2))} (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))))) (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (CoeTCₓ.coe.{max 1 (succ u1) (succ (max u1 u2)), max (succ u1) (succ (max u1 u2))} (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))))) (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (coeBase.{max 1 (succ u1) (succ (max u1 u2)), max (succ u1) (succ (max u1 u2))} (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))))) (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (coeSubtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))))))) (coeFn.{max 1 (max (succ (max u1 u2)) 1 (succ u1) (succ (max u1 u2))) (max 1 (succ u1) (succ (max u1 u2))) (succ (max u1 u2)), max (succ (max u1 u2)) 1 (succ u1) (succ (max u1 u2))} (Equiv.{succ (max u1 u2), max 1 (succ u1) (succ (max u1 u2))} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))))) (fun (_x : Equiv.{succ (max u1 u2), max 1 (succ u1) (succ (max u1 u2))} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))))) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) -> (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))))) (Equiv.hasCoeToFun.{succ (max u1 u2), max 1 (succ u1) (succ (max u1 u2))} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (Subtype.{max (succ u1) (succ (max u1 u2))} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{succ (max u1 u2)} (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))))) (CategoryTheory.Limits.Concrete.multiequalizerEquiv.{u1, u2, u3} C _inst_1 _inst_2 I _inst_5 _inst_6) x) i) (coeFn.{succ u2, succ (max u1 u2)} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) -> (coeSort.{succ u3, succ (succ (max u1 u2))} C Type.{max u1 u2} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u3, max u1 u2, u2} C _inst_1 _inst_2) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u3, u2, max u1 u2} C _inst_1 _inst_2 (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.Multiequalizer.ι.{u2, u3, u1} C _inst_1 I _inst_5 i) x)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.ConcreteCategory.{max u1 u2, u2, u3} C _inst_1] (I : CategoryTheory.Limits.MulticospanIndex.{u1, u2, u3} C _inst_1) [_inst_5 : CategoryTheory.Limits.HasMultiequalizer.{u2, u3, u1} C _inst_1 I] [_inst_6 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, max u2 u1, u3, max (succ u2) (succ u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.WalkingMulticospan.{u1} (CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.WalkingMulticospan.instSmallCategoryWalkingMulticospan.{u1} (CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I) (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I)) (CategoryTheory.Limits.MulticospanIndex.multicospan.{u2, u3, u1} C _inst_1 I) (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)] (x : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (Subtype.val.{max (succ u2) (succ u1)} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max 1 (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (Subtype.{max (succ u2) (succ u1)} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))))) (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (fun (_x : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) => Subtype.{max (succ u2) (succ u1)} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i))))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5)) (Subtype.{max (succ u2) (succ u1)} (forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) (fun (x : forall (i : CategoryTheory.Limits.MulticospanIndex.L.{u1, u2, u3} C _inst_1 I), Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i)) => forall (i : CategoryTheory.Limits.MulticospanIndex.R.{u1, u2, u3} C _inst_1 I), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i)) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.fst.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.fstTo.{u1, u2, u3} C _inst_1 I i))) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)) (CategoryTheory.Limits.MulticospanIndex.right.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.MulticospanIndex.snd.{u1, u2, u3} C _inst_1 I i) (x (CategoryTheory.Limits.MulticospanIndex.sndTo.{u1, u2, u3} C _inst_1 I i)))))) (CategoryTheory.Limits.Concrete.multiequalizerEquiv.{u1, u2, u3} C _inst_1 _inst_2 I _inst_5 _inst_6) x) i) (Prefunctor.map.{succ u2, succ (max u2 u1), u3, succ (max u2 u1)} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u2, max u2 u1, u3, succ (max u2 u1)} C _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{u3, max u2 u1, u2} C _inst_1 _inst_2)) (CategoryTheory.Limits.multiequalizer.{u2, u3, u1} C _inst_1 I _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{u1, u2, u3} C _inst_1 I i) (CategoryTheory.Limits.Multiequalizer.ι.{u2, u3, u1} C _inst_1 I _inst_5 i) x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.multiequalizer_equiv_apply CategoryTheory.Limits.Concrete.multiequalizerEquiv_applyₓ'. -/
@[simp]
theorem Concrete.multiequalizerEquiv_apply (I : MulticospanIndex.{w} C) [HasMultiequalizer I]
    [PreservesLimit I.multicospan (forget C)] (x : multiequalizer I) (i : I.L) :
    ((Concrete.multiequalizerEquiv I) x : ∀ i : I.L, I.left i) i = Multiequalizer.ι I i x :=
  rfl
#align category_theory.limits.concrete.multiequalizer_equiv_apply CategoryTheory.Limits.Concrete.multiequalizerEquiv_apply

end Multiequalizer

-- TODO: Add analogous lemmas about products and equalizers.
end Limits

section Colimits

/- warning: category_theory.limits.cokernel_funext -> CategoryTheory.Limits.cokernel_funext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u1} C _inst_1] [_inst_3 : CategoryTheory.ConcreteCategory.{u3, u2, u1} C _inst_1] {M : C} {N : C} {K : C} {f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) M N} [_inst_4 : CategoryTheory.Limits.HasCokernel.{u2, u1} C _inst_1 _inst_2 M N f] {g : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K} {h : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K}, (forall (n : coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) N), Eq.{succ u3} (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) K) (coeFn.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K) (fun (f_1 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K) => (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) -> (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) K)) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, u2, u3} C _inst_1 _inst_3 (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K) g (coeFn.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) N (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) (fun (f_1 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) N (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) => (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) N) -> (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, u2, u3} C _inst_1 _inst_3 N (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) (CategoryTheory.Limits.cokernel.π.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) n)) (coeFn.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K) (fun (f_1 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K) => (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) -> (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) K)) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, u2, u3} C _inst_1 _inst_3 (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K) h (coeFn.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) N (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) (fun (f_1 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) N (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) => (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) N) -> (coeSort.{succ u1, succ (succ u3)} C Type.{u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, u3, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, u2, u3} C _inst_1 _inst_3 N (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4)) (CategoryTheory.Limits.cokernel.π.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) n))) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u1} C _inst_1 _inst_2 M N f _inst_4) K) g h)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} C _inst_1] [_inst_3 : CategoryTheory.ConcreteCategory.{u1, u2, u3} C _inst_1] {M : C} {N : C} {K : C} {f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) M N} [_inst_4 : CategoryTheory.Limits.HasCokernel.{u2, u3} C _inst_1 _inst_2 M N f] {g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) K} {h : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) K}, (forall (n : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u3, u1, u2} C _inst_1 _inst_3)) N), Eq.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u3, u1, u2} C _inst_1 _inst_3)) K) (Prefunctor.map.{succ u2, succ u1, u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u3, u1, u2} C _inst_1 _inst_3)) (CategoryTheory.Limits.cokernel.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) K g (Prefunctor.map.{succ u2, succ u1, u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u3, u1, u2} C _inst_1 _inst_3)) N (CategoryTheory.Limits.cokernel.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) (CategoryTheory.Limits.cokernel.π.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) n)) (Prefunctor.map.{succ u2, succ u1, u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u3, u1, u2} C _inst_1 _inst_3)) (CategoryTheory.Limits.cokernel.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) K h (Prefunctor.map.{succ u2, succ u1, u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u3, u1, u2} C _inst_1 _inst_3)) N (CategoryTheory.Limits.cokernel.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) (CategoryTheory.Limits.cokernel.π.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) n))) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.cokernel.{u2, u3} C _inst_1 _inst_2 M N f _inst_4) K) g h)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.cokernel_funext CategoryTheory.Limits.cokernel_funextₓ'. -/
-- We don't mark this as an `@[ext]` lemma as we don't always want to work elementwise.
theorem cokernel_funext {C : Type _} [Category C] [HasZeroMorphisms C] [ConcreteCategory C]
    {M N K : C} {f : M ⟶ N} [HasCokernel f] {g h : cokernel f ⟶ K}
    (w : ∀ n : N, g (cokernel.π f n) = h (cokernel.π f n)) : g = h :=
  by
  apply coequalizer.hom_ext
  apply concrete_category.hom_ext _ _
  simpa using w
#align category_theory.limits.cokernel_funext CategoryTheory.Limits.cokernel_funext

variable {C : Type u} [Category.{v} C] [ConcreteCategory.{v} C] {J : Type v} [SmallCategory J]
  (F : J ⥤ C) [PreservesColimit F (forget C)]

/- warning: category_theory.limits.concrete.from_union_surjective_of_is_colimit -> CategoryTheory.Limits.Concrete.from_union_surjective_of_isColimit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (let ff : (Sigma.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j))) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) := fun (a : Sigma.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j))) => coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a))) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a))) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a))) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a)))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a))) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) (Sigma.fst.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a)) (Sigma.snd.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) a); Function.Surjective.{succ u1, succ u1} (Sigma.{u1, u1} J (fun (j : J) => coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j))) (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) ff)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (let ff : (Sigma.{u1, u1} J (fun (j : J) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j))) -> (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) := fun (a : Sigma.{u1, u1} J (fun (j : J) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j))) => Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) (Sigma.fst.{u1, u1} J (fun (j : J) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) a)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) (Sigma.fst.{u1, u1} J (fun (j : J) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) a)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) (Sigma.fst.{u1, u1} J (fun (j : J) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) a)) (Sigma.snd.{u1, u1} J (fun (j : J) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) a); Function.Surjective.{succ u1, succ u1} (Sigma.{u1, u1} J (fun (j : J) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j))) (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) ff)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.from_union_surjective_of_is_colimit CategoryTheory.Limits.Concrete.from_union_surjective_of_isColimitₓ'. -/
theorem Concrete.from_union_surjective_of_isColimit {D : Cocone F} (hD : IsColimit D) :
    let ff : (Σj : J, F.obj j) → D.pt := fun a => D.ι.app a.1 a.2
    Function.Surjective ff :=
  by
  intro ff
  let E := (forget C).mapCocone D
  let hE : is_colimit E := is_colimit_of_preserves _ hD
  let G := Types.colimitCocone.{v, v} (F ⋙ forget C)
  let hG := Types.colimitCoconeIsColimit.{v, v} (F ⋙ forget C)
  let T : E ≅ G := hE.unique_up_to_iso hG
  let TX : E.X ≅ G.X := (cocones.forget _).mapIso T
  suffices Function.Surjective (TX.hom ∘ ff) by
    intro a
    obtain ⟨b, hb⟩ := this (TX.hom a)
    refine' ⟨b, _⟩
    apply_fun TX.inv  at hb
    change (TX.hom ≫ TX.inv) (ff b) = (TX.hom ≫ TX.inv) _ at hb
    simpa only [TX.hom_inv_id] using hb
  have : TX.hom ∘ ff = fun a => G.ι.app a.1 a.2 :=
    by
    ext a
    change (E.ι.app a.1 ≫ hE.desc G) a.2 = _
    rw [hE.fac]
  rw [this]
  rintro ⟨⟨j, a⟩⟩
  exact ⟨⟨j, a⟩, rfl⟩
#align category_theory.limits.concrete.from_union_surjective_of_is_colimit CategoryTheory.Limits.Concrete.from_union_surjective_of_isColimit

/- warning: category_theory.limits.concrete.is_colimit_exists_rep -> CategoryTheory.Limits.Concrete.isColimit_exists_rep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)), Exists.{succ u1} J (fun (j : J) => Exists.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) (fun (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y) x)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)), Exists.{succ u1} J (fun (j : J) => Exists.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) (fun (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) j)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) j) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y) x)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.is_colimit_exists_rep CategoryTheory.Limits.Concrete.isColimit_exists_repₓ'. -/
theorem Concrete.isColimit_exists_rep {D : Cocone F} (hD : IsColimit D) (x : D.pt) :
    ∃ (j : J)(y : F.obj j), D.ι.app j y = x :=
  by
  obtain ⟨a, rfl⟩ := concrete.from_union_surjective_of_is_colimit F hD x
  exact ⟨a.1, a.2, rfl⟩
#align category_theory.limits.concrete.is_colimit_exists_rep CategoryTheory.Limits.Concrete.isColimit_exists_rep

/- warning: category_theory.limits.concrete.colimit_exists_rep -> CategoryTheory.Limits.Concrete.colimit_exists_rep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)), Exists.{succ u1} J (fun (j : J) => Exists.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) (fun (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5 j) y) x))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)), Exists.{succ u1} J (fun (j : J) => Exists.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) (fun (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5 j) y) x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.colimit_exists_rep CategoryTheory.Limits.Concrete.colimit_exists_repₓ'. -/
theorem Concrete.colimit_exists_rep [HasColimit F] (x : colimit F) :
    ∃ (j : J)(y : F.obj j), colimit.ι F j y = x :=
  Concrete.isColimit_exists_rep F (colimit.isColimit _) x
#align category_theory.limits.concrete.colimit_exists_rep CategoryTheory.Limits.Concrete.colimit_exists_rep

/- warning: category_theory.limits.concrete.is_colimit_rep_eq_of_exists -> CategoryTheory.Limits.Concrete.isColimit_rep_eq_of_exists is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F} {i : J} {j : J}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)), (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i k f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j k g) y))))) -> (Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) i) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F} {i : J} {j : J}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i)) (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)), (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i k f) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j k g) y))))) -> (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) i)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) i) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) i) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) j) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.is_colimit_rep_eq_of_exists CategoryTheory.Limits.Concrete.isColimit_rep_eq_of_existsₓ'. -/
theorem Concrete.isColimit_rep_eq_of_exists {D : Cocone F} {i j : J} (hD : IsColimit D)
    (x : F.obj i) (y : F.obj j) (h : ∃ (k : _)(f : i ⟶ k)(g : j ⟶ k), F.map f x = F.map g y) :
    D.ι.app i x = D.ι.app j y := by
  let E := (forget C).mapCocone D
  let hE : is_colimit E := is_colimit_of_preserves _ hD
  let G := Types.colimitCocone.{v, v} (F ⋙ forget C)
  let hG := Types.colimitCoconeIsColimit.{v, v} (F ⋙ forget C)
  let T : E ≅ G := hE.unique_up_to_iso hG
  let TX : E.X ≅ G.X := (cocones.forget _).mapIso T
  apply_fun TX.hom
  swap;
  · suffices Function.Bijective TX.hom by exact this.1
    rw [← is_iso_iff_bijective]
    apply is_iso.of_iso
  change (E.ι.app i ≫ TX.hom) x = (E.ι.app j ≫ TX.hom) y
  erw [T.hom.w, T.hom.w]
  obtain ⟨k, f, g, h⟩ := h
  have : G.ι.app i x = (G.ι.app k (F.map f x) : G.X) := Quot.sound ⟨f, rfl⟩
  rw [this, h]
  symm
  exact Quot.sound ⟨g, rfl⟩
#align category_theory.limits.concrete.is_colimit_rep_eq_of_exists CategoryTheory.Limits.Concrete.isColimit_rep_eq_of_exists

/- warning: category_theory.limits.concrete.colimit_rep_eq_of_exists -> CategoryTheory.Limits.Concrete.colimit_rep_eq_of_exists is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] {i : J} {j : J} (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)), (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i k f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j k g) y))))) -> (Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5 i) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5 j) y))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] {i : J} {j : J} (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i)) (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)), (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i k f) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j k g) y))))) -> (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5 i) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_5 j) y))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.colimit_rep_eq_of_exists CategoryTheory.Limits.Concrete.colimit_rep_eq_of_existsₓ'. -/
theorem Concrete.colimit_rep_eq_of_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)
    (h : ∃ (k : _)(f : i ⟶ k)(g : j ⟶ k), F.map f x = F.map g y) :
    colimit.ι F i x = colimit.ι F j y :=
  Concrete.isColimit_rep_eq_of_exists F (colimit.isColimit _) x y h
#align category_theory.limits.concrete.colimit_rep_eq_of_exists CategoryTheory.Limits.Concrete.colimit_rep_eq_of_exists

section FilteredColimits

variable [IsFiltered J]

/- warning: category_theory.limits.concrete.is_colimit_exists_of_rep_eq -> CategoryTheory.Limits.Concrete.isColimit_exists_of_rep_eq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F} {i : J} {j : J}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)), (Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) i) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y)) -> (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i k f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j k g) y))))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F} {i : J} {j : J}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i)) (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)), (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) i)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) i) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) i) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) j) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y)) -> (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i k f) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j k g) y))))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.is_colimit_exists_of_rep_eq CategoryTheory.Limits.Concrete.isColimit_exists_of_rep_eqₓ'. -/
theorem Concrete.isColimit_exists_of_rep_eq {D : Cocone F} {i j : J} (hD : IsColimit D)
    (x : F.obj i) (y : F.obj j) (h : D.ι.app _ x = D.ι.app _ y) :
    ∃ (k : _)(f : i ⟶ k)(g : j ⟶ k), F.map f x = F.map g y :=
  by
  let E := (forget C).mapCocone D
  let hE : is_colimit E := is_colimit_of_preserves _ hD
  let G := Types.colimitCocone.{v, v} (F ⋙ forget C)
  let hG := Types.colimitCoconeIsColimit.{v, v} (F ⋙ forget C)
  let T : E ≅ G := hE.unique_up_to_iso hG
  let TX : E.X ≅ G.X := (cocones.forget _).mapIso T
  apply_fun TX.hom  at h
  change (E.ι.app i ≫ TX.hom) x = (E.ι.app j ≫ TX.hom) y at h
  erw [T.hom.w, T.hom.w] at h
  replace h := Quot.exact _ h
  suffices
    ∀ (a b : Σj, F.obj j) (h : EqvGen (Limits.Types.Quot.Rel.{v, v} (F ⋙ forget C)) a b),
      ∃ (k : _)(f : a.1 ⟶ k)(g : b.1 ⟶ k), F.map f a.2 = F.map g b.2
    by exact this ⟨i, x⟩ ⟨j, y⟩ h
  intro a b h
  induction h
  case rel x y hh =>
    obtain ⟨e, he⟩ := hh
    use y.1, e, 𝟙 _
    simpa using he.symm
  case refl x => use x.1, 𝟙 _, 𝟙 _, rfl
  case symm x y _ hh =>
    obtain ⟨k, f, g, hh⟩ := hh
    use k, g, f, hh.symm
  case trans x y z _ _ hh1 hh2 =>
    obtain ⟨k1, f1, g1, h1⟩ := hh1
    obtain ⟨k2, f2, g2, h2⟩ := hh2
    let k0 : J := is_filtered.max k1 k2
    let e1 : k1 ⟶ k0 := is_filtered.left_to_max _ _
    let e2 : k2 ⟶ k0 := is_filtered.right_to_max _ _
    let k : J := is_filtered.coeq (g1 ≫ e1) (f2 ≫ e2)
    let e : k0 ⟶ k := is_filtered.coeq_hom _ _
    use k, f1 ≫ e1 ≫ e, g2 ≫ e2 ≫ e
    simp only [F.map_comp, comp_apply, h1, ← h2]
    simp only [← comp_apply, ← F.map_comp]
    rw [is_filtered.coeq_condition]
#align category_theory.limits.concrete.is_colimit_exists_of_rep_eq CategoryTheory.Limits.Concrete.isColimit_exists_of_rep_eq

/- warning: category_theory.limits.concrete.is_colimit_rep_eq_iff_exists -> CategoryTheory.Limits.Concrete.isColimit_rep_eq_iff_exists is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F} {i : J} {j : J}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)), Iff (Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) i)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) i) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) j)) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i k f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j k g) y))))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] {D : CategoryTheory.Limits.Cocone.{u1, u1, u1, u2} J _inst_3 C _inst_1 F} {i : J} {j : J}, (CategoryTheory.Limits.IsColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) -> (forall (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i)) (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)), Iff (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) i)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) i) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) i) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D))) j) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_3 C _inst_1 F (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_3 C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} J _inst_3 C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D)) (CategoryTheory.Limits.Cocone.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F D) j) y)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i k f) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j k g) y))))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.is_colimit_rep_eq_iff_exists CategoryTheory.Limits.Concrete.isColimit_rep_eq_iff_existsₓ'. -/
theorem Concrete.isColimit_rep_eq_iff_exists {D : Cocone F} {i j : J} (hD : IsColimit D)
    (x : F.obj i) (y : F.obj j) :
    D.ι.app i x = D.ι.app j y ↔ ∃ (k : _)(f : i ⟶ k)(g : j ⟶ k), F.map f x = F.map g y :=
  ⟨Concrete.isColimit_exists_of_rep_eq _ hD _ _, Concrete.isColimit_rep_eq_of_exists _ hD _ _⟩
#align category_theory.limits.concrete.is_colimit_rep_eq_iff_exists CategoryTheory.Limits.Concrete.isColimit_rep_eq_iff_exists

/- warning: category_theory.limits.concrete.colimit_exists_of_rep_eq -> CategoryTheory.Limits.Concrete.colimit_exists_of_rep_eq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] {i : J} {j : J} (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)), (Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 i) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 j) y)) -> (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i k f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j k g) y)))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] {i : J} {j : J} (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i)) (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)), (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 i) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 j) y)) -> (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i k f) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j k g) y)))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.colimit_exists_of_rep_eq CategoryTheory.Limits.Concrete.colimit_exists_of_rep_eqₓ'. -/
theorem Concrete.colimit_exists_of_rep_eq [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)
    (h : colimit.ι F _ x = colimit.ι F _ y) :
    ∃ (k : _)(f : i ⟶ k)(g : j ⟶ k), F.map f x = F.map g y :=
  Concrete.isColimit_exists_of_rep_eq F (colimit.isColimit _) x y h
#align category_theory.limits.concrete.colimit_exists_of_rep_eq CategoryTheory.Limits.Concrete.colimit_exists_of_rep_eq

/- warning: category_theory.limits.concrete.colimit_rep_eq_iff_exists -> CategoryTheory.Limits.Concrete.colimit_rep_eq_iff_exists is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] {i : J} {j : J} (x : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) (y : coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)), Iff (Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 i) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 j) y)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F i k f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (fun (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) => (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j)) -> (coeSort.{succ u2, succ (succ u1)} C Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u2, u1, u1} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u2, u1, u1} C _inst_1 _inst_2 (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_3 C _inst_1 F k)) (CategoryTheory.Functor.map.{u1, u1, u1, u2} J _inst_3 C _inst_1 F j k g) y)))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_1] {J : Type.{u1}} [_inst_3 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} J _inst_3 F (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)] [_inst_5 : CategoryTheory.IsFiltered.{u1, u1} J _inst_3] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F] {i : J} {j : J} (x : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i)) (y : Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j)), Iff (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 i) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6) (CategoryTheory.Limits.colimit.ι.{u1, u1, u1, u2} J _inst_3 C _inst_1 F _inst_6 j) y)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) j k) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k)) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) i k f) x) (Prefunctor.map.{succ u1, succ u1, u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} C _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{u2, u1, u1} C _inst_1 _inst_2)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) k) (Prefunctor.map.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_3 C _inst_1 F) j k g) y)))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.concrete.colimit_rep_eq_iff_exists CategoryTheory.Limits.Concrete.colimit_rep_eq_iff_existsₓ'. -/
theorem Concrete.colimit_rep_eq_iff_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j) :
    colimit.ι F i x = colimit.ι F j y ↔ ∃ (k : _)(f : i ⟶ k)(g : j ⟶ k), F.map f x = F.map g y :=
  ⟨Concrete.colimit_exists_of_rep_eq _ _ _, Concrete.colimit_rep_eq_of_exists _ _ _⟩
#align category_theory.limits.concrete.colimit_rep_eq_iff_exists CategoryTheory.Limits.Concrete.colimit_rep_eq_iff_exists

end FilteredColimits

section WidePushout

open WidePushout

open WidePushoutShape

#print CategoryTheory.Limits.Concrete.widePushout_exists_rep /-
theorem Concrete.widePushout_exists_rep {B : C} {α : Type _} {X : α → C} (f : ∀ j : α, B ⟶ X j)
    [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)]
    (x : widePushout B X f) : (∃ y : B, head f y = x) ∨ ∃ (i : α)(y : X i), ι f i y = x :=
  by
  obtain ⟨_ | j, y, rfl⟩ := concrete.colimit_exists_rep _ x
  · use y
  · right
    use j, y
#align category_theory.limits.concrete.wide_pushout_exists_rep CategoryTheory.Limits.Concrete.widePushout_exists_rep
-/

#print CategoryTheory.Limits.Concrete.widePushout_exists_rep' /-
theorem Concrete.widePushout_exists_rep' {B : C} {α : Type _} [Nonempty α] {X : α → C}
    (f : ∀ j : α, B ⟶ X j) [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)]
    (x : widePushout B X f) : ∃ (i : α)(y : X i), ι f i y = x :=
  by
  rcases concrete.wide_pushout_exists_rep f x with (⟨y, rfl⟩ | ⟨i, y, rfl⟩)
  · inhabit α
    use Inhabited.default _, f _ y
    simp only [← arrow_ι _ (Inhabited.default α), comp_apply]
  · use i, y
#align category_theory.limits.concrete.wide_pushout_exists_rep' CategoryTheory.Limits.Concrete.widePushout_exists_rep'
-/

end WidePushout

-- TODO: Add analogous lemmas about coproducts and coequalizers.
end Colimits

end CategoryTheory.Limits

