/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Reid Barton

! This file was ported from Lean 3 source module category_theory.limits.types
! leanprover-community/mathlib commit 4aa2a2e17940311e47007f087c9df229e7f12942
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.Shapes.Images
import Mathbin.CategoryTheory.Filtered
import Mathbin.Tactic.EquivRw

/-!
# Limits in the category of types.

We show that the category of types has all (co)limits, by providing the usual concrete models.

We also give a characterisation of filtered colimits in `Type`, via
`colimit.Œπ F i xi = colimit.Œπ F j xj ‚Üî ‚àÉ k (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj`.

Finally, we prove the category of types has categorical images,
and that these agree with the range of a function.
-/


universe v u

open CategoryTheory

open CategoryTheory.Limits

namespace CategoryTheory.Limits.Types

variable {J : Type v} [SmallCategory J]

#print CategoryTheory.Limits.Types.limitCone /-
/-- (internal implementation) the limit cone of a functor,
implemented as flat sections of a pi type
-/
def limitCone (F : J ‚•§ Type max v u) : Cone F
    where
  pt := F.sections
  œÄ := { app := fun j u => u.val j }
#align category_theory.limits.types.limit_cone CategoryTheory.Limits.Types.limitCone
-/

attribute [local elab_without_expected_type] congr_fun

#print CategoryTheory.Limits.Types.limitConeIsLimit /-
/-- (internal implementation) the fact that the proposed limit cone is the limit -/
def limitConeIsLimit (F : J ‚•§ Type max v u) : IsLimit (limitCone F)
    where
  lift s v := ‚ü®fun j => s.œÄ.app j v, fun j j' f => congr_fun (Cone.w s f) _‚ü©
  uniq := by
    intros
    ext (x j)
    exact congr_fun (w j) x
#align category_theory.limits.types.limit_cone_is_limit CategoryTheory.Limits.Types.limitConeIsLimit
-/

#print CategoryTheory.Limits.Types.hasLimitsOfSize /-
/-- The category of types has all limits.

See <https://stacks.math.columbia.edu/tag/002U>.
-/
instance hasLimitsOfSize : HasLimitsOfSize.{v} (Type max v u)
    where HasLimitsOfShape J ùí• :=
    {
      HasLimit := fun F =>
        has_limit.mk
          { Cone := limit_cone F
            IsLimit := limit_cone_is_limit F } }
#align category_theory.limits.types.has_limits_of_size CategoryTheory.Limits.Types.hasLimitsOfSize
-/

instance : HasLimits (Type u) :=
  Types.hasLimitsOfSize.{u, u}

/- warning: category_theory.limits.types.is_limit_equiv_sections -> CategoryTheory.Limits.Types.isLimitEquivSections is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {c : CategoryTheory.Limits.Cone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F}, (CategoryTheory.Limits.IsLimit.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) -> (Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {c : CategoryTheory.Limits.Cone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F}, (CategoryTheory.Limits.IsLimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) -> (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.is_limit_equiv_sections CategoryTheory.Limits.Types.isLimitEquivSections‚Çì'. -/
/-- The equivalence between a limiting cone of `F` in `Type u` and the "concrete" definition as the
sections of `F`.
-/
def isLimitEquivSections {F : J ‚•§ Type max v u} {c : Cone F} (t : IsLimit c) : c.pt ‚âÉ F.sections :=
  (IsLimit.conePointUniqueUpToIso t (limitConeIsLimit F)).toEquiv
#align category_theory.limits.types.is_limit_equiv_sections CategoryTheory.Limits.Types.isLimitEquivSections

/- warning: category_theory.limits.types.is_limit_equiv_sections_apply -> CategoryTheory.Limits.Types.isLimitEquivSections_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {c : CategoryTheory.Limits.Cone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F} (t : CategoryTheory.Limits.IsLimit.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) (j : J) (x : CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) ((fun (a : Type.{max u1 u2}) (b : Sort.{max (succ u1) (succ (max u1 u2))}) [self : HasLiftT.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (HasLiftT.mk.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CoeTC‚Çì.coe.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeBase.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeSubtype.{max (succ u1) (succ (max u1 u2))} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (fun (x : forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) => Membership.Mem.{max u1 u2, max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (Set.hasMem.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) x (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)))))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) => (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) -> (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) (CategoryTheory.Limits.Types.isLimitEquivSections.{u1, u2} J _inst_1 F c t) x) j) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {c : CategoryTheory.Limits.Cone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F} (t : CategoryTheory.Limits.IsLimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) (j : J) (x : CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (Subtype.val.{succ (max u2 u1)} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (fun (x : forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) => Membership.mem.{max u2 u1, max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (Set.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) (Set.instMembershipSet.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) x (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F))) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) (fun (_x : CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) => Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F))) (CategoryTheory.Limits.Types.isLimitEquivSections.{u1, u2} J _inst_1 F c t) x) j) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.is_limit_equiv_sections_apply CategoryTheory.Limits.Types.isLimitEquivSections_apply‚Çì'. -/
@[simp]
theorem isLimitEquivSections_apply {F : J ‚•§ Type max v u} {c : Cone F} (t : IsLimit c) (j : J)
    (x : c.pt) : ((isLimitEquivSections t) x : ‚àÄ j, F.obj j) j = c.œÄ.app j x :=
  rfl
#align category_theory.limits.types.is_limit_equiv_sections_apply CategoryTheory.Limits.Types.isLimitEquivSections_apply

/- warning: category_theory.limits.types.is_limit_equiv_sections_symm_apply -> CategoryTheory.Limits.Types.isLimitEquivSections_symm_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {c : CategoryTheory.Limits.Cone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F} (t : CategoryTheory.Limits.IsLimit.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) (x : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (j : J), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) j (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c)) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c)) => (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) -> (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c)) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c)) (Equiv.symm.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F c) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.isLimitEquivSections.{u1, u2} J _inst_1 F c t)) x)) ((fun (a : Type.{max u1 u2}) (b : Sort.{max (succ u1) (succ (max u1 u2))}) [self : HasLiftT.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (HasLiftT.mk.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CoeTC‚Çì.coe.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeBase.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeSubtype.{max (succ u1) (succ (max u1 u2))} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (fun (x : forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) => Membership.Mem.{max u1 u2, max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (Set.hasMem.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) x (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)))))) x j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {c : CategoryTheory.Limits.Cone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F} (t : CategoryTheory.Limits.IsLimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) (x : Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) j (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c)) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (fun (_x : Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) => CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F c) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.isLimitEquivSections.{u1, u2} J _inst_1 F c t)) x)) (Subtype.val.{succ (max u2 u1)} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (fun (x : forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) => Membership.mem.{max u2 u1, max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (Set.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) (Set.instMembershipSet.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) x (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) x j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.is_limit_equiv_sections_symm_apply CategoryTheory.Limits.Types.isLimitEquivSections_symm_apply‚Çì'. -/
@[simp]
theorem isLimitEquivSections_symm_apply {F : J ‚•§ Type max v u} {c : Cone F} (t : IsLimit c)
    (x : F.sections) (j : J) : c.œÄ.app j ((isLimitEquivSections t).symm x) = (x : ‚àÄ j, F.obj j) j :=
  by
  equiv_rw(is_limit_equiv_sections t).symm  at x
  simp
#align category_theory.limits.types.is_limit_equiv_sections_symm_apply CategoryTheory.Limits.Types.isLimitEquivSections_symm_apply

/- warning: category_theory.limits.types.limit_equiv_sections -> CategoryTheory.Limits.Types.limitEquivSections is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}), Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F)) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}), Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit_equiv_sections CategoryTheory.Limits.Types.limitEquivSections‚Çì'. -/
/-- The equivalence between the abstract limit of `F` in `Type u`
and the "concrete" definition as the sections of `F`.
-/
noncomputable def limitEquivSections (F : J ‚•§ Type max v u) :
    (limit F : Type max v u) ‚âÉ F.sections :=
  isLimitEquivSections (limit.isLimit _)
#align category_theory.limits.types.limit_equiv_sections CategoryTheory.Limits.Types.limitEquivSections

/- warning: category_theory.limits.types.limit_equiv_sections_apply -> CategoryTheory.Limits.Types.limitEquivSections_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)) (j : J), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) ((fun (a : Type.{max u1 u2}) (b : Sort.{max (succ u1) (succ (max u1 u2))}) [self : HasLiftT.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (HasLiftT.mk.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CoeTC‚Çì.coe.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeBase.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeSubtype.{max (succ u1) (succ (max u1 u2))} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (fun (x : forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) => Membership.Mem.{max u1 u2, max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (Set.hasMem.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) x (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)))))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F)) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F)) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) => (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F)) -> (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F)) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F))) (CategoryTheory.Limits.Types.limitEquivSections.{u1, u2} J _inst_1 F) x) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (Subtype.val.{succ (max u2 u1)} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (fun (x : forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) => Membership.mem.{max u2 u1, max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (Set.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) (Set.instMembershipSet.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) x (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F))) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (fun (_x : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) => Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F))) (CategoryTheory.Limits.Types.limitEquivSections.{u1, u2} J _inst_1 F) x) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit_equiv_sections_apply CategoryTheory.Limits.Types.limitEquivSections_apply‚Çì'. -/
@[simp]
theorem limitEquivSections_apply (F : J ‚•§ Type max v u) (x : limit F) (j : J) :
    ((limitEquivSections F) x : ‚àÄ j, F.obj j) j = limit.œÄ F j x :=
  rfl
#align category_theory.limits.types.limit_equiv_sections_apply CategoryTheory.Limits.Types.limitEquivSections_apply

/- warning: category_theory.limits.types.limit_equiv_sections_symm_apply -> CategoryTheory.Limits.Types.limitEquivSections_symm_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (j : J), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F) j (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F))) => (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) -> (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F))) (Equiv.symm.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.limitEquivSections._proof_1.{u2, u1} J _inst_1 F)) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.limitEquivSections.{u1, u2} J _inst_1 F)) x)) ((fun (a : Type.{max u1 u2}) (b : Sort.{max (succ u1) (succ (max u1 u2))}) [self : HasLiftT.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (HasLiftT.mk.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CoeTC‚Çì.coe.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeBase.{succ (max u1 u2), max (succ u1) (succ (max u1 u2))} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)) (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (coeSubtype.{max (succ u1) (succ (max u1 u2))} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (fun (x : forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) => Membership.Mem.{max u1 u2, max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (Set.hasMem.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) x (CategoryTheory.Functor.sections.{u1, max u1 u2, u1} J _inst_1 F)))))) x j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F))) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (fun (_x : Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) => CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (Set.Elem.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.limitEquivSections.{u1, u2} J _inst_1 F)) x)) (Subtype.val.{succ (max u2 u1)} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (fun (x : forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) => Membership.mem.{max u2 u1, max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j) (Set.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) (Set.instMembershipSet.{max u2 u1} (forall (j : J), Prefunctor.obj.{succ u1, succ (max u2 u1), u1, succ (max u2 u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, succ (max u2 u1)} J _inst_1 Type.{max u2 u1} CategoryTheory.types.{max u2 u1} F) j)) x (CategoryTheory.Functor.sections.{u1, max u2 u1, u1} J _inst_1 F)) x j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit_equiv_sections_symm_apply CategoryTheory.Limits.Types.limitEquivSections_symm_apply‚Çì'. -/
@[simp]
theorem limitEquivSections_symm_apply (F : J ‚•§ Type max v u) (x : F.sections) (j : J) :
    limit.œÄ F j ((limitEquivSections F).symm x) = (x : ‚àÄ j, F.obj j) j :=
  isLimitEquivSections_symm_apply _ _ _
#align category_theory.limits.types.limit_equiv_sections_symm_apply CategoryTheory.Limits.Types.limitEquivSections_symm_apply

@[simp]
theorem limitEquivSections_symm_apply' (F : J ‚•§ Type v) (x : F.sections) (j : J) :
    limit.œÄ F j ((limitEquivSections.{v, v} F).symm x) = (x : ‚àÄ j, F.obj j) j :=
  isLimitEquivSections_symm_apply _ _ _
#align category_theory.limits.types.limit_equiv_sections_symm_apply' CategoryTheory.Limits.Types.limitEquivSections_symm_apply'

/- warning: category_theory.limits.types.limit.mk -> CategoryTheory.Limits.Types.Limit.mk is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j), (forall (j : J) (j' : J) (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j') (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j j' f (x j)) (x j')) -> (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.Limit.mk._proof_1.{u2, u1} J _inst_1 F))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : forall (j : J), Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j), (forall (j : J) (j' : J) (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j') (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j j' f (x j)) (x j')) -> (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.mk CategoryTheory.Limits.Types.Limit.mk‚Çì'. -/
/-- Construct a term of `limit F : Type u` from a family of terms `x : Œ† j, F.obj j`
which are "coherent": `‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j'`.
-/
@[ext]
noncomputable def Limit.mk (F : J ‚•§ Type max v u) (x : ‚àÄ j, F.obj j)
    (h : ‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j') : (limit F : Type max v u) :=
  (limitEquivSections F).symm ‚ü®x, h‚ü©
#align category_theory.limits.types.limit.mk CategoryTheory.Limits.Types.Limit.mk

/- warning: category_theory.limits.types.limit.œÄ_mk -> CategoryTheory.Limits.Types.Limit.œÄ_mk is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : forall (j : J), CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (h : forall (j : J) (j' : J) (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j') (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j j' f (x j)) (x j')) (j : J), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.Limit.mk._proof_1.{u2, u1} J _inst_1 F) j (CategoryTheory.Limits.Types.Limit.mk.{u1, u2} J _inst_1 F x h)) (x j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : forall (j : J), Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (h : forall (j : J) (j' : J) (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j') (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j j' f (x j)) (x j')) (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j (CategoryTheory.Limits.Types.Limit.mk.{u1, u2} J _inst_1 F x h)) (x j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.œÄ_mk CategoryTheory.Limits.Types.Limit.œÄ_mk‚Çì'. -/
@[simp]
theorem Limit.œÄ_mk (F : J ‚•§ Type max v u) (x : ‚àÄ j, F.obj j)
    (h : ‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j') (j) : limit.œÄ F j (Limit.mk F x h) = x j :=
  by
  dsimp [limit.mk]
  simp
#align category_theory.limits.types.limit.œÄ_mk CategoryTheory.Limits.Types.Limit.œÄ_mk

@[simp]
theorem Limit.œÄ_mk' (F : J ‚•§ Type v) (x : ‚àÄ j, F.obj j)
    (h : ‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j') (j) :
    limit.œÄ F j (Limit.mk.{v, v} F x h) = x j :=
  by
  dsimp [limit.mk]
  simp
#align category_theory.limits.types.limit.œÄ_mk' CategoryTheory.Limits.Types.Limit.œÄ_mk'

/- warning: category_theory.limits.types.limit_ext -> CategoryTheory.Limits.Types.limit_ext is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)) (y : CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)), (forall (j : J), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j y)) -> (Eq.{succ (max u1 u2)} (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)) x y)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (y : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)), (forall (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j y)) -> (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) x y)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit_ext CategoryTheory.Limits.Types.limit_ext‚Çì'. -/
-- PROJECT: prove this for concrete categories where the forgetful functor preserves limits
@[ext]
theorem limit_ext (F : J ‚•§ Type max v u) (x y : limit F) (w : ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y) :
    x = y := by
  apply (limit_equiv_sections F).Injective
  ext j
  simp [w j]
#align category_theory.limits.types.limit_ext CategoryTheory.Limits.Types.limit_ext

/- warning: category_theory.limits.types.limit_ext' -> CategoryTheory.Limits.Types.limit_ext' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)) (y : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)), (forall (j : J), Eq.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j y)) -> (Eq.{succ u1} (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)) x y)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)) (y : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)), (forall (j : J), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j y)) -> (Eq.{succ u1} (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)) x y)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit_ext' CategoryTheory.Limits.Types.limit_ext'‚Çì'. -/
@[ext]
theorem limit_ext' (F : J ‚•§ Type v) (x y : limit F) (w : ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y) :
    x = y := by
  apply (limitEquivSections.{v, v} F).Injective
  ext j
  simp [w j]
#align category_theory.limits.types.limit_ext' CategoryTheory.Limits.Types.limit_ext'

/- warning: category_theory.limits.types.limit_ext_iff -> CategoryTheory.Limits.Types.limit_ext_iff is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)) (y : CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)), Iff (Eq.{succ (max u1 u2)} (CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)) x y) (forall (j : J), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j y))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) (y : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)), Iff (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)) x y) (forall (j : J), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j y))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit_ext_iff CategoryTheory.Limits.Types.limit_ext_iff‚Çì'. -/
theorem limit_ext_iff (F : J ‚•§ Type max v u) (x y : limit F) :
    x = y ‚Üî ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y :=
  ‚ü®fun t _ => t ‚ñ∏ rfl, limit_ext _ _ _‚ü©
#align category_theory.limits.types.limit_ext_iff CategoryTheory.Limits.Types.limit_ext_iff

/- warning: category_theory.limits.types.limit_ext_iff' -> CategoryTheory.Limits.Types.limit_ext_iff' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)) (y : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)), Iff (Eq.{succ u1} (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)) x y) (forall (j : J), Eq.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j y))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)) (y : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)), Iff (Eq.{succ u1} (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)) x y) (forall (j : J), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j x) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j y))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit_ext_iff' CategoryTheory.Limits.Types.limit_ext_iff'‚Çì'. -/
theorem limit_ext_iff' (F : J ‚•§ Type v) (x y : limit F) :
    x = y ‚Üî ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y :=
  ‚ü®fun t _ => t ‚ñ∏ rfl, limit_ext _ _ _‚ü©
#align category_theory.limits.types.limit_ext_iff' CategoryTheory.Limits.Types.limit_ext_iff'

/- warning: category_theory.limits.types.limit.w_apply -> CategoryTheory.Limits.Types.Limit.w_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {j : J} {j' : J} {x : CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j') (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j j' f (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j x)) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j' x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {j : J} {j' : J} {x : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j') (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j j' f (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j x)) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j' x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.w_apply CategoryTheory.Limits.Types.Limit.w_apply‚Çì'. -/
-- TODO: are there other limits lemmas that should have `_apply` versions?
-- Can we generate these like with `@[reassoc]`?
-- PROJECT: prove these for any concrete category where the forgetful functor preserves limits?
@[simp]
theorem Limit.w_apply {F : J ‚•§ Type max v u} {j j' : J} {x : limit F} (f : j ‚ü∂ j') :
    F.map f (limit.œÄ F j x) = limit.œÄ F j' x :=
  congr_fun (limit.w F f) x
#align category_theory.limits.types.limit.w_apply CategoryTheory.Limits.Types.Limit.w_apply

/- warning: category_theory.limits.types.limit.lift_œÄ_apply -> CategoryTheory.Limits.Types.Limit.lift_œÄ_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (s : CategoryTheory.Limits.Cone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F) (j : J) (x : CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F s), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j (CategoryTheory.Limits.limit.lift.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) s x)) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F s)) F (CategoryTheory.Limits.Cone.œÄ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F s) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (s : CategoryTheory.Limits.Cone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) (j : J) (x : CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F s), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j (CategoryTheory.Limits.limit.lift.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) s x)) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F s)) F (CategoryTheory.Limits.Cone.œÄ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F s) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.lift_œÄ_apply CategoryTheory.Limits.Types.Limit.lift_œÄ_apply‚Çì'. -/
@[simp]
theorem Limit.lift_œÄ_apply (F : J ‚•§ Type max v u) (s : Cone F) (j : J) (x : s.pt) :
    limit.œÄ F j (limit.lift F s x) = s.œÄ.app j x :=
  congr_fun (limit.lift_œÄ s j) x
#align category_theory.limits.types.limit.lift_œÄ_apply CategoryTheory.Limits.Types.Limit.lift_œÄ_apply

/- warning: category_theory.limits.types.limit.map_œÄ_apply -> CategoryTheory.Limits.Types.Limit.map_œÄ_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {G : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} (Œ± : Quiver.Hom.{succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u1 (max u1 u2) u1 (succ (max u1 u2))} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 (max u1 u2) u1 (succ (max u1 u2))} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}))) F G) (j : J) (x : CategoryTheory.Limits.limit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F)), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} G j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) G) j (CategoryTheory.Limits.limMap.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) G) Œ± x)) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F G Œ± j (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasLimitsOfSize.{u1, u2}) F) j x))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {G : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} (Œ± : Quiver.Hom.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) F G) (j : J) (x : CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F)), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} G) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} G (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 G) j (CategoryTheory.Limits.limMap.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F G (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 G) Œ± x)) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F G Œ± j (CategoryTheory.Limits.limit.œÄ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u2} J _inst_1 F) j x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.map_œÄ_apply CategoryTheory.Limits.Types.Limit.map_œÄ_apply‚Çì'. -/
@[simp]
theorem Limit.map_œÄ_apply {F G : J ‚•§ Type max v u} (Œ± : F ‚ü∂ G) (j : J) (x) :
    limit.œÄ G j (limMap Œ± x) = Œ±.app j (limit.œÄ F j x) :=
  congr_fun (limMap_œÄ Œ± j) x
#align category_theory.limits.types.limit.map_œÄ_apply CategoryTheory.Limits.Types.Limit.map_œÄ_apply

/- warning: category_theory.limits.types.limit.w_apply' -> CategoryTheory.Limits.Types.Limit.w_apply' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {j : J} {j' : J} {x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j') (CategoryTheory.Functor.map.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j j' f (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j x)) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j' x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {j : J} {j' : J} {x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j') (Prefunctor.map.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j j' f (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j x)) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j' x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.w_apply' CategoryTheory.Limits.Types.Limit.w_apply'‚Çì'. -/
@[simp]
theorem Limit.w_apply' {F : J ‚•§ Type v} {j j' : J} {x : limit F} (f : j ‚ü∂ j') :
    F.map f (limit.œÄ F j x) = limit.œÄ F j' x :=
  congr_fun (limit.w F f) x
#align category_theory.limits.types.limit.w_apply' CategoryTheory.Limits.Types.Limit.w_apply'

/- warning: category_theory.limits.types.limit.lift_œÄ_apply' -> CategoryTheory.Limits.Types.Limit.lift_œÄ_apply' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (s : CategoryTheory.Limits.Cone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) (j : J) (x : CategoryTheory.Limits.Cone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s), Eq.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j (CategoryTheory.Limits.limit.lift.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) s x)) (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.const.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Limits.Cone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (s : CategoryTheory.Limits.Cone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) (j : J) (x : CategoryTheory.Limits.Cone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j (CategoryTheory.Limits.limit.lift.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) s x)) (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.const.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Limits.Cone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.lift_œÄ_apply' CategoryTheory.Limits.Types.Limit.lift_œÄ_apply'‚Çì'. -/
@[simp]
theorem Limit.lift_œÄ_apply' (F : J ‚•§ Type v) (s : Cone F) (j : J) (x : s.pt) :
    limit.œÄ F j (limit.lift F s x) = s.œÄ.app j x :=
  congr_fun (limit.lift_œÄ s j) x
#align category_theory.limits.types.limit.lift_œÄ_apply' CategoryTheory.Limits.Types.Limit.lift_œÄ_apply'

/- warning: category_theory.limits.types.limit.map_œÄ_apply' -> CategoryTheory.Limits.Types.Limit.map_œÄ_apply' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {G : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} (Œ± : Quiver.Hom.{succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) F G) (j : J) (x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F)), Eq.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} G j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) G) j (CategoryTheory.Limits.limMap.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) G) Œ± x)) (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F G Œ± j (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) F) j x))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {G : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} (Œ± : Quiver.Hom.{succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) F G) (j : J) (x : CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F)), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} G) j) (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} G (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 G) j (CategoryTheory.Limits.limMap.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F G (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 G) Œ± x)) (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F G Œ± j (CategoryTheory.Limits.limit.œÄ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasLimit.{u1, u1} J _inst_1 F) j x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.limit.map_œÄ_apply' CategoryTheory.Limits.Types.Limit.map_œÄ_apply'‚Çì'. -/
@[simp]
theorem Limit.map_œÄ_apply' {F G : J ‚•§ Type v} (Œ± : F ‚ü∂ G) (j : J) (x) :
    limit.œÄ G j (limMap Œ± x) = Œ±.app j (limit.œÄ F j x) :=
  congr_fun (limMap_œÄ Œ± j) x
#align category_theory.limits.types.limit.map_œÄ_apply' CategoryTheory.Limits.Types.Limit.map_œÄ_apply'

/- warning: category_theory.limits.types.quot.rel -> CategoryTheory.Limits.Types.Quot.Rel is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}), (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) -> (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) -> Prop
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}), (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) -> (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) -> Prop
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.quot.rel CategoryTheory.Limits.Types.Quot.Rel‚Çì'. -/
/--
The relation defining the quotient type which implements the colimit of a functor `F : J ‚•§ Type u`.
See `category_theory.limits.types.quot`.
-/
def Quot.Rel (F : J ‚•§ Type max v u) : (Œ£j, F.obj j) ‚Üí (Œ£j, F.obj j) ‚Üí Prop := fun p p' =>
  ‚àÉ f : p.1 ‚ü∂ p'.1, p'.2 = F.map f p.2
#align category_theory.limits.types.quot.rel CategoryTheory.Limits.Types.Quot.Rel

#print CategoryTheory.Limits.Types.Quot /-
/-- A quotient type implementing the colimit of a functor `F : J ‚•§ Type u`,
as pairs `‚ü®j, x‚ü©` where `x : F.obj j`, modulo the equivalence relation generated by
`‚ü®j, x‚ü© ~ ‚ü®j', x'‚ü©` whenever there is a morphism `f : j ‚ü∂ j'` so `F.map f x = x'`.
-/
@[nolint has_nonempty_instance]
def Quot (F : J ‚•§ Type max v u) : Type max v u :=
  @Quot (Œ£j, F.obj j) (Quot.Rel F)
#align category_theory.limits.types.quot CategoryTheory.Limits.Types.Quot
-/

#print CategoryTheory.Limits.Types.colimitCocone /-
/-- (internal implementation) the colimit cocone of a functor,
implemented as a quotient of a sigma type
-/
def colimitCocone (F : J ‚•§ Type max v u) : Cocone F
    where
  pt := Quot F
  Œπ :=
    { app := fun j x => Quot.mk _ ‚ü®j, x‚ü©
      naturality' := fun j j' f => funext fun x => Eq.symm (Quot.sound ‚ü®f, rfl‚ü©) }
#align category_theory.limits.types.colimit_cocone CategoryTheory.Limits.Types.colimitCocone
-/

attribute [local elab_with_expected_type] Quot.lift

#print CategoryTheory.Limits.Types.colimitCoconeIsColimit /-
/-- (internal implementation) the fact that the proposed colimit cocone is the colimit -/
def colimitCoconeIsColimit (F : J ‚•§ Type max v u) : IsColimit (colimitCocone F)
    where desc s :=
    Quot.lift (fun p : Œ£j, F.obj j => s.Œπ.app p.1 p.2) fun ‚ü®j, x‚ü© ‚ü®j', x'‚ü© ‚ü®f, hf‚ü© => by
      rw [hf] <;> exact (congr_fun (cocone.w s f) x).symm
#align category_theory.limits.types.colimit_cocone_is_colimit CategoryTheory.Limits.Types.colimitCoconeIsColimit
-/

#print CategoryTheory.Limits.Types.hasColimitsOfSize /-
/-- The category of types has all colimits.

See <https://stacks.math.columbia.edu/tag/002U>.
-/
instance hasColimitsOfSize : HasColimitsOfSize.{v} (Type max v u)
    where HasColimitsOfShape J ùí• :=
    {
      HasColimit := fun F =>
        has_colimit.mk
          { Cocone := colimit_cocone F
            IsColimit := colimit_cocone_is_colimit F } }
#align category_theory.limits.types.has_colimits_of_size CategoryTheory.Limits.Types.hasColimitsOfSize
-/

instance : HasColimits (Type u) :=
  Types.hasColimitsOfSize.{u, u}

#print CategoryTheory.Limits.Types.colimitEquivQuot /-
/-- The equivalence between the abstract colimit of `F` in `Type u`
and the "concrete" definition as a quotient.
-/
noncomputable def colimitEquivQuot (F : J ‚•§ Type max v u) : (colimit F : Type max v u) ‚âÉ Quot F :=
  (IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) (colimitCoconeIsColimit F)).toEquiv
#align category_theory.limits.types.colimit_equiv_quot CategoryTheory.Limits.Types.colimitEquivQuot
-/

/- warning: category_theory.limits.types.colimit_equiv_quot_symm_apply -> CategoryTheory.Limits.Types.colimitEquivQuot_symm_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (j : J) (x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j), Eq.{succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F))) => (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) -> (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F))) (Equiv.symm.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.Types.colimitEquivQuot.{u1, u2} J _inst_1 F)) (Quot.mk.{max (succ u1) (succ (max u1 u2))} (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) (Sigma.mk.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) j x))) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (j : J) (x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) => CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (Quot.mk.{max (succ u2) (succ u1)} (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) (Sigma.mk.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) j x))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F))) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (fun (_x : CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) => CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.Types.colimitEquivQuot.{u1, u2} J _inst_1 F)) (Quot.mk.{max (succ u2) (succ u1)} (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) (Sigma.mk.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) j x))) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit_equiv_quot_symm_apply CategoryTheory.Limits.Types.colimitEquivQuot_symm_apply‚Çì'. -/
@[simp]
theorem colimitEquivQuot_symm_apply (F : J ‚•§ Type max v u) (j : J) (x : F.obj j) :
    (colimitEquivQuot F).symm (Quot.mk _ ‚ü®j, x‚ü©) = colimit.Œπ F j x :=
  rfl
#align category_theory.limits.types.colimit_equiv_quot_symm_apply CategoryTheory.Limits.Types.colimitEquivQuot_symm_apply

/- warning: category_theory.limits.types.colimit_equiv_quot_apply -> CategoryTheory.Limits.Types.colimitEquivQuot_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (j : J) (x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j), Eq.{succ (max u1 u2)} (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F)) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F)) => (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F)) -> (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F)) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F)) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.Types.colimitEquivQuot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitEquivQuot._proof_1.{u2, u1} J _inst_1 F) j x)) (Quot.mk.{max (succ u1) (succ (max u1 u2))} (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) (Sigma.mk.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) j x))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (j : J) (x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) => CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (fun (_x : CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) => CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.Types.Quot.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.Types.colimitEquivQuot.{u1, u2} J _inst_1 F) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x)) (Quot.mk.{max (succ u2) (succ u1)} (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) (Sigma.mk.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) j x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit_equiv_quot_apply CategoryTheory.Limits.Types.colimitEquivQuot_apply‚Çì'. -/
@[simp]
theorem colimitEquivQuot_apply (F : J ‚•§ Type max v u) (j : J) (x : F.obj j) :
    (colimitEquivQuot F) (colimit.Œπ F j x) = Quot.mk _ ‚ü®j, x‚ü© :=
  by
  apply (colimit_equiv_quot F).symm.Injective
  simp
#align category_theory.limits.types.colimit_equiv_quot_apply CategoryTheory.Limits.Types.colimitEquivQuot_apply

/- warning: category_theory.limits.types.colimit.w_apply -> CategoryTheory.Limits.Types.Colimit.w_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {j : J} {j' : J} {x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j' (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j j' f x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {j : J} {j' : J} {x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j' (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j j' f x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit.w_apply CategoryTheory.Limits.Types.Colimit.w_apply‚Çì'. -/
@[simp]
theorem Colimit.w_apply {F : J ‚•§ Type max v u} {j j' : J} {x : F.obj j} (f : j ‚ü∂ j') :
    colimit.Œπ F j' (F.map f x) = colimit.Œπ F j x :=
  congr_fun (colimit.w F f) x
#align category_theory.limits.types.colimit.w_apply CategoryTheory.Limits.Types.Colimit.w_apply

/- warning: category_theory.limits.types.colimit.Œπ_desc_apply -> CategoryTheory.Limits.Types.Colimit.Œπ_desc_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (s : CategoryTheory.Limits.Cocone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F) (j : J) (x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j), Eq.{succ (max u1 u2)} (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F s) (CategoryTheory.Limits.colimit.desc.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) s (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j x)) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F s)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F s) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (s : CategoryTheory.Limits.Cocone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) (j : J) (x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F s) (CategoryTheory.Limits.colimit.desc.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) s (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x)) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F s)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F s) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit.Œπ_desc_apply CategoryTheory.Limits.Types.Colimit.Œπ_desc_apply‚Çì'. -/
@[simp]
theorem Colimit.Œπ_desc_apply (F : J ‚•§ Type max v u) (s : Cocone F) (j : J) (x : F.obj j) :
    colimit.desc F s (colimit.Œπ F j x) = s.Œπ.app j x :=
  congr_fun (colimit.Œπ_desc s j) x
#align category_theory.limits.types.colimit.Œπ_desc_apply CategoryTheory.Limits.Types.Colimit.Œπ_desc_apply

/- warning: category_theory.limits.types.colimit.Œπ_map_apply -> CategoryTheory.Limits.Types.Colimit.Œπ_map_apply is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {G : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} (Œ± : Quiver.Hom.{succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u1 (max u1 u2) u1 (succ (max u1 u2))} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 (max u1 u2) u1 (succ (max u1 u2))} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}))) F G) (j : J) (x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j), Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, max u1 (max u1 u2) u1 (succ (max u1 u2)), succ (max u1 u2)} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.colim.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2})) G) (CategoryTheory.Functor.map.{max u1 u2, max u1 u2, max u1 (max u1 u2) u1 (succ (max u1 u2)), succ (max u1 u2)} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.colim.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2})) F G Œ± (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) G) j (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F G Œ± j x))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {G : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} (Œ± : Quiver.Hom.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) F G) (j : J) (x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{max (succ u1) (succ (max u2 u1)), succ (max u2 u1), max (max u1 (succ u2) (succ u1)) u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.colim.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.HasColimitsOfSize.has_colimits_of_shape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2} J _inst_1))) G) (Prefunctor.map.{max (succ u1) (succ (max u2 u1)), succ (max u2 u1), max (max u1 (succ u2) (succ u1)) u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1, max (succ u2) (succ u1)} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.colim.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.HasColimitsOfSize.has_colimits_of_shape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2} J _inst_1))) F G Œ± (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} G (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 G) j (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F G Œ± j x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit.Œπ_map_apply CategoryTheory.Limits.Types.Colimit.Œπ_map_apply‚Çì'. -/
@[simp]
theorem Colimit.Œπ_map_apply {F G : J ‚•§ Type max v u} (Œ± : F ‚ü∂ G) (j : J) (x) :
    colim.map Œ± (colimit.Œπ F j x) = colimit.Œπ G j (Œ±.app j x) :=
  congr_fun (colimit.Œπ_map Œ± j) x
#align category_theory.limits.types.colimit.Œπ_map_apply CategoryTheory.Limits.Types.Colimit.Œπ_map_apply

/- warning: category_theory.limits.types.colimit.w_apply' -> CategoryTheory.Limits.Types.Colimit.w_apply' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {j : J} {j' : J} {x : CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F) j' (CategoryTheory.Functor.map.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j j' f x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {j : J} {j' : J} {x : Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), Eq.{succ u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasColimit'.{u1} J _inst_1 F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasColimit'.{u1} J _inst_1 F) j' (Prefunctor.map.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j j' f x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasColimit'.{u1} J _inst_1 F) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit.w_apply' CategoryTheory.Limits.Types.Colimit.w_apply'‚Çì'. -/
@[simp]
theorem Colimit.w_apply' {F : J ‚•§ Type v} {j j' : J} {x : F.obj j} (f : j ‚ü∂ j') :
    colimit.Œπ F j' (F.map f x) = colimit.Œπ F j x :=
  congr_fun (colimit.w F f) x
#align category_theory.limits.types.colimit.w_apply' CategoryTheory.Limits.Types.Colimit.w_apply'

/- warning: category_theory.limits.types.colimit.Œπ_desc_apply' -> CategoryTheory.Limits.Types.Colimit.Œπ_desc_apply' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (s : CategoryTheory.Limits.Cocone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) (j : J) (x : CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j), Eq.{succ u1} (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s) (CategoryTheory.Limits.colimit.desc.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F) s (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F) j x)) (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.const.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s) j x)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (s : CategoryTheory.Limits.Cocone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) (j : J) (x : Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j), Eq.{succ u1} (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s) (CategoryTheory.Limits.colimit.desc.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasColimit'.{u1} J _inst_1 F) s (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasColimit'.{u1} J _inst_1 F) j x)) (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.const.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Limits.Cocone.pt.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F s) j x)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit.Œπ_desc_apply' CategoryTheory.Limits.Types.Colimit.Œπ_desc_apply'‚Çì'. -/
@[simp]
theorem Colimit.Œπ_desc_apply' (F : J ‚•§ Type v) (s : Cocone F) (j : J) (x : F.obj j) :
    colimit.desc F s (colimit.Œπ F j x) = s.Œπ.app j x :=
  congr_fun (colimit.Œπ_desc s j) x
#align category_theory.limits.types.colimit.Œπ_desc_apply' CategoryTheory.Limits.Types.Colimit.Œπ_desc_apply'

/- warning: category_theory.limits.types.colimit.Œπ_map_apply' -> CategoryTheory.Limits.Types.Colimit.Œπ_map_apply' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {G : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} (Œ± : Quiver.Hom.{succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) F G) (j : J) (x : CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j), Eq.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1})) G) (CategoryTheory.Functor.map.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1})) F G Œ± (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F) j x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) G) j (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F G Œ± j x))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} {G : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}} (Œ± : Quiver.Hom.{succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) F G) (j : J) (x : Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))) G) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))) F G Œ± (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.Types.hasColimit'.{u1} J _inst_1 F) j x)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} G (CategoryTheory.Limits.Types.hasColimit'.{u1} J _inst_1 G) j (CategoryTheory.NatTrans.app.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F G Œ± j x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit.Œπ_map_apply' CategoryTheory.Limits.Types.Colimit.Œπ_map_apply'‚Çì'. -/
@[simp]
theorem Colimit.Œπ_map_apply' {F G : J ‚•§ Type v} (Œ± : F ‚ü∂ G) (j : J) (x) :
    colim.map Œ± (colimit.Œπ F j x) = colimit.Œπ G j (Œ±.app j x) :=
  congr_fun (colimit.Œπ_map Œ± j) x
#align category_theory.limits.types.colimit.Œπ_map_apply' CategoryTheory.Limits.Types.Colimit.Œπ_map_apply'

/- warning: category_theory.limits.types.colimit_sound -> CategoryTheory.Limits.Types.colimit_sound is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {j : J} {j' : J} {x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j} {x' : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j'} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), (Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j') (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j j' f x) x') -> (Eq.{succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j x) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j' x'))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {j : J} {j' : J} {x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j} {x' : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j'} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'), (Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j') (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j j' f x) x') -> (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j' x'))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit_sound CategoryTheory.Limits.Types.colimit_sound‚Çì'. -/
theorem colimit_sound {F : J ‚•§ Type max v u} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j ‚ü∂ j')
    (w : F.map f x = x') : colimit.Œπ F j x = colimit.Œπ F j' x' :=
  by
  rw [‚Üê w]
  simp
#align category_theory.limits.types.colimit_sound CategoryTheory.Limits.Types.colimit_sound

/- warning: category_theory.limits.types.colimit_sound' -> CategoryTheory.Limits.Types.colimit_sound' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {j : J} {j' : J} {x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j} {x' : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j'} {j'' : J} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'') (f' : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j' j''), (Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j'') (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j j'' f x) (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j' j'' f' x')) -> (Eq.{succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j x) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j' x'))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {j : J} {j' : J} {x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j} {x' : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j'} {j'' : J} (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j j'') (f' : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j' j''), (Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j'') (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j j'' f x) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j' j'' f' x')) -> (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j' x'))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit_sound' CategoryTheory.Limits.Types.colimit_sound'‚Çì'. -/
theorem colimit_sound' {F : J ‚•§ Type max v u} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J}
    (f : j ‚ü∂ j'') (f' : j' ‚ü∂ j'') (w : F.map f x = F.map f' x') :
    colimit.Œπ F j x = colimit.Œπ F j' x' :=
  by
  rw [‚Üê colimit.w _ f, ‚Üê colimit.w _ f']
  rw [types_comp_apply, types_comp_apply, w]
#align category_theory.limits.types.colimit_sound' CategoryTheory.Limits.Types.colimit_sound'

/- warning: category_theory.limits.types.colimit_eq -> CategoryTheory.Limits.Types.colimit_eq is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} {j : J} {j' : J} {x : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j} {x' : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j'}, (Eq.{succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j x) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j' x')) -> (EqvGen.{max u1 u2} (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) (Sigma.mk.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) j x) (Sigma.mk.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) j' x'))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} {j : J} {j' : J} {x : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j} {x' : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j'}, (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j x) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j' x')) -> (EqvGen.{max u2 u1} (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) (Sigma.mk.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) j x) (Sigma.mk.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) j' x'))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.colimit_eq CategoryTheory.Limits.Types.colimit_eq‚Çì'. -/
theorem colimit_eq {F : J ‚•§ Type max v u} {j j' : J} {x : F.obj j} {x' : F.obj j'}
    (w : colimit.Œπ F j x = colimit.Œπ F j' x') : EqvGen (Quot.Rel F) ‚ü®j, x‚ü© ‚ü®j', x'‚ü© :=
  by
  apply Quot.eq.1
  simpa using congr_arg (colimit_equiv_quot F) w
#align category_theory.limits.types.colimit_eq CategoryTheory.Limits.Types.colimit_eq

/- warning: category_theory.limits.types.jointly_surjective -> CategoryTheory.Limits.Types.jointly_surjective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) {t : CategoryTheory.Limits.Cocone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F}, (CategoryTheory.Limits.IsColimit.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) -> (forall (x : CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t), Exists.{succ u1} J (fun (j : J) => Exists.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (fun (y : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) => Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) j) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) j y) x)))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) {t : CategoryTheory.Limits.Cocone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F}, (CategoryTheory.Limits.IsColimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) -> (forall (x : CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t), Exists.{succ u1} J (fun (j : J) => Exists.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (fun (y : Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) => Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t))) j) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) j y) x)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.jointly_surjective CategoryTheory.Limits.Types.jointly_surjective‚Çì'. -/
theorem jointly_surjective (F : J ‚•§ Type max v u) {t : Cocone F} (h : IsColimit t) (x : t.pt) :
    ‚àÉ j y, t.Œπ.app j y = x :=
  by
  suffices (fun x : t.X => ULift.up (‚àÉ j y, t.Œπ.app j y = x)) = fun _ => ULift.up True
    by
    have := congr_fun this x
    have H := congr_arg ULift.down this
    dsimp at H
    rwa [eq_true_iff] at H
  refine' h.hom_ext _
  intro j
  ext y
  erw [iff_true_iff]
  exact ‚ü®j, y, rfl‚ü©
#align category_theory.limits.types.jointly_surjective CategoryTheory.Limits.Types.jointly_surjective

/- warning: category_theory.limits.types.jointly_surjective' -> CategoryTheory.Limits.Types.jointly_surjective' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}} (x : CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F)), Exists.{succ u1} J (fun (j : J) => Exists.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) (fun (y : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) => Eq.{succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j y) x))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}} (x : CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Sort.{max (succ u2) (succ u1)} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)), Exists.{succ u1} J (fun (j : J) => Exists.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) (fun (y : Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) => Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j y) x))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.jointly_surjective' CategoryTheory.Limits.Types.jointly_surjective'‚Çì'. -/
/-- A variant of `jointly_surjective` for `x : colimit F`. -/
theorem jointly_surjective' {F : J ‚•§ Type max v u} (x : colimit F) : ‚àÉ j y, colimit.Œπ F j y = x :=
  jointly_surjective F (colimit.isColimit _) x
#align category_theory.limits.types.jointly_surjective' CategoryTheory.Limits.Types.jointly_surjective'

namespace FilteredColimit

/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit.  -/
variable (F : J ‚•§ Type max v u)

/- warning: category_theory.limits.types.filtered_colimit.rel -> CategoryTheory.Limits.Types.FilteredColimit.Rel is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}), (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) -> (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) -> Prop
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}), (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) -> (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) -> Prop
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.rel CategoryTheory.Limits.Types.FilteredColimit.Rel‚Çì'. -/
/-- An alternative relation on `Œ£ j, F.obj j`,
which generates the same equivalence relation as we use to define the colimit in `Type` above,
but that is more convenient when working with filtered colimits.

Elements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right
where their images are equal.
-/
protected def Rel (x y : Œ£j, F.obj j) : Prop :=
  ‚àÉ (k : _)(f : x.1 ‚ü∂ k)(g : y.1 ‚ü∂ k), F.map f x.2 = F.map g y.2
#align category_theory.limits.types.filtered_colimit.rel CategoryTheory.Limits.Types.FilteredColimit.Rel

/- warning: category_theory.limits.types.filtered_colimit.rel_of_quot_rel -> CategoryTheory.Limits.Types.FilteredColimit.rel_of_quot_rel is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (y : Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)), (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F x y) -> (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F x y)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (y : Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)), (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F x y) -> (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F x y)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.rel_of_quot_rel CategoryTheory.Limits.Types.FilteredColimit.rel_of_quot_rel‚Çì'. -/
theorem rel_of_quot_rel (x y : Œ£j, F.obj j) : Quot.Rel F x y ‚Üí FilteredColimit.Rel F x y :=
  fun ‚ü®f, h‚ü© => ‚ü®y.1, f, ùüô y.1, by rw [‚Üê h, functor_to_types.map_id_apply]‚ü©
#align category_theory.limits.types.filtered_colimit.rel_of_quot_rel CategoryTheory.Limits.Types.FilteredColimit.rel_of_quot_rel

/- warning: category_theory.limits.types.filtered_colimit.eqv_gen_quot_rel_of_rel -> CategoryTheory.Limits.Types.FilteredColimit.eqvGen_quot_rel_of_rel is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (x : Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (y : Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)), (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F x y) -> (EqvGen.{max u1 u2} (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) x y)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (x : Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (y : Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)), (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F x y) -> (EqvGen.{max u2 u1} (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F) x y)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.eqv_gen_quot_rel_of_rel CategoryTheory.Limits.Types.FilteredColimit.eqvGen_quot_rel_of_rel‚Çì'. -/
theorem eqvGen_quot_rel_of_rel (x y : Œ£j, F.obj j) :
    FilteredColimit.Rel F x y ‚Üí EqvGen (Quot.Rel F) x y := fun ‚ü®k, f, g, h‚ü© =>
  EqvGen.trans _ ‚ü®k, F.map f x.2‚ü© _ (EqvGen.rel _ _ ‚ü®f, rfl‚ü©)
    (EqvGen.symm _ _ (EqvGen.rel _ _ ‚ü®g, h‚ü©))
#align category_theory.limits.types.filtered_colimit.eqv_gen_quot_rel_of_rel CategoryTheory.Limits.Types.FilteredColimit.eqvGen_quot_rel_of_rel

attribute [local elab_without_expected_type] nat_trans.app

/- warning: category_theory.limits.types.filtered_colimit.is_colimit_of -> CategoryTheory.Limits.Types.FilteredColimit.isColimitOf is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (t : CategoryTheory.Limits.Cocone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F), (forall (x : CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t), Exists.{succ u1} J (fun (i : J) => Exists.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i) (fun (xi : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i) => Eq.{succ (max u1 u2)} (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) x (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) i xi)))) -> (forall (i : J) (j : J) (xi : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i) (xj : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j), (Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) i) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) i xi) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) j xj)) -> (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) => Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F k) (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i k f xi) (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j k g xj)))))) -> (CategoryTheory.Limits.IsColimit.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (t : CategoryTheory.Limits.Cocone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F), (forall (x : CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t), Exists.{succ u1} J (fun (i : J) => Exists.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i) (fun (xi : Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i) => Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) x (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) i xi)))) -> (forall (i : J) (j : J) (xi : Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i) (xj : Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j), (Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t))) i) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) i xi) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) j xj)) -> (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) => Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) k) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i k f xi) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j k g xj)))))) -> (CategoryTheory.Limits.IsColimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.is_colimit_of CategoryTheory.Limits.Types.FilteredColimit.isColimitOf‚Çì'. -/
/-- Recognizing filtered colimits of types. -/
noncomputable def isColimitOf (t : Cocone F) (hsurj : ‚àÄ x : t.pt, ‚àÉ i xi, x = t.Œπ.app i xi)
    (hinj :
      ‚àÄ i j xi xj,
        t.Œπ.app i xi = t.Œπ.app j xj ‚Üí ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj) :
    IsColimit t :=
  by
  -- Strategy: Prove that the map from "the" colimit of F (defined above) to t.X
  -- is a bijection.
  apply is_colimit.of_iso_colimit (colimit.is_colimit F)
  refine' cocones.ext (Equiv.toIso (Equiv.ofBijective _ _)) _
  ¬∑ exact colimit.desc F t
  ¬∑ constructor
    ¬∑ show Function.Injective _
      intro a b h
      rcases jointly_surjective F (colimit.is_colimit F) a with ‚ü®i, xi, rfl‚ü©
      rcases jointly_surjective F (colimit.is_colimit F) b with ‚ü®j, xj, rfl‚ü©
      change (colimit.Œπ F i ‚â´ colimit.desc F t) xi = (colimit.Œπ F j ‚â´ colimit.desc F t) xj at h
      rw [colimit.Œπ_desc, colimit.Œπ_desc] at h
      rcases hinj i j xi xj h with ‚ü®k, f, g, h'‚ü©
      change colimit.Œπ F i xi = colimit.Œπ F j xj
      rw [‚Üê colimit.w F f, ‚Üê colimit.w F g]
      change colimit.Œπ F k (F.map f xi) = colimit.Œπ F k (F.map g xj)
      rw [h']
    ¬∑ show Function.Surjective _
      intro x
      rcases hsurj x with ‚ü®i, xi, rfl‚ü©
      use colimit.Œπ F i xi
      simp
  ¬∑ intro j
    apply colimit.Œπ_desc
#align category_theory.limits.types.filtered_colimit.is_colimit_of CategoryTheory.Limits.Types.FilteredColimit.isColimitOf

variable [IsFilteredOrEmpty J]

/- warning: category_theory.limits.types.filtered_colimit.rel_equiv -> CategoryTheory.Limits.Types.FilteredColimit.rel_equiv is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1], Equivalence.{max (succ u1) (succ (max u1 u2))} (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1], Equivalence.{max (succ u2) (succ u1)} (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.rel_equiv CategoryTheory.Limits.Types.FilteredColimit.rel_equiv‚Çì'. -/
protected theorem rel_equiv : Equivalence (FilteredColimit.Rel F) :=
  ‚ü®fun x => ‚ü®x.1, ùüô x.1, ùüô x.1, rfl‚ü©, fun x y ‚ü®k, f, g, h‚ü© => ‚ü®k, g, f, h.symm‚ü©,
    fun x y z ‚ü®k, f, g, h‚ü© ‚ü®k', f', g', h'‚ü© =>
    let ‚ü®l, fl, gl, _‚ü© := IsFilteredOrEmpty.cocone_objs k k'
    let ‚ü®m, n, hn‚ü© := IsFilteredOrEmpty.cocone_maps (g ‚â´ fl) (f' ‚â´ gl)
    ‚ü®m, f ‚â´ fl ‚â´ n, g' ‚â´ gl ‚â´ n,
      calc
        F.map (f ‚â´ fl ‚â´ n) x.2 = F.map (fl ‚â´ n) (F.map f x.2) := by simp
        _ = F.map (fl ‚â´ n) (F.map g y.2) := by rw [h]
        _ = F.map ((g ‚â´ fl) ‚â´ n) y.2 := by simp
        _ = F.map ((f' ‚â´ gl) ‚â´ n) y.2 := by rw [hn]
        _ = F.map (gl ‚â´ n) (F.map f' y.2) := by simp
        _ = F.map (gl ‚â´ n) (F.map g' z.2) := by rw [h']
        _ = F.map (g' ‚â´ gl ‚â´ n) z.2 := by simp
        ‚ü©‚ü©
#align category_theory.limits.types.filtered_colimit.rel_equiv CategoryTheory.Limits.Types.FilteredColimit.rel_equiv

/- warning: category_theory.limits.types.filtered_colimit.rel_eq_eqv_gen_quot_rel -> CategoryTheory.Limits.Types.FilteredColimit.rel_eq_eqvGen_quot_rel is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1], Eq.{max (max (succ u1) (succ (max u1 u2))) 1} ((Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) -> (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) -> Prop) (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F) (EqvGen.{max u1 u2} (Sigma.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1], Eq.{max (succ u2) (succ u1)} ((Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) -> (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) -> Prop) (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F) (EqvGen.{max u2 u1} (Sigma.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j)) (CategoryTheory.Limits.Types.Quot.Rel.{u1, u2} J _inst_1 F))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.rel_eq_eqv_gen_quot_rel CategoryTheory.Limits.Types.FilteredColimit.rel_eq_eqvGen_quot_rel‚Çì'. -/
protected theorem rel_eq_eqvGen_quot_rel : FilteredColimit.Rel F = EqvGen (Quot.Rel F) :=
  by
  ext (‚ü®j, x‚ü©‚ü®j', y‚ü©)
  constructor
  ¬∑ apply eqv_gen_quot_rel_of_rel
  ¬∑ rw [‚Üê (filtered_colimit.rel_equiv F).eqvGen_iff]
    exact EqvGen.mono (rel_of_quot_rel F)
#align category_theory.limits.types.filtered_colimit.rel_eq_eqv_gen_quot_rel CategoryTheory.Limits.Types.FilteredColimit.rel_eq_eqvGen_quot_rel

/- warning: category_theory.limits.types.filtered_colimit.colimit_eq_iff_aux -> CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff_aux is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1] {i : J} {j : J} {xi : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i} {xj : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j}, Iff (Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F))) i) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F))) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F)) i xi) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F))) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F)) j xj)) (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F (Sigma.mk.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) i xi) (Sigma.mk.{u1, max u1 u2} J (fun (j : J) => CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j) j xj))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1] {i : J} {j : J} {xi : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i} {xj : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j}, Iff (Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F)))) i) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F))) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F)) i xi) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F))) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.colimitCocone.{u1, u2} J _inst_1 F)) j xj)) (CategoryTheory.Limits.Types.FilteredColimit.Rel.{u1, u2} J _inst_1 F (Sigma.mk.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) i xi) (Sigma.mk.{u1, max u2 u1} J (fun (j : J) => Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j) j xj))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.colimit_eq_iff_aux CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff_aux‚Çì'. -/
theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :
    (colimitCocone F).Œπ.app i xi = (colimitCocone F).Œπ.app j xj ‚Üî
      FilteredColimit.Rel F ‚ü®i, xi‚ü© ‚ü®j, xj‚ü© :=
  by
  change Quot.mk _ _ = Quot.mk _ _ ‚Üî _
  rw [Quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]
#align category_theory.limits.types.filtered_colimit.colimit_eq_iff_aux CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff_aux

/- warning: category_theory.limits.types.filtered_colimit.is_colimit_eq_iff -> CategoryTheory.Limits.Types.FilteredColimit.isColimit_eq_iff is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1] {t : CategoryTheory.Limits.Cocone.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F}, (CategoryTheory.Limits.IsColimit.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) -> (forall {i : J} {j : J} {xi : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i} {xj : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j}, Iff (Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) i) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) i xi) (CategoryTheory.NatTrans.app.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, succ (max u1 u2), max u1 (max u1 u2) u1 (succ (max u1 u2))} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.category.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.const.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Limits.Cocone.pt.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F t) j xj)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) => Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F k) (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i k f xi) (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j k g xj))))))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1] {t : CategoryTheory.Limits.Cocone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F}, (CategoryTheory.Limits.IsColimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) -> (forall {i : J} {j : J} {xi : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i} {xj : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j}, Iff (Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t))) i) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) i xi) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F t) j xj)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) => Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) k) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i k f xi) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j k g xj))))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.is_colimit_eq_iff CategoryTheory.Limits.Types.FilteredColimit.isColimit_eq_iff‚Çì'. -/
theorem isColimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :
    t.Œπ.app i xi = t.Œπ.app j xj ‚Üî ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj :=
  by
  let t' := colimitCocone F
  let e : t' ‚âÖ t := IsColimit.uniqueUpToIso (colimitCoconeIsColimit F) ht
  let e' : t'.pt ‚âÖ t.pt := (Cocones.forget _).mapIso e
  refine' Iff.trans _ (colimit_eq_iff_aux F)
  convert e'.to_equiv.apply_eq_iff_eq <;> rw [‚Üê e.hom.w] <;> rfl
#align category_theory.limits.types.filtered_colimit.is_colimit_eq_iff CategoryTheory.Limits.Types.FilteredColimit.isColimit_eq_iff

/- warning: category_theory.limits.types.filtered_colimit.colimit_eq_iff -> CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1] {i : J} {j : J} {xi : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i} {xj : CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j}, Iff (Eq.{succ (max u1 u2)} (CategoryTheory.Limits.colimit.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) i xi) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u1 u2, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} J _inst_1 CategoryTheory.Limits.Types.hasColimitsOfSize.{u1, u2}) F) j xj)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) => Eq.{succ (max u1 u2)} (CategoryTheory.Functor.obj.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F k) (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F i k f xi) (CategoryTheory.Functor.map.{u1, max u1 u2, u1, succ (max u1 u2)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u1 u2} F j k g xj)))))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) [_inst_2 : CategoryTheory.IsFilteredOrEmpty.{u1, u1} J _inst_1] {i : J} {j : J} {xi : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i} {xj : Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j}, Iff (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F)) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) i xi) (CategoryTheory.Limits.colimit.Œπ.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F (CategoryTheory.Limits.Types.hasColimit.{u1, u2} J _inst_1 F) j xj)) (Exists.{succ u1} J (fun (k : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) (fun (f : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) i k) => Exists.{succ u1} (Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) (fun (g : Quiver.Hom.{succ u1, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) j k) => Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) k) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) i k f xi) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 Type.{max u1 u2} CategoryTheory.types.{max u2 u1} F) j k g xj)))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.types.filtered_colimit.colimit_eq_iff CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff‚Çì'. -/
theorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
    colimit.Œπ F i xi = colimit.Œπ F j xj ‚Üî
      ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj :=
  isColimit_eq_iff _ (colimit.isColimit F)
#align category_theory.limits.types.filtered_colimit.colimit_eq_iff CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff

end FilteredColimit

variable {Œ± Œ≤ : Type u} (f : Œ± ‚ü∂ Œ≤)

section

#print CategoryTheory.Limits.Types.Image /-
-- implementation of `has_image`
/-- the image of a morphism in Type is just `set.range f` -/
def Image : Type u :=
  Set.range f
#align category_theory.limits.types.image CategoryTheory.Limits.Types.Image
-/

instance [Inhabited Œ±] : Inhabited (Image f) where default := ‚ü®f default, ‚ü®_, rfl‚ü©‚ü©

#print CategoryTheory.Limits.Types.Image.Œπ /-
/-- the inclusion of `image f` into the target -/
def Image.Œπ : Image f ‚ü∂ Œ≤ :=
  Subtype.val
#align category_theory.limits.types.image.Œπ CategoryTheory.Limits.Types.Image.Œπ
-/

instance : Mono (Image.Œπ f) :=
  (mono_iff_injective _).2 Subtype.val_injective

variable {f}

#print CategoryTheory.Limits.Types.Image.lift /-
/-- the universal property for the image factorisation -/
noncomputable def Image.lift (F' : MonoFactorisation f) : Image f ‚ü∂ F'.i :=
  (fun x => F'.e (Classical.indefiniteDescription _ x.2).1 : Image f ‚Üí F'.i)
#align category_theory.limits.types.image.lift CategoryTheory.Limits.Types.Image.lift
-/

#print CategoryTheory.Limits.Types.Image.lift_fac /-
theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=
  by
  ext x
  change (F'.e ‚â´ F'.m) _ = _
  rw [F'.fac, (Classical.indefiniteDescription _ x.2).2]
  rfl
#align category_theory.limits.types.image.lift_fac CategoryTheory.Limits.Types.Image.lift_fac
-/

end

#print CategoryTheory.Limits.Types.monoFactorisation /-
/-- the factorisation of any morphism in Type through a mono. -/
def monoFactorisation : MonoFactorisation f
    where
  i := Image f
  m := Image.Œπ f
  e := Set.rangeFactorization f
#align category_theory.limits.types.mono_factorisation CategoryTheory.Limits.Types.monoFactorisation
-/

#print CategoryTheory.Limits.Types.isImage /-
/-- the facorisation through a mono has the universal property of the image. -/
noncomputable def isImage : IsImage (monoFactorisation f)
    where
  lift := Image.lift
  lift_fac := Image.lift_fac
#align category_theory.limits.types.is_image CategoryTheory.Limits.Types.isImage
-/

instance : HasImage f :=
  HasImage.mk ‚ü®_, isImage f‚ü©

instance : HasImages (Type u) where HasImage := by infer_instance

instance : HasImageMaps (Type u)
    where HasImageMap f g st :=
    HasImageMap.transport st (monoFactorisation f.Hom) (isImage g.Hom)
      (fun x =>
        ‚ü®st.right x.1,
          ‚ü®st.left (Classical.choose x.2), by
            have p := st.w
            replace p := congr_fun p (Classical.choose x.2)
            simp only [functor.id_map, types_comp_apply, Subtype.val_eq_coe] at p
            erw [p, Classical.choose_spec x.2]‚ü©‚ü©)
      rfl

end CategoryTheory.Limits.Types

